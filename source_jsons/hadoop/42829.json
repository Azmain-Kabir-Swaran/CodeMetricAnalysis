{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAppImpl.java",
  "functionName": "createAndGetApplicationReport",
  "functionId": "createAndGetApplicationReport___clientUserName-String__allowAccess-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
  "functionStartLine": 693,
  "functionEndLine": 803,
  "numCommitsSeen": 236,
  "timeTaken": 16939,
  "changeHistory": [
    "d125d3910843eeaa25dd09fae493c6fd258757e5",
    "bb92bfb4ef96baa234966b60e464d1773fbf3f22",
    "86dfb70875d3e583deeec9998d95cfd7c5ae4ec4",
    "0c14b6f0d80d847be7ef3eda1614eadbf835181c",
    "72d22b753abde4d07a727479d3f3d5d84d5dd6b2",
    "dae65f3bef8ffa34d02a37041f1dfdfeeee91845",
    "ab923a53fcf55d4d75aa027d46e3c4a659015325",
    "eb0a483ed07399c7a06ed9db4bfbec382de470da",
    "a926f895c11cd69cf2117c3b970304f3f1f53d92",
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
    "ae5308fe1d08479da0f3929cc6a57816411e9121",
    "b6265d39c5d0fda21dfe55273f193d8a6a20c6a8",
    "0306d902f53582320aa5895ca9f5c31f64aaaff6",
    "1db355a875c3ecc40a244045c6812e00c8d36ef1",
    "9ea7b6c063c0bdd4551962e21d0173f671e9df03",
    "83be3ad44484bf8a24cb90de4b9c26ab59d226a8",
    "5de6f72054d4911fcaf12132dccb05662f36a82d",
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
    "ec010a29362c6c5572f8681f4e7d0469176345e1",
    "1a649aa51a3fe291b21bd2bb45d84fcd1806c521",
    "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732",
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
    "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
    "5d1b453b8591d87ffb564857015c26c99fb7437c",
    "a2c42330047bf955a6a585dcddf798920d4c8640",
    "43876770d91a374563bf3379a5ffab5c2bac2264",
    "74231f027607ff1a6fe7d72fad28108826963cf3",
    "448df186467c64d992d6d8c9b35b645dbd48898c",
    "efaaf586053b3275209e3d992df68d6a04d6181f",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e",
    "fab57a144de0cd515e1de9107e4d3ac58037d846",
    "8aabd3d4e67cad8dc7e46f5339981135badc7421",
    "26d63ecdae0f1e27606301f90ca93b3a0f62c5d4",
    "063e33a862f99ce93b8399924c35d39ccd880f01",
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72",
    "1dd113b24ae385896ff474860d364a071a4add7e",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "d125d3910843eeaa25dd09fae493c6fd258757e5": "Ybodychange",
    "bb92bfb4ef96baa234966b60e464d1773fbf3f22": "Ybodychange",
    "86dfb70875d3e583deeec9998d95cfd7c5ae4ec4": "Ybodychange",
    "0c14b6f0d80d847be7ef3eda1614eadbf835181c": "Ybodychange",
    "72d22b753abde4d07a727479d3f3d5d84d5dd6b2": "Ybodychange",
    "dae65f3bef8ffa34d02a37041f1dfdfeeee91845": "Ybodychange",
    "ab923a53fcf55d4d75aa027d46e3c4a659015325": "Ybodychange",
    "eb0a483ed07399c7a06ed9db4bfbec382de470da": "Ybodychange",
    "a926f895c11cd69cf2117c3b970304f3f1f53d92": "Ybodychange",
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6": "Ybodychange",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": "Ybodychange",
    "ae5308fe1d08479da0f3929cc6a57816411e9121": "Ybodychange",
    "b6265d39c5d0fda21dfe55273f193d8a6a20c6a8": "Ybodychange",
    "0306d902f53582320aa5895ca9f5c31f64aaaff6": "Ybodychange",
    "1db355a875c3ecc40a244045c6812e00c8d36ef1": "Ybodychange",
    "9ea7b6c063c0bdd4551962e21d0173f671e9df03": "Ybodychange",
    "83be3ad44484bf8a24cb90de4b9c26ab59d226a8": "Ybodychange",
    "5de6f72054d4911fcaf12132dccb05662f36a82d": "Ybodychange",
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5": "Ybodychange",
    "ec010a29362c6c5572f8681f4e7d0469176345e1": "Ybodychange",
    "1a649aa51a3fe291b21bd2bb45d84fcd1806c521": "Ybodychange",
    "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732": "Ymultichange(Yparameterchange,Ybodychange)",
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68": "Ybodychange",
    "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02": "Ybodychange",
    "5d1b453b8591d87ffb564857015c26c99fb7437c": "Ybodychange",
    "a2c42330047bf955a6a585dcddf798920d4c8640": "Ybodychange",
    "43876770d91a374563bf3379a5ffab5c2bac2264": "Ybodychange",
    "74231f027607ff1a6fe7d72fad28108826963cf3": "Ybodychange",
    "448df186467c64d992d6d8c9b35b645dbd48898c": "Ybodychange",
    "efaaf586053b3275209e3d992df68d6a04d6181f": "Ybodychange",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e": "Ybodychange",
    "fab57a144de0cd515e1de9107e4d3ac58037d846": "Ymultichange(Yparameterchange,Ybodychange)",
    "8aabd3d4e67cad8dc7e46f5339981135badc7421": "Ybodychange",
    "26d63ecdae0f1e27606301f90ca93b3a0f62c5d4": "Ybodychange",
    "063e33a862f99ce93b8399924c35d39ccd880f01": "Ybodychange",
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72": "Ybodychange",
    "1dd113b24ae385896ff474860d364a071a4add7e": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d125d3910843eeaa25dd09fae493c6fd258757e5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6973. Adding RM Cluster Id in ApplicationReport. Contributed by Bilwa S T.\n",
      "commitDate": "29/04/20 11:23 AM",
      "commitName": "d125d3910843eeaa25dd09fae493c6fd258757e5",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "27/04/20 1:35 PM",
      "commitNameOld": "6ef01646ba9540248ffaf322f4678fbdac28fcd4",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 1.91,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,111 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport\n             .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n         appUsageReport.setPreemptedResourceSecondsMap(\n             rmAppMetrics.getPreemptedResourceSecondsMap());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.launchTime, this.finishTime, finishState, appUsageReport,\n           origTrackingUrl, progress, this.applicationType, amrmToken,\n           applicationTags, this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n+      if (HAUtil.isFederationEnabled(conf)) {\n+        report.setRMClusterId(YarnConfiguration.getClusterId(conf));\n+      }\n \n       ApplicationTimeout timeout \u003d ApplicationTimeout\n           .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n       // Currently timeout type supported is LIFETIME. When more timeout types\n       // are supported in YARN-5692, the below logic need to be changed.\n       if (!this.applicationTimeouts.isEmpty()) {\n         long timeoutInMillis \u003d applicationTimeouts\n             .get(ApplicationTimeoutType.LIFETIME).longValue();\n         timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n         if (isAppInCompletedStates()) {\n           // if application configured with timeout and finished before timeout\n           // happens then remaining time should not be calculated.\n           timeout.setRemainingTime(0);\n         } else {\n           timeout.setRemainingTime(\n               Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n         }\n       }\n       report.setApplicationTimeouts(\n           Collections.singletonMap(timeout.getTimeoutType(), timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport\n            .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n        appUsageReport.setPreemptedResourceSecondsMap(\n            rmAppMetrics.getPreemptedResourceSecondsMap());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.launchTime, this.finishTime, finishState, appUsageReport,\n          origTrackingUrl, progress, this.applicationType, amrmToken,\n          applicationTags, this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n      if (HAUtil.isFederationEnabled(conf)) {\n        report.setRMClusterId(YarnConfiguration.getClusterId(conf));\n      }\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        if (isAppInCompletedStates()) {\n          // if application configured with timeout and finished before timeout\n          // happens then remaining time should not be calculated.\n          timeout.setRemainingTime(0);\n        } else {\n          timeout.setRemainingTime(\n              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n        }\n      }\n      report.setApplicationTimeouts(\n          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "bb92bfb4ef96baa234966b60e464d1773fbf3f22": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7088. Add application launch time to Resource Manager REST API. (Kanwaljeet Sachdev via Haibo Chen)\n",
      "commitDate": "17/04/18 11:15 AM",
      "commitName": "bb92bfb4ef96baa234966b60e464d1773fbf3f22",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "17/04/18 6:04 AM",
      "commitNameOld": "86dfb70875d3e583deeec9998d95cfd7c5ae4ec4",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport\n             .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n         appUsageReport.setPreemptedResourceSecondsMap(\n             rmAppMetrics.getPreemptedResourceSecondsMap());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n-          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n-          progress, this.applicationType, amrmToken, applicationTags,\n-          this.getApplicationPriority());\n+          this.launchTime, this.finishTime, finishState, appUsageReport,\n+          origTrackingUrl, progress, this.applicationType, amrmToken,\n+          applicationTags, this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n \n       ApplicationTimeout timeout \u003d ApplicationTimeout\n           .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n       // Currently timeout type supported is LIFETIME. When more timeout types\n       // are supported in YARN-5692, the below logic need to be changed.\n       if (!this.applicationTimeouts.isEmpty()) {\n         long timeoutInMillis \u003d applicationTimeouts\n             .get(ApplicationTimeoutType.LIFETIME).longValue();\n         timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n         if (isAppInCompletedStates()) {\n           // if application configured with timeout and finished before timeout\n           // happens then remaining time should not be calculated.\n           timeout.setRemainingTime(0);\n         } else {\n           timeout.setRemainingTime(\n               Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n         }\n       }\n       report.setApplicationTimeouts(\n           Collections.singletonMap(timeout.getTimeoutType(), timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport\n            .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n        appUsageReport.setPreemptedResourceSecondsMap(\n            rmAppMetrics.getPreemptedResourceSecondsMap());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.launchTime, this.finishTime, finishState, appUsageReport,\n          origTrackingUrl, progress, this.applicationType, amrmToken,\n          applicationTags, this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        if (isAppInCompletedStates()) {\n          // if application configured with timeout and finished before timeout\n          // happens then remaining time should not be calculated.\n          timeout.setRemainingTime(0);\n        } else {\n          timeout.setRemainingTime(\n              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n        }\n      }\n      report.setApplicationTimeouts(\n          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "86dfb70875d3e583deeec9998d95cfd7c5ae4ec4": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7088. Add application launch time to Resource Manager REST API. (Kanwaljeet Sachdev via Haibo Chen)\"\n\nThis reverts commit 0c14b6f0d80d847be7ef3eda1614eadbf835181c.\n",
      "commitDate": "17/04/18 6:04 AM",
      "commitName": "86dfb70875d3e583deeec9998d95cfd7c5ae4ec4",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "17/04/18 5:59 AM",
      "commitNameOld": "0c14b6f0d80d847be7ef3eda1614eadbf835181c",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport\n             .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n         appUsageReport.setPreemptedResourceSecondsMap(\n             rmAppMetrics.getPreemptedResourceSecondsMap());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n-          this.launchTime, this.finishTime, finishState, appUsageReport,\n-          origTrackingUrl, progress, this.applicationType, amrmToken,\n-          applicationTags, this.getApplicationPriority());\n+          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n+          progress, this.applicationType, amrmToken, applicationTags,\n+          this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n \n       ApplicationTimeout timeout \u003d ApplicationTimeout\n           .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n       // Currently timeout type supported is LIFETIME. When more timeout types\n       // are supported in YARN-5692, the below logic need to be changed.\n       if (!this.applicationTimeouts.isEmpty()) {\n         long timeoutInMillis \u003d applicationTimeouts\n             .get(ApplicationTimeoutType.LIFETIME).longValue();\n         timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n         if (isAppInCompletedStates()) {\n           // if application configured with timeout and finished before timeout\n           // happens then remaining time should not be calculated.\n           timeout.setRemainingTime(0);\n         } else {\n           timeout.setRemainingTime(\n               Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n         }\n       }\n       report.setApplicationTimeouts(\n           Collections.singletonMap(timeout.getTimeoutType(), timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport\n            .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n        appUsageReport.setPreemptedResourceSecondsMap(\n            rmAppMetrics.getPreemptedResourceSecondsMap());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        if (isAppInCompletedStates()) {\n          // if application configured with timeout and finished before timeout\n          // happens then remaining time should not be calculated.\n          timeout.setRemainingTime(0);\n        } else {\n          timeout.setRemainingTime(\n              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n        }\n      }\n      report.setApplicationTimeouts(\n          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "0c14b6f0d80d847be7ef3eda1614eadbf835181c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7088. Add application launch time to Resource Manager REST API. (Kanwaljeet Sachdev via Haibo Chen)\n",
      "commitDate": "17/04/18 5:59 AM",
      "commitName": "0c14b6f0d80d847be7ef3eda1614eadbf835181c",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "26/03/18 11:19 AM",
      "commitNameOld": "9eef19b2ad78b8464da252d0e23c08675898b9d8",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 21.78,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport\n             .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n         appUsageReport.setPreemptedResourceSecondsMap(\n             rmAppMetrics.getPreemptedResourceSecondsMap());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n-          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n-          progress, this.applicationType, amrmToken, applicationTags,\n-          this.getApplicationPriority());\n+          this.launchTime, this.finishTime, finishState, appUsageReport,\n+          origTrackingUrl, progress, this.applicationType, amrmToken,\n+          applicationTags, this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n \n       ApplicationTimeout timeout \u003d ApplicationTimeout\n           .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n       // Currently timeout type supported is LIFETIME. When more timeout types\n       // are supported in YARN-5692, the below logic need to be changed.\n       if (!this.applicationTimeouts.isEmpty()) {\n         long timeoutInMillis \u003d applicationTimeouts\n             .get(ApplicationTimeoutType.LIFETIME).longValue();\n         timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n         if (isAppInCompletedStates()) {\n           // if application configured with timeout and finished before timeout\n           // happens then remaining time should not be calculated.\n           timeout.setRemainingTime(0);\n         } else {\n           timeout.setRemainingTime(\n               Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n         }\n       }\n       report.setApplicationTimeouts(\n           Collections.singletonMap(timeout.getTimeoutType(), timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport\n            .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n        appUsageReport.setPreemptedResourceSecondsMap(\n            rmAppMetrics.getPreemptedResourceSecondsMap());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.launchTime, this.finishTime, finishState, appUsageReport,\n          origTrackingUrl, progress, this.applicationType, amrmToken,\n          applicationTags, this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        if (isAppInCompletedStates()) {\n          // if application configured with timeout and finished before timeout\n          // happens then remaining time should not be calculated.\n          timeout.setRemainingTime(0);\n        } else {\n          timeout.setRemainingTime(\n              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n        }\n      }\n      report.setApplicationTimeouts(\n          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "72d22b753abde4d07a727479d3f3d5d84d5dd6b2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7207. Cache the RM proxy server address. (Yufei Gu)\n",
      "commitDate": "06/10/17 9:49 AM",
      "commitName": "72d22b753abde4d07a727479d3f3d5d84d5dd6b2",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "26/09/17 2:04 AM",
      "commitNameOld": "06e5a7b5cf141420d3a411088b87acba72e68cad",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 10.32,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n-        trackingUrl \u003d getDefaultProxyTrackingUrl();\n+        trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport\n             .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n         appUsageReport.setPreemptedResourceSecondsMap(\n             rmAppMetrics.getPreemptedResourceSecondsMap());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n           this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n \n       ApplicationTimeout timeout \u003d ApplicationTimeout\n           .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n       // Currently timeout type supported is LIFETIME. When more timeout types\n       // are supported in YARN-5692, the below logic need to be changed.\n       if (!this.applicationTimeouts.isEmpty()) {\n         long timeoutInMillis \u003d applicationTimeouts\n             .get(ApplicationTimeoutType.LIFETIME).longValue();\n         timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n         if (isAppInCompletedStates()) {\n           // if application configured with timeout and finished before timeout\n           // happens then remaining time should not be calculated.\n           timeout.setRemainingTime(0);\n         } else {\n           timeout.setRemainingTime(\n               Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n         }\n       }\n       report.setApplicationTimeouts(\n           Collections.singletonMap(timeout.getTimeoutType(), timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d rmContext.getAppProxyUrl(conf, applicationId);\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport\n            .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n        appUsageReport.setPreemptedResourceSecondsMap(\n            rmAppMetrics.getPreemptedResourceSecondsMap());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        if (isAppInCompletedStates()) {\n          // if application configured with timeout and finished before timeout\n          // happens then remaining time should not be calculated.\n          timeout.setRemainingTime(0);\n        } else {\n          timeout.setRemainingTime(\n              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n        }\n      }\n      report.setApplicationTimeouts(\n          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "dae65f3bef8ffa34d02a37041f1dfdfeeee91845": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6232. Update resource usage and preempted resource calculations to take into account all resource types. Contributed by Varun Vasudev.\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "dae65f3bef8ffa34d02a37041f1dfdfeeee91845",
      "commitAuthor": "Sunil G",
      "commitDateOld": "07/09/17 6:45 PM",
      "commitNameOld": "56d93d2e39ead89bb79c4f4096554820dc77e84b",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 4.61,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,108 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n-        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n-        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n-        appUsageReport.\n-            setPreemptedMemorySeconds(rmAppMetrics.\n-                getPreemptedMemorySeconds());\n-        appUsageReport.\n-            setPreemptedVcoreSeconds(rmAppMetrics.\n-                getPreemptedVcoreSeconds());\n+        appUsageReport\n+            .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n+        appUsageReport.setPreemptedResourceSecondsMap(\n+            rmAppMetrics.getPreemptedResourceSecondsMap());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n           this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n \n       ApplicationTimeout timeout \u003d ApplicationTimeout\n           .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n       // Currently timeout type supported is LIFETIME. When more timeout types\n       // are supported in YARN-5692, the below logic need to be changed.\n       if (!this.applicationTimeouts.isEmpty()) {\n         long timeoutInMillis \u003d applicationTimeouts\n             .get(ApplicationTimeoutType.LIFETIME).longValue();\n         timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n         if (isAppInCompletedStates()) {\n           // if application configured with timeout and finished before timeout\n           // happens then remaining time should not be calculated.\n           timeout.setRemainingTime(0);\n         } else {\n           timeout.setRemainingTime(\n               Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n         }\n       }\n       report.setApplicationTimeouts(\n           Collections.singletonMap(timeout.getTimeoutType(), timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport\n            .setResourceSecondsMap(rmAppMetrics.getResourceSecondsMap());\n        appUsageReport.setPreemptedResourceSecondsMap(\n            rmAppMetrics.getPreemptedResourceSecondsMap());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        if (isAppInCompletedStates()) {\n          // if application configured with timeout and finished before timeout\n          // happens then remaining time should not be calculated.\n          timeout.setRemainingTime(0);\n        } else {\n          timeout.setRemainingTime(\n              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n        }\n      }\n      report.setApplicationTimeouts(\n          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "ab923a53fcf55d4d75aa027d46e3c4a659015325": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5965. Retrospect ApplicationReport#getApplicationTimeouts. Contributed by Rohith Sharma K S\n",
      "commitDate": "07/12/16 10:57 AM",
      "commitName": "ab923a53fcf55d4d75aa027d46e3c4a659015325",
      "commitAuthor": "Sunil",
      "commitDateOld": "06/12/16 9:09 PM",
      "commitNameOld": "563480dccd0136d82730f4228f1df44449ed5822",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 0.58,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,112 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n         appUsageReport.\n             setPreemptedMemorySeconds(rmAppMetrics.\n                 getPreemptedMemorySeconds());\n         appUsageReport.\n             setPreemptedVcoreSeconds(rmAppMetrics.\n                 getPreemptedVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n           this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n \n       ApplicationTimeout timeout \u003d ApplicationTimeout\n           .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n       // Currently timeout type supported is LIFETIME. When more timeout types\n       // are supported in YARN-5692, the below logic need to be changed.\n       if (!this.applicationTimeouts.isEmpty()) {\n         long timeoutInMillis \u003d applicationTimeouts\n             .get(ApplicationTimeoutType.LIFETIME).longValue();\n         timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n-        timeout.setRemainingTime(\n-            Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n+        if (isAppInCompletedStates()) {\n+          // if application configured with timeout and finished before timeout\n+          // happens then remaining time should not be calculated.\n+          timeout.setRemainingTime(0);\n+        } else {\n+          timeout.setRemainingTime(\n+              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n+        }\n       }\n-      report.setApplicationTimeouts(Collections.singletonList(timeout));\n+      report.setApplicationTimeouts(\n+          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n        appUsageReport.\n            setPreemptedMemorySeconds(rmAppMetrics.\n                getPreemptedMemorySeconds());\n        appUsageReport.\n            setPreemptedVcoreSeconds(rmAppMetrics.\n                getPreemptedVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        if (isAppInCompletedStates()) {\n          // if application configured with timeout and finished before timeout\n          // happens then remaining time should not be calculated.\n          timeout.setRemainingTime(0);\n        } else {\n          timeout.setRemainingTime(\n              Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n        }\n      }\n      report.setApplicationTimeouts(\n          Collections.singletonMap(timeout.getTimeoutType(), timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "eb0a483ed07399c7a06ed9db4bfbec382de470da": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4206. Add Application timeouts in Application report and CLI. Contributed by Rohith Sharma K S.\n",
      "commitDate": "24/11/16 4:48 AM",
      "commitName": "eb0a483ed07399c7a06ed9db4bfbec382de470da",
      "commitAuthor": "Sunil",
      "commitDateOld": "22/11/16 1:19 AM",
      "commitNameOld": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,105 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n         appUsageReport.\n             setPreemptedMemorySeconds(rmAppMetrics.\n                 getPreemptedMemorySeconds());\n         appUsageReport.\n             setPreemptedVcoreSeconds(rmAppMetrics.\n                 getPreemptedVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n           this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n+\n+      ApplicationTimeout timeout \u003d ApplicationTimeout\n+          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n+      // Currently timeout type supported is LIFETIME. When more timeout types\n+      // are supported in YARN-5692, the below logic need to be changed.\n+      if (!this.applicationTimeouts.isEmpty()) {\n+        long timeoutInMillis \u003d applicationTimeouts\n+            .get(ApplicationTimeoutType.LIFETIME).longValue();\n+        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n+        timeout.setRemainingTime(\n+            Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n+      }\n+      report.setApplicationTimeouts(Collections.singletonList(timeout));\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n        appUsageReport.\n            setPreemptedMemorySeconds(rmAppMetrics.\n                getPreemptedMemorySeconds());\n        appUsageReport.\n            setPreemptedVcoreSeconds(rmAppMetrics.\n                getPreemptedVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n\n      ApplicationTimeout timeout \u003d ApplicationTimeout\n          .newInstance(ApplicationTimeoutType.LIFETIME, UNLIMITED, UNKNOWN);\n      // Currently timeout type supported is LIFETIME. When more timeout types\n      // are supported in YARN-5692, the below logic need to be changed.\n      if (!this.applicationTimeouts.isEmpty()) {\n        long timeoutInMillis \u003d applicationTimeouts\n            .get(ApplicationTimeoutType.LIFETIME).longValue();\n        timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));\n        timeout.setRemainingTime(\n            Math.max((timeoutInMillis - systemClock.getTime()) / 1000, 0));\n      }\n      report.setApplicationTimeouts(Collections.singletonList(timeout));\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "a926f895c11cd69cf2117c3b970304f3f1f53d92": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5865. Retrospect updateApplicationPriority api to handle state store exception in align with YARN-5611. Contributed by Sunil G.\n",
      "commitDate": "22/11/16 1:19 AM",
      "commitName": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "10/11/16 2:35 PM",
      "commitNameOld": "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 11.45,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n         appUsageReport.\n             setPreemptedMemorySeconds(rmAppMetrics.\n                 getPreemptedMemorySeconds());\n         appUsageReport.\n             setPreemptedVcoreSeconds(rmAppMetrics.\n                 getPreemptedVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n-          this.submissionContext.getPriority());\n+          this.getApplicationPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n        appUsageReport.\n            setPreemptedMemorySeconds(rmAppMetrics.\n                getPreemptedMemorySeconds());\n        appUsageReport.\n            setPreemptedVcoreSeconds(rmAppMetrics.\n                getPreemptedVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.getApplicationPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4218. Metric for resource*time that was preempted. Contributed by Chang Li.\n",
      "commitDate": "10/11/16 2:35 PM",
      "commitName": "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "09/11/16 4:08 PM",
      "commitNameOld": "bcc15c6290b3912a054323695a6a931b0de163bd",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,92 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         //if the diagnostics is not already set get it from attempt\n         diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n+        appUsageReport.\n+            setPreemptedMemorySeconds(rmAppMetrics.\n+                getPreemptedMemorySeconds());\n+        appUsageReport.\n+            setPreemptedVcoreSeconds(rmAppMetrics.\n+                getPreemptedVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n           this.submissionContext.getPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n        appUsageReport.\n            setPreemptedMemorySeconds(rmAppMetrics.\n                getPreemptedMemorySeconds());\n        appUsageReport.\n            setPreemptedVcoreSeconds(rmAppMetrics.\n                getPreemptedVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.submissionContext.getPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app\u0027s diagnostic message. (Naganarasimha G R via wangda)\n",
      "commitDate": "14/12/15 10:52 AM",
      "commitName": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/12/15 10:01 PM",
      "commitNameOld": "a5e2e1ecb06a3942903cb79f61f0f4bb02480f19",
      "commitAuthorOld": "rohithsharmaks",
      "daysBetweenCommits": 5.54,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,86 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n-        diags \u003d this.diagnostics.toString();\n+        //if the diagnostics is not already set get it from attempt\n+        diags \u003d getDiagnostics().toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n           this.submissionContext.getPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n       report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        //if the diagnostics is not already set get it from attempt\n        diags \u003d getDiagnostics().toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.submissionContext.getPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "ae5308fe1d08479da0f3929cc6a57816411e9121": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3717. Expose app/am/queue\u0027s node-label-expression to RM web UI / CLI / REST-API. (Naganarasimha G R via wangda)\n",
      "commitDate": "15/09/15 11:40 AM",
      "commitName": "ae5308fe1d08479da0f3929cc6a57816411e9121",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/09/15 5:03 PM",
      "commitNameOld": "81df7b586a16f8226c7b01c139c1c70c060399c3",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,85 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags, trackingUrl, this.startTime,\n           this.finishTime, finishState, appUsageReport, origTrackingUrl,\n           progress, this.applicationType, amrmToken, applicationTags,\n           this.submissionContext.getPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n+      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n+      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.submissionContext.getPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      report.setAppNodeLabelExpression(getAppNodeLabelExpression());\n      report.setAmNodeLabelExpression(getAmNodeLabelExpression());\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "b6265d39c5d0fda21dfe55273f193d8a6a20c6a8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3948. Display Application Priority in RM Web UI.(Sunil G via rohithsharmaks)\n",
      "commitDate": "06/08/15 10:13 PM",
      "commitName": "b6265d39c5d0fda21dfe55273f193d8a6a20c6a8",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "03/08/15 3:46 PM",
      "commitNameOld": "0306d902f53582320aa5895ca9f5c31f64aaaff6",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 3.27,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n-          createApplicationState(), diags,\n-          trackingUrl, this.startTime, this.finishTime, finishState,\n-          appUsageReport, origTrackingUrl, progress, this.applicationType, \n-              amrmToken, applicationTags);\n+          createApplicationState(), diags, trackingUrl, this.startTime,\n+          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n+          progress, this.applicationType, amrmToken, applicationTags,\n+          this.submissionContext.getPriority());\n       report.setLogAggregationStatus(logAggregationStatus);\n       report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags, trackingUrl, this.startTime,\n          this.finishTime, finishState, appUsageReport, origTrackingUrl,\n          progress, this.applicationType, amrmToken, applicationTags,\n          this.submissionContext.getPriority());\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "0306d902f53582320aa5895ca9f5c31f64aaaff6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3543. ApplicationReport should be able to tell whether the\nApplication is AM managed or not. Contributed by Rohith Sharma K S\n",
      "commitDate": "03/08/15 3:46 PM",
      "commitName": "0306d902f53582320aa5895ca9f5c31f64aaaff6",
      "commitAuthor": "Xuan",
      "commitDateOld": "21/07/15 9:57 AM",
      "commitNameOld": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.24,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,83 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n           logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n           this.applicationId, currentApplicationAttemptId, this.user,\n           this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n-          amrmToken, applicationTags);\n+              amrmToken, applicationTags);\n       report.setLogAggregationStatus(logAggregationStatus);\n+      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n       return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n              amrmToken, applicationTags);\n      report.setLogAggregationStatus(logAggregationStatus);\n      report.setUnmanagedApp(submissionContext.getUnmanagedAM());\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "1db355a875c3ecc40a244045c6812e00c8d36ef1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1402. Update related Web UI and CLI with exposing client API to check log aggregation status. Contributed by Xuan Gong.\n",
      "commitDate": "17/04/15 1:18 PM",
      "commitName": "1db355a875c3ecc40a244045c6812e00c8d36ef1",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/04/15 8:56 AM",
      "commitNameOld": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 7.18,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,82 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n+      LogAggregationStatus logAggregationStatus \u003d null;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n+          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n-      return BuilderUtils.newApplicationReport(this.applicationId,\n-          currentApplicationAttemptId, this.user, this.queue,\n-          this.name, host, rpcPort, clientToAMToken,\n+      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n+          this.applicationId, currentApplicationAttemptId, this.user,\n+          this.queue, this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken, applicationTags);\n+      report.setLogAggregationStatus(logAggregationStatus);\n+      return report;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      LogAggregationStatus logAggregationStatus \u003d null;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n          logAggregationStatus \u003d this.getLogAggregationStatusForAppReport();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      ApplicationReport report \u003d BuilderUtils.newApplicationReport(\n          this.applicationId, currentApplicationAttemptId, this.user,\n          this.queue, this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken, applicationTags);\n      report.setLogAggregationStatus(logAggregationStatus);\n      return report;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "9ea7b6c063c0bdd4551962e21d0173f671e9df03": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2363. Submitted applications occasionally lack a tracking URL. Contributed by Jason Lowe\n",
      "commitDate": "18/09/14 1:13 PM",
      "commitName": "9ea7b6c063c0bdd4551962e21d0173f671e9df03",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "13/09/14 6:04 PM",
      "commitNameOld": "14e2639fd0d53f7e0b58f2f4744af44983d4e867",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.8,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,78 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n+        trackingUrl \u003d getDefaultProxyTrackingUrl();\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n \n         RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n         appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n         appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken, applicationTags);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        trackingUrl \u003d getDefaultProxyTrackingUrl();\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken, applicationTags);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "83be3ad44484bf8a24cb90de4b9c26ab59d226a8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-415. Capture aggregate memory allocation at the app-level for chargeback. Contributed by Eric Payne \u0026 Andrey Klochkov\n",
      "commitDate": "10/09/14 6:20 PM",
      "commitName": "83be3ad44484bf8a24cb90de4b9c26ab59d226a8",
      "commitAuthor": "Jian He",
      "commitDateOld": "10/09/14 11:44 AM",
      "commitNameOld": "47bdfa044aa1d587b24edae8b1b0c796d829c960",
      "commitAuthorOld": "XUAN",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,77 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n+\n+        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n+        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n+        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken, applicationTags);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n\n        RMAppMetrics rmAppMetrics \u003d getRMAppMetrics();\n        appUsageReport.setMemorySeconds(rmAppMetrics.getMemorySeconds());\n        appUsageReport.setVcoreSeconds(rmAppMetrics.getVcoreSeconds());\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken, applicationTags);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "5de6f72054d4911fcaf12132dccb05662f36a82d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1424. RMAppAttemptImpl should return the DummyApplicationResourceUsageReport for all invalid accesses. (Ray Chiang via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601742 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 12:03 PM",
      "commitName": "5de6f72054d4911fcaf12132dccb05662f36a82d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "08/06/14 8:09 PM",
      "commitNameOld": "424fd9494f144c035fdef8c533be51e2027ad8d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n-          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n+          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken, applicationTags);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          RMServerUtils.DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken, applicationTags);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1461. Added tags for YARN applications and changed RM to handle them. Contributed by Karthik Kambatla.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/02/14 8:55 PM",
      "commitName": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "31/01/14 8:03 PM",
      "commitNameOld": "1079c371289cd31478ed4bc123c1c4dd846c76ee",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n-          amrmToken);\n+          amrmToken, applicationTags);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken, applicationTags);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "ec010a29362c6c5572f8681f4e7d0469176345e1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-540. Race condition causing RM to potentially relaunch already unregistered AMs on RM restart (Jian He via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523376 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/13 6:01 PM",
      "commitName": "ec010a29362c6c5572f8681f4e7d0469176345e1",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "13/09/13 4:51 PM",
      "commitNameOld": "f4951e07087c99ab6d57ff5efdd962432ac641ab",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 1.05,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             // get a token so the client can communicate with the app attempt\n             // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                 this.currentAttempt.createClientToken(clientUserName);\n             if (attemptClientToAMToken !\u003d null) {\n               clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                   attemptClientToAMToken.getIdentifier(),\n                   attemptClientToAMToken.getKind().toString(),\n                   attemptClientToAMToken.getPassword(),\n                   attemptClientToAMToken.getService().toString());\n             }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n-          RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n+          createApplicationState(), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "1a649aa51a3fe291b21bd2bb45d84fcd1806c521": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1152. Fixed a bug in ResourceManager that was causing clients to get invalid client token key errors when an appliation is about to finish. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1521292 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/09/13 2:19 PM",
      "commitName": "1a649aa51a3fe291b21bd2bb45d84fcd1806c521",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/08/13 6:12 PM",
      "commitNameOld": "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 10.84,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   public ApplicationReport createAndGetApplicationReport(String clientUserName,\n       boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n-          if (UserGroupInformation.isSecurityEnabled()\n-              \u0026\u0026 clientUserName !\u003d null) {\n+          if (UserGroupInformation.isSecurityEnabled()) {\n+            // get a token so the client can communicate with the app attempt\n+            // NOTE: token may be unavailable if the attempt is not running\n             Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n-                new Token\u003cClientToAMTokenIdentifier\u003e(\n-                    new ClientToAMTokenIdentifier(\n-                        currentApplicationAttemptId, clientUserName),\n-                        rmContext.getClientToAMTokenSecretManager());\n-            clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n-                attemptClientToAMToken.getIdentifier(),\n-                attemptClientToAMToken.getKind().toString(),\n-                attemptClientToAMToken.getPassword(),\n-                attemptClientToAMToken.getService().toString());\n+                this.currentAttempt.createClientToken(clientUserName);\n+            if (attemptClientToAMToken !\u003d null) {\n+              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n+                  attemptClientToAMToken.getIdentifier(),\n+                  attemptClientToAMToken.getKind().toString(),\n+                  attemptClientToAMToken.getPassword(),\n+                  attemptClientToAMToken.getService().toString());\n+            }\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n             Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n             if (token !\u003d null) {\n               amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                   token.getKind().toString(), token.getPassword(),\n                   token.getService().toString());\n             }\n           }\n         }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            // get a token so the client can communicate with the app attempt\n            // NOTE: token may be unavailable if the attempt is not running\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                this.currentAttempt.createClientToken(clientUserName);\n            if (attemptClientToAMToken !\u003d null) {\n              clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                  attemptClientToAMToken.getIdentifier(),\n                  attemptClientToAMToken.getKind().toString(),\n                  attemptClientToAMToken.getPassword(),\n                  attemptClientToAMToken.getService().toString());\n            }\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-707. Added user information also in the YARN ClientToken so that AMs can implement authorization based on incoming users. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518868 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/08/13 6:12 PM",
      "commitName": "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-707. Added user information also in the YARN ClientToken so that AMs can implement authorization based on incoming users. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518868 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/08/13 6:12 PM",
          "commitName": "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "24/08/13 2:16 PM",
          "commitNameOld": "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 5.16,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,73 @@\n-  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n+  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n+      boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n-          Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n-              this.currentAttempt.getClientToAMToken();\n-          if (attemptClientToAMToken !\u003d null) {\n-            clientToAMToken \u003d\n-                BuilderUtils.newClientToAMToken(\n-                    attemptClientToAMToken.getIdentifier(),\n-                    attemptClientToAMToken.getKind().toString(),\n-                    attemptClientToAMToken.getPassword(),\n-                    attemptClientToAMToken.getService().toString());\n+          if (UserGroupInformation.isSecurityEnabled()\n+              \u0026\u0026 clientUserName !\u003d null) {\n+            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n+                new Token\u003cClientToAMTokenIdentifier\u003e(\n+                    new ClientToAMTokenIdentifier(\n+                        currentApplicationAttemptId, clientUserName),\n+                        rmContext.getClientToAMTokenSecretManager());\n+            clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n+                attemptClientToAMToken.getIdentifier(),\n+                attemptClientToAMToken.getKind().toString(),\n+                attemptClientToAMToken.getPassword(),\n+                attemptClientToAMToken.getService().toString());\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n-          try {\n-            if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n-              getUser().equals(UserGroupInformation.getCurrentUser().getUserName())) {\n-              Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n-              if (token !\u003d null) {\n-                amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n-                    token.getKind().toString(), token.getPassword(),\n-                    token.getService().toString());\n-              }\n+          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n+              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n+            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n+            if (token !\u003d null) {\n+              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n+                  token.getKind().toString(), token.getPassword(),\n+                  token.getService().toString());\n             }\n-          } catch (IOException ex) {\n-            LOG.warn(\"UserGroupInformation.getCurrentUser() error: \" + \n-              ex.toString(), ex);\n-          }          \n+          }\n         }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()\n              \u0026\u0026 clientUserName !\u003d null) {\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                new Token\u003cClientToAMTokenIdentifier\u003e(\n                    new ClientToAMTokenIdentifier(\n                        currentApplicationAttemptId, clientUserName),\n                        rmContext.getClientToAMTokenSecretManager());\n            clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                attemptClientToAMToken.getIdentifier(),\n                attemptClientToAMToken.getKind().toString(),\n                attemptClientToAMToken.getPassword(),\n                attemptClientToAMToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
          "extendedDetails": {
            "oldValue": "[allowAccess-boolean]",
            "newValue": "[clientUserName-String, allowAccess-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-707. Added user information also in the YARN ClientToken so that AMs can implement authorization based on incoming users. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518868 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/08/13 6:12 PM",
          "commitName": "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "24/08/13 2:16 PM",
          "commitNameOld": "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 5.16,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,73 @@\n-  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n+  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n+      boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n-          Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n-              this.currentAttempt.getClientToAMToken();\n-          if (attemptClientToAMToken !\u003d null) {\n-            clientToAMToken \u003d\n-                BuilderUtils.newClientToAMToken(\n-                    attemptClientToAMToken.getIdentifier(),\n-                    attemptClientToAMToken.getKind().toString(),\n-                    attemptClientToAMToken.getPassword(),\n-                    attemptClientToAMToken.getService().toString());\n+          if (UserGroupInformation.isSecurityEnabled()\n+              \u0026\u0026 clientUserName !\u003d null) {\n+            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n+                new Token\u003cClientToAMTokenIdentifier\u003e(\n+                    new ClientToAMTokenIdentifier(\n+                        currentApplicationAttemptId, clientUserName),\n+                        rmContext.getClientToAMTokenSecretManager());\n+            clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n+                attemptClientToAMToken.getIdentifier(),\n+                attemptClientToAMToken.getKind().toString(),\n+                attemptClientToAMToken.getPassword(),\n+                attemptClientToAMToken.getService().toString());\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n-          try {\n-            if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n-              getUser().equals(UserGroupInformation.getCurrentUser().getUserName())) {\n-              Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n-              if (token !\u003d null) {\n-                amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n-                    token.getKind().toString(), token.getPassword(),\n-                    token.getService().toString());\n-              }\n+          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n+              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n+            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n+            if (token !\u003d null) {\n+              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n+                  token.getKind().toString(), token.getPassword(),\n+                  token.getService().toString());\n             }\n-          } catch (IOException ex) {\n-            LOG.warn(\"UserGroupInformation.getCurrentUser() error: \" + \n-              ex.toString(), ex);\n-          }          \n+          }\n         }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ApplicationReport createAndGetApplicationReport(String clientUserName,\n      boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          if (UserGroupInformation.isSecurityEnabled()\n              \u0026\u0026 clientUserName !\u003d null) {\n            Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n                new Token\u003cClientToAMTokenIdentifier\u003e(\n                    new ClientToAMTokenIdentifier(\n                        currentApplicationAttemptId, clientUserName),\n                        rmContext.getClientToAMTokenSecretManager());\n            clientToAMToken \u003d BuilderUtils.newClientToAMToken(\n                attemptClientToAMToken.getIdentifier(),\n                attemptClientToAMToken.getKind().toString(),\n                attemptClientToAMToken.getPassword(),\n                attemptClientToAMToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              clientUserName !\u003d null \u0026\u0026 getUser().equals(clientUserName)) {\n            Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n            if (token !\u003d null) {\n              amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                  token.getKind().toString(), token.getPassword(),\n                  token.getService().toString());\n            }\n          }\n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1074. Cleaned up YARN CLI application list to only display running applications by default. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1517196 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/13 2:16 PM",
      "commitName": "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/07/13 1:04 PM",
      "commitNameOld": "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 28.05,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n               this.currentAttempt.getClientToAMToken();\n           if (attemptClientToAMToken !\u003d null) {\n             clientToAMToken \u003d\n                 BuilderUtils.newClientToAMToken(\n                     attemptClientToAMToken.getIdentifier(),\n                     attemptClientToAMToken.getKind().toString(),\n                     attemptClientToAMToken.getPassword(),\n                     attemptClientToAMToken.getService().toString());\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n \n         if (currentAttempt !\u003d null \u0026\u0026 \n             currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n           try {\n             if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n               getUser().equals(UserGroupInformation.getCurrentUser().getUserName())) {\n               Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n               if (token !\u003d null) {\n                 amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                     token.getKind().toString(), token.getPassword(),\n                     token.getService().toString());\n               }\n             }\n           } catch (IOException ex) {\n             LOG.warn(\"UserGroupInformation.getCurrentUser() error: \" + \n               ex.toString(), ex);\n           }          \n         }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n-          createApplicationState(this.stateMachine.getCurrentState()), diags,\n+          RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType, \n           amrmToken);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n              this.currentAttempt.getClientToAMToken();\n          if (attemptClientToAMToken !\u003d null) {\n            clientToAMToken \u003d\n                BuilderUtils.newClientToAMToken(\n                    attemptClientToAMToken.getIdentifier(),\n                    attemptClientToAMToken.getKind().toString(),\n                    attemptClientToAMToken.getPassword(),\n                    attemptClientToAMToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          try {\n            if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              getUser().equals(UserGroupInformation.getCurrentUser().getUserName())) {\n              Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n              if (token !\u003d null) {\n                amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                    token.getKind().toString(), token.getPassword(),\n                    token.getService().toString());\n              }\n            }\n          } catch (IOException ex) {\n            LOG.warn(\"UserGroupInformation.getCurrentUser() error: \" + \n              ex.toString(), ex);\n          }          \n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          RMServerUtils.createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-937. Fix unmanaged AM in non-secure/secure setup post YARN-701. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1507706 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/07/13 1:04 PM",
      "commitName": "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "11/07/13 2:39 PM",
      "commitNameOld": "171493215889a3b6bf2f6ba33212c4f06861a189",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 15.93,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,74 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n+      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n               this.currentAttempt.getClientToAMToken();\n           if (attemptClientToAMToken !\u003d null) {\n             clientToAMToken \u003d\n                 BuilderUtils.newClientToAMToken(\n                     attemptClientToAMToken.getIdentifier(),\n                     attemptClientToAMToken.getKind().toString(),\n                     attemptClientToAMToken.getPassword(),\n                     attemptClientToAMToken.getService().toString());\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n+\n+        if (currentAttempt !\u003d null \u0026\u0026 \n+            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n+          try {\n+            if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n+              getUser().equals(UserGroupInformation.getCurrentUser().getUserName())) {\n+              Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n+              if (token !\u003d null) {\n+                amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n+                    token.getKind().toString(), token.getPassword(),\n+                    token.getService().toString());\n+              }\n+            }\n+          } catch (IOException ex) {\n+            LOG.warn(\"UserGroupInformation.getCurrentUser() error: \" + \n+              ex.toString(), ex);\n+          }          \n+        }\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n-          appUsageReport, origTrackingUrl, progress, this.applicationType);\n+          appUsageReport, origTrackingUrl, progress, this.applicationType, \n+          amrmToken);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      org.apache.hadoop.yarn.api.records.Token amrmToken \u003d null;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n              this.currentAttempt.getClientToAMToken();\n          if (attemptClientToAMToken !\u003d null) {\n            clientToAMToken \u003d\n                BuilderUtils.newClientToAMToken(\n                    attemptClientToAMToken.getIdentifier(),\n                    attemptClientToAMToken.getKind().toString(),\n                    attemptClientToAMToken.getPassword(),\n                    attemptClientToAMToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n\n        if (currentAttempt !\u003d null \u0026\u0026 \n            currentAttempt.getAppAttemptState() \u003d\u003d RMAppAttemptState.LAUNCHED) {\n          try {\n            if (getApplicationSubmissionContext().getUnmanagedAM() \u0026\u0026\n              getUser().equals(UserGroupInformation.getCurrentUser().getUserName())) {\n              Token\u003cAMRMTokenIdentifier\u003e token \u003d currentAttempt.getAMRMToken();\n              if (token !\u003d null) {\n                amrmToken \u003d BuilderUtils.newAMRMToken(token.getIdentifier(),\n                    token.getKind().toString(), token.getPassword(),\n                    token.getService().toString());\n              }\n            }\n          } catch (IOException ex) {\n            LOG.warn(\"UserGroupInformation.getCurrentUser() error: \" + \n              ex.toString(), ex);\n          }          \n        }\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType, \n          amrmToken);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "5d1b453b8591d87ffb564857015c26c99fb7437c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-610. ClientToken is no longer set in the environment of the Containers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493968 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 4:13 PM",
      "commitName": "5d1b453b8591d87ffb564857015c26c99fb7437c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 4:25 PM",
      "commitNameOld": "c0cd68d8fbf5c8cafa6d563c7d0401e7a87a2d9e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,54 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n-      org.apache.hadoop.yarn.api.records.Token clientToken \u003d null;\n+      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n-          Token\u003cClientTokenIdentifier\u003e attemptClientToken \u003d\n-              this.currentAttempt.getClientToken();\n-          if (attemptClientToken !\u003d null) {\n-            clientToken \u003d\n-                BuilderUtils.newClientToken(attemptClientToken.getIdentifier(),\n-                  attemptClientToken.getKind().toString(), attemptClientToken\n-                    .getPassword(), attemptClientToken.getService().toString());\n+          Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n+              this.currentAttempt.getClientToAMToken();\n+          if (attemptClientToAMToken !\u003d null) {\n+            clientToAMToken \u003d\n+                BuilderUtils.newClientToAMToken(\n+                    attemptClientToAMToken.getIdentifier(),\n+                    attemptClientToAMToken.getKind().toString(),\n+                    attemptClientToAMToken.getPassword(),\n+                    attemptClientToAMToken.getService().toString());\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n-          this.name, host, rpcPort, clientToken,\n+          this.name, host, rpcPort, clientToAMToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          Token\u003cClientToAMTokenIdentifier\u003e attemptClientToAMToken \u003d\n              this.currentAttempt.getClientToAMToken();\n          if (attemptClientToAMToken !\u003d null) {\n            clientToAMToken \u003d\n                BuilderUtils.newClientToAMToken(\n                    attemptClientToAMToken.getIdentifier(),\n                    attemptClientToAMToken.getKind().toString(),\n                    attemptClientToAMToken.getPassword(),\n                    attemptClientToAMToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToAMToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "a2c42330047bf955a6a585dcddf798920d4c8640": {
      "type": "Ybodychange",
      "commitMessage": "YARN-717. Put object creation factories for Token in the class itself and remove useless derivations for specific tokens. Contributed by Jian He.\nMAPREDUCE-5289. Updated MR App to use Token directly after YARN-717. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 2:43 PM",
      "commitName": "a2c42330047bf955a6a585dcddf798920d4c8640",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/05/13 5:14 PM",
      "commitNameOld": "39f019f41392d9e46ea1dc86ddd5563aabbeda1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n-      ClientToken clientToken \u003d null;\n+      org.apache.hadoop.yarn.api.records.Token clientToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           Token\u003cClientTokenIdentifier\u003e attemptClientToken \u003d\n               this.currentAttempt.getClientToken();\n           if (attemptClientToken !\u003d null) {\n             clientToken \u003d\n                 BuilderUtils.newClientToken(attemptClientToken.getIdentifier(),\n                   attemptClientToken.getKind().toString(), attemptClientToken\n                     .getPassword(), attemptClientToken.getService().toString());\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress, this.applicationType);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      org.apache.hadoop.yarn.api.records.Token clientToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          Token\u003cClientTokenIdentifier\u003e attemptClientToken \u003d\n              this.currentAttempt.getClientToken();\n          if (attemptClientToken !\u003d null) {\n            clientToken \u003d\n                BuilderUtils.newClientToken(attemptClientToken.getIdentifier(),\n                  attemptClientToken.getKind().toString(), attemptClientToken\n                    .getPassword(), attemptClientToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "43876770d91a374563bf3379a5ffab5c2bac2264": {
      "type": "Ybodychange",
      "commitMessage": "YARN-563. Add the concept of an application-type for each application. Contributed by Mayank Bansal.\nMAPREDUCE-5246. Specify application-type at the time of job submission after YARN-563. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485790 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/13 11:02 AM",
      "commitName": "43876770d91a374563bf3379a5ffab5c2bac2264",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/05/13 11:20 PM",
      "commitNameOld": "74231f027607ff1a6fe7d72fad28108826963cf3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.49,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       ClientToken clientToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           Token\u003cClientTokenIdentifier\u003e attemptClientToken \u003d\n               this.currentAttempt.getClientToken();\n           if (attemptClientToken !\u003d null) {\n             clientToken \u003d\n                 BuilderUtils.newClientToken(attemptClientToken.getIdentifier(),\n                   attemptClientToken.getKind().toString(), attemptClientToken\n                     .getPassword(), attemptClientToken.getService().toString());\n           }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n-          appUsageReport, origTrackingUrl, progress);\n+          appUsageReport, origTrackingUrl, progress, this.applicationType);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      ClientToken clientToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          Token\u003cClientTokenIdentifier\u003e attemptClientToken \u003d\n              this.currentAttempt.getClientToken();\n          if (attemptClientToken !\u003d null) {\n            clientToken \u003d\n                BuilderUtils.newClientToken(attemptClientToken.getIdentifier(),\n                  attemptClientToken.getKind().toString(), attemptClientToken\n                    .getPassword(), attemptClientToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress, this.applicationType);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "74231f027607ff1a6fe7d72fad28108826963cf3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-582. Changed ResourceManager to recover Application token and client tokens for app attempt so that RM can be restarted while preserving current applications. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480168 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/05/13 11:20 PM",
      "commitName": "74231f027607ff1a6fe7d72fad28108826963cf3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/04/13 10:42 PM",
      "commitNameOld": "448df186467c64d992d6d8c9b35b645dbd48898c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 13.03,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,52 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       ClientToken clientToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       float progress \u003d 0.0f;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n-          clientToken \u003d this.currentAttempt.getClientToken();\n+          Token\u003cClientTokenIdentifier\u003e attemptClientToken \u003d\n+              this.currentAttempt.getClientToken();\n+          if (attemptClientToken !\u003d null) {\n+            clientToken \u003d\n+                BuilderUtils.newClientToken(attemptClientToken.getIdentifier(),\n+                  attemptClientToken.getKind().toString(), attemptClientToken\n+                    .getPassword(), attemptClientToken.getService().toString());\n+          }\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n           progress \u003d currentAttempt.getProgress();\n         }\n         diags \u003d this.diagnostics.toString();\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl, progress);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      ClientToken clientToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          Token\u003cClientTokenIdentifier\u003e attemptClientToken \u003d\n              this.currentAttempt.getClientToken();\n          if (attemptClientToken !\u003d null) {\n            clientToken \u003d\n                BuilderUtils.newClientToken(attemptClientToken.getIdentifier(),\n                  attemptClientToken.getKind().toString(), attemptClientToken\n                    .getPassword(), attemptClientToken.getService().toString());\n          }\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "448df186467c64d992d6d8c9b35b645dbd48898c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-577. Add application-progress also to ApplicationReport. Contributed by Hitesh Shah.\nMAPREDUCE-5178. Update MR App to set progress in ApplicationReport after YARN-577. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1475636 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/04/13 10:42 PM",
      "commitName": "448df186467c64d992d6d8c9b35b645dbd48898c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/04/13 1:19 PM",
      "commitNameOld": "ef9f251679d7e87698eecd6a119652900274a172",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 7.39,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       ClientToken clientToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d\n           DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n+      float progress \u003d 0.0f;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           clientToken \u003d this.currentAttempt.getClientToken();\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n+          progress \u003d currentAttempt.getProgress();\n         }\n-\n         diags \u003d this.diagnostics.toString();\n       }\n \n       if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n \n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n-          appUsageReport, origTrackingUrl);\n+          appUsageReport, origTrackingUrl, progress);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      ClientToken clientToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      float progress \u003d 0.0f;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n          progress \u003d currentAttempt.getProgress();\n        }\n        diags \u003d this.diagnostics.toString();\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl, progress);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "efaaf586053b3275209e3d992df68d6a04d6181f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-400. RM can return null application resource usage report leading to NPE in client (Jason Lowe via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1448241 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/02/13 7:35 AM",
      "commitName": "efaaf586053b3275209e3d992df68d6a04d6181f",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "15/01/13 10:33 AM",
      "commitNameOld": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 35.88,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       ClientToken clientToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n-      ApplicationResourceUsageReport appUsageReport \u003d null;\n+      ApplicationResourceUsageReport appUsageReport \u003d\n+          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           clientToken \u003d this.currentAttempt.getClientToken();\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n-        } else {\n-          currentApplicationAttemptId \u003d \n-              BuilderUtils.newApplicationAttemptId(this.applicationId, \n-                  DUMMY_APPLICATION_ATTEMPT_NUMBER);\n         }\n+\n         diags \u003d this.diagnostics.toString();\n-      } else {\n-        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n+      }\n+\n+      if (currentApplicationAttemptId \u003d\u003d null) {\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n+\n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      ClientToken clientToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d\n          DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n        }\n\n        diags \u003d this.diagnostics.toString();\n      }\n\n      if (currentApplicationAttemptId \u003d\u003d null) {\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-135. Client tokens should be per app-attempt, and should be unregistered on App-finish. Contributed by Vinod Kumar Vavilapalli\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1433570 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/01/13 10:33 AM",
      "commitName": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "08/01/13 9:08 PM",
      "commitNameOld": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.56,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       ApplicationAttemptId currentApplicationAttemptId \u003d null;\n-      String clientToken \u003d UNAVAILABLE;\n+      ClientToken clientToken \u003d null;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d null;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           clientToken \u003d this.currentAttempt.getClientToken();\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n         } else {\n           currentApplicationAttemptId \u003d \n               BuilderUtils.newApplicationAttemptId(this.applicationId, \n                   DUMMY_APPLICATION_ATTEMPT_NUMBER);\n         }\n         diags \u003d this.diagnostics.toString();\n       } else {\n         appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n         currentApplicationAttemptId \u003d \n             BuilderUtils.newApplicationAttemptId(this.applicationId, \n                 DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId,\n           currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      ClientToken clientToken \u003d null;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n        } else {\n          currentApplicationAttemptId \u003d \n              BuilderUtils.newApplicationAttemptId(this.applicationId, \n                  DUMMY_APPLICATION_ATTEMPT_NUMBER);\n        }\n        diags \u003d this.diagnostics.toString();\n      } else {\n        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      String clientToken \u003d UNAVAILABLE;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n        } else {\n          currentApplicationAttemptId \u003d \n              BuilderUtils.newApplicationAttemptId(this.applicationId, \n                  DUMMY_APPLICATION_ATTEMPT_NUMBER);\n        }\n        diags \u003d this.diagnostics.toString();\n      } else {\n        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "15/07/12 2:46 PM",
      "commitNameOld": "ae6cc14611a5898ed637a2e0f9df559f6c29093e",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,44 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n+      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n       String clientToken \u003d UNAVAILABLE;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d null;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n+          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           clientToken \u003d this.currentAttempt.getClientToken();\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n+        } else {\n+          currentApplicationAttemptId \u003d \n+              BuilderUtils.newApplicationAttemptId(this.applicationId, \n+                  DUMMY_APPLICATION_ATTEMPT_NUMBER);\n         }\n         diags \u003d this.diagnostics.toString();\n       } else {\n         appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n+        currentApplicationAttemptId \u003d \n+            BuilderUtils.newApplicationAttemptId(this.applicationId, \n+                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId,\n-          this.currentAttempt.getAppAttemptId(), this.user, this.queue,\n+          currentApplicationAttemptId, this.user, this.queue,\n           this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()), diags,\n           trackingUrl, this.startTime, this.finishTime, finishState,\n           appUsageReport, origTrackingUrl);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      ApplicationAttemptId currentApplicationAttemptId \u003d null;\n      String clientToken \u003d UNAVAILABLE;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          currentApplicationAttemptId \u003d this.currentAttempt.getAppAttemptId();\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n        } else {\n          currentApplicationAttemptId \u003d \n              BuilderUtils.newApplicationAttemptId(this.applicationId, \n                  DUMMY_APPLICATION_ATTEMPT_NUMBER);\n        }\n        diags \u003d this.diagnostics.toString();\n      } else {\n        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n        currentApplicationAttemptId \u003d \n            BuilderUtils.newApplicationAttemptId(this.applicationId, \n                DUMMY_APPLICATION_ATTEMPT_NUMBER);\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          currentApplicationAttemptId, this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4427. Added an \u0027unmanaged\u0027 mode for AMs so as to ease development of new applications. Contributed by Bikas Saha.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361813 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/12 2:46 PM",
      "commitName": "ae6cc14611a5898ed637a2e0f9df559f6c29093e",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "04/06/12 10:41 AM",
      "commitNameOld": "358eda0bfaaf24f2ff4b2ef9967a370ddcb0a336",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 41.17,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n       String clientToken \u003d UNAVAILABLE;\n       String trackingUrl \u003d UNAVAILABLE;\n       String host \u003d UNAVAILABLE;\n       String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d null;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       String diags \u003d UNAVAILABLE;\n       if (allowAccess) {\n         if (this.currentAttempt !\u003d null) {\n           trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n           origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n           clientToken \u003d this.currentAttempt.getClientToken();\n           host \u003d this.currentAttempt.getHost();\n           rpcPort \u003d this.currentAttempt.getRpcPort();\n           appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n         }\n         diags \u003d this.diagnostics.toString();\n       } else {\n         appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       }\n-      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n-          this.queue, this.name, host, rpcPort, clientToken,\n-          createApplicationState(this.stateMachine.getCurrentState()),\n-          diags, trackingUrl,\n-          this.startTime, this.finishTime, finishState, appUsageReport,\n-          origTrackingUrl);\n+      return BuilderUtils.newApplicationReport(this.applicationId,\n+          this.currentAttempt.getAppAttemptId(), this.user, this.queue,\n+          this.name, host, rpcPort, clientToken,\n+          createApplicationState(this.stateMachine.getCurrentState()), diags,\n+          trackingUrl, this.startTime, this.finishTime, finishState,\n+          appUsageReport, origTrackingUrl);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d UNAVAILABLE;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n        }\n        diags \u003d this.diagnostics.toString();\n      } else {\n        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId,\n          this.currentAttempt.getAppAttemptId(), this.user, this.queue,\n          this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()), diags,\n          trackingUrl, this.startTime, this.finishTime, finishState,\n          appUsageReport, origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "fab57a144de0cd515e1de9107e4d3ac58037d846": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3792. Fix \"bin/mapred job -list\" to display all jobs instead of only the jobs owned by the user. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296721 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/12 3:40 PM",
      "commitName": "fab57a144de0cd515e1de9107e4d3ac58037d846",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3792. Fix \"bin/mapred job -list\" to display all jobs instead of only the jobs owned by the user. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296721 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/03/12 3:40 PM",
          "commitName": "fab57a144de0cd515e1de9107e4d3ac58037d846",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "19/01/12 2:23 PM",
          "commitNameOld": "68615600985dfadf067a4967a5e08c1421e7a1c8",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 44.05,
          "commitsBetweenForRepo": 390,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,35 @@\n-  public ApplicationReport createAndGetApplicationReport() {\n+  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n-      String clientToken \u003d \"N/A\";\n-      String trackingUrl \u003d \"N/A\";\n-      String host \u003d \"N/A\";\n-      String origTrackingUrl \u003d \"N/A\";\n+      String clientToken \u003d UNAVAILABLE;\n+      String trackingUrl \u003d UNAVAILABLE;\n+      String host \u003d UNAVAILABLE;\n+      String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d null;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n-      if (this.currentAttempt !\u003d null) {\n-        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n-        origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n-        clientToken \u003d this.currentAttempt.getClientToken();\n-        host \u003d this.currentAttempt.getHost();\n-        rpcPort \u003d this.currentAttempt.getRpcPort();\n-        appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n+      String diags \u003d UNAVAILABLE;\n+      if (allowAccess) {\n+        if (this.currentAttempt !\u003d null) {\n+          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n+          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n+          clientToken \u003d this.currentAttempt.getClientToken();\n+          host \u003d this.currentAttempt.getHost();\n+          rpcPort \u003d this.currentAttempt.getRpcPort();\n+          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n+        }\n+        diags \u003d this.diagnostics.toString();\n+      } else {\n+        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n           this.queue, this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()),\n-          this.diagnostics.toString(), trackingUrl,\n+          diags, trackingUrl,\n           this.startTime, this.finishTime, finishState, appUsageReport,\n           origTrackingUrl);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d UNAVAILABLE;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n        }\n        diags \u003d this.diagnostics.toString();\n      } else {\n        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          diags, trackingUrl,\n          this.startTime, this.finishTime, finishState, appUsageReport,\n          origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[allowAccess-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3792. Fix \"bin/mapred job -list\" to display all jobs instead of only the jobs owned by the user. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296721 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/03/12 3:40 PM",
          "commitName": "fab57a144de0cd515e1de9107e4d3ac58037d846",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "19/01/12 2:23 PM",
          "commitNameOld": "68615600985dfadf067a4967a5e08c1421e7a1c8",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 44.05,
          "commitsBetweenForRepo": 390,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,35 @@\n-  public ApplicationReport createAndGetApplicationReport() {\n+  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n     this.readLock.lock();\n \n     try {\n-      String clientToken \u003d \"N/A\";\n-      String trackingUrl \u003d \"N/A\";\n-      String host \u003d \"N/A\";\n-      String origTrackingUrl \u003d \"N/A\";\n+      String clientToken \u003d UNAVAILABLE;\n+      String trackingUrl \u003d UNAVAILABLE;\n+      String host \u003d UNAVAILABLE;\n+      String origTrackingUrl \u003d UNAVAILABLE;\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d null;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n-      if (this.currentAttempt !\u003d null) {\n-        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n-        origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n-        clientToken \u003d this.currentAttempt.getClientToken();\n-        host \u003d this.currentAttempt.getHost();\n-        rpcPort \u003d this.currentAttempt.getRpcPort();\n-        appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n+      String diags \u003d UNAVAILABLE;\n+      if (allowAccess) {\n+        if (this.currentAttempt !\u003d null) {\n+          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n+          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n+          clientToken \u003d this.currentAttempt.getClientToken();\n+          host \u003d this.currentAttempt.getHost();\n+          rpcPort \u003d this.currentAttempt.getRpcPort();\n+          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n+        }\n+        diags \u003d this.diagnostics.toString();\n+      } else {\n+        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n           this.queue, this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()),\n-          this.diagnostics.toString(), trackingUrl,\n+          diags, trackingUrl,\n           this.startTime, this.finishTime, finishState, appUsageReport,\n           origTrackingUrl);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ApplicationReport createAndGetApplicationReport(boolean allowAccess) {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d UNAVAILABLE;\n      String trackingUrl \u003d UNAVAILABLE;\n      String host \u003d UNAVAILABLE;\n      String origTrackingUrl \u003d UNAVAILABLE;\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      String diags \u003d UNAVAILABLE;\n      if (allowAccess) {\n        if (this.currentAttempt !\u003d null) {\n          trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n          origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n          clientToken \u003d this.currentAttempt.getClientToken();\n          host \u003d this.currentAttempt.getHost();\n          rpcPort \u003d this.currentAttempt.getRpcPort();\n          appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n        }\n        diags \u003d this.diagnostics.toString();\n      } else {\n        appUsageReport \u003d DUMMY_APPLICATION_RESOURCE_USAGE_REPORT;\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          diags, trackingUrl,\n          this.startTime, this.finishTime, finishState, appUsageReport,\n          origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "8aabd3d4e67cad8dc7e46f5339981135badc7421": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2858. Added a WebApp Proxy for applications. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189036 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/11 11:29 PM",
      "commitName": "8aabd3d4e67cad8dc7e46f5339981135badc7421",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "21/10/11 11:35 AM",
      "commitNameOld": "45b2bce8714ecbcb17c6b487208a48d26eed7824",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,29 @@\n   public ApplicationReport createAndGetApplicationReport() {\n     this.readLock.lock();\n \n     try {\n       String clientToken \u003d \"N/A\";\n       String trackingUrl \u003d \"N/A\";\n       String host \u003d \"N/A\";\n+      String origTrackingUrl \u003d \"N/A\";\n       int rpcPort \u003d -1;\n       ApplicationResourceUsageReport appUsageReport \u003d null;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       if (this.currentAttempt !\u003d null) {\n         trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n+        origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n         clientToken \u003d this.currentAttempt.getClientToken();\n         host \u003d this.currentAttempt.getHost();\n         rpcPort \u003d this.currentAttempt.getRpcPort();\n         appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n           this.queue, this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()),\n           this.diagnostics.toString(), trackingUrl,\n-          this.startTime, this.finishTime, finishState, appUsageReport);\n+          this.startTime, this.finishTime, finishState, appUsageReport,\n+          origTrackingUrl);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport() {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d \"N/A\";\n      String trackingUrl \u003d \"N/A\";\n      String host \u003d \"N/A\";\n      String origTrackingUrl \u003d \"N/A\";\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      if (this.currentAttempt !\u003d null) {\n        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n        origTrackingUrl \u003d this.currentAttempt.getOriginalTrackingUrl();\n        clientToken \u003d this.currentAttempt.getClientToken();\n        host \u003d this.currentAttempt.getHost();\n        rpcPort \u003d this.currentAttempt.getRpcPort();\n        appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          this.diagnostics.toString(), trackingUrl,\n          this.startTime, this.finishTime, finishState, appUsageReport,\n          origTrackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "26d63ecdae0f1e27606301f90ca93b3a0f62c5d4": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2789. Complete schedulingInfo on CLI. Contributed by Eric Payne.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1182616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/10/11 4:29 PM",
      "commitName": "26d63ecdae0f1e27606301f90ca93b3a0f62c5d4",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "30/09/11 5:46 AM",
      "commitNameOld": "063e33a862f99ce93b8399924c35d39ccd880f01",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 12.45,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,26 @@\n   public ApplicationReport createAndGetApplicationReport() {\n     this.readLock.lock();\n \n     try {\n       String clientToken \u003d \"N/A\";\n       String trackingUrl \u003d \"N/A\";\n       String host \u003d \"N/A\";\n       int rpcPort \u003d -1;\n+      ApplicationResourceUsageReport appUsageReport \u003d null;\n       FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       if (this.currentAttempt !\u003d null) {\n         trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n         clientToken \u003d this.currentAttempt.getClientToken();\n         host \u003d this.currentAttempt.getHost();\n         rpcPort \u003d this.currentAttempt.getRpcPort();\n+        appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n           this.queue, this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()),\n           this.diagnostics.toString(), trackingUrl,\n-          this.startTime, this.finishTime, finishState);\n+          this.startTime, this.finishTime, finishState, appUsageReport);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport() {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d \"N/A\";\n      String trackingUrl \u003d \"N/A\";\n      String host \u003d \"N/A\";\n      int rpcPort \u003d -1;\n      ApplicationResourceUsageReport appUsageReport \u003d null;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      if (this.currentAttempt !\u003d null) {\n        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n        clientToken \u003d this.currentAttempt.getClientToken();\n        host \u003d this.currentAttempt.getHost();\n        rpcPort \u003d this.currentAttempt.getRpcPort();\n        appUsageReport \u003d currentAttempt.getApplicationResourceUsageReport();\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          this.diagnostics.toString(), trackingUrl,\n          this.startTime, this.finishTime, finishState, appUsageReport);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "063e33a862f99ce93b8399924c35d39ccd880f01": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3098. Fixed RM and MR AM to report YarnApplicationState and application\u0027s FinalStatus separately. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/11 5:46 AM",
      "commitName": "063e33a862f99ce93b8399924c35d39ccd880f01",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/09/11 1:30 PM",
      "commitNameOld": "0d2bb0623696c2cc822cb44e431345b2c773dbff",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 2.68,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,24 @@\n   public ApplicationReport createAndGetApplicationReport() {\n     this.readLock.lock();\n \n     try {\n       String clientToken \u003d \"N/A\";\n       String trackingUrl \u003d \"N/A\";\n       String host \u003d \"N/A\";\n       int rpcPort \u003d -1;\n+      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n       if (this.currentAttempt !\u003d null) {\n         trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n         clientToken \u003d this.currentAttempt.getClientToken();\n         host \u003d this.currentAttempt.getHost();\n         rpcPort \u003d this.currentAttempt.getRpcPort();\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n           this.queue, this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()),\n-          this.diagnostics.toString(), trackingUrl, \n-          this.startTime, this.finishTime);\n+          this.diagnostics.toString(), trackingUrl,\n+          this.startTime, this.finishTime, finishState);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport() {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d \"N/A\";\n      String trackingUrl \u003d \"N/A\";\n      String host \u003d \"N/A\";\n      int rpcPort \u003d -1;\n      FinalApplicationStatus finishState \u003d getFinalApplicationStatus();\n      if (this.currentAttempt !\u003d null) {\n        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n        clientToken \u003d this.currentAttempt.getClientToken();\n        host \u003d this.currentAttempt.getHost();\n        rpcPort \u003d this.currentAttempt.getRpcPort();\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          this.diagnostics.toString(), trackingUrl,\n          this.startTime, this.finishTime, finishState);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2952. Fixed ResourceManager/MR-client to consume diagnostics for AM failures in a couple of corner cases. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1175403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/09/11 7:46 AM",
      "commitName": "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/09/11 4:56 PM",
      "commitNameOld": "bbfd81503cfd98aaeb0334ba356076bfdf6bbd9f",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 5.62,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,23 @@\n   public ApplicationReport createAndGetApplicationReport() {\n     this.readLock.lock();\n \n     try {\n       String clientToken \u003d \"N/A\";\n       String trackingUrl \u003d \"N/A\";\n       String host \u003d \"N/A\";\n       int rpcPort \u003d -1;\n       if (this.currentAttempt !\u003d null) {\n         trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n         clientToken \u003d this.currentAttempt.getClientToken();\n         host \u003d this.currentAttempt.getHost();\n         rpcPort \u003d this.currentAttempt.getRpcPort();\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n           this.queue, this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()),\n-          this.diagnostics.toString(), trackingUrl, this.startTime);\n+          this.diagnostics.toString(), trackingUrl, \n+          this.startTime, this.finishTime);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport() {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d \"N/A\";\n      String trackingUrl \u003d \"N/A\";\n      String host \u003d \"N/A\";\n      int rpcPort \u003d -1;\n      if (this.currentAttempt !\u003d null) {\n        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n        clientToken \u003d this.currentAttempt.getClientToken();\n        host \u003d this.currentAttempt.getHost();\n        rpcPort \u003d this.currentAttempt.getRpcPort();\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          this.diagnostics.toString(), trackingUrl, \n          this.startTime, this.finishTime);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "1dd113b24ae385896ff474860d364a071a4add7e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2796. Set start times for MR applications for clients to see.  Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161704 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/08/11 12:12 PM",
      "commitName": "1dd113b24ae385896ff474860d364a071a4add7e",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "25/08/11 10:16 AM",
      "commitNameOld": "7c85f33ce1b209e1e5bb17b9dd2ad270ca451d60",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,22 @@\n   public ApplicationReport createAndGetApplicationReport() {\n     this.readLock.lock();\n \n     try {\n       String clientToken \u003d \"N/A\";\n       String trackingUrl \u003d \"N/A\";\n       String host \u003d \"N/A\";\n       int rpcPort \u003d -1;\n       if (this.currentAttempt !\u003d null) {\n         trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n         clientToken \u003d this.currentAttempt.getClientToken();\n         host \u003d this.currentAttempt.getHost();\n         rpcPort \u003d this.currentAttempt.getRpcPort();\n       }\n       return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n           this.queue, this.name, host, rpcPort, clientToken,\n           createApplicationState(this.stateMachine.getCurrentState()),\n-          this.diagnostics.toString(), trackingUrl);\n+          this.diagnostics.toString(), trackingUrl, this.startTime);\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport() {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d \"N/A\";\n      String trackingUrl \u003d \"N/A\";\n      String host \u003d \"N/A\";\n      int rpcPort \u003d -1;\n      if (this.currentAttempt !\u003d null) {\n        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n        clientToken \u003d this.currentAttempt.getClientToken();\n        host \u003d this.currentAttempt.getHost();\n        rpcPort \u003d this.currentAttempt.getRpcPort();\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          this.diagnostics.toString(), trackingUrl, this.startTime);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport() {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d \"N/A\";\n      String trackingUrl \u003d \"N/A\";\n      String host \u003d \"N/A\";\n      int rpcPort \u003d -1;\n      if (this.currentAttempt !\u003d null) {\n        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n        clientToken \u003d this.currentAttempt.getClientToken();\n        host \u003d this.currentAttempt.getHost();\n        rpcPort \u003d this.currentAttempt.getRpcPort();\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          this.diagnostics.toString(), trackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,22 @@\n+  public ApplicationReport createAndGetApplicationReport() {\n+    this.readLock.lock();\n+\n+    try {\n+      String clientToken \u003d \"N/A\";\n+      String trackingUrl \u003d \"N/A\";\n+      String host \u003d \"N/A\";\n+      int rpcPort \u003d -1;\n+      if (this.currentAttempt !\u003d null) {\n+        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n+        clientToken \u003d this.currentAttempt.getClientToken();\n+        host \u003d this.currentAttempt.getHost();\n+        rpcPort \u003d this.currentAttempt.getRpcPort();\n+      }\n+      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n+          this.queue, this.name, host, rpcPort, clientToken,\n+          createApplicationState(this.stateMachine.getCurrentState()),\n+          this.diagnostics.toString(), trackingUrl);\n+    } finally {\n+      this.readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ApplicationReport createAndGetApplicationReport() {\n    this.readLock.lock();\n\n    try {\n      String clientToken \u003d \"N/A\";\n      String trackingUrl \u003d \"N/A\";\n      String host \u003d \"N/A\";\n      int rpcPort \u003d -1;\n      if (this.currentAttempt !\u003d null) {\n        trackingUrl \u003d this.currentAttempt.getTrackingUrl();\n        clientToken \u003d this.currentAttempt.getClientToken();\n        host \u003d this.currentAttempt.getHost();\n        rpcPort \u003d this.currentAttempt.getRpcPort();\n      }\n      return BuilderUtils.newApplicationReport(this.applicationId, this.user,\n          this.queue, this.name, host, rpcPort, clientToken,\n          createApplicationState(this.stateMachine.getCurrentState()),\n          this.diagnostics.toString(), trackingUrl);\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java"
    }
  }
}