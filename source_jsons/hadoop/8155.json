{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileJournalManager.java",
  "functionName": "getRemoteEditLogs",
  "functionId": "getRemoteEditLogs___firstTxId-long__inProgressOk-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
  "functionStartLine": 234,
  "functionEndLine": 267,
  "numCommitsSeen": 139,
  "timeTaken": 4143,
  "changeHistory": [
    "53bad4eb008ec553dcdbe01e7ae975dcecde6590",
    "53c38cc89ab979ec47557dcfa7affbad20578c0a",
    "faa4455be512e070fa420084be8d1be5c72f3b08",
    "512a18a8d92305a34f3037064ceabdc5aff1f8bf",
    "8172215e5601c3bb03fb5c0a0d88768142ea5087",
    "8c62c46046656c01b327c378e89d57b4bf37e16e",
    "74d4573a23db5586c6e47ff2277aa7c35237da34",
    "b9e74da41b750ff93f2524da09f06ded1a7bd6e2",
    "641f79a325bad571b11b5700a42efb844eabc5af",
    "9a07ba8945407cd8f63169faf9e0faa4311d38c7",
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f"
  ],
  "changeHistoryShort": {
    "53bad4eb008ec553dcdbe01e7ae975dcecde6590": "Ybodychange",
    "53c38cc89ab979ec47557dcfa7affbad20578c0a": "Ybodychange",
    "faa4455be512e070fa420084be8d1be5c72f3b08": "Ybodychange",
    "512a18a8d92305a34f3037064ceabdc5aff1f8bf": "Ymultichange(Yparameterchange,Ybodychange)",
    "8172215e5601c3bb03fb5c0a0d88768142ea5087": "Ymultichange(Yparameterchange,Ybodychange)",
    "8c62c46046656c01b327c378e89d57b4bf37e16e": "Ymultichange(Yparameterchange,Ybodychange)",
    "74d4573a23db5586c6e47ff2277aa7c35237da34": "Ymultichange(Ymodifierchange,Ybodychange)",
    "b9e74da41b750ff93f2524da09f06ded1a7bd6e2": "Ybodychange",
    "641f79a325bad571b11b5700a42efb844eabc5af": "Ybodychange",
    "9a07ba8945407cd8f63169faf9e0faa4311d38c7": "Ybodychange",
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "53bad4eb008ec553dcdbe01e7ae975dcecde6590": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8996. Consolidate validateLog and scanLog in FJM#EditLogFile (Zhe Zhang via Colin P. McCabe)\n",
      "commitDate": "14/09/15 3:22 PM",
      "commitName": "53bad4eb008ec553dcdbe01e7ae975dcecde6590",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "03/09/15 11:22 AM",
      "commitNameOld": "53c38cc89ab979ec47557dcfa7affbad20578c0a",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 11.17,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n       boolean inProgressOk) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n         continue;\n       }\n       if (elf.isInProgress()) {\n         try {\n-          elf.validateLog(getLastReadableTxId());\n+          elf.scanLog(getLastReadableTxId(), true);\n         } catch (IOException e) {\n           LOG.error(\"got IOException while trying to validate header of \" +\n               elf + \".  Skipping.\", e);\n           continue;\n         }\n       }\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n             elf.isInProgress()));\n       } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n         // If the firstTxId is in the middle of an edit log segment. Return this\n         // anyway and let the caller figure out whether it wants to use it.\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n             elf.isInProgress()));\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean inProgressOk) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n        continue;\n      }\n      if (elf.isInProgress()) {\n        try {\n          elf.scanLog(getLastReadableTxId(), true);\n        } catch (IOException e) {\n          LOG.error(\"got IOException while trying to validate header of \" +\n              elf + \".  Skipping.\", e);\n          continue;\n        }\n      }\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n            elf.isInProgress()));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment. Return this\n        // anyway and let the caller figure out whether it wants to use it.\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n            elf.isInProgress()));\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {}
    },
    "53c38cc89ab979ec47557dcfa7affbad20578c0a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8964. When validating the edit log, do not read at or beyond the file offset that is being written (Zhe Zhang via Colin P. McCabe)\n",
      "commitDate": "03/09/15 11:22 AM",
      "commitName": "53c38cc89ab979ec47557dcfa7affbad20578c0a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 124.06,
      "commitsBetweenForRepo": 888,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n       boolean inProgressOk) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n         continue;\n       }\n       if (elf.isInProgress()) {\n         try {\n-          elf.validateLog();\n+          elf.validateLog(getLastReadableTxId());\n         } catch (IOException e) {\n           LOG.error(\"got IOException while trying to validate header of \" +\n               elf + \".  Skipping.\", e);\n           continue;\n         }\n       }\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n             elf.isInProgress()));\n       } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n         // If the firstTxId is in the middle of an edit log segment. Return this\n         // anyway and let the caller figure out whether it wants to use it.\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n             elf.isInProgress()));\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean inProgressOk) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n        continue;\n      }\n      if (elf.isInProgress()) {\n        try {\n          elf.validateLog(getLastReadableTxId());\n        } catch (IOException e) {\n          LOG.error(\"got IOException while trying to validate header of \" +\n              elf + \".  Skipping.\", e);\n          continue;\n        }\n      }\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n            elf.isInProgress()));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment. Return this\n        // anyway and let the caller figure out whether it wants to use it.\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n            elf.isInProgress()));\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {}
    },
    "faa4455be512e070fa420084be8d1be5c72f3b08": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6634. inotify in HDFS. Contributed by James Thomas.\n",
      "commitDate": "02/09/14 2:02 PM",
      "commitName": "faa4455be512e070fa420084be8d1be5c72f3b08",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "25/07/14 12:02 AM",
      "commitNameOld": "2bb650146ddb36830ea9c0d248fd3df1f6aa7534",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 39.58,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,34 @@\n   public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n       boolean inProgressOk) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n-\n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n         continue;\n       }\n+      if (elf.isInProgress()) {\n+        try {\n+          elf.validateLog();\n+        } catch (IOException e) {\n+          LOG.error(\"got IOException while trying to validate header of \" +\n+              elf + \".  Skipping.\", e);\n+          continue;\n+        }\n+      }\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n-        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n+        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n+            elf.isInProgress()));\n       } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n         // If the firstTxId is in the middle of an edit log segment. Return this\n         // anyway and let the caller figure out whether it wants to use it.\n-        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n+        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n+            elf.isInProgress()));\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean inProgressOk) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n        continue;\n      }\n      if (elf.isInProgress()) {\n        try {\n          elf.validateLog();\n        } catch (IOException e) {\n          LOG.error(\"got IOException while trying to validate header of \" +\n              elf + \".  Skipping.\", e);\n          continue;\n        }\n      }\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n            elf.isInProgress()));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment. Return this\n        // anyway and let the caller figure out whether it wants to use it.\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId,\n            elf.isInProgress()));\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {}
    },
    "512a18a8d92305a34f3037064ceabdc5aff1f8bf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5074. Allow starting up from an fsimage checkpoint in the middle of a segment. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550016 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/12/13 5:32 PM",
      "commitName": "512a18a8d92305a34f3037064ceabdc5aff1f8bf",
      "commitAuthor": "Aaron Myers",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5074. Allow starting up from an fsimage checkpoint in the middle of a segment. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550016 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/12/13 5:32 PM",
          "commitName": "512a18a8d92305a34f3037064ceabdc5aff1f8bf",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "15/08/13 10:19 AM",
          "commitNameOld": "8172215e5601c3bb03fb5c0a0d88768142ea5087",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 117.34,
          "commitsBetweenForRepo": 711,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,24 @@\n   public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n-      boolean forReading, boolean inProgressOk) throws IOException {\n-    // make sure not reading in-progress edit log, i.e., if forReading is true,\n-    // we should ignore the in-progress edit log.\n-    Preconditions.checkArgument(!(forReading \u0026\u0026 inProgressOk));\n-    \n+      boolean inProgressOk) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n         continue;\n       }\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n-        // If the firstTxId is in the middle of an edit log segment\n-        if (forReading) {\n-          // Note that this behavior is different from getLogFiles below.\n-          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n-              + \" which is in the middle of file \" + elf.file);\n-        } else {\n-          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n-        }\n+        // If the firstTxId is in the middle of an edit log segment. Return this\n+        // anyway and let the caller figure out whether it wants to use it.\n+        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean inProgressOk) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n        continue;\n      }\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment. Return this\n        // anyway and let the caller figure out whether it wants to use it.\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {
            "oldValue": "[firstTxId-long, forReading-boolean, inProgressOk-boolean]",
            "newValue": "[firstTxId-long, inProgressOk-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5074. Allow starting up from an fsimage checkpoint in the middle of a segment. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550016 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/12/13 5:32 PM",
          "commitName": "512a18a8d92305a34f3037064ceabdc5aff1f8bf",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "15/08/13 10:19 AM",
          "commitNameOld": "8172215e5601c3bb03fb5c0a0d88768142ea5087",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 117.34,
          "commitsBetweenForRepo": 711,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,24 @@\n   public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n-      boolean forReading, boolean inProgressOk) throws IOException {\n-    // make sure not reading in-progress edit log, i.e., if forReading is true,\n-    // we should ignore the in-progress edit log.\n-    Preconditions.checkArgument(!(forReading \u0026\u0026 inProgressOk));\n-    \n+      boolean inProgressOk) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n         continue;\n       }\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n-        // If the firstTxId is in the middle of an edit log segment\n-        if (forReading) {\n-          // Note that this behavior is different from getLogFiles below.\n-          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n-              + \" which is in the middle of file \" + elf.file);\n-        } else {\n-          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n-        }\n+        // If the firstTxId is in the middle of an edit log segment. Return this\n+        // anyway and let the caller figure out whether it wants to use it.\n+        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean inProgressOk) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n        continue;\n      }\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment. Return this\n        // anyway and let the caller figure out whether it wants to use it.\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "8172215e5601c3bb03fb5c0a0d88768142ea5087": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5080. BootstrapStandby not working with QJM when the existing NN is active. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514386 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/08/13 10:19 AM",
      "commitName": "8172215e5601c3bb03fb5c0a0d88768142ea5087",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5080. BootstrapStandby not working with QJM when the existing NN is active. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514386 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/08/13 10:19 AM",
          "commitName": "8172215e5601c3bb03fb5c0a0d88768142ea5087",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "08/06/13 4:28 PM",
          "commitNameOld": "cb11d68f409b7dabfc1f31c43f026a905810ed01",
          "commitAuthorOld": "Ivan Mitic",
          "daysBetweenCommits": 67.74,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,33 @@\n   public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n-      boolean forReading) throws IOException {\n+      boolean forReading, boolean inProgressOk) throws IOException {\n+    // make sure not reading in-progress edit log, i.e., if forReading is true,\n+    // we should ignore the in-progress edit log.\n+    Preconditions.checkArgument(!(forReading \u0026\u0026 inProgressOk));\n+    \n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n-      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n+      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n+        continue;\n+      }\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n         // If the firstTxId is in the middle of an edit log segment\n         if (forReading) {\n           // Note that this behavior is different from getLogFiles below.\n           throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n               + \" which is in the middle of file \" + elf.file);\n         } else {\n           ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n         }\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean forReading, boolean inProgressOk) throws IOException {\n    // make sure not reading in-progress edit log, i.e., if forReading is true,\n    // we should ignore the in-progress edit log.\n    Preconditions.checkArgument(!(forReading \u0026\u0026 inProgressOk));\n    \n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n        continue;\n      }\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment\n        if (forReading) {\n          // Note that this behavior is different from getLogFiles below.\n          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n              + \" which is in the middle of file \" + elf.file);\n        } else {\n          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n        }\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {
            "oldValue": "[firstTxId-long, forReading-boolean]",
            "newValue": "[firstTxId-long, forReading-boolean, inProgressOk-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5080. BootstrapStandby not working with QJM when the existing NN is active. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514386 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/08/13 10:19 AM",
          "commitName": "8172215e5601c3bb03fb5c0a0d88768142ea5087",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "08/06/13 4:28 PM",
          "commitNameOld": "cb11d68f409b7dabfc1f31c43f026a905810ed01",
          "commitAuthorOld": "Ivan Mitic",
          "daysBetweenCommits": 67.74,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,33 @@\n   public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n-      boolean forReading) throws IOException {\n+      boolean forReading, boolean inProgressOk) throws IOException {\n+    // make sure not reading in-progress edit log, i.e., if forReading is true,\n+    // we should ignore the in-progress edit log.\n+    Preconditions.checkArgument(!(forReading \u0026\u0026 inProgressOk));\n+    \n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n-      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n+      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n+        continue;\n+      }\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n         // If the firstTxId is in the middle of an edit log segment\n         if (forReading) {\n           // Note that this behavior is different from getLogFiles below.\n           throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n               + \" which is in the middle of file \" + elf.file);\n         } else {\n           ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n         }\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean forReading, boolean inProgressOk) throws IOException {\n    // make sure not reading in-progress edit log, i.e., if forReading is true,\n    // we should ignore the in-progress edit log.\n    Preconditions.checkArgument(!(forReading \u0026\u0026 inProgressOk));\n    \n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || (!inProgressOk \u0026\u0026 elf.isInProgress())) {\n        continue;\n      }\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment\n        if (forReading) {\n          // Note that this behavior is different from getLogFiles below.\n          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n              + \" which is in the middle of file \" + elf.file);\n        } else {\n          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n        }\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "8c62c46046656c01b327c378e89d57b4bf37e16e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-4298. StorageRetentionManager spews warnings when used with QJM. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485371 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/05/13 12:37 PM",
      "commitName": "8c62c46046656c01b327c378e89d57b4bf37e16e",
      "commitAuthor": "Aaron Myers",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-4298. StorageRetentionManager spews warnings when used with QJM. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485371 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/05/13 12:37 PM",
          "commitName": "8c62c46046656c01b327c378e89d57b4bf37e16e",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "15/10/12 6:59 PM",
          "commitNameOld": "557ffe2101325438f15dbb218128d327984ecb11",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 218.73,
          "commitsBetweenForRepo": 1215,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,27 @@\n-  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n+  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n+      boolean forReading) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n-      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n-                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n-        // Note that this behavior is different from getLogFiles below.\n-        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n-            + \" which is in the middle of file \" + elf.file);\n+      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n+        // If the firstTxId is in the middle of an edit log segment\n+        if (forReading) {\n+          // Note that this behavior is different from getLogFiles below.\n+          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n+              + \" which is in the middle of file \" + elf.file);\n+        } else {\n+          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n+        }\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean forReading) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment\n        if (forReading) {\n          // Note that this behavior is different from getLogFiles below.\n          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n              + \" which is in the middle of file \" + elf.file);\n        } else {\n          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n        }\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {
            "oldValue": "[firstTxId-long]",
            "newValue": "[firstTxId-long, forReading-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4298. StorageRetentionManager spews warnings when used with QJM. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485371 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/05/13 12:37 PM",
          "commitName": "8c62c46046656c01b327c378e89d57b4bf37e16e",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "15/10/12 6:59 PM",
          "commitNameOld": "557ffe2101325438f15dbb218128d327984ecb11",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 218.73,
          "commitsBetweenForRepo": 1215,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,27 @@\n-  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n+  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n+      boolean forReading) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n-      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n-                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n-        // Note that this behavior is different from getLogFiles below.\n-        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n-            + \" which is in the middle of file \" + elf.file);\n+      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n+        // If the firstTxId is in the middle of an edit log segment\n+        if (forReading) {\n+          // Note that this behavior is different from getLogFiles below.\n+          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n+              + \" which is in the middle of file \" + elf.file);\n+        } else {\n+          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n+        }\n       }\n     }\n     \n     Collections.sort(ret);\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId,\n      boolean forReading) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if (elf.getFirstTxId() \u003c firstTxId \u0026\u0026 firstTxId \u003c\u003d elf.getLastTxId()) {\n        // If the firstTxId is in the middle of an edit log segment\n        if (forReading) {\n          // Note that this behavior is different from getLogFiles below.\n          throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n              + \" which is in the middle of file \" + elf.file);\n        } else {\n          ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n        }\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "74d4573a23db5586c6e47ff2277aa7c35237da34": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/12 5:25 PM",
      "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/07/12 5:25 PM",
          "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "15/07/12 7:58 PM",
          "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
          "commitAuthorOld": "Harsh J",
          "daysBetweenCommits": 3.89,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,20 +1,22 @@\n-  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n+  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                  (firstTxId \u003c\u003d elf.getLastTxId())) {\n         // Note that this behavior is different from getLogFiles below.\n         throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n             + \" which is in the middle of file \" + elf.file);\n       }\n     }\n     \n+    Collections.sort(ret);\n+    \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        // Note that this behavior is different from getLogFiles below.\n        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/07/12 5:25 PM",
          "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "15/07/12 7:58 PM",
          "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
          "commitAuthorOld": "Harsh J",
          "daysBetweenCommits": 3.89,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,20 +1,22 @@\n-  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n+  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                  (firstTxId \u003c\u003d elf.getLastTxId())) {\n         // Note that this behavior is different from getLogFiles below.\n         throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n             + \" which is in the middle of file \" + elf.file);\n       }\n     }\n     \n+    Collections.sort(ret);\n+    \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        // Note that this behavior is different from getLogFiles below.\n        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    Collections.sort(ret);\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "b9e74da41b750ff93f2524da09f06ded1a7bd6e2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2905. HA: Standby NN NPE when shared edits dir is deleted. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1241757 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/02/12 7:17 PM",
      "commitName": "b9e74da41b750ff93f2524da09f06ded1a7bd6e2",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "30/01/12 3:05 PM",
      "commitNameOld": "641f79a325bad571b11b5700a42efb844eabc5af",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 8.17,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,20 @@\n   List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n-    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n-        FileUtil.listFiles(currentDir));\n+    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                  (firstTxId \u003c\u003d elf.getLastTxId())) {\n         // Note that this behavior is different from getLogFiles below.\n         throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n             + \" which is in the middle of file \" + elf.file);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(currentDir);\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        // Note that this behavior is different from getLogFiles below.\n        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {}
    },
    "641f79a325bad571b11b5700a42efb844eabc5af": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2824. Fix failover when prior NN died just after creating an edit log segment. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1238069 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/12 3:05 PM",
      "commitName": "641f79a325bad571b11b5700a42efb844eabc5af",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/01/12 12:32 AM",
      "commitNameOld": "4f1bf2fe23e53ff4b8550882d19f2cf1dd477926",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 19.61,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,21 @@\n   List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n         FileUtil.listFiles(currentDir));\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n-      if (elf.isCorrupt() || elf.isInProgress()) continue;\n+      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                  (firstTxId \u003c\u003d elf.getLastTxId())) {\n         // Note that this behavior is different from getLogFiles below.\n         throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n             + \" which is in the middle of file \" + elf.file);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n        FileUtil.listFiles(currentDir));\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.hasCorruptHeader() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        // Note that this behavior is different from getLogFiles below.\n        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {}
    },
    "9a07ba8945407cd8f63169faf9e0faa4311d38c7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2709. Appropriately handle error conditions in EditLogTailer. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1228390 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/12 12:44 PM",
      "commitName": "9a07ba8945407cd8f63169faf9e0faa4311d38c7",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "15/12/11 8:25 PM",
      "commitNameOld": "cdb9f01ad4e6084ddf83e40eb3ec18a89fbbae42",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 21.68,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,21 @@\n   List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n         FileUtil.listFiles(currentDir));\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.isCorrupt() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                  (firstTxId \u003c\u003d elf.getLastTxId())) {\n+        // Note that this behavior is different from getLogFiles below.\n         throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n             + \" which is in the middle of file \" + elf.file);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n        FileUtil.listFiles(currentDir));\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.isCorrupt() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        // Note that this behavior is different from getLogFiles below.\n        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {}
    },
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2634. Standby needs to ingest latest edit logs before transitioning to active. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1212187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/12/11 3:55 PM",
      "commitName": "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "30/11/11 1:46 PM",
      "commitNameOld": "f87a4b40bc99e76602a75906df31747cfdbff78a",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 8.09,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,20 @@\n   List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n     File currentDir \u003d sd.getCurrentDir();\n     List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n         FileUtil.listFiles(currentDir));\n     List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n         allLogFiles.size());\n \n     for (EditLogFile elf : allLogFiles) {\n       if (elf.isCorrupt() || elf.isInProgress()) continue;\n       if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n         ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n       } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                  (firstTxId \u003c\u003d elf.getLastTxId())) {\n-        throw new IOException(\"Asked for firstTxId \" + firstTxId\n+        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n             + \" which is in the middle of file \" + elf.file);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n        FileUtil.listFiles(currentDir));\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.isCorrupt() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        throw new IllegalStateException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n        FileUtil.listFiles(currentDir));\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.isCorrupt() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        throw new IOException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n        FileUtil.listFiles(currentDir));\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.isCorrupt() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        throw new IOException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java"
      }
    },
    "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2227. getRemoteEditLogManifest should pull its information from FileJournalManager during checkpoint process. Contributed by Ivan Kelly and Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1155977 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/11 5:01 PM",
      "commitName": "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,20 @@\n+  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n+    File currentDir \u003d sd.getCurrentDir();\n+    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n+        FileUtil.listFiles(currentDir));\n+    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n+        allLogFiles.size());\n+\n+    for (EditLogFile elf : allLogFiles) {\n+      if (elf.isCorrupt() || elf.isInProgress()) continue;\n+      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n+        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n+      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n+                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n+        throw new IOException(\"Asked for firstTxId \" + firstTxId\n+            + \" which is in the middle of file \" + elf.file);\n+      }\n+    }\n+    \n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cRemoteEditLog\u003e getRemoteEditLogs(long firstTxId) throws IOException {\n    File currentDir \u003d sd.getCurrentDir();\n    List\u003cEditLogFile\u003e allLogFiles \u003d matchEditLogs(\n        FileUtil.listFiles(currentDir));\n    List\u003cRemoteEditLog\u003e ret \u003d Lists.newArrayListWithCapacity(\n        allLogFiles.size());\n\n    for (EditLogFile elf : allLogFiles) {\n      if (elf.isCorrupt() || elf.isInProgress()) continue;\n      if (elf.getFirstTxId() \u003e\u003d firstTxId) {\n        ret.add(new RemoteEditLog(elf.firstTxId, elf.lastTxId));\n      } else if ((firstTxId \u003e elf.getFirstTxId()) \u0026\u0026\n                 (firstTxId \u003c\u003d elf.getLastTxId())) {\n        throw new IOException(\"Asked for firstTxId \" + firstTxId\n            + \" which is in the middle of file \" + elf.file);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FileJournalManager.java"
    }
  }
}