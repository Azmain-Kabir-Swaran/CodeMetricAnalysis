{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ResourceLocalizationService.java",
  "functionName": "findNextResource",
  "functionId": "findNextResource___user-String__applicationId-ApplicationId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
  "functionStartLine": 1068,
  "functionEndLine": 1137,
  "numCommitsSeen": 191,
  "timeTaken": 10995,
  "changeHistory": [
    "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "0d6bd62102f94c55d59f7a0a86a684e99d746127",
    "4757963d3294b6492156a569af8d370436569aff",
    "c570309b078d3c6080e89cd90c7c2157a270aaca",
    "050fd3a11744cde3d54c1fff23d8fdeb3803bf92",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "0d6bd62102f94c55d59f7a0a86a684e99d746127": "Ybodychange",
    "4757963d3294b6492156a569af8d370436569aff": "Ybodychange",
    "c570309b078d3c6080e89cd90c7c2157a270aaca": "Ybodychange",
    "050fd3a11744cde3d54c1fff23d8fdeb3803bf92": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-9527.  Prevent rogue Localizer Runner from downloading same file repeatly.\n            Contributed by Jim Brennan\n",
      "commitDate": "09/08/19 11:12 AM",
      "commitName": "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
      "commitAuthor": "Eric Yang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9527.  Prevent rogue Localizer Runner from downloading same file repeatly.\n            Contributed by Jim Brennan\n",
          "commitDate": "09/08/19 11:12 AM",
          "commitName": "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "15/03/19 4:20 PM",
          "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 146.79,
          "commitsBetweenForRepo": 1054,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,70 @@\n-    private LocalResource findNextResource() {\n+    private ResourceLocalizationSpec findNextResource(\n+        String user, ApplicationId applicationId) {\n       synchronized (pending) {\n         for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n             i.hasNext();) {\n-         LocalizerResourceRequestEvent evt \u003d i.next();\n-         LocalizedResource nRsrc \u003d evt.getResource();\n-         // Resource download should take place ONLY if resource is in\n-         // Downloading state\n-         if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n-           i.remove();\n-           continue;\n-         }\n-         /*\n-          * Multiple containers will try to download the same resource. So the\n-          * resource download should start only if\n-          * 1) We can acquire a non blocking semaphore lock on resource\n-          * 2) Resource is still in DOWNLOADING state\n-          */\n-         if (nRsrc.tryAcquire()) {\n-           if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n-             LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n-             LocalResource next \u003d\n-                 recordFactory.newRecordInstance(LocalResource.class);\n-             next.setResource(URL.fromPath(nextRsrc\n-               .getPath()));\n-             next.setTimestamp(nextRsrc.getTimestamp());\n-             next.setType(nextRsrc.getType());\n-             next.setVisibility(evt.getVisibility());\n-             next.setPattern(evt.getPattern());\n-             scheduled.put(nextRsrc, evt);\n-             return next;\n-           } else {\n-             // Need to release acquired lock\n-             nRsrc.unlock();\n-           }\n-         }\n-       }\n-       return null;\n+          LocalizerResourceRequestEvent evt \u003d i.next();\n+          LocalizedResource nRsrc \u003d evt.getResource();\n+          // Resource download should take place ONLY if resource is in\n+          // Downloading state\n+          if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n+            i.remove();\n+            continue;\n+          }\n+          /*\n+           * Multiple containers will try to download the same resource. So the\n+           * resource download should start only if\n+           * 1) We can acquire a non blocking semaphore lock on resource\n+           * 2) Resource is still in DOWNLOADING state\n+           */\n+          if (nRsrc.tryAcquire()) {\n+            if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n+              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n+              LocalResource next \u003d\n+                  recordFactory.newRecordInstance(LocalResource.class);\n+              next.setResource(URL.fromPath(nextRsrc.getPath()));\n+              next.setTimestamp(nextRsrc.getTimestamp());\n+              next.setType(nextRsrc.getType());\n+              next.setVisibility(evt.getVisibility());\n+              next.setPattern(evt.getPattern());\n+              ResourceLocalizationSpec nextSpec \u003d null;\n+              try {\n+                LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n+                    next.getVisibility(), user, applicationId);\n+                if (tracker !\u003d null) {\n+                  Path localPath \u003d getPathForLocalization(next, tracker);\n+                  if (localPath !\u003d null) {\n+                    nextSpec \u003d NodeManagerBuilderUtils.\n+                        newResourceLocalizationSpec(next, localPath);\n+                  }\n+                }\n+              } catch (IOException e) {\n+                LOG.error(\"local path for PRIVATE localization could not be \" +\n+                    \"found. Disks might have failed.\", e);\n+              } catch (IllegalArgumentException e) {\n+                LOG.error(\"Incorrect path for PRIVATE localization.\"\n+                    + next.getResource().getFile(), e);\n+              } catch (URISyntaxException e) {\n+                LOG.error(\n+                    \"Got exception in parsing URL of LocalResource:\"\n+                        + next.getResource(), e);\n+              }\n+              if (nextSpec !\u003d null) {\n+                scheduled.put(nextRsrc, evt);\n+                return nextSpec;\n+              } else {\n+                // We failed to get a path for this, don\u0027t try to localize this\n+                // resource again.\n+                nRsrc.unlock();\n+                i.remove();\n+                continue;\n+              }\n+            } else {\n+              // Need to release acquired lock\n+              nRsrc.unlock();\n+            }\n+          }\n+        }\n+        return null;\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private ResourceLocalizationSpec findNextResource(\n        String user, ApplicationId applicationId) {\n      synchronized (pending) {\n        for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n          LocalizerResourceRequestEvent evt \u003d i.next();\n          LocalizedResource nRsrc \u003d evt.getResource();\n          // Resource download should take place ONLY if resource is in\n          // Downloading state\n          if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n            i.remove();\n            continue;\n          }\n          /*\n           * Multiple containers will try to download the same resource. So the\n           * resource download should start only if\n           * 1) We can acquire a non blocking semaphore lock on resource\n           * 2) Resource is still in DOWNLOADING state\n           */\n          if (nRsrc.tryAcquire()) {\n            if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n              LocalResource next \u003d\n                  recordFactory.newRecordInstance(LocalResource.class);\n              next.setResource(URL.fromPath(nextRsrc.getPath()));\n              next.setTimestamp(nextRsrc.getTimestamp());\n              next.setType(nextRsrc.getType());\n              next.setVisibility(evt.getVisibility());\n              next.setPattern(evt.getPattern());\n              ResourceLocalizationSpec nextSpec \u003d null;\n              try {\n                LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n                    next.getVisibility(), user, applicationId);\n                if (tracker !\u003d null) {\n                  Path localPath \u003d getPathForLocalization(next, tracker);\n                  if (localPath !\u003d null) {\n                    nextSpec \u003d NodeManagerBuilderUtils.\n                        newResourceLocalizationSpec(next, localPath);\n                  }\n                }\n              } catch (IOException e) {\n                LOG.error(\"local path for PRIVATE localization could not be \" +\n                    \"found. Disks might have failed.\", e);\n              } catch (IllegalArgumentException e) {\n                LOG.error(\"Incorrect path for PRIVATE localization.\"\n                    + next.getResource().getFile(), e);\n              } catch (URISyntaxException e) {\n                LOG.error(\n                    \"Got exception in parsing URL of LocalResource:\"\n                        + next.getResource(), e);\n              }\n              if (nextSpec !\u003d null) {\n                scheduled.put(nextRsrc, evt);\n                return nextSpec;\n              } else {\n                // We failed to get a path for this, don\u0027t try to localize this\n                // resource again.\n                nRsrc.unlock();\n                i.remove();\n                continue;\n              }\n            } else {\n              // Need to release acquired lock\n              nRsrc.unlock();\n            }\n          }\n        }\n        return null;\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[user-String, applicationId-ApplicationId]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-9527.  Prevent rogue Localizer Runner from downloading same file repeatly.\n            Contributed by Jim Brennan\n",
          "commitDate": "09/08/19 11:12 AM",
          "commitName": "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "15/03/19 4:20 PM",
          "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 146.79,
          "commitsBetweenForRepo": 1054,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,70 @@\n-    private LocalResource findNextResource() {\n+    private ResourceLocalizationSpec findNextResource(\n+        String user, ApplicationId applicationId) {\n       synchronized (pending) {\n         for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n             i.hasNext();) {\n-         LocalizerResourceRequestEvent evt \u003d i.next();\n-         LocalizedResource nRsrc \u003d evt.getResource();\n-         // Resource download should take place ONLY if resource is in\n-         // Downloading state\n-         if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n-           i.remove();\n-           continue;\n-         }\n-         /*\n-          * Multiple containers will try to download the same resource. So the\n-          * resource download should start only if\n-          * 1) We can acquire a non blocking semaphore lock on resource\n-          * 2) Resource is still in DOWNLOADING state\n-          */\n-         if (nRsrc.tryAcquire()) {\n-           if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n-             LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n-             LocalResource next \u003d\n-                 recordFactory.newRecordInstance(LocalResource.class);\n-             next.setResource(URL.fromPath(nextRsrc\n-               .getPath()));\n-             next.setTimestamp(nextRsrc.getTimestamp());\n-             next.setType(nextRsrc.getType());\n-             next.setVisibility(evt.getVisibility());\n-             next.setPattern(evt.getPattern());\n-             scheduled.put(nextRsrc, evt);\n-             return next;\n-           } else {\n-             // Need to release acquired lock\n-             nRsrc.unlock();\n-           }\n-         }\n-       }\n-       return null;\n+          LocalizerResourceRequestEvent evt \u003d i.next();\n+          LocalizedResource nRsrc \u003d evt.getResource();\n+          // Resource download should take place ONLY if resource is in\n+          // Downloading state\n+          if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n+            i.remove();\n+            continue;\n+          }\n+          /*\n+           * Multiple containers will try to download the same resource. So the\n+           * resource download should start only if\n+           * 1) We can acquire a non blocking semaphore lock on resource\n+           * 2) Resource is still in DOWNLOADING state\n+           */\n+          if (nRsrc.tryAcquire()) {\n+            if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n+              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n+              LocalResource next \u003d\n+                  recordFactory.newRecordInstance(LocalResource.class);\n+              next.setResource(URL.fromPath(nextRsrc.getPath()));\n+              next.setTimestamp(nextRsrc.getTimestamp());\n+              next.setType(nextRsrc.getType());\n+              next.setVisibility(evt.getVisibility());\n+              next.setPattern(evt.getPattern());\n+              ResourceLocalizationSpec nextSpec \u003d null;\n+              try {\n+                LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n+                    next.getVisibility(), user, applicationId);\n+                if (tracker !\u003d null) {\n+                  Path localPath \u003d getPathForLocalization(next, tracker);\n+                  if (localPath !\u003d null) {\n+                    nextSpec \u003d NodeManagerBuilderUtils.\n+                        newResourceLocalizationSpec(next, localPath);\n+                  }\n+                }\n+              } catch (IOException e) {\n+                LOG.error(\"local path for PRIVATE localization could not be \" +\n+                    \"found. Disks might have failed.\", e);\n+              } catch (IllegalArgumentException e) {\n+                LOG.error(\"Incorrect path for PRIVATE localization.\"\n+                    + next.getResource().getFile(), e);\n+              } catch (URISyntaxException e) {\n+                LOG.error(\n+                    \"Got exception in parsing URL of LocalResource:\"\n+                        + next.getResource(), e);\n+              }\n+              if (nextSpec !\u003d null) {\n+                scheduled.put(nextRsrc, evt);\n+                return nextSpec;\n+              } else {\n+                // We failed to get a path for this, don\u0027t try to localize this\n+                // resource again.\n+                nRsrc.unlock();\n+                i.remove();\n+                continue;\n+              }\n+            } else {\n+              // Need to release acquired lock\n+              nRsrc.unlock();\n+            }\n+          }\n+        }\n+        return null;\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private ResourceLocalizationSpec findNextResource(\n        String user, ApplicationId applicationId) {\n      synchronized (pending) {\n        for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n          LocalizerResourceRequestEvent evt \u003d i.next();\n          LocalizedResource nRsrc \u003d evt.getResource();\n          // Resource download should take place ONLY if resource is in\n          // Downloading state\n          if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n            i.remove();\n            continue;\n          }\n          /*\n           * Multiple containers will try to download the same resource. So the\n           * resource download should start only if\n           * 1) We can acquire a non blocking semaphore lock on resource\n           * 2) Resource is still in DOWNLOADING state\n           */\n          if (nRsrc.tryAcquire()) {\n            if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n              LocalResource next \u003d\n                  recordFactory.newRecordInstance(LocalResource.class);\n              next.setResource(URL.fromPath(nextRsrc.getPath()));\n              next.setTimestamp(nextRsrc.getTimestamp());\n              next.setType(nextRsrc.getType());\n              next.setVisibility(evt.getVisibility());\n              next.setPattern(evt.getPattern());\n              ResourceLocalizationSpec nextSpec \u003d null;\n              try {\n                LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n                    next.getVisibility(), user, applicationId);\n                if (tracker !\u003d null) {\n                  Path localPath \u003d getPathForLocalization(next, tracker);\n                  if (localPath !\u003d null) {\n                    nextSpec \u003d NodeManagerBuilderUtils.\n                        newResourceLocalizationSpec(next, localPath);\n                  }\n                }\n              } catch (IOException e) {\n                LOG.error(\"local path for PRIVATE localization could not be \" +\n                    \"found. Disks might have failed.\", e);\n              } catch (IllegalArgumentException e) {\n                LOG.error(\"Incorrect path for PRIVATE localization.\"\n                    + next.getResource().getFile(), e);\n              } catch (URISyntaxException e) {\n                LOG.error(\n                    \"Got exception in parsing URL of LocalResource:\"\n                        + next.getResource(), e);\n              }\n              if (nextSpec !\u003d null) {\n                scheduled.put(nextRsrc, evt);\n                return nextSpec;\n              } else {\n                // We failed to get a path for this, don\u0027t try to localize this\n                // resource again.\n                nRsrc.unlock();\n                i.remove();\n                continue;\n              }\n            } else {\n              // Need to release acquired lock\n              nRsrc.unlock();\n            }\n          }\n        }\n        return null;\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
          "extendedDetails": {
            "oldValue": "LocalResource",
            "newValue": "ResourceLocalizationSpec"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9527.  Prevent rogue Localizer Runner from downloading same file repeatly.\n            Contributed by Jim Brennan\n",
          "commitDate": "09/08/19 11:12 AM",
          "commitName": "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "15/03/19 4:20 PM",
          "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 146.79,
          "commitsBetweenForRepo": 1054,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,70 @@\n-    private LocalResource findNextResource() {\n+    private ResourceLocalizationSpec findNextResource(\n+        String user, ApplicationId applicationId) {\n       synchronized (pending) {\n         for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n             i.hasNext();) {\n-         LocalizerResourceRequestEvent evt \u003d i.next();\n-         LocalizedResource nRsrc \u003d evt.getResource();\n-         // Resource download should take place ONLY if resource is in\n-         // Downloading state\n-         if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n-           i.remove();\n-           continue;\n-         }\n-         /*\n-          * Multiple containers will try to download the same resource. So the\n-          * resource download should start only if\n-          * 1) We can acquire a non blocking semaphore lock on resource\n-          * 2) Resource is still in DOWNLOADING state\n-          */\n-         if (nRsrc.tryAcquire()) {\n-           if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n-             LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n-             LocalResource next \u003d\n-                 recordFactory.newRecordInstance(LocalResource.class);\n-             next.setResource(URL.fromPath(nextRsrc\n-               .getPath()));\n-             next.setTimestamp(nextRsrc.getTimestamp());\n-             next.setType(nextRsrc.getType());\n-             next.setVisibility(evt.getVisibility());\n-             next.setPattern(evt.getPattern());\n-             scheduled.put(nextRsrc, evt);\n-             return next;\n-           } else {\n-             // Need to release acquired lock\n-             nRsrc.unlock();\n-           }\n-         }\n-       }\n-       return null;\n+          LocalizerResourceRequestEvent evt \u003d i.next();\n+          LocalizedResource nRsrc \u003d evt.getResource();\n+          // Resource download should take place ONLY if resource is in\n+          // Downloading state\n+          if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n+            i.remove();\n+            continue;\n+          }\n+          /*\n+           * Multiple containers will try to download the same resource. So the\n+           * resource download should start only if\n+           * 1) We can acquire a non blocking semaphore lock on resource\n+           * 2) Resource is still in DOWNLOADING state\n+           */\n+          if (nRsrc.tryAcquire()) {\n+            if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n+              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n+              LocalResource next \u003d\n+                  recordFactory.newRecordInstance(LocalResource.class);\n+              next.setResource(URL.fromPath(nextRsrc.getPath()));\n+              next.setTimestamp(nextRsrc.getTimestamp());\n+              next.setType(nextRsrc.getType());\n+              next.setVisibility(evt.getVisibility());\n+              next.setPattern(evt.getPattern());\n+              ResourceLocalizationSpec nextSpec \u003d null;\n+              try {\n+                LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n+                    next.getVisibility(), user, applicationId);\n+                if (tracker !\u003d null) {\n+                  Path localPath \u003d getPathForLocalization(next, tracker);\n+                  if (localPath !\u003d null) {\n+                    nextSpec \u003d NodeManagerBuilderUtils.\n+                        newResourceLocalizationSpec(next, localPath);\n+                  }\n+                }\n+              } catch (IOException e) {\n+                LOG.error(\"local path for PRIVATE localization could not be \" +\n+                    \"found. Disks might have failed.\", e);\n+              } catch (IllegalArgumentException e) {\n+                LOG.error(\"Incorrect path for PRIVATE localization.\"\n+                    + next.getResource().getFile(), e);\n+              } catch (URISyntaxException e) {\n+                LOG.error(\n+                    \"Got exception in parsing URL of LocalResource:\"\n+                        + next.getResource(), e);\n+              }\n+              if (nextSpec !\u003d null) {\n+                scheduled.put(nextRsrc, evt);\n+                return nextSpec;\n+              } else {\n+                // We failed to get a path for this, don\u0027t try to localize this\n+                // resource again.\n+                nRsrc.unlock();\n+                i.remove();\n+                continue;\n+              }\n+            } else {\n+              // Need to release acquired lock\n+              nRsrc.unlock();\n+            }\n+          }\n+        }\n+        return null;\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private ResourceLocalizationSpec findNextResource(\n        String user, ApplicationId applicationId) {\n      synchronized (pending) {\n        for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n          LocalizerResourceRequestEvent evt \u003d i.next();\n          LocalizedResource nRsrc \u003d evt.getResource();\n          // Resource download should take place ONLY if resource is in\n          // Downloading state\n          if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n            i.remove();\n            continue;\n          }\n          /*\n           * Multiple containers will try to download the same resource. So the\n           * resource download should start only if\n           * 1) We can acquire a non blocking semaphore lock on resource\n           * 2) Resource is still in DOWNLOADING state\n           */\n          if (nRsrc.tryAcquire()) {\n            if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n              LocalResource next \u003d\n                  recordFactory.newRecordInstance(LocalResource.class);\n              next.setResource(URL.fromPath(nextRsrc.getPath()));\n              next.setTimestamp(nextRsrc.getTimestamp());\n              next.setType(nextRsrc.getType());\n              next.setVisibility(evt.getVisibility());\n              next.setPattern(evt.getPattern());\n              ResourceLocalizationSpec nextSpec \u003d null;\n              try {\n                LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n                    next.getVisibility(), user, applicationId);\n                if (tracker !\u003d null) {\n                  Path localPath \u003d getPathForLocalization(next, tracker);\n                  if (localPath !\u003d null) {\n                    nextSpec \u003d NodeManagerBuilderUtils.\n                        newResourceLocalizationSpec(next, localPath);\n                  }\n                }\n              } catch (IOException e) {\n                LOG.error(\"local path for PRIVATE localization could not be \" +\n                    \"found. Disks might have failed.\", e);\n              } catch (IllegalArgumentException e) {\n                LOG.error(\"Incorrect path for PRIVATE localization.\"\n                    + next.getResource().getFile(), e);\n              } catch (URISyntaxException e) {\n                LOG.error(\n                    \"Got exception in parsing URL of LocalResource:\"\n                        + next.getResource(), e);\n              }\n              if (nextSpec !\u003d null) {\n                scheduled.put(nextRsrc, evt);\n                return nextSpec;\n              } else {\n                // We failed to get a path for this, don\u0027t try to localize this\n                // resource again.\n                nRsrc.unlock();\n                i.remove();\n                continue;\n              }\n            } else {\n              // Need to release acquired lock\n              nRsrc.unlock();\n            }\n          }\n        }\n        return null;\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
          "extendedDetails": {}
        }
      ]
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "10/02/16 10:36 PM",
      "commitNameOld": "fa00d3e20560bee412b49e5792595749a247a8ab",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 124.65,
      "commitsBetweenForRepo": 784,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     private LocalResource findNextResource() {\n       synchronized (pending) {\n         for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n             i.hasNext();) {\n          LocalizerResourceRequestEvent evt \u003d i.next();\n          LocalizedResource nRsrc \u003d evt.getResource();\n          // Resource download should take place ONLY if resource is in\n          // Downloading state\n          if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n            i.remove();\n            continue;\n          }\n          /*\n           * Multiple containers will try to download the same resource. So the\n           * resource download should start only if\n           * 1) We can acquire a non blocking semaphore lock on resource\n           * 2) Resource is still in DOWNLOADING state\n           */\n          if (nRsrc.tryAcquire()) {\n            if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n              LocalResource next \u003d\n                  recordFactory.newRecordInstance(LocalResource.class);\n-             next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n+             next.setResource(URL.fromPath(nextRsrc\n                .getPath()));\n              next.setTimestamp(nextRsrc.getTimestamp());\n              next.setType(nextRsrc.getType());\n              next.setVisibility(evt.getVisibility());\n              next.setPattern(evt.getPattern());\n              scheduled.put(nextRsrc, evt);\n              return next;\n            } else {\n              // Need to release acquired lock\n              nRsrc.unlock();\n            }\n          }\n        }\n        return null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LocalResource findNextResource() {\n      synchronized (pending) {\n        for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n         LocalizerResourceRequestEvent evt \u003d i.next();\n         LocalizedResource nRsrc \u003d evt.getResource();\n         // Resource download should take place ONLY if resource is in\n         // Downloading state\n         if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n           i.remove();\n           continue;\n         }\n         /*\n          * Multiple containers will try to download the same resource. So the\n          * resource download should start only if\n          * 1) We can acquire a non blocking semaphore lock on resource\n          * 2) Resource is still in DOWNLOADING state\n          */\n         if (nRsrc.tryAcquire()) {\n           if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n             LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n             LocalResource next \u003d\n                 recordFactory.newRecordInstance(LocalResource.class);\n             next.setResource(URL.fromPath(nextRsrc\n               .getPath()));\n             next.setTimestamp(nextRsrc.getTimestamp());\n             next.setType(nextRsrc.getType());\n             next.setVisibility(evt.getVisibility());\n             next.setPattern(evt.getPattern());\n             scheduled.put(nextRsrc, evt);\n             return next;\n           } else {\n             // Need to release acquired lock\n             nRsrc.unlock();\n           }\n         }\n       }\n       return null;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "0d6bd62102f94c55d59f7a0a86a684e99d746127": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3024. LocalizerRunner should give DIE action when all resources are\nlocalized. Contributed by Chengbing Liu\n",
      "commitDate": "25/01/15 7:37 PM",
      "commitName": "0d6bd62102f94c55d59f7a0a86a684e99d746127",
      "commitAuthor": "Xuan",
      "commitDateOld": "08/12/14 10:26 PM",
      "commitNameOld": "db73cc9124bb8511c1626ba40d3fad81e980e44f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 47.88,
      "commitsBetweenForRepo": 284,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     private LocalResource findNextResource() {\n       synchronized (pending) {\n         for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n             i.hasNext();) {\n          LocalizerResourceRequestEvent evt \u003d i.next();\n          LocalizedResource nRsrc \u003d evt.getResource();\n          // Resource download should take place ONLY if resource is in\n          // Downloading state\n-         if (!ResourceState.DOWNLOADING.equals(nRsrc.getState())) {\n+         if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n            i.remove();\n            continue;\n          }\n          /*\n           * Multiple containers will try to download the same resource. So the\n           * resource download should start only if\n           * 1) We can acquire a non blocking semaphore lock on resource\n           * 2) Resource is still in DOWNLOADING state\n           */\n          if (nRsrc.tryAcquire()) {\n-           if (nRsrc.getState().equals(ResourceState.DOWNLOADING)) {\n+           if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n              LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n              LocalResource next \u003d\n                  recordFactory.newRecordInstance(LocalResource.class);\n              next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n                .getPath()));\n              next.setTimestamp(nextRsrc.getTimestamp());\n              next.setType(nextRsrc.getType());\n              next.setVisibility(evt.getVisibility());\n              next.setPattern(evt.getPattern());\n              scheduled.put(nextRsrc, evt);\n              return next;\n            } else {\n              // Need to release acquired lock\n              nRsrc.unlock();\n            }\n          }\n        }\n        return null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LocalResource findNextResource() {\n      synchronized (pending) {\n        for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n         LocalizerResourceRequestEvent evt \u003d i.next();\n         LocalizedResource nRsrc \u003d evt.getResource();\n         // Resource download should take place ONLY if resource is in\n         // Downloading state\n         if (nRsrc.getState() !\u003d ResourceState.DOWNLOADING) {\n           i.remove();\n           continue;\n         }\n         /*\n          * Multiple containers will try to download the same resource. So the\n          * resource download should start only if\n          * 1) We can acquire a non blocking semaphore lock on resource\n          * 2) Resource is still in DOWNLOADING state\n          */\n         if (nRsrc.tryAcquire()) {\n           if (nRsrc.getState() \u003d\u003d ResourceState.DOWNLOADING) {\n             LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n             LocalResource next \u003d\n                 recordFactory.newRecordInstance(LocalResource.class);\n             next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n               .getPath()));\n             next.setTimestamp(nextRsrc.getTimestamp());\n             next.setType(nextRsrc.getType());\n             next.setVisibility(evt.getVisibility());\n             next.setPattern(evt.getPattern());\n             scheduled.put(nextRsrc, evt);\n             return next;\n           } else {\n             // Need to release acquired lock\n             nRsrc.unlock();\n           }\n         }\n       }\n       return null;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "4757963d3294b6492156a569af8d370436569aff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-573. Shared data structures in Public Localizer and Private Localizer are not Thread safe. Contributed by Omkar Vinit Joshi\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1509389 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/08/13 12:34 PM",
      "commitName": "4757963d3294b6492156a569af8d370436569aff",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "16/07/13 4:31 PM",
      "commitNameOld": "af0d2fc3e343e5db82c2398d31de85c47b239e35",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.84,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,40 @@\n     private LocalResource findNextResource() {\n-      // TODO: Synchronization\n-      for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n-           i.hasNext();) {\n-        LocalizerResourceRequestEvent evt \u003d i.next();\n-        LocalizedResource nRsrc \u003d evt.getResource();\n-        // Resource download should take place ONLY if resource is in\n-        // Downloading state\n-        if (!ResourceState.DOWNLOADING.equals(nRsrc.getState())) {\n-          i.remove();\n-          continue;\n-        }\n-        /*\n-         * Multiple containers will try to download the same resource. So the\n-         * resource download should start only if\n-         * 1) We can acquire a non blocking semaphore lock on resource\n-         * 2) Resource is still in DOWNLOADING state\n-         */\n-        if (nRsrc.tryAcquire()) {\n-          if (nRsrc.getState().equals(ResourceState.DOWNLOADING)) {\n-            LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n-            LocalResource next \u003d\n-                recordFactory.newRecordInstance(LocalResource.class);\n-            next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n-              .getPath()));\n-            next.setTimestamp(nextRsrc.getTimestamp());\n-            next.setType(nextRsrc.getType());\n-            next.setVisibility(evt.getVisibility());\n-            next.setPattern(evt.getPattern());\n-            scheduled.put(nextRsrc, evt);\n-            return next;\n-          } else {\n-            // Need to release acquired lock\n-            nRsrc.unlock();\n-          }\n-        }\n+      synchronized (pending) {\n+        for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n+            i.hasNext();) {\n+         LocalizerResourceRequestEvent evt \u003d i.next();\n+         LocalizedResource nRsrc \u003d evt.getResource();\n+         // Resource download should take place ONLY if resource is in\n+         // Downloading state\n+         if (!ResourceState.DOWNLOADING.equals(nRsrc.getState())) {\n+           i.remove();\n+           continue;\n+         }\n+         /*\n+          * Multiple containers will try to download the same resource. So the\n+          * resource download should start only if\n+          * 1) We can acquire a non blocking semaphore lock on resource\n+          * 2) Resource is still in DOWNLOADING state\n+          */\n+         if (nRsrc.tryAcquire()) {\n+           if (nRsrc.getState().equals(ResourceState.DOWNLOADING)) {\n+             LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n+             LocalResource next \u003d\n+                 recordFactory.newRecordInstance(LocalResource.class);\n+             next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n+               .getPath()));\n+             next.setTimestamp(nextRsrc.getTimestamp());\n+             next.setType(nextRsrc.getType());\n+             next.setVisibility(evt.getVisibility());\n+             next.setPattern(evt.getPattern());\n+             scheduled.put(nextRsrc, evt);\n+             return next;\n+           } else {\n+             // Need to release acquired lock\n+             nRsrc.unlock();\n+           }\n+         }\n+       }\n+       return null;\n       }\n-      return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LocalResource findNextResource() {\n      synchronized (pending) {\n        for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n         LocalizerResourceRequestEvent evt \u003d i.next();\n         LocalizedResource nRsrc \u003d evt.getResource();\n         // Resource download should take place ONLY if resource is in\n         // Downloading state\n         if (!ResourceState.DOWNLOADING.equals(nRsrc.getState())) {\n           i.remove();\n           continue;\n         }\n         /*\n          * Multiple containers will try to download the same resource. So the\n          * resource download should start only if\n          * 1) We can acquire a non blocking semaphore lock on resource\n          * 2) Resource is still in DOWNLOADING state\n          */\n         if (nRsrc.tryAcquire()) {\n           if (nRsrc.getState().equals(ResourceState.DOWNLOADING)) {\n             LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n             LocalResource next \u003d\n                 recordFactory.newRecordInstance(LocalResource.class);\n             next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n               .getPath()));\n             next.setTimestamp(nextRsrc.getTimestamp());\n             next.setType(nextRsrc.getType());\n             next.setVisibility(evt.getVisibility());\n             next.setPattern(evt.getPattern());\n             scheduled.put(nextRsrc, evt);\n             return next;\n           } else {\n             // Need to release acquired lock\n             nRsrc.unlock();\n           }\n         }\n       }\n       return null;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "c570309b078d3c6080e89cd90c7c2157a270aaca": {
      "type": "Ybodychange",
      "commitMessage": "YARN-547. Fixed race conditions in public and private resource localization which used to cause duplicate downloads. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1470076 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/04/13 3:35 PM",
      "commitName": "c570309b078d3c6080e89cd90c7c2157a270aaca",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/04/13 7:08 PM",
      "commitNameOld": "4234bc87b3e0bf7e9716d6ca1873b8bb0239472e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.85,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,39 @@\n     private LocalResource findNextResource() {\n       // TODO: Synchronization\n       for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n         LocalizerResourceRequestEvent evt \u003d i.next();\n         LocalizedResource nRsrc \u003d evt.getResource();\n-        if (ResourceState.LOCALIZED.equals(nRsrc.getState())) {\n+        // Resource download should take place ONLY if resource is in\n+        // Downloading state\n+        if (!ResourceState.DOWNLOADING.equals(nRsrc.getState())) {\n           i.remove();\n           continue;\n         }\n+        /*\n+         * Multiple containers will try to download the same resource. So the\n+         * resource download should start only if\n+         * 1) We can acquire a non blocking semaphore lock on resource\n+         * 2) Resource is still in DOWNLOADING state\n+         */\n         if (nRsrc.tryAcquire()) {\n-          LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n-          LocalResource next \u003d\n-            recordFactory.newRecordInstance(LocalResource.class);\n-          next.setResource(\n-              ConverterUtils.getYarnUrlFromPath(nextRsrc.getPath()));\n-          next.setTimestamp(nextRsrc.getTimestamp());\n-          next.setType(nextRsrc.getType());\n-          next.setVisibility(evt.getVisibility());\n-          next.setPattern(evt.getPattern());\n-          scheduled.put(nextRsrc, evt);\n-          return next;\n+          if (nRsrc.getState().equals(ResourceState.DOWNLOADING)) {\n+            LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n+            LocalResource next \u003d\n+                recordFactory.newRecordInstance(LocalResource.class);\n+            next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n+              .getPath()));\n+            next.setTimestamp(nextRsrc.getTimestamp());\n+            next.setType(nextRsrc.getType());\n+            next.setVisibility(evt.getVisibility());\n+            next.setPattern(evt.getPattern());\n+            scheduled.put(nextRsrc, evt);\n+            return next;\n+          } else {\n+            // Need to release acquired lock\n+            nRsrc.unlock();\n+          }\n         }\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LocalResource findNextResource() {\n      // TODO: Synchronization\n      for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n           i.hasNext();) {\n        LocalizerResourceRequestEvent evt \u003d i.next();\n        LocalizedResource nRsrc \u003d evt.getResource();\n        // Resource download should take place ONLY if resource is in\n        // Downloading state\n        if (!ResourceState.DOWNLOADING.equals(nRsrc.getState())) {\n          i.remove();\n          continue;\n        }\n        /*\n         * Multiple containers will try to download the same resource. So the\n         * resource download should start only if\n         * 1) We can acquire a non blocking semaphore lock on resource\n         * 2) Resource is still in DOWNLOADING state\n         */\n        if (nRsrc.tryAcquire()) {\n          if (nRsrc.getState().equals(ResourceState.DOWNLOADING)) {\n            LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n            LocalResource next \u003d\n                recordFactory.newRecordInstance(LocalResource.class);\n            next.setResource(ConverterUtils.getYarnUrlFromPath(nextRsrc\n              .getPath()));\n            next.setTimestamp(nextRsrc.getTimestamp());\n            next.setType(nextRsrc.getType());\n            next.setVisibility(evt.getVisibility());\n            next.setPattern(evt.getPattern());\n            scheduled.put(nextRsrc, evt);\n            return next;\n          } else {\n            // Need to release acquired lock\n            nRsrc.unlock();\n          }\n        }\n      }\n      return null;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "050fd3a11744cde3d54c1fff23d8fdeb3803bf92": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4647. We should only unjar jobjar if there is a lib directory in it. (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1390557 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/09/12 8:22 AM",
      "commitName": "050fd3a11744cde3d54c1fff23d8fdeb3803bf92",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "05/09/12 7:08 PM",
      "commitNameOld": "02c0317eff8ebb78c1bbb41d87dddbd63246432c",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 20.55,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,26 @@\n     private LocalResource findNextResource() {\n       // TODO: Synchronization\n       for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n            i.hasNext();) {\n         LocalizerResourceRequestEvent evt \u003d i.next();\n         LocalizedResource nRsrc \u003d evt.getResource();\n         if (ResourceState.LOCALIZED.equals(nRsrc.getState())) {\n           i.remove();\n           continue;\n         }\n         if (nRsrc.tryAcquire()) {\n           LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n           LocalResource next \u003d\n             recordFactory.newRecordInstance(LocalResource.class);\n           next.setResource(\n               ConverterUtils.getYarnUrlFromPath(nextRsrc.getPath()));\n           next.setTimestamp(nextRsrc.getTimestamp());\n           next.setType(nextRsrc.getType());\n           next.setVisibility(evt.getVisibility());\n+          next.setPattern(evt.getPattern());\n           scheduled.put(nextRsrc, evt);\n           return next;\n         }\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LocalResource findNextResource() {\n      // TODO: Synchronization\n      for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n           i.hasNext();) {\n        LocalizerResourceRequestEvent evt \u003d i.next();\n        LocalizedResource nRsrc \u003d evt.getResource();\n        if (ResourceState.LOCALIZED.equals(nRsrc.getState())) {\n          i.remove();\n          continue;\n        }\n        if (nRsrc.tryAcquire()) {\n          LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n          LocalResource next \u003d\n            recordFactory.newRecordInstance(LocalResource.class);\n          next.setResource(\n              ConverterUtils.getYarnUrlFromPath(nextRsrc.getPath()));\n          next.setTimestamp(nextRsrc.getTimestamp());\n          next.setType(nextRsrc.getType());\n          next.setVisibility(evt.getVisibility());\n          next.setPattern(evt.getPattern());\n          scheduled.put(nextRsrc, evt);\n          return next;\n        }\n      }\n      return null;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private LocalResource findNextResource() {\n      // TODO: Synchronization\n      for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n           i.hasNext();) {\n        LocalizerResourceRequestEvent evt \u003d i.next();\n        LocalizedResource nRsrc \u003d evt.getResource();\n        if (ResourceState.LOCALIZED.equals(nRsrc.getState())) {\n          i.remove();\n          continue;\n        }\n        if (nRsrc.tryAcquire()) {\n          LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n          LocalResource next \u003d\n            recordFactory.newRecordInstance(LocalResource.class);\n          next.setResource(\n              ConverterUtils.getYarnUrlFromPath(nextRsrc.getPath()));\n          next.setTimestamp(nextRsrc.getTimestamp());\n          next.setType(nextRsrc.getType());\n          next.setVisibility(evt.getVisibility());\n          scheduled.put(nextRsrc, evt);\n          return next;\n        }\n      }\n      return null;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private LocalResource findNextResource() {\n      // TODO: Synchronization\n      for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n           i.hasNext();) {\n        LocalizerResourceRequestEvent evt \u003d i.next();\n        LocalizedResource nRsrc \u003d evt.getResource();\n        if (ResourceState.LOCALIZED.equals(nRsrc.getState())) {\n          i.remove();\n          continue;\n        }\n        if (nRsrc.tryAcquire()) {\n          LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n          LocalResource next \u003d\n            recordFactory.newRecordInstance(LocalResource.class);\n          next.setResource(\n              ConverterUtils.getYarnUrlFromPath(nextRsrc.getPath()));\n          next.setTimestamp(nextRsrc.getTimestamp());\n          next.setType(nextRsrc.getType());\n          next.setVisibility(evt.getVisibility());\n          scheduled.put(nextRsrc, evt);\n          return next;\n        }\n      }\n      return null;\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,25 @@\n+    private LocalResource findNextResource() {\n+      // TODO: Synchronization\n+      for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n+           i.hasNext();) {\n+        LocalizerResourceRequestEvent evt \u003d i.next();\n+        LocalizedResource nRsrc \u003d evt.getResource();\n+        if (ResourceState.LOCALIZED.equals(nRsrc.getState())) {\n+          i.remove();\n+          continue;\n+        }\n+        if (nRsrc.tryAcquire()) {\n+          LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n+          LocalResource next \u003d\n+            recordFactory.newRecordInstance(LocalResource.class);\n+          next.setResource(\n+              ConverterUtils.getYarnUrlFromPath(nextRsrc.getPath()));\n+          next.setTimestamp(nextRsrc.getTimestamp());\n+          next.setType(nextRsrc.getType());\n+          next.setVisibility(evt.getVisibility());\n+          scheduled.put(nextRsrc, evt);\n+          return next;\n+        }\n+      }\n+      return null;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private LocalResource findNextResource() {\n      // TODO: Synchronization\n      for (Iterator\u003cLocalizerResourceRequestEvent\u003e i \u003d pending.iterator();\n           i.hasNext();) {\n        LocalizerResourceRequestEvent evt \u003d i.next();\n        LocalizedResource nRsrc \u003d evt.getResource();\n        if (ResourceState.LOCALIZED.equals(nRsrc.getState())) {\n          i.remove();\n          continue;\n        }\n        if (nRsrc.tryAcquire()) {\n          LocalResourceRequest nextRsrc \u003d nRsrc.getRequest();\n          LocalResource next \u003d\n            recordFactory.newRecordInstance(LocalResource.class);\n          next.setResource(\n              ConverterUtils.getYarnUrlFromPath(nextRsrc.getPath()));\n          next.setTimestamp(nextRsrc.getTimestamp());\n          next.setType(nextRsrc.getType());\n          next.setVisibility(evt.getVisibility());\n          scheduled.put(nextRsrc, evt);\n          return next;\n        }\n      }\n      return null;\n    }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java"
    }
  }
}