{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SaslRpcClient.java",
  "functionName": "getServerPrincipal",
  "functionId": "getServerPrincipal___authType-SaslAuth",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
  "functionStartLine": 297,
  "functionEndLine": 349,
  "numCommitsSeen": 30,
  "timeTaken": 1913,
  "changeHistory": [
    "c5c3e81b49ae6ef0cf9022f90f3709166aa4488d",
    "0710b5890b4795f8f9c57b17b669b6a7190a5d17",
    "e69614d6508c279f34a32160e1fab4aee9f49b2a",
    "e6c1f2233af74f6507367e7e7540ed0cc843a3ba",
    "65be21267587f04a2c33af65b951211cc9085b15"
  ],
  "changeHistoryShort": {
    "c5c3e81b49ae6ef0cf9022f90f3709166aa4488d": "Ybodychange",
    "0710b5890b4795f8f9c57b17b669b6a7190a5d17": "Ybodychange",
    "e69614d6508c279f34a32160e1fab4aee9f49b2a": "Ybodychange",
    "e6c1f2233af74f6507367e7e7540ed0cc843a3ba": "Ymultichange(Ymodifierchange,Ybodychange)",
    "65be21267587f04a2c33af65b951211cc9085b15": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c5c3e81b49ae6ef0cf9022f90f3709166aa4488d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13503. Improve SaslRpcClient failure logging. Contributed by Xiaobing Zhou.\n",
      "commitDate": "18/08/16 2:55 PM",
      "commitName": "c5c3e81b49ae6ef0cf9022f90f3709166aa4488d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "28/10/15 3:25 AM",
      "commitNameOld": "ff2b2bea9143c6299cad4bb7d1d049e415d2d7f3",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 295.48,
      "commitsBetweenForRepo": 2048,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,53 @@\n   String getServerPrincipal(SaslAuth authType) throws IOException {\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     LOG.debug(\"Get kerberos info proto:\" + protocol + \" info:\" + krbInfo);\n     if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n       return null;\n     }\n     String serverKey \u003d krbInfo.serverPrincipal();\n     if (serverKey \u003d\u003d null) {\n       throw new IllegalArgumentException(\n           \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n               + protocol.getCanonicalName());\n     }\n     // construct server advertised principal for comparision\n     String serverPrincipal \u003d new KerberosPrincipal(\n         authType.getProtocol() + \"/\" + authType.getServerId(),\n         KerberosPrincipal.KRB_NT_SRV_HST).getName();\n \n-    boolean isPrincipalValid \u003d false;\n-\n     // use the pattern if defined\n     String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n     if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n       Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n-      isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n+      if (!pattern.matcher(serverPrincipal).matches()) {\n+        throw new IllegalArgumentException(String.format(\n+            \"Server has invalid Kerberos principal: %s,\"\n+                + \" doesn\u0027t match the pattern: %s\",\n+            serverPrincipal, serverKeyPattern));\n+      }\n     } else {\n       // check that the server advertised principal matches our conf\n       String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n           conf.get(serverKey), serverAddr.getAddress());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"getting serverKey: \" + serverKey + \" conf value: \" + conf.get(serverKey)\n             + \" principal: \" + confPrincipal);\n       }\n       if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n         throw new IllegalArgumentException(\n             \"Failed to specify server\u0027s Kerberos principal name\");\n       }\n       KerberosName name \u003d new KerberosName(confPrincipal);\n       if (name.getHostName() \u003d\u003d null) {\n         throw new IllegalArgumentException(\n             \"Kerberos principal name does NOT have the expected hostname part: \"\n                 + confPrincipal);\n       }\n-      isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n-    }\n-    if (!isPrincipalValid) {\n-      throw new IllegalArgumentException(\n-          \"Server has invalid Kerberos principal: \" + serverPrincipal);\n+      if (!serverPrincipal.equals(confPrincipal)) {\n+        throw new IllegalArgumentException(String.format(\n+            \"Server has invalid Kerberos principal: %s, expecting: %s\",\n+            serverPrincipal, confPrincipal));\n+      }\n     }\n     return serverPrincipal;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  String getServerPrincipal(SaslAuth authType) throws IOException {\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    LOG.debug(\"Get kerberos info proto:\" + protocol + \" info:\" + krbInfo);\n    if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n      return null;\n    }\n    String serverKey \u003d krbInfo.serverPrincipal();\n    if (serverKey \u003d\u003d null) {\n      throw new IllegalArgumentException(\n          \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n              + protocol.getCanonicalName());\n    }\n    // construct server advertised principal for comparision\n    String serverPrincipal \u003d new KerberosPrincipal(\n        authType.getProtocol() + \"/\" + authType.getServerId(),\n        KerberosPrincipal.KRB_NT_SRV_HST).getName();\n\n    // use the pattern if defined\n    String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n    if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n      Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n      if (!pattern.matcher(serverPrincipal).matches()) {\n        throw new IllegalArgumentException(String.format(\n            \"Server has invalid Kerberos principal: %s,\"\n                + \" doesn\u0027t match the pattern: %s\",\n            serverPrincipal, serverKeyPattern));\n      }\n    } else {\n      // check that the server advertised principal matches our conf\n      String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n          conf.get(serverKey), serverAddr.getAddress());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"getting serverKey: \" + serverKey + \" conf value: \" + conf.get(serverKey)\n            + \" principal: \" + confPrincipal);\n      }\n      if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n        throw new IllegalArgumentException(\n            \"Failed to specify server\u0027s Kerberos principal name\");\n      }\n      KerberosName name \u003d new KerberosName(confPrincipal);\n      if (name.getHostName() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            \"Kerberos principal name does NOT have the expected hostname part: \"\n                + confPrincipal);\n      }\n      if (!serverPrincipal.equals(confPrincipal)) {\n        throw new IllegalArgumentException(String.format(\n            \"Server has invalid Kerberos principal: %s, expecting: %s\",\n            serverPrincipal, confPrincipal));\n      }\n    }\n    return serverPrincipal;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "0710b5890b4795f8f9c57b17b669b6a7190a5d17": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10418. SaslRpcClient should not assume that remote principals are in the default_realm. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/03/14 5:00 PM",
      "commitName": "0710b5890b4795f8f9c57b17b669b6a7190a5d17",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "19/03/14 1:16 PM",
      "commitNameOld": "f799618828b0ba09b694b07eaab0689d31f4954d",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 4.16,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,50 @@\n   String getServerPrincipal(SaslAuth authType) throws IOException {\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n     if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n       return null;\n     }\n     String serverKey \u003d krbInfo.serverPrincipal();\n     if (serverKey \u003d\u003d null) {\n       throw new IllegalArgumentException(\n           \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n               + protocol.getCanonicalName());\n     }\n     // construct server advertised principal for comparision\n     String serverPrincipal \u003d new KerberosPrincipal(\n-        authType.getProtocol() + \"/\" + authType.getServerId()).getName();\n+        authType.getProtocol() + \"/\" + authType.getServerId(),\n+        KerberosPrincipal.KRB_NT_SRV_HST).getName();\n+\n     boolean isPrincipalValid \u003d false;\n \n     // use the pattern if defined\n     String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n     if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n       Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n       isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n     } else {\n       // check that the server advertised principal matches our conf\n       String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n           conf.get(serverKey), serverAddr.getAddress());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"getting serverKey: \" + serverKey + \" conf value: \" + conf.get(serverKey)\n             + \" principal: \" + confPrincipal);\n       }\n       if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n         throw new IllegalArgumentException(\n             \"Failed to specify server\u0027s Kerberos principal name\");\n       }\n       KerberosName name \u003d new KerberosName(confPrincipal);\n       if (name.getHostName() \u003d\u003d null) {\n         throw new IllegalArgumentException(\n             \"Kerberos principal name does NOT have the expected hostname part: \"\n                 + confPrincipal);\n       }\n       isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n     }\n     if (!isPrincipalValid) {\n       throw new IllegalArgumentException(\n           \"Server has invalid Kerberos principal: \" + serverPrincipal);\n     }\n     return serverPrincipal;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  String getServerPrincipal(SaslAuth authType) throws IOException {\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n    if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n      return null;\n    }\n    String serverKey \u003d krbInfo.serverPrincipal();\n    if (serverKey \u003d\u003d null) {\n      throw new IllegalArgumentException(\n          \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n              + protocol.getCanonicalName());\n    }\n    // construct server advertised principal for comparision\n    String serverPrincipal \u003d new KerberosPrincipal(\n        authType.getProtocol() + \"/\" + authType.getServerId(),\n        KerberosPrincipal.KRB_NT_SRV_HST).getName();\n\n    boolean isPrincipalValid \u003d false;\n\n    // use the pattern if defined\n    String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n    if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n      Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n      isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n    } else {\n      // check that the server advertised principal matches our conf\n      String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n          conf.get(serverKey), serverAddr.getAddress());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"getting serverKey: \" + serverKey + \" conf value: \" + conf.get(serverKey)\n            + \" principal: \" + confPrincipal);\n      }\n      if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n        throw new IllegalArgumentException(\n            \"Failed to specify server\u0027s Kerberos principal name\");\n      }\n      KerberosName name \u003d new KerberosName(confPrincipal);\n      if (name.getHostName() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            \"Kerberos principal name does NOT have the expected hostname part: \"\n                + confPrincipal);\n      }\n      isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n    }\n    if (!isPrincipalValid) {\n      throw new IllegalArgumentException(\n          \"Server has invalid Kerberos principal: \" + serverPrincipal);\n    }\n    return serverPrincipal;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "e69614d6508c279f34a32160e1fab4aee9f49b2a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10070. RPC client doesn\u0027t use per-connection conf to determine server\u0027s expected Kerberos principal name. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570776 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/02/14 5:09 PM",
      "commitName": "e69614d6508c279f34a32160e1fab4aee9f49b2a",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "09/08/13 9:28 AM",
      "commitNameOld": "e6c1f2233af74f6507367e7e7540ed0cc843a3ba",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 196.36,
      "commitsBetweenForRepo": 1283,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,48 @@\n   String getServerPrincipal(SaslAuth authType) throws IOException {\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n     if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n       return null;\n     }\n     String serverKey \u003d krbInfo.serverPrincipal();\n     if (serverKey \u003d\u003d null) {\n       throw new IllegalArgumentException(\n           \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n               + protocol.getCanonicalName());\n     }\n     // construct server advertised principal for comparision\n     String serverPrincipal \u003d new KerberosPrincipal(\n         authType.getProtocol() + \"/\" + authType.getServerId()).getName();\n     boolean isPrincipalValid \u003d false;\n \n     // use the pattern if defined\n     String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n     if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n       Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n       isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n     } else {\n       // check that the server advertised principal matches our conf\n       String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n           conf.get(serverKey), serverAddr.getAddress());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"getting serverKey: \" + serverKey + \" conf value: \" + conf.get(serverKey)\n+            + \" principal: \" + confPrincipal);\n+      }\n       if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n         throw new IllegalArgumentException(\n             \"Failed to specify server\u0027s Kerberos principal name\");\n       }\n       KerberosName name \u003d new KerberosName(confPrincipal);\n       if (name.getHostName() \u003d\u003d null) {\n         throw new IllegalArgumentException(\n             \"Kerberos principal name does NOT have the expected hostname part: \"\n                 + confPrincipal);\n       }\n       isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n     }\n     if (!isPrincipalValid) {\n       throw new IllegalArgumentException(\n           \"Server has invalid Kerberos principal: \" + serverPrincipal);\n     }\n     return serverPrincipal;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  String getServerPrincipal(SaslAuth authType) throws IOException {\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n    if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n      return null;\n    }\n    String serverKey \u003d krbInfo.serverPrincipal();\n    if (serverKey \u003d\u003d null) {\n      throw new IllegalArgumentException(\n          \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n              + protocol.getCanonicalName());\n    }\n    // construct server advertised principal for comparision\n    String serverPrincipal \u003d new KerberosPrincipal(\n        authType.getProtocol() + \"/\" + authType.getServerId()).getName();\n    boolean isPrincipalValid \u003d false;\n\n    // use the pattern if defined\n    String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n    if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n      Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n      isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n    } else {\n      // check that the server advertised principal matches our conf\n      String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n          conf.get(serverKey), serverAddr.getAddress());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"getting serverKey: \" + serverKey + \" conf value: \" + conf.get(serverKey)\n            + \" principal: \" + confPrincipal);\n      }\n      if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n        throw new IllegalArgumentException(\n            \"Failed to specify server\u0027s Kerberos principal name\");\n      }\n      KerberosName name \u003d new KerberosName(confPrincipal);\n      if (name.getHostName() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            \"Kerberos principal name does NOT have the expected hostname part: \"\n                + confPrincipal);\n      }\n      isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n    }\n    if (!isPrincipalValid) {\n      throw new IllegalArgumentException(\n          \"Server has invalid Kerberos principal: \" + serverPrincipal);\n    }\n    return serverPrincipal;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "e6c1f2233af74f6507367e7e7540ed0cc843a3ba": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-9789. Support server advertised kerberos principals (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512380 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/13 9:28 AM",
      "commitName": "e6c1f2233af74f6507367e7e7540ed0cc843a3ba",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-9789. Support server advertised kerberos principals (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512380 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/08/13 9:28 AM",
          "commitName": "e6c1f2233af74f6507367e7e7540ed0cc843a3ba",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "08/08/13 4:02 PM",
          "commitNameOld": "c03c8fe199429a43c6aa944016566738abd9b193",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 0.73,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,44 @@\n-  private String getServerPrincipal(SaslAuth authType) throws IOException {\n+  String getServerPrincipal(SaslAuth authType) throws IOException {\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n     if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n       return null;\n     }\n     String serverKey \u003d krbInfo.serverPrincipal();\n     if (serverKey \u003d\u003d null) {\n       throw new IllegalArgumentException(\n           \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n               + protocol.getCanonicalName());\n     }\n-    // construct the expected principal from the config\n-    String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n-        conf.get(serverKey), serverAddr.getAddress());\n-    if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n-      throw new IllegalArgumentException(\n-          \"Failed to specify server\u0027s Kerberos principal name\");\n+    // construct server advertised principal for comparision\n+    String serverPrincipal \u003d new KerberosPrincipal(\n+        authType.getProtocol() + \"/\" + authType.getServerId()).getName();\n+    boolean isPrincipalValid \u003d false;\n+\n+    // use the pattern if defined\n+    String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n+    if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n+      Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n+      isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n+    } else {\n+      // check that the server advertised principal matches our conf\n+      String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n+          conf.get(serverKey), serverAddr.getAddress());\n+      if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n+        throw new IllegalArgumentException(\n+            \"Failed to specify server\u0027s Kerberos principal name\");\n+      }\n+      KerberosName name \u003d new KerberosName(confPrincipal);\n+      if (name.getHostName() \u003d\u003d null) {\n+        throw new IllegalArgumentException(\n+            \"Kerberos principal name does NOT have the expected hostname part: \"\n+                + confPrincipal);\n+      }\n+      isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n     }\n-    // ensure it looks like a host-based service principal\n-    KerberosName name \u003d new KerberosName(confPrincipal);\n-    if (name.getHostName() \u003d\u003d null) {\n-      throw new IllegalArgumentException(\n-          \"Kerberos principal name does NOT have the expected hostname part: \"\n-              + confPrincipal);\n-    }\n-    // check that the server advertised principal matches our conf\n-    KerberosPrincipal serverPrincipal \u003d new KerberosPrincipal(\n-        authType.getProtocol() + \"/\" + authType.getServerId());\n-    if (!serverPrincipal.getName().equals(confPrincipal)) {\n+    if (!isPrincipalValid) {\n       throw new IllegalArgumentException(\n           \"Server has invalid Kerberos principal: \" + serverPrincipal);\n     }\n-    return confPrincipal;\n+    return serverPrincipal;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  String getServerPrincipal(SaslAuth authType) throws IOException {\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n    if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n      return null;\n    }\n    String serverKey \u003d krbInfo.serverPrincipal();\n    if (serverKey \u003d\u003d null) {\n      throw new IllegalArgumentException(\n          \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n              + protocol.getCanonicalName());\n    }\n    // construct server advertised principal for comparision\n    String serverPrincipal \u003d new KerberosPrincipal(\n        authType.getProtocol() + \"/\" + authType.getServerId()).getName();\n    boolean isPrincipalValid \u003d false;\n\n    // use the pattern if defined\n    String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n    if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n      Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n      isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n    } else {\n      // check that the server advertised principal matches our conf\n      String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n          conf.get(serverKey), serverAddr.getAddress());\n      if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n        throw new IllegalArgumentException(\n            \"Failed to specify server\u0027s Kerberos principal name\");\n      }\n      KerberosName name \u003d new KerberosName(confPrincipal);\n      if (name.getHostName() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            \"Kerberos principal name does NOT have the expected hostname part: \"\n                + confPrincipal);\n      }\n      isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n    }\n    if (!isPrincipalValid) {\n      throw new IllegalArgumentException(\n          \"Server has invalid Kerberos principal: \" + serverPrincipal);\n    }\n    return serverPrincipal;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9789. Support server advertised kerberos principals (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512380 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/08/13 9:28 AM",
          "commitName": "e6c1f2233af74f6507367e7e7540ed0cc843a3ba",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "08/08/13 4:02 PM",
          "commitNameOld": "c03c8fe199429a43c6aa944016566738abd9b193",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 0.73,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,44 @@\n-  private String getServerPrincipal(SaslAuth authType) throws IOException {\n+  String getServerPrincipal(SaslAuth authType) throws IOException {\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n     if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n       return null;\n     }\n     String serverKey \u003d krbInfo.serverPrincipal();\n     if (serverKey \u003d\u003d null) {\n       throw new IllegalArgumentException(\n           \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n               + protocol.getCanonicalName());\n     }\n-    // construct the expected principal from the config\n-    String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n-        conf.get(serverKey), serverAddr.getAddress());\n-    if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n-      throw new IllegalArgumentException(\n-          \"Failed to specify server\u0027s Kerberos principal name\");\n+    // construct server advertised principal for comparision\n+    String serverPrincipal \u003d new KerberosPrincipal(\n+        authType.getProtocol() + \"/\" + authType.getServerId()).getName();\n+    boolean isPrincipalValid \u003d false;\n+\n+    // use the pattern if defined\n+    String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n+    if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n+      Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n+      isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n+    } else {\n+      // check that the server advertised principal matches our conf\n+      String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n+          conf.get(serverKey), serverAddr.getAddress());\n+      if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n+        throw new IllegalArgumentException(\n+            \"Failed to specify server\u0027s Kerberos principal name\");\n+      }\n+      KerberosName name \u003d new KerberosName(confPrincipal);\n+      if (name.getHostName() \u003d\u003d null) {\n+        throw new IllegalArgumentException(\n+            \"Kerberos principal name does NOT have the expected hostname part: \"\n+                + confPrincipal);\n+      }\n+      isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n     }\n-    // ensure it looks like a host-based service principal\n-    KerberosName name \u003d new KerberosName(confPrincipal);\n-    if (name.getHostName() \u003d\u003d null) {\n-      throw new IllegalArgumentException(\n-          \"Kerberos principal name does NOT have the expected hostname part: \"\n-              + confPrincipal);\n-    }\n-    // check that the server advertised principal matches our conf\n-    KerberosPrincipal serverPrincipal \u003d new KerberosPrincipal(\n-        authType.getProtocol() + \"/\" + authType.getServerId());\n-    if (!serverPrincipal.getName().equals(confPrincipal)) {\n+    if (!isPrincipalValid) {\n       throw new IllegalArgumentException(\n           \"Server has invalid Kerberos principal: \" + serverPrincipal);\n     }\n-    return confPrincipal;\n+    return serverPrincipal;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  String getServerPrincipal(SaslAuth authType) throws IOException {\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n    if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n      return null;\n    }\n    String serverKey \u003d krbInfo.serverPrincipal();\n    if (serverKey \u003d\u003d null) {\n      throw new IllegalArgumentException(\n          \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n              + protocol.getCanonicalName());\n    }\n    // construct server advertised principal for comparision\n    String serverPrincipal \u003d new KerberosPrincipal(\n        authType.getProtocol() + \"/\" + authType.getServerId()).getName();\n    boolean isPrincipalValid \u003d false;\n\n    // use the pattern if defined\n    String serverKeyPattern \u003d conf.get(serverKey + \".pattern\");\n    if (serverKeyPattern !\u003d null \u0026\u0026 !serverKeyPattern.isEmpty()) {\n      Pattern pattern \u003d GlobPattern.compile(serverKeyPattern);\n      isPrincipalValid \u003d pattern.matcher(serverPrincipal).matches();\n    } else {\n      // check that the server advertised principal matches our conf\n      String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n          conf.get(serverKey), serverAddr.getAddress());\n      if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n        throw new IllegalArgumentException(\n            \"Failed to specify server\u0027s Kerberos principal name\");\n      }\n      KerberosName name \u003d new KerberosName(confPrincipal);\n      if (name.getHostName() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            \"Kerberos principal name does NOT have the expected hostname part: \"\n                + confPrincipal);\n      }\n      isPrincipalValid \u003d serverPrincipal.equals(confPrincipal);\n    }\n    if (!isPrincipalValid) {\n      throw new IllegalArgumentException(\n          \"Server has invalid Kerberos principal: \" + serverPrincipal);\n    }\n    return serverPrincipal;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "65be21267587f04a2c33af65b951211cc9085b15": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 7:44 AM",
      "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthor": "Daryn Sharp",
      "diff": "@@ -0,0 +1,35 @@\n+  private String getServerPrincipal(SaslAuth authType) throws IOException {\n+    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n+    LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n+    if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n+      return null;\n+    }\n+    String serverKey \u003d krbInfo.serverPrincipal();\n+    if (serverKey \u003d\u003d null) {\n+      throw new IllegalArgumentException(\n+          \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n+              + protocol.getCanonicalName());\n+    }\n+    // construct the expected principal from the config\n+    String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n+        conf.get(serverKey), serverAddr.getAddress());\n+    if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Failed to specify server\u0027s Kerberos principal name\");\n+    }\n+    // ensure it looks like a host-based service principal\n+    KerberosName name \u003d new KerberosName(confPrincipal);\n+    if (name.getHostName() \u003d\u003d null) {\n+      throw new IllegalArgumentException(\n+          \"Kerberos principal name does NOT have the expected hostname part: \"\n+              + confPrincipal);\n+    }\n+    // check that the server advertised principal matches our conf\n+    KerberosPrincipal serverPrincipal \u003d new KerberosPrincipal(\n+        authType.getProtocol() + \"/\" + authType.getServerId());\n+    if (!serverPrincipal.getName().equals(confPrincipal)) {\n+      throw new IllegalArgumentException(\n+          \"Server has invalid Kerberos principal: \" + serverPrincipal);\n+    }\n+    return confPrincipal;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private String getServerPrincipal(SaslAuth authType) throws IOException {\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    LOG.debug(\"Get kerberos info proto:\"+protocol+\" info:\"+krbInfo);\n    if (krbInfo \u003d\u003d null) { // protocol has no support for kerberos\n      return null;\n    }\n    String serverKey \u003d krbInfo.serverPrincipal();\n    if (serverKey \u003d\u003d null) {\n      throw new IllegalArgumentException(\n          \"Can\u0027t obtain server Kerberos config key from protocol\u003d\"\n              + protocol.getCanonicalName());\n    }\n    // construct the expected principal from the config\n    String confPrincipal \u003d SecurityUtil.getServerPrincipal(\n        conf.get(serverKey), serverAddr.getAddress());\n    if (confPrincipal \u003d\u003d null || confPrincipal.isEmpty()) {\n      throw new IllegalArgumentException(\n          \"Failed to specify server\u0027s Kerberos principal name\");\n    }\n    // ensure it looks like a host-based service principal\n    KerberosName name \u003d new KerberosName(confPrincipal);\n    if (name.getHostName() \u003d\u003d null) {\n      throw new IllegalArgumentException(\n          \"Kerberos principal name does NOT have the expected hostname part: \"\n              + confPrincipal);\n    }\n    // check that the server advertised principal matches our conf\n    KerberosPrincipal serverPrincipal \u003d new KerberosPrincipal(\n        authType.getProtocol() + \"/\" + authType.getServerId());\n    if (!serverPrincipal.getName().equals(confPrincipal)) {\n      throw new IllegalArgumentException(\n          \"Server has invalid Kerberos principal: \" + serverPrincipal);\n    }\n    return confPrincipal;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java"
    }
  }
}