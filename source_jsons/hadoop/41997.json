{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKRMStateStore.java",
  "functionName": "initInternal",
  "functionId": "initInternal___conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
  "functionStartLine": 299,
  "functionEndLine": 386,
  "numCommitsSeen": 77,
  "timeTaken": 7107,
  "changeHistory": [
    "285d2c07531a92067368ac4bdd21d309e6e81bc4",
    "a9c70b0e84dab0c41e480a0dc0cb1a22efdc64ee",
    "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9",
    "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
    "bbbf0e2a4136b30cad9dfd36ef138650a1adea60",
    "740204b2926f49ea70596c6059582ce409fbdd90",
    "2e52789edf68016e7a3f450164f8bd3d8e6cb210",
    "bcb2528a51c33e4caff8d744c5e14c1accfc47d0",
    "890a2ebd1af51d24ccbbc5d1d65d17b24ad8ab9b",
    "f271d377357ad680924d19f07e6c8315e7c89bae",
    "960b8f19ca98dbcfdd30f2f1f275b8718d2e872f",
    "d4fec3493351c619a0278929ae2d5c8cd67cbfbe",
    "49a3a0cd0ceb0dfe84367a2adfb8f9f0990a5548",
    "1ba26e3e68bd3bc8d55c18553777c5ba7b97aa4b",
    "c3cc855d27470edca7ca0bdc0aa8907b544b636e",
    "93907baa0b033c1431dc7055116746fc9db508cc",
    "9c95015bb47f362e592393f0cec899fd8fdd3b04",
    "797159bbd4f80c92d8bfe6979b4dd91ce51d0afc",
    "8628c1704b7d8c1a0ac01cea679c03245d11d330"
  ],
  "changeHistoryShort": {
    "285d2c07531a92067368ac4bdd21d309e6e81bc4": "Ybodychange",
    "a9c70b0e84dab0c41e480a0dc0cb1a22efdc64ee": "Ybodychange",
    "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9": "Ybodychange",
    "ff39c0de206a4fce1f0e8a416357a7a8261f8634": "Ybodychange",
    "bbbf0e2a4136b30cad9dfd36ef138650a1adea60": "Ybodychange",
    "740204b2926f49ea70596c6059582ce409fbdd90": "Ybodychange",
    "2e52789edf68016e7a3f450164f8bd3d8e6cb210": "Ybodychange",
    "bcb2528a51c33e4caff8d744c5e14c1accfc47d0": "Yexceptionschange",
    "890a2ebd1af51d24ccbbc5d1d65d17b24ad8ab9b": "Ybodychange",
    "f271d377357ad680924d19f07e6c8315e7c89bae": "Ybodychange",
    "960b8f19ca98dbcfdd30f2f1f275b8718d2e872f": "Ybodychange",
    "d4fec3493351c619a0278929ae2d5c8cd67cbfbe": "Ybodychange",
    "49a3a0cd0ceb0dfe84367a2adfb8f9f0990a5548": "Ybodychange",
    "1ba26e3e68bd3bc8d55c18553777c5ba7b97aa4b": "Ybodychange",
    "c3cc855d27470edca7ca0bdc0aa8907b544b636e": "Ybodychange",
    "93907baa0b033c1431dc7055116746fc9db508cc": "Ybodychange",
    "9c95015bb47f362e592393f0cec899fd8fdd3b04": "Ybodychange",
    "797159bbd4f80c92d8bfe6979b4dd91ce51d0afc": "Ybodychange",
    "8628c1704b7d8c1a0ac01cea679c03245d11d330": "Yintroduced"
  },
  "changeHistoryDetails": {
    "285d2c07531a92067368ac4bdd21d309e6e81bc4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8449. RM HA for AM web server HTTPS Support. (Contributed by Robert Kanter)\n",
      "commitDate": "18/10/18 9:24 PM",
      "commitName": "285d2c07531a92067368ac4bdd21d309e6e81bc4",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "12/06/18 4:43 AM",
      "commitNameOld": "2df73dace06cfd2b3193a14cd455297f8f989617",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 128.7,
      "commitsBetweenForRepo": 1076,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,88 @@\n   public synchronized void initInternal(Configuration conf)\n       throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n     String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n     rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmAppRootHierarchies.put(0, rmAppRoot);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmAppRootHierarchies.put(splitIndex,\n           getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n     }\n \n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n     zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n         YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n \n     appIdNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n     if (appIdNodeSplitIndex \u003c 0 || appIdNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n           YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n               \"Resetting it to \" +\n                   YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n       appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n     }\n \n     zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n \n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \"\n               + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     rmDelegationTokenHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmDelegationTokenHierarchies.put(0, delegationTokensRootPath);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmDelegationTokenHierarchies.put(splitIndex,\n           getNodePath(delegationTokensRootPath, Integer.toString(splitIndex)));\n     }\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n+    proxyCARoot \u003d getNodePath(zkRootNodePath, PROXY_CA_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n     zkManager \u003d resourceManager.getZKManager();\n     if(zkManager\u003d\u003dnull) {\n       zkManager \u003d resourceManager.createAndStartZKManager(conf);\n     }\n     delegationTokenNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n     if (delegationTokenNodeSplitIndex \u003c 0\n         || delegationTokenNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + delegationTokenNodeSplitIndex + \" for config \"\n           + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX\n           + \" specified.  Resetting it to \" +\n           YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n       delegationTokenNodeSplitIndex \u003d\n           YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmAppRootHierarchies.put(0, rmAppRoot);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmAppRootHierarchies.put(splitIndex,\n          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n    }\n\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n        YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n\n    appIdNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n    if (appIdNodeSplitIndex \u003c 0 || appIdNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n              \"Resetting it to \" +\n                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n    }\n\n    zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    rmDelegationTokenHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmDelegationTokenHierarchies.put(0, delegationTokensRootPath);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmDelegationTokenHierarchies.put(splitIndex,\n          getNodePath(delegationTokensRootPath, Integer.toString(splitIndex)));\n    }\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    proxyCARoot \u003d getNodePath(zkRootNodePath, PROXY_CA_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    zkManager \u003d resourceManager.getZKManager();\n    if(zkManager\u003d\u003dnull) {\n      zkManager \u003d resourceManager.createAndStartZKManager(conf);\n    }\n    delegationTokenNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n    if (delegationTokenNodeSplitIndex \u003c 0\n        || delegationTokenNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + delegationTokenNodeSplitIndex + \" for config \"\n          + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX\n          + \" specified.  Resetting it to \" +\n          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n      delegationTokenNodeSplitIndex \u003d\n          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "a9c70b0e84dab0c41e480a0dc0cb1a22efdc64ee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7453. Fix issue where RM fails to switch to active after first successful start. (Rohith Sharma K S via asuresh)\n",
      "commitDate": "08/11/17 8:00 AM",
      "commitName": "a9c70b0e84dab0c41e480a0dc0cb1a22efdc64ee",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "26/10/17 5:47 PM",
      "commitNameOld": "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 12.63,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,87 @@\n   public synchronized void initInternal(Configuration conf)\n       throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n     String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n     rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmAppRootHierarchies.put(0, rmAppRoot);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmAppRootHierarchies.put(splitIndex,\n           getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n     }\n \n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n     zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n         YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n \n     appIdNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n     if (appIdNodeSplitIndex \u003c 0 || appIdNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n           YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n               \"Resetting it to \" +\n                   YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n       appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n     }\n \n     zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n \n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \"\n               + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     rmDelegationTokenHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmDelegationTokenHierarchies.put(0, delegationTokensRootPath);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmDelegationTokenHierarchies.put(splitIndex,\n           getNodePath(delegationTokensRootPath, Integer.toString(splitIndex)));\n     }\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n-    zkManager \u003d resourceManager.getAndStartZKManager(conf);\n+    zkManager \u003d resourceManager.getZKManager();\n+    if(zkManager\u003d\u003dnull) {\n+      zkManager \u003d resourceManager.createAndStartZKManager(conf);\n+    }\n     delegationTokenNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n     if (delegationTokenNodeSplitIndex \u003c 0\n         || delegationTokenNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + delegationTokenNodeSplitIndex + \" for config \"\n           + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX\n           + \" specified.  Resetting it to \" +\n           YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n       delegationTokenNodeSplitIndex \u003d\n           YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmAppRootHierarchies.put(0, rmAppRoot);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmAppRootHierarchies.put(splitIndex,\n          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n    }\n\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n        YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n\n    appIdNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n    if (appIdNodeSplitIndex \u003c 0 || appIdNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n              \"Resetting it to \" +\n                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n    }\n\n    zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    rmDelegationTokenHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmDelegationTokenHierarchies.put(0, delegationTokensRootPath);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmDelegationTokenHierarchies.put(splitIndex,\n          getNodePath(delegationTokensRootPath, Integer.toString(splitIndex)));\n    }\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    zkManager \u003d resourceManager.getZKManager();\n    if(zkManager\u003d\u003dnull) {\n      zkManager \u003d resourceManager.createAndStartZKManager(conf);\n    }\n    delegationTokenNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n    if (delegationTokenNodeSplitIndex \u003c 0\n        || delegationTokenNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + delegationTokenNodeSplitIndex + \" for config \"\n          + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX\n          + \" specified.  Resetting it to \" +\n          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n      delegationTokenNodeSplitIndex \u003d\n          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7262. Add a hierarchy into the ZKRMStateStore for delegation token znodes to prevent jute buffer overflow (rkanter)\n",
      "commitDate": "26/10/17 5:47 PM",
      "commitName": "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 17.28,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,84 @@\n   public synchronized void initInternal(Configuration conf)\n       throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n     String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n     rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmAppRootHierarchies.put(0, rmAppRoot);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmAppRootHierarchies.put(splitIndex,\n           getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n     }\n \n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n     zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n         YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n \n     appIdNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n-    if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n+    if (appIdNodeSplitIndex \u003c 0 || appIdNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n           YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n               \"Resetting it to \" +\n                   YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n       appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n     }\n \n     zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n \n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \"\n               + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n+    rmDelegationTokenHierarchies \u003d new HashMap\u003c\u003e(5);\n+    rmDelegationTokenHierarchies.put(0, delegationTokensRootPath);\n+    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n+      rmDelegationTokenHierarchies.put(splitIndex,\n+          getNodePath(delegationTokensRootPath, Integer.toString(splitIndex)));\n+    }\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n     zkManager \u003d resourceManager.getAndStartZKManager(conf);\n+    delegationTokenNodeSplitIndex \u003d\n+        conf.getInt(YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX,\n+            YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n+    if (delegationTokenNodeSplitIndex \u003c 0\n+        || delegationTokenNodeSplitIndex \u003e 4) {\n+      LOG.info(\"Invalid value \" + delegationTokenNodeSplitIndex + \" for config \"\n+          + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX\n+          + \" specified.  Resetting it to \" +\n+          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n+      delegationTokenNodeSplitIndex \u003d\n+          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX;\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmAppRootHierarchies.put(0, rmAppRoot);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmAppRootHierarchies.put(splitIndex,\n          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n    }\n\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n        YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n\n    appIdNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n    if (appIdNodeSplitIndex \u003c 0 || appIdNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n              \"Resetting it to \" +\n                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n    }\n\n    zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    rmDelegationTokenHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmDelegationTokenHierarchies.put(0, delegationTokensRootPath);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmDelegationTokenHierarchies.put(splitIndex,\n          getNodePath(delegationTokensRootPath, Integer.toString(splitIndex)));\n    }\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    zkManager \u003d resourceManager.getAndStartZKManager(conf);\n    delegationTokenNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n    if (delegationTokenNodeSplitIndex \u003c 0\n        || delegationTokenNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + delegationTokenNodeSplitIndex + \" for config \"\n          + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX\n          + \" specified.  Resetting it to \" +\n          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);\n      delegationTokenNodeSplitIndex \u003d\n          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "ff39c0de206a4fce1f0e8a416357a7a8261f8634": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6840. Implement zookeeper based store for scheduler configuration updates. (Jonathan Hung via wangda)\n\nChange-Id: I9debea674fe8c7e4109d4ca136965a1ea4c48bcc\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "22/08/17 7:20 PM",
      "commitNameOld": "4249172e1419acdb2b69ae3db43dc59da2aa2e03",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 47.66,
      "commitsBetweenForRepo": 467,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,66 @@\n   public synchronized void initInternal(Configuration conf)\n       throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n     String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n     rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmAppRootHierarchies.put(0, rmAppRoot);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmAppRootHierarchies.put(splitIndex,\n           getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n     }\n \n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n     zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n         YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n \n     appIdNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n     if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n           YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n               \"Resetting it to \" +\n                   YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n       appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n     }\n \n     zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n \n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \"\n               + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n-    zkManager \u003d resourceManager.getZKManager();\n-    if (zkManager \u003d\u003d null) {\n-      zkManager \u003d resourceManager.createAndStartZKManager(conf);\n-    }\n+    zkManager \u003d resourceManager.getAndStartZKManager(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmAppRootHierarchies.put(0, rmAppRoot);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmAppRootHierarchies.put(splitIndex,\n          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n    }\n\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n        YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n\n    appIdNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n    if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n              \"Resetting it to \" +\n                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n    }\n\n    zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    zkManager \u003d resourceManager.getAndStartZKManager(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "bbbf0e2a4136b30cad9dfd36ef138650a1adea60": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14741. Refactor curator based ZooKeeper communication into common library. (Íñigo Goiri via Subru).\n",
      "commitDate": "11/08/17 1:58 PM",
      "commitName": "bbbf0e2a4136b30cad9dfd36ef138650a1adea60",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "2797507d51566ab3b8328e5fb1d0beb9fbce5bae",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 9.85,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,69 @@\n   public synchronized void initInternal(Configuration conf)\n       throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n     String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n     rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmAppRootHierarchies.put(0, rmAppRoot);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmAppRootHierarchies.put(splitIndex,\n           getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n     }\n \n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n     zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n         YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n \n     appIdNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n     if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n           YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n               \"Resetting it to \" +\n                   YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n       appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n     }\n \n-    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n+    zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n-\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n \n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \"\n               + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n-    curatorFramework \u003d resourceManager.getCurator();\n-\n-    if (curatorFramework \u003d\u003d null) {\n-      curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n+    zkManager \u003d resourceManager.getZKManager();\n+    if (zkManager \u003d\u003d null) {\n+      zkManager \u003d resourceManager.createAndStartZKManager(conf);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmAppRootHierarchies.put(0, rmAppRoot);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmAppRootHierarchies.put(splitIndex,\n          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n    }\n\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n        YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n\n    appIdNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n    if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n              \"Resetting it to \" +\n                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n    }\n\n    zkAcl \u003d ZKCuratorManager.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    zkManager \u003d resourceManager.getZKManager();\n    if (zkManager \u003d\u003d null) {\n      zkManager \u003d resourceManager.createAndStartZKManager(conf);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "740204b2926f49ea70596c6059582ce409fbdd90": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5006. ResourceManager quit due to ApplicationStateData exceed the limit size of znode in zk. Contributed by Bibin A Chundatt.\n",
      "commitDate": "22/06/17 7:22 PM",
      "commitName": "740204b2926f49ea70596c6059582ce409fbdd90",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "12/06/17 5:37 AM",
      "commitNameOld": "d64c842743da0d9d91c46985a9fd7350ea14b204",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 10.57,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,71 @@\n   public synchronized void initInternal(Configuration conf)\n       throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n     String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n     rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n     rmAppRootHierarchies.put(0, rmAppRoot);\n     for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n       rmAppRootHierarchies.put(splitIndex,\n           getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n     }\n \n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n+    zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n+        YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n \n     appIdNodeSplitIndex \u003d\n         conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n             YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n     if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n       LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n           YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n               \"Resetting it to \" +\n                   YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n       appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n     }\n \n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n \n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n \n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \"\n               + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n     curatorFramework \u003d resourceManager.getCurator();\n \n     if (curatorFramework \u003d\u003d null) {\n       curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmAppRootHierarchies.put(0, rmAppRoot);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmAppRootHierarchies.put(splitIndex,\n          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n    }\n\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zknodeLimit \u003d conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,\n        YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);\n\n    appIdNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n    if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n              \"Resetting it to \" +\n                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n    }\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    curatorFramework \u003d resourceManager.getCurator();\n\n    if (curatorFramework \u003d\u003d null) {\n      curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "2e52789edf68016e7a3f450164f8bd3d8e6cb210": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2962. ZKRMStateStore: Limit the number of znodes under a znode (Contributed by Varun Sexena via Daniel Templeton)\n",
      "commitDate": "28/04/17 1:30 PM",
      "commitName": "2e52789edf68016e7a3f450164f8bd3d8e6cb210",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "30/01/17 9:44 PM",
      "commitNameOld": "87852b6ef4b9d973b7b3999974d41c8860fb1495",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 87.62,
      "commitsBetweenForRepo": 498,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,69 @@\n   public synchronized void initInternal(Configuration conf)\n       throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n-    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n+    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n+    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n+    rmAppRootHierarchies.put(0, rmAppRoot);\n+    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n+      rmAppRootHierarchies.put(splitIndex,\n+          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n+    }\n+\n+    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n \n+    appIdNodeSplitIndex \u003d\n+        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n+            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n+    if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n+      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n+          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n+              \"Resetting it to \" +\n+                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n+      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n+    }\n+\n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n \n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n \n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \"\n               + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n     curatorFramework \u003d resourceManager.getCurator();\n \n     if (curatorFramework \u003d\u003d null) {\n       curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    String hierarchiesPath \u003d getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);\n    rmAppRootHierarchies \u003d new HashMap\u003c\u003e(5);\n    rmAppRootHierarchies.put(0, rmAppRoot);\n    for (int splitIndex \u003d 1; splitIndex \u003c\u003d 4; splitIndex++) {\n      rmAppRootHierarchies.put(splitIndex,\n          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));\n    }\n\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n\n    appIdNodeSplitIndex \u003d\n        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,\n            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n    if (appIdNodeSplitIndex \u003c 1 || appIdNodeSplitIndex \u003e 4) {\n      LOG.info(\"Invalid value \" + appIdNodeSplitIndex + \" for config \" +\n          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + \" specified. \" +\n              \"Resetting it to \" +\n                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);\n      appIdNodeSplitIndex \u003d YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;\n    }\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    curatorFramework \u003d resourceManager.getCurator();\n\n    if (curatorFramework \u003d\u003d null) {\n      curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "bcb2528a51c33e4caff8d744c5e14c1accfc47d0": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-5400. Light cleanup in ZKRMStateStore (templedf via rkanter)\n",
      "commitDate": "28/09/16 2:56 PM",
      "commitName": "bcb2528a51c33e4caff8d744c5e14c1accfc47d0",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "25/09/16 11:00 PM",
      "commitNameOld": "14a696f369f7e3802587f57c8fff3aa51b5ab576",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 2.66,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,50 @@\n-  public synchronized void initInternal(Configuration conf) throws Exception {\n-\n+  public synchronized void initInternal(Configuration conf)\n+      throws IOException, NoSuchAlgorithmException {\n     /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n     zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n         YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n \n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n+\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n+\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n+\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n-          LOG.error(\"Invalid format for \" +\n-              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n+          LOG.error(\"Invalid format for \"\n+              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n     curatorFramework \u003d resourceManager.getCurator();\n+\n     if (curatorFramework \u003d\u003d null) {\n       curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf)\n      throws IOException, NoSuchAlgorithmException {\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \"\n              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    curatorFramework \u003d resourceManager.getCurator();\n\n    if (curatorFramework \u003d\u003d null) {\n      curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {
        "oldValue": "[Exception]",
        "newValue": "[IOException, NoSuchAlgorithmException]"
      }
    },
    "890a2ebd1af51d24ccbbc5d1d65d17b24ad8ab9b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4559. Make leader elector and zk store share the same curator\nclient. Contributed by Jian He\n",
      "commitDate": "20/01/16 2:48 PM",
      "commitName": "890a2ebd1af51d24ccbbc5d1d65d17b24ad8ab9b",
      "commitAuthor": "Xuan",
      "commitDateOld": "29/12/15 3:58 PM",
      "commitNameOld": "52734134116eb4b18686e308d00e71e7e903383e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 21.95,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,46 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n-    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n-    if (zkHostPort \u003d\u003d null) {\n-      throw new YarnRuntimeException(\"No server address specified for \" +\n-          \"zookeeper state store for Resource Manager recovery. \" +\n-          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n-    }\n-    numRetries \u003d\n-        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n-            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n+\n+    /* Initialize fencing related paths, acls, and ops */\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n-    zkSessionTimeout \u003d\n-        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n-            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n-\n-    if (HAUtil.isHAEnabled(conf)) {\n-      zkRetryInterval \u003d zkSessionTimeout / numRetries;\n-    } else {\n-      zkRetryInterval \u003d\n-          conf.getInt(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n-              YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n-    }\n+    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n+    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n+    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n+    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n+        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n \n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n-    zkAuths \u003d RMZKUtils.getZKAuths(conf);\n-\n-    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n-    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n-\n-    /* Initialize fencing related paths, acls, and ops */\n-    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n-        useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n     reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n+    curatorFramework \u003d resourceManager.getCurator();\n+    if (curatorFramework \u003d\u003d null) {\n+      curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n\n    /* Initialize fencing related paths, acls, and ops */\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n    zkSessionTimeout \u003d conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n    curatorFramework \u003d resourceManager.getCurator();\n    if (curatorFramework \u003d\u003d null) {\n      curatorFramework \u003d resourceManager.createAndStartCurator(conf);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "f271d377357ad680924d19f07e6c8315e7c89bae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3736. Add RMStateStore apis to store and load accepted reservations for failover (adhoot via asuresh)\n",
      "commitDate": "05/08/15 12:57 PM",
      "commitName": "f271d377357ad680924d19f07e6c8315e7c89bae",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "07/07/15 2:16 PM",
      "commitNameOld": "c9dd2cada055c0beffd04bad0ded8324f66ad1b7",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 28.95,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       zkRetryInterval \u003d zkSessionTimeout / numRetries;\n     } else {\n       zkRetryInterval \u003d\n           conf.getInt(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n               YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n     }\n \n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n     zkAuths \u003d RMZKUtils.getZKAuths(conf);\n \n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n \n     /* Initialize fencing related paths, acls, and ops */\n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n+    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      zkRetryInterval \u003d zkSessionTimeout / numRetries;\n    } else {\n      zkRetryInterval \u003d\n          conf.getInt(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n              YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n    }\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n    zkAuths \u003d RMZKUtils.getZKAuths(conf);\n\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n    reservationRoot \u003d getNodePath(zkRootNodePath, RESERVATION_SYSTEM_ROOT);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "960b8f19ca98dbcfdd30f2f1f275b8718d2e872f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2716. Refactor ZKRMStateStore retry code with Apache Curator. Contributed by Karthik Kambatla\n",
      "commitDate": "08/06/15 2:50 PM",
      "commitName": "960b8f19ca98dbcfdd30f2f1f275b8718d2e872f",
      "commitAuthor": "Jian He",
      "commitDateOld": "08/05/15 3:12 PM",
      "commitNameOld": "d0b73287c26983f32b0efe01862150e9fd28086f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 30.99,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,62 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       zkRetryInterval \u003d zkSessionTimeout / numRetries;\n     } else {\n       zkRetryInterval \u003d\n-          conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n+          conf.getInt(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n               YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n     }\n \n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n     zkAuths \u003d RMZKUtils.getZKAuths(conf);\n \n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n \n     /* Initialize fencing related paths, acls, and ops */\n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n-    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n-        CreateMode.PERSISTENT);\n-    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n     amrmTokenSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      zkRetryInterval \u003d zkSessionTimeout / numRetries;\n    } else {\n      zkRetryInterval \u003d\n          conf.getInt(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n              YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n    }\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n    zkAuths \u003d RMZKUtils.getZKAuths(conf);\n\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "d4fec3493351c619a0278929ae2d5c8cd67cbfbe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2211. Persist AMRMToken master key in RMStateStore for RM recovery. Contributed by Xuan Gong\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1613515 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/07/14 1:42 PM",
      "commitName": "d4fec3493351c619a0278929ae2d5c8cd67cbfbe",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/07/14 12:58 PM",
      "commitNameOld": "8fbca62a9008306249779367af1d3c329f875552",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 16.03,
      "commitsBetweenForRepo": 135,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,65 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n \n     if (HAUtil.isHAEnabled(conf)) {\n       zkRetryInterval \u003d zkSessionTimeout / numRetries;\n     } else {\n       zkRetryInterval \u003d\n           conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n               YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n     }\n \n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n     zkAuths \u003d RMZKUtils.getZKAuths(conf);\n \n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n \n     /* Initialize fencing related paths, acls, and ops */\n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n         CreateMode.PERSISTENT);\n     deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n+    amrmTokenSecretManagerRoot \u003d\n+        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      zkRetryInterval \u003d zkSessionTimeout / numRetries;\n    } else {\n      zkRetryInterval \u003d\n          conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n              YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n    }\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n    zkAuths \u003d RMZKUtils.getZKAuths(conf);\n\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n        CreateMode.PERSISTENT);\n    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n    amrmTokenSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, AMRMTOKEN_SECRET_MANAGER_ROOT);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "49a3a0cd0ceb0dfe84367a2adfb8f9f0990a5548": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2054. Better defaults for YARN ZK configs for retries and retry-inteval when HA is enabled. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598630 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/14 8:24 AM",
      "commitName": "49a3a0cd0ceb0dfe84367a2adfb8f9f0990a5548",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "15/04/14 7:02 PM",
      "commitNameOld": "38d5ca2e47e8ca1b08d77fe2de6e1e83c6440344",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 44.56,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,63 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n-    zkRetryInterval \u003d\n-        conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n-          YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n+\n+    if (HAUtil.isHAEnabled(conf)) {\n+      zkRetryInterval \u003d zkSessionTimeout / numRetries;\n+    } else {\n+      zkRetryInterval \u003d\n+          conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n+              YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n+    }\n \n     zkAcl \u003d RMZKUtils.getZKAcls(conf);\n     zkAuths \u003d RMZKUtils.getZKAuths(conf);\n \n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n \n     /* Initialize fencing related paths, acls, and ops */\n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n         CreateMode.PERSISTENT);\n     deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n\n    if (HAUtil.isHAEnabled(conf)) {\n      zkRetryInterval \u003d zkSessionTimeout / numRetries;\n    } else {\n      zkRetryInterval \u003d\n          conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n              YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n    }\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n    zkAuths \u003d RMZKUtils.getZKAuths(conf);\n\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n        CreateMode.PERSISTENT);\n    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "1ba26e3e68bd3bc8d55c18553777c5ba7b97aa4b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1528. Allow setting auth for ZK connections. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573014 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/14 9:34 AM",
      "commitName": "1ba26e3e68bd3bc8d55c18553777c5ba7b97aa4b",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "12/02/14 6:09 AM",
      "commitNameOld": "41ec3cce7698c4f6a8156cb6a20e752e25a993a0",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 16.14,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,58 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n     zkRetryInterval \u003d\n         conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n           YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n-    // Parse authentication from configuration.\n-    String zkAclConf \u003d\n-        conf.get(YarnConfiguration.RM_ZK_ACL,\n-            YarnConfiguration.DEFAULT_RM_ZK_ACL);\n-    zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n \n-    try {\n-      zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n-    } catch (ZKUtil.BadAclFormatException bafe) {\n-      LOG.error(\"Invalid format for \" + YarnConfiguration.RM_ZK_ACL);\n-      throw bafe;\n-    }\n+    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n+    zkAuths \u003d RMZKUtils.getZKAuths(conf);\n \n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n \n     /* Initialize fencing related paths, acls, and ops */\n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n         CreateMode.PERSISTENT);\n     deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zkRetryInterval \u003d\n        conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n          YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n\n    zkAcl \u003d RMZKUtils.getZKAcls(conf);\n    zkAuths \u003d RMZKUtils.getZKAuths(conf);\n\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n        CreateMode.PERSISTENT);\n    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "c3cc855d27470edca7ca0bdc0aa8907b544b636e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1029. Added embedded leader election in the ResourceManager. Contributed by Karthik Kambatla.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556103 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/14 5:56 PM",
      "commitName": "c3cc855d27470edca7ca0bdc0aa8907b544b636e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/12/13 6:33 PM",
      "commitNameOld": "93907baa0b033c1431dc7055116746fc9db508cc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 18.97,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n-    zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n+    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n-          YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n+          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n-        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n-            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n+        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n+            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n-        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n-            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n+        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n+            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n     zkRetryInterval \u003d\n-        conf.getLong(YarnConfiguration.ZK_RM_STATE_STORE_RETRY_INTERVAL_MS,\n-          YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_RETRY_INTERVAL_MS);\n+        conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n+          YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n     // Parse authentication from configuration.\n     String zkAclConf \u003d\n-        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n-            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n+        conf.get(YarnConfiguration.RM_ZK_ACL,\n+            YarnConfiguration.DEFAULT_RM_ZK_ACL);\n     zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n \n     try {\n       zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n     } catch (ZKUtil.BadAclFormatException bafe) {\n-      LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n+      LOG.error(\"Invalid format for \" + YarnConfiguration.RM_ZK_ACL);\n       throw bafe;\n     }\n \n     zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n     rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n \n     /* Initialize fencing related paths, acls, and ops */\n     fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n         CreateMode.PERSISTENT);\n     deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n \n     rmDTSecretManagerRoot \u003d\n         getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n     dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n     delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n     dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n         RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.RM_ZK_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.RM_ZK_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);\n    zkRetryInterval \u003d\n        conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,\n          YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);\n    // Parse authentication from configuration.\n    String zkAclConf \u003d\n        conf.get(YarnConfiguration.RM_ZK_ACL,\n            YarnConfiguration.DEFAULT_RM_ZK_ACL);\n    zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n\n    try {\n      zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n    } catch (ZKUtil.BadAclFormatException bafe) {\n      LOG.error(\"Invalid format for \" + YarnConfiguration.RM_ZK_ACL);\n      throw bafe;\n    }\n\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n        CreateMode.PERSISTENT);\n    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "93907baa0b033c1431dc7055116746fc9db508cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1307. Redesign znode structure for Zookeeper based RM state-store for better organization and scalability. Contributed by Tsuyoshi OZAWA.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1552209 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/12/13 6:33 PM",
      "commitName": "93907baa0b033c1431dc7055116746fc9db508cc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/12/13 8:17 PM",
      "commitNameOld": "305ae48136d6e201de4451e824cb7b84f94ba2e0",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 10.93,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,67 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n     zkRetryInterval \u003d\n         conf.getLong(YarnConfiguration.ZK_RM_STATE_STORE_RETRY_INTERVAL_MS,\n           YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_RETRY_INTERVAL_MS);\n     // Parse authentication from configuration.\n     String zkAclConf \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n     zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n \n     try {\n       zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n     } catch (ZKUtil.BadAclFormatException bafe) {\n       LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n       throw bafe;\n     }\n \n-    zkRootNodePath \u003d znodeWorkingPath + \"/\" + ROOT_ZNODE_NAME;\n-    rmDTSecretManagerRoot \u003d zkRootNodePath + \"/\" + RM_DT_SECRET_MANAGER_ROOT;\n-    rmAppRoot \u003d zkRootNodePath + \"/\" + RM_APP_ROOT;\n+    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n+    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n \n     /* Initialize fencing related paths, acls, and ops */\n-    fencingNodePath \u003d zkRootNodePath + \"/\" + FENCING_LOCK;\n+    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n     createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n         CreateMode.PERSISTENT);\n     deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n+\n+    rmDTSecretManagerRoot \u003d\n+        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n+    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n+        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n+    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n+        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n+    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n+        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n    zkRetryInterval \u003d\n        conf.getLong(YarnConfiguration.ZK_RM_STATE_STORE_RETRY_INTERVAL_MS,\n          YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_RETRY_INTERVAL_MS);\n    // Parse authentication from configuration.\n    String zkAclConf \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n    zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n\n    try {\n      zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n    } catch (ZKUtil.BadAclFormatException bafe) {\n      LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n      throw bafe;\n    }\n\n    zkRootNodePath \u003d getNodePath(znodeWorkingPath, ROOT_ZNODE_NAME);\n    rmAppRoot \u003d getNodePath(zkRootNodePath, RM_APP_ROOT);\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d getNodePath(zkRootNodePath, FENCING_LOCK);\n    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n        CreateMode.PERSISTENT);\n    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n\n    rmDTSecretManagerRoot \u003d\n        getNodePath(zkRootNodePath, RM_DT_SECRET_MANAGER_ROOT);\n    dtMasterKeysRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME);\n    delegationTokensRootPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME);\n    dtSequenceNumberPath \u003d getNodePath(rmDTSecretManagerRoot,\n        RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "9c95015bb47f362e592393f0cec899fd8fdd3b04": {
      "type": "Ybodychange",
      "commitMessage": "YARN-895. Changed RM state-store to not crash immediately if RM restarts while the state-store is down. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1547538 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/12/13 11:28 AM",
      "commitName": "9c95015bb47f362e592393f0cec899fd8fdd3b04",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/11/13 3:22 PM",
      "commitNameOld": "6369c8d81972a9a0b6ef41f4508fcb60d34e3d78",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.84,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,59 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n+    zkRetryInterval \u003d\n+        conf.getLong(YarnConfiguration.ZK_RM_STATE_STORE_RETRY_INTERVAL_MS,\n+          YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_RETRY_INTERVAL_MS);\n     // Parse authentication from configuration.\n     String zkAclConf \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n     zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n \n     try {\n       zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n     } catch (ZKUtil.BadAclFormatException bafe) {\n       LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n       throw bafe;\n     }\n \n     zkRootNodePath \u003d znodeWorkingPath + \"/\" + ROOT_ZNODE_NAME;\n     rmDTSecretManagerRoot \u003d zkRootNodePath + \"/\" + RM_DT_SECRET_MANAGER_ROOT;\n     rmAppRoot \u003d zkRootNodePath + \"/\" + RM_APP_ROOT;\n \n     /* Initialize fencing related paths, acls, and ops */\n     fencingNodePath \u003d zkRootNodePath + \"/\" + FENCING_LOCK;\n     createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n         CreateMode.PERSISTENT);\n     deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n     if (HAUtil.isHAEnabled(conf)) {\n       String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n           (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n       if (zkRootNodeAclConf !\u003d null) {\n         zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n         try {\n           zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n         } catch (ZKUtil.BadAclFormatException bafe) {\n           LOG.error(\"Invalid format for \" +\n               YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n           throw bafe;\n         }\n       } else {\n         useDefaultFencingScheme \u003d true;\n         zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n    zkRetryInterval \u003d\n        conf.getLong(YarnConfiguration.ZK_RM_STATE_STORE_RETRY_INTERVAL_MS,\n          YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_RETRY_INTERVAL_MS);\n    // Parse authentication from configuration.\n    String zkAclConf \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n    zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n\n    try {\n      zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n    } catch (ZKUtil.BadAclFormatException bafe) {\n      LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n      throw bafe;\n    }\n\n    zkRootNodePath \u003d znodeWorkingPath + \"/\" + ROOT_ZNODE_NAME;\n    rmDTSecretManagerRoot \u003d zkRootNodePath + \"/\" + RM_DT_SECRET_MANAGER_ROOT;\n    rmAppRoot \u003d zkRootNodePath + \"/\" + RM_APP_ROOT;\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d zkRootNodePath + \"/\" + FENCING_LOCK;\n    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n        CreateMode.PERSISTENT);\n    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "797159bbd4f80c92d8bfe6979b4dd91ce51d0afc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1222. Make improvements in ZKRMStateStore for fencing (Karthik Kambatla via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1541995 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 9:53 AM",
      "commitName": "797159bbd4f80c92d8bfe6979b4dd91ce51d0afc",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "31/10/13 10:25 AM",
      "commitNameOld": "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 14.02,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,56 @@\n   public synchronized void initInternal(Configuration conf) throws Exception {\n     zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n     if (zkHostPort \u003d\u003d null) {\n       throw new YarnRuntimeException(\"No server address specified for \" +\n           \"zookeeper state store for Resource Manager recovery. \" +\n           YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n     }\n     numRetries \u003d\n         conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n     znodeWorkingPath \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n     zkSessionTimeout \u003d\n         conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n     // Parse authentication from configuration.\n     String zkAclConf \u003d\n         conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n             YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n     zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n \n     try {\n       zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n     } catch (ZKUtil.BadAclFormatException bafe) {\n       LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n       throw bafe;\n     }\n \n     zkRootNodePath \u003d znodeWorkingPath + \"/\" + ROOT_ZNODE_NAME;\n     rmDTSecretManagerRoot \u003d zkRootNodePath + \"/\" + RM_DT_SECRET_MANAGER_ROOT;\n     rmAppRoot \u003d zkRootNodePath + \"/\" + RM_APP_ROOT;\n+\n+    /* Initialize fencing related paths, acls, and ops */\n+    fencingNodePath \u003d zkRootNodePath + \"/\" + FENCING_LOCK;\n+    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n+        CreateMode.PERSISTENT);\n+    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n+    if (HAUtil.isHAEnabled(conf)) {\n+      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n+          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n+      if (zkRootNodeAclConf !\u003d null) {\n+        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n+        try {\n+          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n+        } catch (ZKUtil.BadAclFormatException bafe) {\n+          LOG.error(\"Invalid format for \" +\n+              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n+          throw bafe;\n+        }\n+      } else {\n+        useDefaultFencingScheme \u003d true;\n+        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n    // Parse authentication from configuration.\n    String zkAclConf \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n    zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n\n    try {\n      zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n    } catch (ZKUtil.BadAclFormatException bafe) {\n      LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n      throw bafe;\n    }\n\n    zkRootNodePath \u003d znodeWorkingPath + \"/\" + ROOT_ZNODE_NAME;\n    rmDTSecretManagerRoot \u003d zkRootNodePath + \"/\" + RM_DT_SECRET_MANAGER_ROOT;\n    rmAppRoot \u003d zkRootNodePath + \"/\" + RM_APP_ROOT;\n\n    /* Initialize fencing related paths, acls, and ops */\n    fencingNodePath \u003d zkRootNodePath + \"/\" + FENCING_LOCK;\n    createFencingNodePathOp \u003d Op.create(fencingNodePath, new byte[0], zkAcl,\n        CreateMode.PERSISTENT);\n    deleteFencingNodePathOp \u003d Op.delete(fencingNodePath, -1);\n    if (HAUtil.isHAEnabled(conf)) {\n      String zkRootNodeAclConf \u003d HAUtil.getConfValueForRMInstance\n          (YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL, conf);\n      if (zkRootNodeAclConf !\u003d null) {\n        zkRootNodeAclConf \u003d ZKUtil.resolveConfIndirection(zkRootNodeAclConf);\n        try {\n          zkRootNodeAcl \u003d ZKUtil.parseACLs(zkRootNodeAclConf);\n        } catch (ZKUtil.BadAclFormatException bafe) {\n          LOG.error(\"Invalid format for \" +\n              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);\n          throw bafe;\n        }\n      } else {\n        useDefaultFencingScheme \u003d true;\n        zkRootNodeAcl \u003d constructZkRootNodeACL(conf, zkAcl);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "8628c1704b7d8c1a0ac01cea679c03245d11d330": {
      "type": "Yintroduced",
      "commitMessage": "YARN-353. Add Zookeeper-based store implementation for RMStateStore. Contributed by Bikas Saha, Jian He and Karthik Kambatla.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1524829 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/09/13 1:39 PM",
      "commitName": "8628c1704b7d8c1a0ac01cea679c03245d11d330",
      "commitAuthor": "Hitesh Shah",
      "diff": "@@ -0,0 +1,33 @@\n+  public synchronized void initInternal(Configuration conf) throws Exception {\n+    zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n+    if (zkHostPort \u003d\u003d null) {\n+      throw new YarnRuntimeException(\"No server address specified for \" +\n+          \"zookeeper state store for Resource Manager recovery. \" +\n+          YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n+    }\n+    numRetries \u003d\n+        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n+            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n+    znodeWorkingPath \u003d\n+        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n+            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n+    zkSessionTimeout \u003d\n+        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n+            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n+    // Parse authentication from configuration.\n+    String zkAclConf \u003d\n+        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n+            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n+    zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n+\n+    try {\n+      zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n+    } catch (ZKUtil.BadAclFormatException bafe) {\n+      LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n+      throw bafe;\n+    }\n+\n+    zkRootNodePath \u003d znodeWorkingPath + \"/\" + ROOT_ZNODE_NAME;\n+    rmDTSecretManagerRoot \u003d zkRootNodePath + \"/\" + RM_DT_SECRET_MANAGER_ROOT;\n+    rmAppRoot \u003d zkRootNodePath + \"/\" + RM_APP_ROOT;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void initInternal(Configuration conf) throws Exception {\n    zkHostPort \u003d conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS);\n    if (zkHostPort \u003d\u003d null) {\n      throw new YarnRuntimeException(\"No server address specified for \" +\n          \"zookeeper state store for Resource Manager recovery. \" +\n          YarnConfiguration.ZK_RM_STATE_STORE_ADDRESS + \" is not configured.\");\n    }\n    numRetries \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_NUM_RETRIES,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_NUM_RETRIES);\n    znodeWorkingPath \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);\n    zkSessionTimeout \u003d\n        conf.getInt(YarnConfiguration.ZK_RM_STATE_STORE_TIMEOUT_MS,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_TIMEOUT_MS);\n    // Parse authentication from configuration.\n    String zkAclConf \u003d\n        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_ACL,\n            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_ACL);\n    zkAclConf \u003d ZKUtil.resolveConfIndirection(zkAclConf);\n\n    try {\n      zkAcl \u003d ZKUtil.parseACLs(zkAclConf);\n    } catch (ZKUtil.BadAclFormatException bafe) {\n      LOG.error(\"Invalid format for \" + YarnConfiguration.ZK_RM_STATE_STORE_ACL);\n      throw bafe;\n    }\n\n    zkRootNodePath \u003d znodeWorkingPath + \"/\" + ROOT_ZNODE_NAME;\n    rmDTSecretManagerRoot \u003d zkRootNodePath + \"/\" + RM_DT_SECRET_MANAGER_ROOT;\n    rmAppRoot \u003d zkRootNodePath + \"/\" + RM_APP_ROOT;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java"
    }
  }
}