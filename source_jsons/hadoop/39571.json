{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ParentQueue.java",
  "functionName": "assignContainers",
  "functionId": "assignContainers___clusterResource-Resource__candidates-CandidateNodeSet__FiCaSchedulerNode____resourceLimits-ResourceLimits__schedulingMode-SchedulingMode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
  "functionStartLine": 541,
  "functionEndLine": 717,
  "numCommitsSeen": 322,
  "timeTaken": 21280,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
    "bd2590d71ba1f3db1c686f7afeaf51382f8d8a2f",
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
    "51654a3962bcd0482c0e1dd32765e9533e3f9158",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "1eae719bcead45915977aa220324650eab3c1b9e",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188",
    "4d92aefd35d4517d9435d81bafdec0d77905a7a0",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434",
    "ba2313d6145a1234777938a747187373f4cd58d9",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15",
    "14dd647c556016d351f425ee956ccf800ccb9ce2",
    "86358221fc85a7743052a0b4c1647353508bf308",
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "9c22065109a77681bc2534063eabe8692fbcb3cd",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "c76b264196d76a323ccf409acdd5fabe429e047c",
    "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef",
    "4a343c9d4ab4c993b545f0c1062c6b5449b065f0",
    "f24dcb3449c77da665058427bc7fa480cad507fc",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": "Ybodychange",
    "bd2590d71ba1f3db1c686f7afeaf51382f8d8a2f": "Ybodychange",
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd": "Ybodychange",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": "Ybodychange",
    "51654a3962bcd0482c0e1dd32765e9533e3f9158": "Ybodychange",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": "Ymultichange(Yparameterchange,Ybodychange)",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ymultichange(Yparameterchange,Ybodychange)",
    "1eae719bcead45915977aa220324650eab3c1b9e": "Ybodychange",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": "Ymultichange(Ymodifierchange,Ybodychange)",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": "Ybodychange",
    "4d92aefd35d4517d9435d81bafdec0d77905a7a0": "Ybodychange",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": "Ybodychange",
    "ba2313d6145a1234777938a747187373f4cd58d9": "Ybodychange",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": "Ybodychange",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": "Ymultichange(Yparameterchange,Ybodychange)",
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383": "Ybodychange",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": "Ymultichange(Yparameterchange,Ybodychange)",
    "14dd647c556016d351f425ee956ccf800ccb9ce2": "Ymultichange(Yparameterchange,Ybodychange)",
    "86358221fc85a7743052a0b4c1647353508bf308": "Ybodychange",
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "9c22065109a77681bc2534063eabe8692fbcb3cd": "Ymultichange(Yparameterchange,Ybodychange)",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Yparameterchange",
    "c76b264196d76a323ccf409acdd5fabe429e047c": "Ybodychange",
    "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef": "Ybodychange",
    "4a343c9d4ab4c993b545f0c1062c6b5449b065f0": "Ymultichange(Yreturntypechange,Ybodychange)",
    "f24dcb3449c77da665058427bc7fa480cad507fc": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "29/08/19 3:14 AM",
      "commitNameOld": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 209.05,
      "commitsBetweenForRepo": 935,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,177 +1,177 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n       CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it is not able to access partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          getParentName(), getQueueName(), ActivityState.REJECTED,\n+          getParentName(), getQueuePath(), ActivityState.REJECTED,\n           ActivityDiagnosticConstant.QUEUE_NOT_ABLE_TO_ACCESS_PARTITION);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(candidates.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n               + schedulingMode.name() + \" node-partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          getParentName(), getQueueName(), ActivityState.SKIPPED,\n+          getParentName(), getQueuePath(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n       LOG.debug(\"Trying to assign containers to child-queue of {}\",\n-          getQueueName());\n+          getQueuePath());\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource,\n           candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.REJECTED,\n+            getParentName(), getQueuePath(), ActivityState.REJECTED,\n             ActivityDiagnosticConstant.QUEUE_HIT_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n           clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n       assignment.setFulfilledReservation(\n           assignedToChild.isFulfilledReservation());\n       assignment.setFulfilledReservedContainer(\n           assignedToChild.getFulfilledReservedContainer());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n+            getParentName(), getQueuePath(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n               activitiesManager, node,\n               assignedToChild.getAssignmentInformation()\n                   .getFirstAllocatedOrReservedContainerId(),\n               isReserved ?\n                   AllocationState.RESERVED : AllocationState.ALLOCATED);\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n-              + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n+              + getQueuePath() + \" usedCapacity\u003d\" + getUsedCapacity()\n               + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n               + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n \n           LOG.debug(\n-              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n+              \"ParentQ\u003d\" + getQueuePath() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.SKIPPED,\n+            getParentName(), getQueuePath(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueuePath(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.QUEUE_NOT_ABLE_TO_ACCESS_PARTITION);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueuePath(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      LOG.debug(\"Trying to assign containers to child-queue of {}\",\n          getQueuePath());\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueuePath(), ActivityState.REJECTED,\n            ActivityDiagnosticConstant.QUEUE_HIT_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n      assignment.setFulfilledReservation(\n          assignedToChild.isFulfilledReservation());\n      assignment.setFulfilledReservedContainer(\n          assignedToChild.getFulfilledReservedContainer());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueuePath(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n              activitiesManager, node,\n              assignedToChild.getAssignmentInformation()\n                  .getFirstAllocatedOrReservedContainerId(),\n              isReserved ?\n                  AllocationState.RESERVED : AllocationState.ALLOCATED);\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n              + getQueuePath() + \" usedCapacity\u003d\" + getUsedCapacity()\n              + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n              + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueuePath() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueuePath(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9664. Improve response of scheduler/app activities for better understanding. Contributed by Tao Yang.\n",
      "commitDate": "29/08/19 3:14 AM",
      "commitName": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "26/08/19 8:36 AM",
      "commitNameOld": "689d2e61058b5f719c6cbe9897a72b19b44a29a3",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 2.78,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,177 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n       CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it is not able to access partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.REJECTED,\n-          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION\n-              + candidates.getPartition());\n+          ActivityDiagnosticConstant.QUEUE_NOT_ABLE_TO_ACCESS_PARTITION);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(candidates.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n               + schedulingMode.name() + \" node-partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n       LOG.debug(\"Trying to assign containers to child-queue of {}\",\n           getQueueName());\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource,\n           candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.SKIPPED,\n-            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+            getParentName(), getQueueName(), ActivityState.REJECTED,\n+            ActivityDiagnosticConstant.QUEUE_HIT_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n           clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n       assignment.setFulfilledReservation(\n           assignedToChild.isFulfilledReservation());\n       assignment.setFulfilledReservedContainer(\n           assignedToChild.getFulfilledReservedContainer());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n-        if (node !\u003d null \u0026\u0026 !isReserved) {\n-          if (rootQueue) {\n-            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                activitiesManager, node,\n-                assignedToChild.getAssignmentInformation()\n-                    .getFirstAllocatedOrReservedContainerId(),\n-                AllocationState.ALLOCATED);\n-          }\n-        } else{\n-          if (rootQueue) {\n-            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                activitiesManager, node,\n-                assignedToChild.getAssignmentInformation()\n-                    .getFirstAllocatedOrReservedContainerId(),\n-                AllocationState.RESERVED);\n-          }\n+        if (rootQueue) {\n+          ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+              activitiesManager, node,\n+              assignedToChild.getAssignmentInformation()\n+                  .getFirstAllocatedOrReservedContainerId(),\n+              isReserved ?\n+                  AllocationState.RESERVED : AllocationState.ALLOCATED);\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n               + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n               + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n               + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n \n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.QUEUE_NOT_ABLE_TO_ACCESS_PARTITION);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      LOG.debug(\"Trying to assign containers to child-queue of {}\",\n          getQueueName());\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.REJECTED,\n            ActivityDiagnosticConstant.QUEUE_HIT_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n      assignment.setFulfilledReservation(\n          assignedToChild.isFulfilledReservation());\n      assignment.setFulfilledReservedContainer(\n          assignedToChild.getFulfilledReservedContainer());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n              activitiesManager, node,\n              assignedToChild.getAssignmentInformation()\n                  .getFirstAllocatedOrReservedContainerId(),\n              isReserved ?\n                  AllocationState.RESERVED : AllocationState.ALLOCATED);\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n              + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n              + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n              + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "bd2590d71ba1f3db1c686f7afeaf51382f8d8a2f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9580. Fulfilled reservation information in assignment is lost when transferring in ParentQueue#assignContainers. Contributed by Tao Yang.\n",
      "commitDate": "03/06/19 7:59 AM",
      "commitName": "bd2590d71ba1f3db1c686f7afeaf51382f8d8a2f",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "23/04/19 12:40 PM",
      "commitNameOld": "c504eee0c29276a385ff68ce456f08150aa25e80",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 40.8,
      "commitsBetweenForRepo": 216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,183 +1,187 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n       CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it is not able to access partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.REJECTED,\n           ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION\n               + candidates.getPartition());\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(candidates.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n               + schedulingMode.name() + \" node-partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n       LOG.debug(\"Trying to assign containers to child-queue of {}\",\n           getQueueName());\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource,\n           candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n           clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n+      assignment.setFulfilledReservation(\n+          assignedToChild.isFulfilledReservation());\n+      assignment.setFulfilledReservedContainer(\n+          assignedToChild.getFulfilledReservedContainer());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n         if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.ALLOCATED);\n           }\n         } else{\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.RESERVED);\n           }\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n               + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n               + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n               + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n \n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION\n              + candidates.getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      LOG.debug(\"Trying to assign containers to child-queue of {}\",\n          getQueueName());\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n      assignment.setFulfilledReservation(\n          assignedToChild.isFulfilledReservation());\n      assignment.setFulfilledReservedContainer(\n          assignedToChild.getFulfilledReservedContainer());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n              + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n              + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n              + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9363.  Replaced debug logging with SLF4J parameterized log message.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "18/03/19 10:57 AM",
      "commitName": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 2.78,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,185 +1,183 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n       CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it is not able to access partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.REJECTED,\n           ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION\n               + candidates.getPartition());\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(candidates.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n               + schedulingMode.name() + \" node-partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Trying to assign containers to child-queue of \"\n-            + getQueueName());\n-      }\n+      LOG.debug(\"Trying to assign containers to child-queue of {}\",\n+          getQueueName());\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource,\n           candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n           clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n         if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.ALLOCATED);\n           }\n         } else{\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.RESERVED);\n           }\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n               + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n               + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n               + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n \n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION\n              + candidates.getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      LOG.debug(\"Trying to assign containers to child-queue of {}\",\n          getQueueName());\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n              + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n              + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n              + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
      "commitDate": "21/08/18 7:42 AM",
      "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "03/07/18 9:59 AM",
      "commitNameOld": "51654a3962bcd0482c0e1dd32765e9533e3f9158",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 48.9,
      "commitsBetweenForRepo": 376,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,185 +1,185 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n       CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it is not able to access partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.REJECTED,\n-          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n-              .getPartition());\n+          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION\n+              + candidates.getPartition());\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(candidates.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         long now \u003d System.currentTimeMillis();\n         // Do logging every 1 sec to avoid excessive logging.\n         if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n               + schedulingMode.name() + \" node-partition\u003d\" + candidates\n               .getPartition());\n           this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n         }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n             + getQueueName());\n       }\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource,\n           candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n           clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n         if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.ALLOCATED);\n           }\n         } else{\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.RESERVED);\n           }\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n               + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n               + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n               + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n \n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION\n              + candidates.getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n            + getQueueName());\n      }\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n              + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n              + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n              + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "51654a3962bcd0482c0e1dd32765e9533e3f9158": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8459. Improve Capacity Scheduler logs to debug invalid states. Contributed by Wangda Tan.\n",
      "commitDate": "03/07/18 9:59 AM",
      "commitName": "51654a3962bcd0482c0e1dd32765e9533e3f9158",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.06,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,185 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n       CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it is not able to access partition\u003d\" + candidates\n-            .getPartition());\n+        long now \u003d System.currentTimeMillis();\n+        // Do logging every 1 sec to avoid excessive logging.\n+        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n+          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+              + \", because it is not able to access partition\u003d\" + candidates\n+              .getPartition());\n+          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n+        }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.REJECTED,\n           ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n               .getPartition());\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(candidates.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n-            + schedulingMode.name() + \" node-partition\u003d\" + candidates\n-            .getPartition());\n+        long now \u003d System.currentTimeMillis();\n+        // Do logging every 1 sec to avoid excessive logging.\n+        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n+          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n+              + schedulingMode.name() + \" node-partition\u003d\" + candidates\n+              .getPartition());\n+          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n+        }\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n             + getQueueName());\n       }\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource,\n           candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n           clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n         if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.ALLOCATED);\n           }\n         } else{\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.RESERVED);\n           }\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n-        LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n-            + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n-            + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n-            + \" cluster\u003d\" + clusterResource);\n-\n         if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n+              + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n+              + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n+              + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n+\n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n              .getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        long now \u003d System.currentTimeMillis();\n        // Do logging every 1 sec to avoid excessive logging.\n        if (now - this.lastSkipQueueDebugLoggingTimestamp \u003e 1000) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + candidates\n              .getPartition());\n          this.lastSkipQueueDebugLoggingTimestamp \u003d now;\n        }\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n            + getQueueName());\n      }\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"assignedContainer reserved\u003d\" + isReserved + \" queue\u003d\"\n              + getQueueName() + \" usedCapacity\u003d\" + getUsedCapacity()\n              + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() + \" used\u003d\"\n              + queueUsage.getUsed() + \" cluster\u003d\" + clusterResource);\n\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
      "commitDate": "09/11/17 1:01 PM",
      "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
      "commitAuthor": "Konstantinos Karanasos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
          "commitDate": "09/11/17 1:01 PM",
          "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
          "commitAuthor": "Konstantinos Karanasos",
          "commitDateOld": "06/11/17 9:38 PM",
          "commitNameOld": "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 2.64,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,174 +1,175 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n-      PlacementSet\u003cFiCaSchedulerNode\u003e ps, ResourceLimits resourceLimits,\n-    SchedulingMode schedulingMode) {\n-    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n+      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n+    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n-        \u0026\u0026 !accessibleToPartition(ps.getPartition())) {\n+        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it is not able to access partition\u003d\" + ps\n+            + \", because it is not able to access partition\u003d\" + candidates\n             .getPartition());\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.REJECTED,\n           ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n               .getPartition());\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n-    if (!super.hasPendingResourceRequest(ps.getPartition(), clusterResource,\n-        schedulingMode)) {\n+    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n+        clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n-            + schedulingMode.name() + \" node-partition\u003d\" + ps\n+            + schedulingMode.name() + \" node-partition\u003d\" + candidates\n             .getPartition());\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n             + getQueueName());\n       }\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n-      if (!super.canAssignToThisQueue(clusterResource, ps.getPartition(),\n+      if (!super.canAssignToThisQueue(clusterResource,\n+          candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n-          clusterResource, ps, resourceLimits, schedulingMode);\n+          clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n         if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.ALLOCATED);\n           }\n         } else{\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.RESERVED);\n           }\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n         LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n             + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n             + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n             + \" cluster\u003d\" + clusterResource);\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + candidates\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n              .getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + candidates\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n            + getQueueName());\n      }\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n            + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n            + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n            + \" cluster\u003d\" + clusterResource);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, ps-PlacementSet\u003cFiCaSchedulerNode\u003e, resourceLimits-ResourceLimits, schedulingMode-SchedulingMode]",
            "newValue": "[clusterResource-Resource, candidates-CandidateNodeSet\u003cFiCaSchedulerNode\u003e, resourceLimits-ResourceLimits, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
          "commitDate": "09/11/17 1:01 PM",
          "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
          "commitAuthor": "Konstantinos Karanasos",
          "commitDateOld": "06/11/17 9:38 PM",
          "commitNameOld": "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 2.64,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,174 +1,175 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n-      PlacementSet\u003cFiCaSchedulerNode\u003e ps, ResourceLimits resourceLimits,\n-    SchedulingMode schedulingMode) {\n-    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n+      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n+    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n-        \u0026\u0026 !accessibleToPartition(ps.getPartition())) {\n+        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it is not able to access partition\u003d\" + ps\n+            + \", because it is not able to access partition\u003d\" + candidates\n             .getPartition());\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.REJECTED,\n           ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n               .getPartition());\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n-    if (!super.hasPendingResourceRequest(ps.getPartition(), clusterResource,\n-        schedulingMode)) {\n+    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n+        clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n-            + schedulingMode.name() + \" node-partition\u003d\" + ps\n+            + schedulingMode.name() + \" node-partition\u003d\" + candidates\n             .getPartition());\n       }\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           getParentName(), getQueueName(), ActivityState.SKIPPED,\n           ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n       if (rootQueue) {\n         ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n             node);\n       }\n \n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n \n     CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n         NodeType.NODE_LOCAL);\n \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n             + getQueueName());\n       }\n \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n-      if (!super.canAssignToThisQueue(clusterResource, ps.getPartition(),\n+      if (!super.canAssignToThisQueue(clusterResource,\n+          candidates.getPartition(),\n           resourceLimits, Resources\n               .createResource(getMetrics().getReservedMB(),\n                   getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       // Schedule\n       CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n-          clusterResource, ps, resourceLimits, schedulingMode);\n+          clusterResource, candidates, resourceLimits, schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       assignment.setRequestLocalityType(\n           assignedToChild.getRequestLocalityType());\n       assignment.setExcessReservation(assignedToChild.getExcessReservation());\n       assignment.setContainersToKill(assignedToChild.getContainersToKill());\n \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           assignedToChild.getResource(), Resources.none())) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.ACCEPTED,\n             ActivityDiagnosticConstant.EMPTY);\n \n         boolean isReserved \u003d\n             assignedToChild.getAssignmentInformation().getReservationDetails()\n                 !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                 .getReservationDetails().isEmpty();\n         if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.ALLOCATED);\n           }\n         } else{\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                 activitiesManager, node,\n                 assignedToChild.getAssignmentInformation()\n                     .getFirstAllocatedOrReservedContainerId(),\n                 AllocationState.RESERVED);\n           }\n         }\n \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(),\n             assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n             assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n             assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n             assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment.getAssignmentInformation().getAllocationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getAllocationDetails());\n         assignment.getAssignmentInformation().getReservationDetails().addAll(\n             assignedToChild.getAssignmentInformation()\n                 .getReservationDetails());\n         assignment.setIncreasedAllocation(\n             assignedToChild.isIncreasedAllocation());\n \n         LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n             + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n             + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n             + \" cluster\u003d\" + clusterResource);\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n       } else{\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.EMPTY);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         break;\n       }\n \n       /*\n        * Previously here, we can allocate more than one container for each\n        * allocation under rootQ. Now this logic is not proper any more\n        * in global scheduling world.\n        *\n        * So here do not try to allocate more than one container for each\n        * allocation, let top scheduler make the decision.\n        */\n       break;\n     }\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      ResourceLimits resourceLimits, SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + candidates\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n              .getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(candidates.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + candidates\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n            + getQueueName());\n      }\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource,\n          candidates.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, candidates, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n            + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n            + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n            + \" cluster\u003d\" + clusterResource);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "28/10/16 10:30 AM",
          "commitNameOld": "1eae719bcead45915977aa220324650eab3c1b9e",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 10.03,
          "commitsBetweenForRepo": 100,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,182 +1,174 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n-      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n-      SchedulingMode schedulingMode) {\n-    int offswitchCount \u003d 0;\n-    try {\n-      writeLock.lock();\n-      // if our queue cannot access this node, just return\n-      if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n-          \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-              + \", because it is not able to access partition\u003d\" + node\n-              .getPartition());\n-        }\n+      PlacementSet\u003cFiCaSchedulerNode\u003e ps, ResourceLimits resourceLimits,\n+    SchedulingMode schedulingMode) {\n+    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n \n-        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.REJECTED,\n-            ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n-                .getPartition());\n-        if (rootQueue) {\n-          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-              node);\n-        }\n-\n-        return CSAssignment.NULL_ASSIGNMENT;\n+    // if our queue cannot access this node, just return\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n+        \u0026\u0026 !accessibleToPartition(ps.getPartition())) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it is not able to access partition\u003d\" + ps\n+            .getPartition());\n       }\n \n-      // Check if this queue need more resource, simply skip allocation if this\n-      // queue doesn\u0027t need more resources.\n-      if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n-          schedulingMode)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n-              + schedulingMode.name() + \" node-partition\u003d\" + node\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          getParentName(), getQueueName(), ActivityState.REJECTED,\n+          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n               .getPartition());\n-        }\n+      if (rootQueue) {\n+        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+            node);\n+      }\n+\n+      return CSAssignment.NULL_ASSIGNMENT;\n+    }\n+\n+    // Check if this queue need more resource, simply skip allocation if this\n+    // queue doesn\u0027t need more resources.\n+    if (!super.hasPendingResourceRequest(ps.getPartition(), clusterResource,\n+        schedulingMode)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n+            + schedulingMode.name() + \" node-partition\u003d\" + ps\n+            .getPartition());\n+      }\n+\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          getParentName(), getQueueName(), ActivityState.SKIPPED,\n+          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n+      if (rootQueue) {\n+        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+            node);\n+      }\n+\n+      return CSAssignment.NULL_ASSIGNMENT;\n+    }\n+\n+    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n+        NodeType.NODE_LOCAL);\n+\n+    while (canAssign(clusterResource, node)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Trying to assign containers to child-queue of \"\n+            + getQueueName());\n+      }\n+\n+      // Are we over maximum-capacity for this queue?\n+      // This will also consider parent\u0027s limits and also continuous reservation\n+      // looking\n+      if (!super.canAssignToThisQueue(clusterResource, ps.getPartition(),\n+          resourceLimits, Resources\n+              .createResource(getMetrics().getReservedMB(),\n+                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n-            ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n+            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n-        return CSAssignment.NULL_ASSIGNMENT;\n+        break;\n       }\n \n-      CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n-          NodeType.NODE_LOCAL);\n+      // Schedule\n+      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n+          clusterResource, ps, resourceLimits, schedulingMode);\n+      assignment.setType(assignedToChild.getType());\n+      assignment.setRequestLocalityType(\n+          assignedToChild.getRequestLocalityType());\n+      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n+      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n \n-      while (canAssign(clusterResource, node)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Trying to assign containers to child-queue of \"\n-              + getQueueName());\n-        }\n+      // Done if no child-queue assigned anything\n+      if (Resources.greaterThan(resourceCalculator, clusterResource,\n+          assignedToChild.getResource(), Resources.none())) {\n \n-        // Are we over maximum-capacity for this queue?\n-        // This will also consider parent\u0027s limits and also continuous reservation\n-        // looking\n-        if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n-            resourceLimits, Resources\n-                .createResource(getMetrics().getReservedMB(),\n-                    getMetrics().getReservedVirtualCores()), schedulingMode)) {\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n+            ActivityDiagnosticConstant.EMPTY);\n \n-          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-              getParentName(), getQueueName(), ActivityState.SKIPPED,\n-              ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+        boolean isReserved \u003d\n+            assignedToChild.getAssignmentInformation().getReservationDetails()\n+                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n+                .getReservationDetails().isEmpty();\n+        if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n-            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-                node);\n+            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                activitiesManager, node,\n+                assignedToChild.getAssignmentInformation()\n+                    .getFirstAllocatedOrReservedContainerId(),\n+                AllocationState.ALLOCATED);\n           }\n-\n-          break;\n-        }\n-\n-        // Schedule\n-        CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n-            clusterResource, node, resourceLimits, schedulingMode);\n-        assignment.setType(assignedToChild.getType());\n-\n-        // Done if no child-queue assigned anything\n-        if (Resources.greaterThan(resourceCalculator, clusterResource,\n-            assignedToChild.getResource(), Resources.none())) {\n-\n-          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-              getParentName(), getQueueName(), ActivityState.ACCEPTED,\n-              ActivityDiagnosticConstant.EMPTY);\n-\n-          if (node.getReservedContainer() \u003d\u003d null) {\n-            if (rootQueue) {\n-              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                  activitiesManager, node,\n-                  assignedToChild.getAssignmentInformation()\n-                      .getFirstAllocatedOrReservedContainerId(),\n-                  AllocationState.ALLOCATED);\n-            }\n-          } else{\n-            if (rootQueue) {\n-              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                  activitiesManager, node,\n-                  assignedToChild.getAssignmentInformation()\n-                      .getFirstAllocatedOrReservedContainerId(),\n-                  AllocationState.RESERVED);\n-            }\n-          }\n-\n-          // Track resource utilization for the parent-queue\n-          allocateResource(clusterResource, assignedToChild.getResource(),\n-              node.getPartition(), assignedToChild.isIncreasedAllocation());\n-\n-          // Track resource utilization in this pass of the scheduler\n-          Resources.addTo(assignment.getResource(),\n-              assignedToChild.getResource());\n-          Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n-              assignedToChild.getAssignmentInformation().getAllocated());\n-          Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n-              assignedToChild.getAssignmentInformation().getReserved());\n-          assignment.getAssignmentInformation().incrAllocations(\n-              assignedToChild.getAssignmentInformation().getNumAllocations());\n-          assignment.getAssignmentInformation().incrReservations(\n-              assignedToChild.getAssignmentInformation().getNumReservations());\n-          assignment.getAssignmentInformation().getAllocationDetails().addAll(\n-              assignedToChild.getAssignmentInformation()\n-                  .getAllocationDetails());\n-          assignment.getAssignmentInformation().getReservationDetails().addAll(\n-              assignedToChild.getAssignmentInformation()\n-                  .getReservationDetails());\n-          assignment.setIncreasedAllocation(\n-              assignedToChild.isIncreasedAllocation());\n-\n-          LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n-              + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n-              + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n-              + \" cluster\u003d\" + clusterResource);\n-\n         } else{\n-          assignment.setSkippedType(assignedToChild.getSkippedType());\n-\n-          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-              getParentName(), getQueueName(), ActivityState.SKIPPED,\n-              ActivityDiagnosticConstant.EMPTY);\n           if (rootQueue) {\n-            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-                node);\n+            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                activitiesManager, node,\n+                assignedToChild.getAssignmentInformation()\n+                    .getFirstAllocatedOrReservedContainerId(),\n+                AllocationState.RESERVED);\n           }\n-\n-          break;\n         }\n \n+        // Track resource utilization in this pass of the scheduler\n+        Resources.addTo(assignment.getResource(),\n+            assignedToChild.getResource());\n+        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n+            assignedToChild.getAssignmentInformation().getAllocated());\n+        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n+            assignedToChild.getAssignmentInformation().getReserved());\n+        assignment.getAssignmentInformation().incrAllocations(\n+            assignedToChild.getAssignmentInformation().getNumAllocations());\n+        assignment.getAssignmentInformation().incrReservations(\n+            assignedToChild.getAssignmentInformation().getNumReservations());\n+        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n+            assignedToChild.getAssignmentInformation()\n+                .getAllocationDetails());\n+        assignment.getAssignmentInformation().getReservationDetails().addAll(\n+            assignedToChild.getAssignmentInformation()\n+                .getReservationDetails());\n+        assignment.setIncreasedAllocation(\n+            assignedToChild.isIncreasedAllocation());\n+\n+        LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n+            + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n+            + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n+            + \" cluster\u003d\" + clusterResource);\n+\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n+      } else{\n+        assignment.setSkippedType(assignedToChild.getSkippedType());\n \n-        if (assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n-          offswitchCount++;\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.SKIPPED,\n+            ActivityDiagnosticConstant.EMPTY);\n+        if (rootQueue) {\n+          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+              node);\n         }\n \n-        // Do not assign more containers if this isn\u0027t the root queue\n-        // or if we\u0027ve already assigned enough OFF_SWITCH containers in\n-        // this pass\n-        if (!rootQueue || offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n-          if (LOG.isDebugEnabled()) {\n-            if (rootQueue \u0026\u0026 offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n-              LOG.debug(\"Assigned maximum number of off-switch containers: \" +\n-                  offswitchCount + \", assignments so far: \" + assignment);\n-            }\n-          }\n-          break;\n-        }\n+        break;\n       }\n \n-      return assignment;\n-    } finally {\n-      writeLock.unlock();\n+      /*\n+       * Previously here, we can allocate more than one container for each\n+       * allocation under rootQ. Now this logic is not proper any more\n+       * in global scheduling world.\n+       *\n+       * So here do not try to allocate more than one container for each\n+       * allocation, let top scheduler make the decision.\n+       */\n+      break;\n     }\n+\n+    return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, ResourceLimits resourceLimits,\n    SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(ps.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + ps\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n              .getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(ps.getPartition(), clusterResource,\n        schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + ps\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n            + getQueueName());\n      }\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, ps.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, ps, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n            + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n            + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n            + \" cluster\u003d\" + clusterResource);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode, resourceLimits-ResourceLimits, schedulingMode-SchedulingMode]",
            "newValue": "[clusterResource-Resource, ps-PlacementSet\u003cFiCaSchedulerNode\u003e, resourceLimits-ResourceLimits, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "28/10/16 10:30 AM",
          "commitNameOld": "1eae719bcead45915977aa220324650eab3c1b9e",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 10.03,
          "commitsBetweenForRepo": 100,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,182 +1,174 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n-      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n-      SchedulingMode schedulingMode) {\n-    int offswitchCount \u003d 0;\n-    try {\n-      writeLock.lock();\n-      // if our queue cannot access this node, just return\n-      if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n-          \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-              + \", because it is not able to access partition\u003d\" + node\n-              .getPartition());\n-        }\n+      PlacementSet\u003cFiCaSchedulerNode\u003e ps, ResourceLimits resourceLimits,\n+    SchedulingMode schedulingMode) {\n+    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n \n-        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.REJECTED,\n-            ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n-                .getPartition());\n-        if (rootQueue) {\n-          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-              node);\n-        }\n-\n-        return CSAssignment.NULL_ASSIGNMENT;\n+    // if our queue cannot access this node, just return\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n+        \u0026\u0026 !accessibleToPartition(ps.getPartition())) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it is not able to access partition\u003d\" + ps\n+            .getPartition());\n       }\n \n-      // Check if this queue need more resource, simply skip allocation if this\n-      // queue doesn\u0027t need more resources.\n-      if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n-          schedulingMode)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n-              + schedulingMode.name() + \" node-partition\u003d\" + node\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          getParentName(), getQueueName(), ActivityState.REJECTED,\n+          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n               .getPartition());\n-        }\n+      if (rootQueue) {\n+        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+            node);\n+      }\n+\n+      return CSAssignment.NULL_ASSIGNMENT;\n+    }\n+\n+    // Check if this queue need more resource, simply skip allocation if this\n+    // queue doesn\u0027t need more resources.\n+    if (!super.hasPendingResourceRequest(ps.getPartition(), clusterResource,\n+        schedulingMode)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n+            + schedulingMode.name() + \" node-partition\u003d\" + ps\n+            .getPartition());\n+      }\n+\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          getParentName(), getQueueName(), ActivityState.SKIPPED,\n+          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n+      if (rootQueue) {\n+        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+            node);\n+      }\n+\n+      return CSAssignment.NULL_ASSIGNMENT;\n+    }\n+\n+    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n+        NodeType.NODE_LOCAL);\n+\n+    while (canAssign(clusterResource, node)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Trying to assign containers to child-queue of \"\n+            + getQueueName());\n+      }\n+\n+      // Are we over maximum-capacity for this queue?\n+      // This will also consider parent\u0027s limits and also continuous reservation\n+      // looking\n+      if (!super.canAssignToThisQueue(clusterResource, ps.getPartition(),\n+          resourceLimits, Resources\n+              .createResource(getMetrics().getReservedMB(),\n+                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n-            ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n+            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n-        return CSAssignment.NULL_ASSIGNMENT;\n+        break;\n       }\n \n-      CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n-          NodeType.NODE_LOCAL);\n+      // Schedule\n+      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n+          clusterResource, ps, resourceLimits, schedulingMode);\n+      assignment.setType(assignedToChild.getType());\n+      assignment.setRequestLocalityType(\n+          assignedToChild.getRequestLocalityType());\n+      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n+      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n \n-      while (canAssign(clusterResource, node)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Trying to assign containers to child-queue of \"\n-              + getQueueName());\n-        }\n+      // Done if no child-queue assigned anything\n+      if (Resources.greaterThan(resourceCalculator, clusterResource,\n+          assignedToChild.getResource(), Resources.none())) {\n \n-        // Are we over maximum-capacity for this queue?\n-        // This will also consider parent\u0027s limits and also continuous reservation\n-        // looking\n-        if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n-            resourceLimits, Resources\n-                .createResource(getMetrics().getReservedMB(),\n-                    getMetrics().getReservedVirtualCores()), schedulingMode)) {\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n+            ActivityDiagnosticConstant.EMPTY);\n \n-          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-              getParentName(), getQueueName(), ActivityState.SKIPPED,\n-              ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+        boolean isReserved \u003d\n+            assignedToChild.getAssignmentInformation().getReservationDetails()\n+                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n+                .getReservationDetails().isEmpty();\n+        if (node !\u003d null \u0026\u0026 !isReserved) {\n           if (rootQueue) {\n-            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-                node);\n+            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                activitiesManager, node,\n+                assignedToChild.getAssignmentInformation()\n+                    .getFirstAllocatedOrReservedContainerId(),\n+                AllocationState.ALLOCATED);\n           }\n-\n-          break;\n-        }\n-\n-        // Schedule\n-        CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n-            clusterResource, node, resourceLimits, schedulingMode);\n-        assignment.setType(assignedToChild.getType());\n-\n-        // Done if no child-queue assigned anything\n-        if (Resources.greaterThan(resourceCalculator, clusterResource,\n-            assignedToChild.getResource(), Resources.none())) {\n-\n-          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-              getParentName(), getQueueName(), ActivityState.ACCEPTED,\n-              ActivityDiagnosticConstant.EMPTY);\n-\n-          if (node.getReservedContainer() \u003d\u003d null) {\n-            if (rootQueue) {\n-              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                  activitiesManager, node,\n-                  assignedToChild.getAssignmentInformation()\n-                      .getFirstAllocatedOrReservedContainerId(),\n-                  AllocationState.ALLOCATED);\n-            }\n-          } else{\n-            if (rootQueue) {\n-              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                  activitiesManager, node,\n-                  assignedToChild.getAssignmentInformation()\n-                      .getFirstAllocatedOrReservedContainerId(),\n-                  AllocationState.RESERVED);\n-            }\n-          }\n-\n-          // Track resource utilization for the parent-queue\n-          allocateResource(clusterResource, assignedToChild.getResource(),\n-              node.getPartition(), assignedToChild.isIncreasedAllocation());\n-\n-          // Track resource utilization in this pass of the scheduler\n-          Resources.addTo(assignment.getResource(),\n-              assignedToChild.getResource());\n-          Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n-              assignedToChild.getAssignmentInformation().getAllocated());\n-          Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n-              assignedToChild.getAssignmentInformation().getReserved());\n-          assignment.getAssignmentInformation().incrAllocations(\n-              assignedToChild.getAssignmentInformation().getNumAllocations());\n-          assignment.getAssignmentInformation().incrReservations(\n-              assignedToChild.getAssignmentInformation().getNumReservations());\n-          assignment.getAssignmentInformation().getAllocationDetails().addAll(\n-              assignedToChild.getAssignmentInformation()\n-                  .getAllocationDetails());\n-          assignment.getAssignmentInformation().getReservationDetails().addAll(\n-              assignedToChild.getAssignmentInformation()\n-                  .getReservationDetails());\n-          assignment.setIncreasedAllocation(\n-              assignedToChild.isIncreasedAllocation());\n-\n-          LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n-              + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n-              + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n-              + \" cluster\u003d\" + clusterResource);\n-\n         } else{\n-          assignment.setSkippedType(assignedToChild.getSkippedType());\n-\n-          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-              getParentName(), getQueueName(), ActivityState.SKIPPED,\n-              ActivityDiagnosticConstant.EMPTY);\n           if (rootQueue) {\n-            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-                node);\n+            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                activitiesManager, node,\n+                assignedToChild.getAssignmentInformation()\n+                    .getFirstAllocatedOrReservedContainerId(),\n+                AllocationState.RESERVED);\n           }\n-\n-          break;\n         }\n \n+        // Track resource utilization in this pass of the scheduler\n+        Resources.addTo(assignment.getResource(),\n+            assignedToChild.getResource());\n+        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n+            assignedToChild.getAssignmentInformation().getAllocated());\n+        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n+            assignedToChild.getAssignmentInformation().getReserved());\n+        assignment.getAssignmentInformation().incrAllocations(\n+            assignedToChild.getAssignmentInformation().getNumAllocations());\n+        assignment.getAssignmentInformation().incrReservations(\n+            assignedToChild.getAssignmentInformation().getNumReservations());\n+        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n+            assignedToChild.getAssignmentInformation()\n+                .getAllocationDetails());\n+        assignment.getAssignmentInformation().getReservationDetails().addAll(\n+            assignedToChild.getAssignmentInformation()\n+                .getReservationDetails());\n+        assignment.setIncreasedAllocation(\n+            assignedToChild.isIncreasedAllocation());\n+\n+        LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n+            + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n+            + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n+            + \" cluster\u003d\" + clusterResource);\n+\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n+      } else{\n+        assignment.setSkippedType(assignedToChild.getSkippedType());\n \n-        if (assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n-          offswitchCount++;\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.SKIPPED,\n+            ActivityDiagnosticConstant.EMPTY);\n+        if (rootQueue) {\n+          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+              node);\n         }\n \n-        // Do not assign more containers if this isn\u0027t the root queue\n-        // or if we\u0027ve already assigned enough OFF_SWITCH containers in\n-        // this pass\n-        if (!rootQueue || offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n-          if (LOG.isDebugEnabled()) {\n-            if (rootQueue \u0026\u0026 offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n-              LOG.debug(\"Assigned maximum number of off-switch containers: \" +\n-                  offswitchCount + \", assignments so far: \" + assignment);\n-            }\n-          }\n-          break;\n-        }\n+        break;\n       }\n \n-      return assignment;\n-    } finally {\n-      writeLock.unlock();\n+      /*\n+       * Previously here, we can allocate more than one container for each\n+       * allocation under rootQ. Now this logic is not proper any more\n+       * in global scheduling world.\n+       *\n+       * So here do not try to allocate more than one container for each\n+       * allocation, let top scheduler make the decision.\n+       */\n+      break;\n     }\n+\n+    return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, ResourceLimits resourceLimits,\n    SchedulingMode schedulingMode) {\n    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(ps.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + ps\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n              .getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(ps.getPartition(), clusterResource,\n        schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + ps\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n\n    CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n        NodeType.NODE_LOCAL);\n\n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n            + getQueueName());\n      }\n\n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, ps.getPartition(),\n          resourceLimits, Resources\n              .createResource(getMetrics().getReservedMB(),\n                  getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n          clusterResource, ps, resourceLimits, schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      assignment.setRequestLocalityType(\n          assignedToChild.getRequestLocalityType());\n      assignment.setExcessReservation(assignedToChild.getExcessReservation());\n      assignment.setContainersToKill(assignedToChild.getContainersToKill());\n\n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        boolean isReserved \u003d\n            assignedToChild.getAssignmentInformation().getReservationDetails()\n                !\u003d null \u0026\u0026 !assignedToChild.getAssignmentInformation()\n                .getReservationDetails().isEmpty();\n        if (node !\u003d null \u0026\u0026 !isReserved) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else{\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(),\n            assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n            assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n            assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n            assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment.getAssignmentInformation().getAllocationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getAllocationDetails());\n        assignment.getAssignmentInformation().getReservationDetails().addAll(\n            assignedToChild.getAssignmentInformation()\n                .getReservationDetails());\n        assignment.setIncreasedAllocation(\n            assignedToChild.isIncreasedAllocation());\n\n        LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n            + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n            + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n            + \" cluster\u003d\" + clusterResource);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n      } else{\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      /*\n       * Previously here, we can allocate more than one container for each\n       * allocation under rootQ. Now this logic is not proper any more\n       * in global scheduling world.\n       *\n       * So here do not try to allocate more than one container for each\n       * allocation, let top scheduler make the decision.\n       */\n      break;\n    }\n\n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "1eae719bcead45915977aa220324650eab3c1b9e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4963. capacity scheduler: Make number of OFF_SWITCH assignments per heartbeat configurable. Contributed by Nathan Roberts\n",
      "commitDate": "28/10/16 10:30 AM",
      "commitName": "1eae719bcead45915977aa220324650eab3c1b9e",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "20/09/16 12:03 AM",
      "commitNameOld": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 38.44,
      "commitsBetweenForRepo": 323,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,182 @@\n   public CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n+    int offswitchCount \u003d 0;\n     try {\n       writeLock.lock();\n       // if our queue cannot access this node, just return\n       if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n           \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it is not able to access partition\u003d\" + node\n               .getPartition());\n         }\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.REJECTED,\n             ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n                 .getPartition());\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         return CSAssignment.NULL_ASSIGNMENT;\n       }\n \n       // Check if this queue need more resource, simply skip allocation if this\n       // queue doesn\u0027t need more resources.\n       if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n           schedulingMode)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n               + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n               + schedulingMode.name() + \" node-partition\u003d\" + node\n               .getPartition());\n         }\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n             getParentName(), getQueueName(), ActivityState.SKIPPED,\n             ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n         return CSAssignment.NULL_ASSIGNMENT;\n       }\n \n       CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n           NodeType.NODE_LOCAL);\n \n       while (canAssign(clusterResource, node)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Trying to assign containers to child-queue of \"\n               + getQueueName());\n         }\n \n         // Are we over maximum-capacity for this queue?\n         // This will also consider parent\u0027s limits and also continuous reservation\n         // looking\n         if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n             resourceLimits, Resources\n                 .createResource(getMetrics().getReservedMB(),\n                     getMetrics().getReservedVirtualCores()), schedulingMode)) {\n \n           ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n               getParentName(), getQueueName(), ActivityState.SKIPPED,\n               ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                 node);\n           }\n \n           break;\n         }\n \n         // Schedule\n         CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n             clusterResource, node, resourceLimits, schedulingMode);\n         assignment.setType(assignedToChild.getType());\n \n         // Done if no child-queue assigned anything\n         if (Resources.greaterThan(resourceCalculator, clusterResource,\n             assignedToChild.getResource(), Resources.none())) {\n \n           ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n               getParentName(), getQueueName(), ActivityState.ACCEPTED,\n               ActivityDiagnosticConstant.EMPTY);\n \n           if (node.getReservedContainer() \u003d\u003d null) {\n             if (rootQueue) {\n               ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                   activitiesManager, node,\n                   assignedToChild.getAssignmentInformation()\n                       .getFirstAllocatedOrReservedContainerId(),\n                   AllocationState.ALLOCATED);\n             }\n           } else{\n             if (rootQueue) {\n               ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                   activitiesManager, node,\n                   assignedToChild.getAssignmentInformation()\n                       .getFirstAllocatedOrReservedContainerId(),\n                   AllocationState.RESERVED);\n             }\n           }\n \n           // Track resource utilization for the parent-queue\n           allocateResource(clusterResource, assignedToChild.getResource(),\n               node.getPartition(), assignedToChild.isIncreasedAllocation());\n \n           // Track resource utilization in this pass of the scheduler\n           Resources.addTo(assignment.getResource(),\n               assignedToChild.getResource());\n           Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n               assignedToChild.getAssignmentInformation().getAllocated());\n           Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n               assignedToChild.getAssignmentInformation().getReserved());\n           assignment.getAssignmentInformation().incrAllocations(\n               assignedToChild.getAssignmentInformation().getNumAllocations());\n           assignment.getAssignmentInformation().incrReservations(\n               assignedToChild.getAssignmentInformation().getNumReservations());\n           assignment.getAssignmentInformation().getAllocationDetails().addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getAllocationDetails());\n           assignment.getAssignmentInformation().getReservationDetails().addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n           assignment.setIncreasedAllocation(\n               assignedToChild.isIncreasedAllocation());\n \n           LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n               + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n               + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n               + \" cluster\u003d\" + clusterResource);\n \n         } else{\n           assignment.setSkippedType(assignedToChild.getSkippedType());\n \n           ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n               getParentName(), getQueueName(), ActivityState.SKIPPED,\n               ActivityDiagnosticConstant.EMPTY);\n           if (rootQueue) {\n             ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                 node);\n           }\n \n           break;\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                   + assignment.getResource() + \" usedCapacity\u003d\"\n                   + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                   + getAbsoluteUsedCapacity());\n         }\n \n-        // Do not assign more than one container if this isn\u0027t the root queue\n-        // or if we\u0027ve already assigned an off-switch container\n-        if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n+        if (assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n+          offswitchCount++;\n+        }\n+\n+        // Do not assign more containers if this isn\u0027t the root queue\n+        // or if we\u0027ve already assigned enough OFF_SWITCH containers in\n+        // this pass\n+        if (!rootQueue || offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n           if (LOG.isDebugEnabled()) {\n-            if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n-              LOG.debug(\"Not assigning more than one off-switch container,\"\n-                  + \" assignments so far: \" + assignment);\n+            if (rootQueue \u0026\u0026 offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n+              LOG.debug(\"Assigned maximum number of off-switch containers: \" +\n+                  offswitchCount + \", assignments so far: \" + assignment);\n             }\n           }\n           break;\n         }\n       }\n \n       return assignment;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    int offswitchCount \u003d 0;\n    try {\n      writeLock.lock();\n      // if our queue cannot access this node, just return\n      if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n          \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + node\n              .getPartition());\n        }\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.REJECTED,\n            ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n                .getPartition());\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        return CSAssignment.NULL_ASSIGNMENT;\n      }\n\n      // Check if this queue need more resource, simply skip allocation if this\n      // queue doesn\u0027t need more resources.\n      if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n          schedulingMode)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + node\n              .getPartition());\n        }\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        return CSAssignment.NULL_ASSIGNMENT;\n      }\n\n      CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n          NodeType.NODE_LOCAL);\n\n      while (canAssign(clusterResource, node)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Trying to assign containers to child-queue of \"\n              + getQueueName());\n        }\n\n        // Are we over maximum-capacity for this queue?\n        // This will also consider parent\u0027s limits and also continuous reservation\n        // looking\n        if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n            resourceLimits, Resources\n                .createResource(getMetrics().getReservedMB(),\n                    getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.SKIPPED,\n              ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                node);\n          }\n\n          break;\n        }\n\n        // Schedule\n        CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n            clusterResource, node, resourceLimits, schedulingMode);\n        assignment.setType(assignedToChild.getType());\n\n        // Done if no child-queue assigned anything\n        if (Resources.greaterThan(resourceCalculator, clusterResource,\n            assignedToChild.getResource(), Resources.none())) {\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.ACCEPTED,\n              ActivityDiagnosticConstant.EMPTY);\n\n          if (node.getReservedContainer() \u003d\u003d null) {\n            if (rootQueue) {\n              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                  activitiesManager, node,\n                  assignedToChild.getAssignmentInformation()\n                      .getFirstAllocatedOrReservedContainerId(),\n                  AllocationState.ALLOCATED);\n            }\n          } else{\n            if (rootQueue) {\n              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                  activitiesManager, node,\n                  assignedToChild.getAssignmentInformation()\n                      .getFirstAllocatedOrReservedContainerId(),\n                  AllocationState.RESERVED);\n            }\n          }\n\n          // Track resource utilization for the parent-queue\n          allocateResource(clusterResource, assignedToChild.getResource(),\n              node.getPartition(), assignedToChild.isIncreasedAllocation());\n\n          // Track resource utilization in this pass of the scheduler\n          Resources.addTo(assignment.getResource(),\n              assignedToChild.getResource());\n          Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n              assignedToChild.getAssignmentInformation().getAllocated());\n          Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n              assignedToChild.getAssignmentInformation().getReserved());\n          assignment.getAssignmentInformation().incrAllocations(\n              assignedToChild.getAssignmentInformation().getNumAllocations());\n          assignment.getAssignmentInformation().incrReservations(\n              assignedToChild.getAssignmentInformation().getNumReservations());\n          assignment.getAssignmentInformation().getAllocationDetails().addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getAllocationDetails());\n          assignment.getAssignmentInformation().getReservationDetails().addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n          assignment.setIncreasedAllocation(\n              assignedToChild.isIncreasedAllocation());\n\n          LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n              + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n              + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n              + \" cluster\u003d\" + clusterResource);\n\n        } else{\n          assignment.setSkippedType(assignedToChild.getSkippedType());\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.SKIPPED,\n              ActivityDiagnosticConstant.EMPTY);\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                node);\n          }\n\n          break;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n\n        if (assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n          offswitchCount++;\n        }\n\n        // Do not assign more containers if this isn\u0027t the root queue\n        // or if we\u0027ve already assigned enough OFF_SWITCH containers in\n        // this pass\n        if (!rootQueue || offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n          if (LOG.isDebugEnabled()) {\n            if (rootQueue \u0026\u0026 offswitchCount \u003e\u003d getOffSwitchPerHeartbeatLimit()) {\n              LOG.debug(\"Assigned maximum number of off-switch containers: \" +\n                  offswitchCount + \", assignments so far: \" + assignment);\n            }\n          }\n          break;\n        }\n      }\n\n      return assignment;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
      "commitDate": "20/09/16 12:03 AM",
      "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,178 +1,176 @@\n-  public synchronized CSAssignment assignContainers(Resource clusterResource,\n+  public CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n-    // if our queue cannot access this node, just return\n-    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n-        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it is not able to access partition\u003d\" + node\n-            .getPartition());\n-      }\n-\n-      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          getParentName(), getQueueName(), ActivityState.REJECTED,\n-          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n+    try {\n+      writeLock.lock();\n+      // if our queue cannot access this node, just return\n+      if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n+          \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+              + \", because it is not able to access partition\u003d\" + node\n               .getPartition());\n-      if (rootQueue) {\n-        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-            node);\n-      }\n-\n-      return CSAssignment.NULL_ASSIGNMENT;\n-    }\n-    \n-    // Check if this queue need more resource, simply skip allocation if this\n-    // queue doesn\u0027t need more resources.\n-    if (!super.hasPendingResourceRequest(node.getPartition(),\n-        clusterResource, schedulingMode)) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n-            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n-      }\n-\n-      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          getParentName(), getQueueName(), ActivityState.SKIPPED,\n-          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n-      if (rootQueue) {\n-        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-            node);\n-      }\n-\n-      return CSAssignment.NULL_ASSIGNMENT;\n-    }\n-    \n-    CSAssignment assignment \u003d \n-        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n-    \n-    while (canAssign(clusterResource, node)) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Trying to assign containers to child-queue of \"\n-          + getQueueName());\n-      }\n-      \n-      // Are we over maximum-capacity for this queue?\n-      // This will also consider parent\u0027s limits and also continuous reservation\n-      // looking\n-      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n-          resourceLimits, Resources.createResource(\n-              getMetrics().getReservedMB(), getMetrics()\n-                  .getReservedVirtualCores()), schedulingMode)) {\n+        }\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.SKIPPED,\n-            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+            getParentName(), getQueueName(), ActivityState.REJECTED,\n+            ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n+                .getPartition());\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n-        break;\n+        return CSAssignment.NULL_ASSIGNMENT;\n       }\n \n-      // Schedule\n-      CSAssignment assignedToChild \u003d\n-          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n-              schedulingMode);\n-      assignment.setType(assignedToChild.getType());\n-      \n-      // Done if no child-queue assigned anything\n-      if (Resources.greaterThan(\n-              resourceCalculator, clusterResource, \n-              assignedToChild.getResource(), Resources.none())) {\n-\n-        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n-            ActivityDiagnosticConstant.EMPTY);\n-\n-        if (node.getReservedContainer() \u003d\u003d null) {\n-          if (rootQueue) {\n-            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                activitiesManager, node,\n-                assignedToChild.getAssignmentInformation()\n-                    .getFirstAllocatedOrReservedContainerId(),\n-                AllocationState.ALLOCATED);\n-          }\n-        } else {\n-          if (rootQueue) {\n-            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                activitiesManager, node,\n-                assignedToChild.getAssignmentInformation()\n-                    .getFirstAllocatedOrReservedContainerId(),\n-                AllocationState.RESERVED);\n-          }\n+      // Check if this queue need more resource, simply skip allocation if this\n+      // queue doesn\u0027t need more resources.\n+      if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n+          schedulingMode)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n+              + schedulingMode.name() + \" node-partition\u003d\" + node\n+              .getPartition());\n         }\n \n-        // Track resource utilization for the parent-queue\n-        allocateResource(clusterResource, assignedToChild.getResource(),\n-            node.getPartition(), assignedToChild.isIncreasedAllocation());\n-        \n-        // Track resource utilization in this pass of the scheduler\n-        Resources\n-          .addTo(assignment.getResource(), assignedToChild.getResource());\n-        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n-          assignedToChild.getAssignmentInformation().getAllocated());\n-        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n-            assignedToChild.getAssignmentInformation().getReserved());\n-        assignment.getAssignmentInformation().incrAllocations(\n-          assignedToChild.getAssignmentInformation().getNumAllocations());\n-        assignment.getAssignmentInformation().incrReservations(\n-          assignedToChild.getAssignmentInformation().getNumReservations());\n-        assignment\n-          .getAssignmentInformation()\n-          .getAllocationDetails()\n-          .addAll(\n-              assignedToChild.getAssignmentInformation().getAllocationDetails());\n-        assignment\n-          .getAssignmentInformation()\n-          .getReservationDetails()\n-          .addAll(\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.SKIPPED,\n+            ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n+        if (rootQueue) {\n+          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+              node);\n+        }\n+\n+        return CSAssignment.NULL_ASSIGNMENT;\n+      }\n+\n+      CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n+          NodeType.NODE_LOCAL);\n+\n+      while (canAssign(clusterResource, node)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Trying to assign containers to child-queue of \"\n+              + getQueueName());\n+        }\n+\n+        // Are we over maximum-capacity for this queue?\n+        // This will also consider parent\u0027s limits and also continuous reservation\n+        // looking\n+        if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n+            resourceLimits, Resources\n+                .createResource(getMetrics().getReservedMB(),\n+                    getMetrics().getReservedVirtualCores()), schedulingMode)) {\n+\n+          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+              getParentName(), getQueueName(), ActivityState.SKIPPED,\n+              ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+          if (rootQueue) {\n+            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+                node);\n+          }\n+\n+          break;\n+        }\n+\n+        // Schedule\n+        CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n+            clusterResource, node, resourceLimits, schedulingMode);\n+        assignment.setType(assignedToChild.getType());\n+\n+        // Done if no child-queue assigned anything\n+        if (Resources.greaterThan(resourceCalculator, clusterResource,\n+            assignedToChild.getResource(), Resources.none())) {\n+\n+          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+              getParentName(), getQueueName(), ActivityState.ACCEPTED,\n+              ActivityDiagnosticConstant.EMPTY);\n+\n+          if (node.getReservedContainer() \u003d\u003d null) {\n+            if (rootQueue) {\n+              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                  activitiesManager, node,\n+                  assignedToChild.getAssignmentInformation()\n+                      .getFirstAllocatedOrReservedContainerId(),\n+                  AllocationState.ALLOCATED);\n+            }\n+          } else{\n+            if (rootQueue) {\n+              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                  activitiesManager, node,\n+                  assignedToChild.getAssignmentInformation()\n+                      .getFirstAllocatedOrReservedContainerId(),\n+                  AllocationState.RESERVED);\n+            }\n+          }\n+\n+          // Track resource utilization for the parent-queue\n+          allocateResource(clusterResource, assignedToChild.getResource(),\n+              node.getPartition(), assignedToChild.isIncreasedAllocation());\n+\n+          // Track resource utilization in this pass of the scheduler\n+          Resources.addTo(assignment.getResource(),\n+              assignedToChild.getResource());\n+          Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n+              assignedToChild.getAssignmentInformation().getAllocated());\n+          Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n+              assignedToChild.getAssignmentInformation().getReserved());\n+          assignment.getAssignmentInformation().incrAllocations(\n+              assignedToChild.getAssignmentInformation().getNumAllocations());\n+          assignment.getAssignmentInformation().incrReservations(\n+              assignedToChild.getAssignmentInformation().getNumReservations());\n+          assignment.getAssignmentInformation().getAllocationDetails().addAll(\n+              assignedToChild.getAssignmentInformation()\n+                  .getAllocationDetails());\n+          assignment.getAssignmentInformation().getReservationDetails().addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n-        assignment.setIncreasedAllocation(assignedToChild\n-            .isIncreasedAllocation());\n-        \n-        LOG.info(\"assignedContainer\" +\n-            \" queue\u003d\" + getQueueName() + \n-            \" usedCapacity\u003d\" + getUsedCapacity() +\n-            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n-            \" used\u003d\" + queueUsage.getUsed() + \n-            \" cluster\u003d\" + clusterResource);\n+          assignment.setIncreasedAllocation(\n+              assignedToChild.isIncreasedAllocation());\n \n-      } else {\n-        assignment.setSkippedType(assignedToChild.getSkippedType());\n+          LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n+              + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n+              + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n+              + \" cluster\u003d\" + clusterResource);\n \n-        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.SKIPPED,\n-            ActivityDiagnosticConstant.EMPTY);\n-        if (rootQueue) {\n-          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-              node);\n-        }\n+        } else{\n+          assignment.setSkippedType(assignedToChild.getSkippedType());\n \n-        break;\n-      }\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n-          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n-          + \" usedCapacity\u003d\" + getUsedCapacity()\n-          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n-      }\n-\n-      // Do not assign more than one container if this isn\u0027t the root queue\n-      // or if we\u0027ve already assigned an off-switch container\n-      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n-        if (LOG.isDebugEnabled()) {\n-          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n-            LOG.debug(\"Not assigning more than one off-switch container,\" +\n-                \" assignments so far: \" + assignment);\n+          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+              getParentName(), getQueueName(), ActivityState.SKIPPED,\n+              ActivityDiagnosticConstant.EMPTY);\n+          if (rootQueue) {\n+            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+                node);\n           }\n+\n+          break;\n         }\n-        break;\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\n+              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n+                  + assignment.getResource() + \" usedCapacity\u003d\"\n+                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n+                  + getAbsoluteUsedCapacity());\n+        }\n+\n+        // Do not assign more than one container if this isn\u0027t the root queue\n+        // or if we\u0027ve already assigned an off-switch container\n+        if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n+          if (LOG.isDebugEnabled()) {\n+            if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n+              LOG.debug(\"Not assigning more than one off-switch container,\"\n+                  + \" assignments so far: \" + assignment);\n+            }\n+          }\n+          break;\n+        }\n       }\n-    } \n-    \n-    return assignment;\n+\n+      return assignment;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    try {\n      writeLock.lock();\n      // if our queue cannot access this node, just return\n      if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n          \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + node\n              .getPartition());\n        }\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.REJECTED,\n            ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n                .getPartition());\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        return CSAssignment.NULL_ASSIGNMENT;\n      }\n\n      // Check if this queue need more resource, simply skip allocation if this\n      // queue doesn\u0027t need more resources.\n      if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n          schedulingMode)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + node\n              .getPartition());\n        }\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        return CSAssignment.NULL_ASSIGNMENT;\n      }\n\n      CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n          NodeType.NODE_LOCAL);\n\n      while (canAssign(clusterResource, node)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Trying to assign containers to child-queue of \"\n              + getQueueName());\n        }\n\n        // Are we over maximum-capacity for this queue?\n        // This will also consider parent\u0027s limits and also continuous reservation\n        // looking\n        if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n            resourceLimits, Resources\n                .createResource(getMetrics().getReservedMB(),\n                    getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.SKIPPED,\n              ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                node);\n          }\n\n          break;\n        }\n\n        // Schedule\n        CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n            clusterResource, node, resourceLimits, schedulingMode);\n        assignment.setType(assignedToChild.getType());\n\n        // Done if no child-queue assigned anything\n        if (Resources.greaterThan(resourceCalculator, clusterResource,\n            assignedToChild.getResource(), Resources.none())) {\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.ACCEPTED,\n              ActivityDiagnosticConstant.EMPTY);\n\n          if (node.getReservedContainer() \u003d\u003d null) {\n            if (rootQueue) {\n              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                  activitiesManager, node,\n                  assignedToChild.getAssignmentInformation()\n                      .getFirstAllocatedOrReservedContainerId(),\n                  AllocationState.ALLOCATED);\n            }\n          } else{\n            if (rootQueue) {\n              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                  activitiesManager, node,\n                  assignedToChild.getAssignmentInformation()\n                      .getFirstAllocatedOrReservedContainerId(),\n                  AllocationState.RESERVED);\n            }\n          }\n\n          // Track resource utilization for the parent-queue\n          allocateResource(clusterResource, assignedToChild.getResource(),\n              node.getPartition(), assignedToChild.isIncreasedAllocation());\n\n          // Track resource utilization in this pass of the scheduler\n          Resources.addTo(assignment.getResource(),\n              assignedToChild.getResource());\n          Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n              assignedToChild.getAssignmentInformation().getAllocated());\n          Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n              assignedToChild.getAssignmentInformation().getReserved());\n          assignment.getAssignmentInformation().incrAllocations(\n              assignedToChild.getAssignmentInformation().getNumAllocations());\n          assignment.getAssignmentInformation().incrReservations(\n              assignedToChild.getAssignmentInformation().getNumReservations());\n          assignment.getAssignmentInformation().getAllocationDetails().addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getAllocationDetails());\n          assignment.getAssignmentInformation().getReservationDetails().addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n          assignment.setIncreasedAllocation(\n              assignedToChild.isIncreasedAllocation());\n\n          LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n              + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n              + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n              + \" cluster\u003d\" + clusterResource);\n\n        } else{\n          assignment.setSkippedType(assignedToChild.getSkippedType());\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.SKIPPED,\n              ActivityDiagnosticConstant.EMPTY);\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                node);\n          }\n\n          break;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n\n        // Do not assign more than one container if this isn\u0027t the root queue\n        // or if we\u0027ve already assigned an off-switch container\n        if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n          if (LOG.isDebugEnabled()) {\n            if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n              LOG.debug(\"Not assigning more than one off-switch container,\"\n                  + \" assignments so far: \" + assignment);\n            }\n          }\n          break;\n        }\n      }\n\n      return assignment;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,178 +1,176 @@\n-  public synchronized CSAssignment assignContainers(Resource clusterResource,\n+  public CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n-    // if our queue cannot access this node, just return\n-    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n-        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it is not able to access partition\u003d\" + node\n-            .getPartition());\n-      }\n-\n-      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          getParentName(), getQueueName(), ActivityState.REJECTED,\n-          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n+    try {\n+      writeLock.lock();\n+      // if our queue cannot access this node, just return\n+      if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n+          \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+              + \", because it is not able to access partition\u003d\" + node\n               .getPartition());\n-      if (rootQueue) {\n-        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-            node);\n-      }\n-\n-      return CSAssignment.NULL_ASSIGNMENT;\n-    }\n-    \n-    // Check if this queue need more resource, simply skip allocation if this\n-    // queue doesn\u0027t need more resources.\n-    if (!super.hasPendingResourceRequest(node.getPartition(),\n-        clusterResource, schedulingMode)) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n-            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n-      }\n-\n-      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          getParentName(), getQueueName(), ActivityState.SKIPPED,\n-          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n-      if (rootQueue) {\n-        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-            node);\n-      }\n-\n-      return CSAssignment.NULL_ASSIGNMENT;\n-    }\n-    \n-    CSAssignment assignment \u003d \n-        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n-    \n-    while (canAssign(clusterResource, node)) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Trying to assign containers to child-queue of \"\n-          + getQueueName());\n-      }\n-      \n-      // Are we over maximum-capacity for this queue?\n-      // This will also consider parent\u0027s limits and also continuous reservation\n-      // looking\n-      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n-          resourceLimits, Resources.createResource(\n-              getMetrics().getReservedMB(), getMetrics()\n-                  .getReservedVirtualCores()), schedulingMode)) {\n+        }\n \n         ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.SKIPPED,\n-            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+            getParentName(), getQueueName(), ActivityState.REJECTED,\n+            ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n+                .getPartition());\n         if (rootQueue) {\n           ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n               node);\n         }\n \n-        break;\n+        return CSAssignment.NULL_ASSIGNMENT;\n       }\n \n-      // Schedule\n-      CSAssignment assignedToChild \u003d\n-          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n-              schedulingMode);\n-      assignment.setType(assignedToChild.getType());\n-      \n-      // Done if no child-queue assigned anything\n-      if (Resources.greaterThan(\n-              resourceCalculator, clusterResource, \n-              assignedToChild.getResource(), Resources.none())) {\n-\n-        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n-            ActivityDiagnosticConstant.EMPTY);\n-\n-        if (node.getReservedContainer() \u003d\u003d null) {\n-          if (rootQueue) {\n-            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                activitiesManager, node,\n-                assignedToChild.getAssignmentInformation()\n-                    .getFirstAllocatedOrReservedContainerId(),\n-                AllocationState.ALLOCATED);\n-          }\n-        } else {\n-          if (rootQueue) {\n-            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n-                activitiesManager, node,\n-                assignedToChild.getAssignmentInformation()\n-                    .getFirstAllocatedOrReservedContainerId(),\n-                AllocationState.RESERVED);\n-          }\n+      // Check if this queue need more resource, simply skip allocation if this\n+      // queue doesn\u0027t need more resources.\n+      if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n+          schedulingMode)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n+              + schedulingMode.name() + \" node-partition\u003d\" + node\n+              .getPartition());\n         }\n \n-        // Track resource utilization for the parent-queue\n-        allocateResource(clusterResource, assignedToChild.getResource(),\n-            node.getPartition(), assignedToChild.isIncreasedAllocation());\n-        \n-        // Track resource utilization in this pass of the scheduler\n-        Resources\n-          .addTo(assignment.getResource(), assignedToChild.getResource());\n-        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n-          assignedToChild.getAssignmentInformation().getAllocated());\n-        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n-            assignedToChild.getAssignmentInformation().getReserved());\n-        assignment.getAssignmentInformation().incrAllocations(\n-          assignedToChild.getAssignmentInformation().getNumAllocations());\n-        assignment.getAssignmentInformation().incrReservations(\n-          assignedToChild.getAssignmentInformation().getNumReservations());\n-        assignment\n-          .getAssignmentInformation()\n-          .getAllocationDetails()\n-          .addAll(\n-              assignedToChild.getAssignmentInformation().getAllocationDetails());\n-        assignment\n-          .getAssignmentInformation()\n-          .getReservationDetails()\n-          .addAll(\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.SKIPPED,\n+            ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n+        if (rootQueue) {\n+          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+              node);\n+        }\n+\n+        return CSAssignment.NULL_ASSIGNMENT;\n+      }\n+\n+      CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n+          NodeType.NODE_LOCAL);\n+\n+      while (canAssign(clusterResource, node)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Trying to assign containers to child-queue of \"\n+              + getQueueName());\n+        }\n+\n+        // Are we over maximum-capacity for this queue?\n+        // This will also consider parent\u0027s limits and also continuous reservation\n+        // looking\n+        if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n+            resourceLimits, Resources\n+                .createResource(getMetrics().getReservedMB(),\n+                    getMetrics().getReservedVirtualCores()), schedulingMode)) {\n+\n+          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+              getParentName(), getQueueName(), ActivityState.SKIPPED,\n+              ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+          if (rootQueue) {\n+            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+                node);\n+          }\n+\n+          break;\n+        }\n+\n+        // Schedule\n+        CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n+            clusterResource, node, resourceLimits, schedulingMode);\n+        assignment.setType(assignedToChild.getType());\n+\n+        // Done if no child-queue assigned anything\n+        if (Resources.greaterThan(resourceCalculator, clusterResource,\n+            assignedToChild.getResource(), Resources.none())) {\n+\n+          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+              getParentName(), getQueueName(), ActivityState.ACCEPTED,\n+              ActivityDiagnosticConstant.EMPTY);\n+\n+          if (node.getReservedContainer() \u003d\u003d null) {\n+            if (rootQueue) {\n+              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                  activitiesManager, node,\n+                  assignedToChild.getAssignmentInformation()\n+                      .getFirstAllocatedOrReservedContainerId(),\n+                  AllocationState.ALLOCATED);\n+            }\n+          } else{\n+            if (rootQueue) {\n+              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                  activitiesManager, node,\n+                  assignedToChild.getAssignmentInformation()\n+                      .getFirstAllocatedOrReservedContainerId(),\n+                  AllocationState.RESERVED);\n+            }\n+          }\n+\n+          // Track resource utilization for the parent-queue\n+          allocateResource(clusterResource, assignedToChild.getResource(),\n+              node.getPartition(), assignedToChild.isIncreasedAllocation());\n+\n+          // Track resource utilization in this pass of the scheduler\n+          Resources.addTo(assignment.getResource(),\n+              assignedToChild.getResource());\n+          Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n+              assignedToChild.getAssignmentInformation().getAllocated());\n+          Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n+              assignedToChild.getAssignmentInformation().getReserved());\n+          assignment.getAssignmentInformation().incrAllocations(\n+              assignedToChild.getAssignmentInformation().getNumAllocations());\n+          assignment.getAssignmentInformation().incrReservations(\n+              assignedToChild.getAssignmentInformation().getNumReservations());\n+          assignment.getAssignmentInformation().getAllocationDetails().addAll(\n+              assignedToChild.getAssignmentInformation()\n+                  .getAllocationDetails());\n+          assignment.getAssignmentInformation().getReservationDetails().addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n-        assignment.setIncreasedAllocation(assignedToChild\n-            .isIncreasedAllocation());\n-        \n-        LOG.info(\"assignedContainer\" +\n-            \" queue\u003d\" + getQueueName() + \n-            \" usedCapacity\u003d\" + getUsedCapacity() +\n-            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n-            \" used\u003d\" + queueUsage.getUsed() + \n-            \" cluster\u003d\" + clusterResource);\n+          assignment.setIncreasedAllocation(\n+              assignedToChild.isIncreasedAllocation());\n \n-      } else {\n-        assignment.setSkippedType(assignedToChild.getSkippedType());\n+          LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n+              + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n+              + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n+              + \" cluster\u003d\" + clusterResource);\n \n-        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-            getParentName(), getQueueName(), ActivityState.SKIPPED,\n-            ActivityDiagnosticConstant.EMPTY);\n-        if (rootQueue) {\n-          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n-              node);\n-        }\n+        } else{\n+          assignment.setSkippedType(assignedToChild.getSkippedType());\n \n-        break;\n-      }\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n-          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n-          + \" usedCapacity\u003d\" + getUsedCapacity()\n-          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n-      }\n-\n-      // Do not assign more than one container if this isn\u0027t the root queue\n-      // or if we\u0027ve already assigned an off-switch container\n-      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n-        if (LOG.isDebugEnabled()) {\n-          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n-            LOG.debug(\"Not assigning more than one off-switch container,\" +\n-                \" assignments so far: \" + assignment);\n+          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+              getParentName(), getQueueName(), ActivityState.SKIPPED,\n+              ActivityDiagnosticConstant.EMPTY);\n+          if (rootQueue) {\n+            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+                node);\n           }\n+\n+          break;\n         }\n-        break;\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\n+              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n+                  + assignment.getResource() + \" usedCapacity\u003d\"\n+                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n+                  + getAbsoluteUsedCapacity());\n+        }\n+\n+        // Do not assign more than one container if this isn\u0027t the root queue\n+        // or if we\u0027ve already assigned an off-switch container\n+        if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n+          if (LOG.isDebugEnabled()) {\n+            if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n+              LOG.debug(\"Not assigning more than one off-switch container,\"\n+                  + \" assignments so far: \" + assignment);\n+            }\n+          }\n+          break;\n+        }\n       }\n-    } \n-    \n-    return assignment;\n+\n+      return assignment;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    try {\n      writeLock.lock();\n      // if our queue cannot access this node, just return\n      if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n          \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it is not able to access partition\u003d\" + node\n              .getPartition());\n        }\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.REJECTED,\n            ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n                .getPartition());\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        return CSAssignment.NULL_ASSIGNMENT;\n      }\n\n      // Check if this queue need more resource, simply skip allocation if this\n      // queue doesn\u0027t need more resources.\n      if (!super.hasPendingResourceRequest(node.getPartition(), clusterResource,\n          schedulingMode)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n              + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n              + schedulingMode.name() + \" node-partition\u003d\" + node\n              .getPartition());\n        }\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        return CSAssignment.NULL_ASSIGNMENT;\n      }\n\n      CSAssignment assignment \u003d new CSAssignment(Resources.createResource(0, 0),\n          NodeType.NODE_LOCAL);\n\n      while (canAssign(clusterResource, node)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Trying to assign containers to child-queue of \"\n              + getQueueName());\n        }\n\n        // Are we over maximum-capacity for this queue?\n        // This will also consider parent\u0027s limits and also continuous reservation\n        // looking\n        if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n            resourceLimits, Resources\n                .createResource(getMetrics().getReservedMB(),\n                    getMetrics().getReservedVirtualCores()), schedulingMode)) {\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.SKIPPED,\n              ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                node);\n          }\n\n          break;\n        }\n\n        // Schedule\n        CSAssignment assignedToChild \u003d assignContainersToChildQueues(\n            clusterResource, node, resourceLimits, schedulingMode);\n        assignment.setType(assignedToChild.getType());\n\n        // Done if no child-queue assigned anything\n        if (Resources.greaterThan(resourceCalculator, clusterResource,\n            assignedToChild.getResource(), Resources.none())) {\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.ACCEPTED,\n              ActivityDiagnosticConstant.EMPTY);\n\n          if (node.getReservedContainer() \u003d\u003d null) {\n            if (rootQueue) {\n              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                  activitiesManager, node,\n                  assignedToChild.getAssignmentInformation()\n                      .getFirstAllocatedOrReservedContainerId(),\n                  AllocationState.ALLOCATED);\n            }\n          } else{\n            if (rootQueue) {\n              ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                  activitiesManager, node,\n                  assignedToChild.getAssignmentInformation()\n                      .getFirstAllocatedOrReservedContainerId(),\n                  AllocationState.RESERVED);\n            }\n          }\n\n          // Track resource utilization for the parent-queue\n          allocateResource(clusterResource, assignedToChild.getResource(),\n              node.getPartition(), assignedToChild.isIncreasedAllocation());\n\n          // Track resource utilization in this pass of the scheduler\n          Resources.addTo(assignment.getResource(),\n              assignedToChild.getResource());\n          Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n              assignedToChild.getAssignmentInformation().getAllocated());\n          Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n              assignedToChild.getAssignmentInformation().getReserved());\n          assignment.getAssignmentInformation().incrAllocations(\n              assignedToChild.getAssignmentInformation().getNumAllocations());\n          assignment.getAssignmentInformation().incrReservations(\n              assignedToChild.getAssignmentInformation().getNumReservations());\n          assignment.getAssignmentInformation().getAllocationDetails().addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getAllocationDetails());\n          assignment.getAssignmentInformation().getReservationDetails().addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n          assignment.setIncreasedAllocation(\n              assignedToChild.isIncreasedAllocation());\n\n          LOG.info(\"assignedContainer\" + \" queue\u003d\" + getQueueName()\n              + \" usedCapacity\u003d\" + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n              + getAbsoluteUsedCapacity() + \" used\u003d\" + queueUsage.getUsed()\n              + \" cluster\u003d\" + clusterResource);\n\n        } else{\n          assignment.setSkippedType(assignedToChild.getSkippedType());\n\n          ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n              getParentName(), getQueueName(), ActivityState.SKIPPED,\n              ActivityDiagnosticConstant.EMPTY);\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n                node);\n          }\n\n          break;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"ParentQ\u003d\" + getQueueName() + \" assignedSoFarInThisIteration\u003d\"\n                  + assignment.getResource() + \" usedCapacity\u003d\"\n                  + getUsedCapacity() + \" absoluteUsedCapacity\u003d\"\n                  + getAbsoluteUsedCapacity());\n        }\n\n        // Do not assign more than one container if this isn\u0027t the root queue\n        // or if we\u0027ve already assigned an off-switch container\n        if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n          if (LOG.isDebugEnabled()) {\n            if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n              LOG.debug(\"Not assigning more than one off-switch container,\"\n                  + \" assignments so far: \" + assignment);\n            }\n          }\n          break;\n        }\n      }\n\n      return assignment;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4091. Add REST API to retrieve scheduler activity. (Chen Ge and Sunil G via wangda)\n",
      "commitDate": "05/08/16 10:27 AM",
      "commitName": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "03/08/16 11:53 AM",
      "commitNameOld": "4d92aefd35d4517d9435d81bafdec0d77905a7a0",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,178 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it is not able to access partition\u003d\" + node\n             .getPartition());\n       }\n+\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          getParentName(), getQueueName(), ActivityState.REJECTED,\n+          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n+              .getPartition());\n+      if (rootQueue) {\n+        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+            node);\n+      }\n+\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n+\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          getParentName(), getQueueName(), ActivityState.SKIPPED,\n+          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n+      if (rootQueue) {\n+        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+            node);\n+      }\n+\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n           resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n+\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.SKIPPED,\n+            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n+        if (rootQueue) {\n+          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+              node);\n+        }\n+\n         break;\n       }\n-      \n+\n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n+\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n+            ActivityDiagnosticConstant.EMPTY);\n+\n+        if (node.getReservedContainer() \u003d\u003d null) {\n+          if (rootQueue) {\n+            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                activitiesManager, node,\n+                assignedToChild.getAssignmentInformation()\n+                    .getFirstAllocatedOrReservedContainerId(),\n+                AllocationState.ALLOCATED);\n+          }\n+        } else {\n+          if (rootQueue) {\n+            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n+                activitiesManager, node,\n+                assignedToChild.getAssignmentInformation()\n+                    .getFirstAllocatedOrReservedContainerId(),\n+                AllocationState.RESERVED);\n+          }\n+        }\n+\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource(),\n             node.getPartition(), assignedToChild.isIncreasedAllocation());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         assignment.setIncreasedAllocation(assignedToChild\n             .isIncreasedAllocation());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         assignment.setSkippedType(assignedToChild.getSkippedType());\n+\n+        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+            getParentName(), getQueueName(), ActivityState.SKIPPED,\n+            ActivityDiagnosticConstant.EMPTY);\n+        if (rootQueue) {\n+          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n+              node);\n+        }\n+\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + node\n            .getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.REJECTED,\n          ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node\n              .getPartition());\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          getParentName(), getQueueName(), ActivityState.SKIPPED,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);\n      if (rootQueue) {\n        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n            node);\n      }\n\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.ACCEPTED,\n            ActivityDiagnosticConstant.EMPTY);\n\n        if (node.getReservedContainer() \u003d\u003d null) {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.ALLOCATED);\n          }\n        } else {\n          if (rootQueue) {\n            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(\n                activitiesManager, node,\n                assignedToChild.getAssignmentInformation()\n                    .getFirstAllocatedOrReservedContainerId(),\n                AllocationState.RESERVED);\n          }\n        }\n\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition(), assignedToChild.isIncreasedAllocation());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        assignment.setIncreasedAllocation(assignedToChild\n            .isIncreasedAllocation());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n\n        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n            getParentName(), getQueueName(), ActivityState.SKIPPED,\n            ActivityDiagnosticConstant.EMPTY);\n        if (rootQueue) {\n          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,\n              node);\n        }\n\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "4d92aefd35d4517d9435d81bafdec0d77905a7a0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4280. CapacityScheduler reservations may not prevent indefinite postponement on a busy cluster. Contributed by Kuhu Shukla\n",
      "commitDate": "03/08/16 11:53 AM",
      "commitName": "4d92aefd35d4517d9435d81bafdec0d77905a7a0",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 139.79,
      "commitsBetweenForRepo": 1021,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,118 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it is not able to access partition\u003d\" + node\n             .getPartition());\n       }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n           resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource(),\n             node.getPartition(), assignedToChild.isIncreasedAllocation());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         assignment.setIncreasedAllocation(assignedToChild\n             .isIncreasedAllocation());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n+        assignment.setSkippedType(assignedToChild.getSkippedType());\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + node\n            .getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition(), assignedToChild.isIncreasedAllocation());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        assignment.setIncreasedAllocation(assignedToChild\n            .isIncreasedAllocation());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        assignment.setSkippedType(assignedToChild.getSkippedType());\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,117 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it is not able to access partition\u003d\" + node\n+            .getPartition());\n+      }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n           resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n-        super.allocateResource(clusterResource, assignedToChild.getResource(),\n+        allocateResource(clusterResource, assignedToChild.getResource(),\n             node.getPartition(), assignedToChild.isIncreasedAllocation());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         assignment.setIncreasedAllocation(assignedToChild\n             .isIncreasedAllocation());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + node\n            .getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition(), assignedToChild.isIncreasedAllocation());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        assignment.setIncreasedAllocation(assignedToChild\n            .isIncreasedAllocation());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,112 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n-            + \", because it is not able to access partition\u003d\" + node\n-            .getPartition());\n-      }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n           resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n-        allocateResource(clusterResource, assignedToChild.getResource(),\n+        super.allocateResource(clusterResource, assignedToChild.getResource(),\n             node.getPartition(), assignedToChild.isIncreasedAllocation());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         assignment.setIncreasedAllocation(assignedToChild\n             .isIncreasedAllocation());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition(), assignedToChild.isIncreasedAllocation());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        assignment.setIncreasedAllocation(assignedToChild\n            .isIncreasedAllocation());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "28/02/16 9:35 AM",
      "commitNameOld": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 17.27,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,117 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it is not able to access partition\u003d\" + node\n+            .getPartition());\n+      }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n           resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n-        super.allocateResource(clusterResource, assignedToChild.getResource(),\n+        allocateResource(clusterResource, assignedToChild.getResource(),\n             node.getPartition(), assignedToChild.isIncreasedAllocation());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         assignment.setIncreasedAllocation(assignedToChild\n             .isIncreasedAllocation());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it is not able to access partition\u003d\" + node\n            .getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition(), assignedToChild.isIncreasedAllocation());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        assignment.setIncreasedAllocation(assignedToChild\n            .isIncreasedAllocation());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthor": "Jian He",
      "commitDateOld": "07/08/15 9:46 AM",
      "commitNameOld": "4bc42d76e7fa53cb268cab0f9fe1fd8d8dbb17fd",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 47.15,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,112 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n       return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n           resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n-            node.getPartition());\n+            node.getPartition(), assignedToChild.isIncreasedAllocation());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n+        assignment.setIncreasedAllocation(assignedToChild\n+            .isIncreasedAllocation());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition(), assignedToChild.isIncreasedAllocation());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        assignment.setIncreasedAllocation(assignedToChild\n            .isIncreasedAllocation());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "ba2313d6145a1234777938a747187373f4cd58d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3983. Refactored CapacityScheduleri#FiCaSchedulerApp to easier extend container allocation logic. Contributed by Wangda Tan\n",
      "commitDate": "05/08/15 1:47 PM",
      "commitName": "ba2313d6145a1234777938a747187373f4cd58d9",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/07/15 2:00 PM",
      "commitNameOld": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n-      return NULL_ASSIGNMENT;\n+      return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n-      return NULL_ASSIGNMENT;\n+      return CSAssignment.NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n           resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             node.getPartition());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return CSAssignment.NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
      "commitDate": "24/07/15 2:00 PM",
      "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/07/15 9:52 PM",
      "commitNameOld": "5ed1fead6b5ec24bb0ce1a3db033c2ee1ede4bb4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 11.67,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits,\n       SchedulingMode schedulingMode) {\n     // if our queue cannot access this node, just return\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n         \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n       return NULL_ASSIGNMENT;\n     }\n     \n     // Check if this queue need more resource, simply skip allocation if this\n     // queue doesn\u0027t need more resources.\n     if (!super.hasPendingResourceRequest(node.getPartition(),\n         clusterResource, schedulingMode)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n             + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n             + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n       }\n       return NULL_ASSIGNMENT;\n     }\n     \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n-          resourceLimits, minimumAllocation, Resources.createResource(\n+          resourceLimits, Resources.createResource(\n               getMetrics().getReservedMB(), getMetrics()\n                   .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d\n           assignContainersToChildQueues(clusterResource, node, resourceLimits,\n               schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             node.getPartition());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      return NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
      "commitDate": "14/04/15 11:45 AM",
      "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,110 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n-      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n+      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n+      SchedulingMode schedulingMode) {\n+    // if our queue cannot access this node, just return\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n+        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n+      return NULL_ASSIGNMENT;\n+    }\n+    \n+    // Check if this queue need more resource, simply skip allocation if this\n+    // queue doesn\u0027t need more resources.\n+    if (!super.hasPendingResourceRequest(node.getPartition(),\n+        clusterResource, schedulingMode)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n+            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n+      }\n+      return NULL_ASSIGNMENT;\n+    }\n+    \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n-    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n-    \n-    // if our queue cannot access this node, just return\n-    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n-      return assignment;\n-    }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n-      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n-          minimumAllocation, Resources.createResource(getMetrics()\n-              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n+      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n+          resourceLimits, minimumAllocation, Resources.createResource(\n+              getMetrics().getReservedMB(), getMetrics()\n+                  .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n-      CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n+      CSAssignment assignedToChild \u003d\n+          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n+              schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n-            nodeLabels);\n+            node.getPartition());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      return NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, minimumAllocation, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode, resourceLimits-ResourceLimits]",
            "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode, resourceLimits-ResourceLimits, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,110 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n-      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n+      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n+      SchedulingMode schedulingMode) {\n+    // if our queue cannot access this node, just return\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n+        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n+      return NULL_ASSIGNMENT;\n+    }\n+    \n+    // Check if this queue need more resource, simply skip allocation if this\n+    // queue doesn\u0027t need more resources.\n+    if (!super.hasPendingResourceRequest(node.getPartition(),\n+        clusterResource, schedulingMode)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n+            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n+            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n+      }\n+      return NULL_ASSIGNMENT;\n+    }\n+    \n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n-    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n-    \n-    // if our queue cannot access this node, just return\n-    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n-      return assignment;\n-    }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n-      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n-          minimumAllocation, Resources.createResource(getMetrics()\n-              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n+      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n+          resourceLimits, minimumAllocation, Resources.createResource(\n+              getMetrics().getReservedMB(), getMetrics()\n+                  .getReservedVirtualCores()), schedulingMode)) {\n         break;\n       }\n       \n       // Schedule\n-      CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n+      CSAssignment assignedToChild \u003d\n+          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n+              schedulingMode);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n-            nodeLabels);\n+            node.getPartition());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources\n           .addTo(assignment.getResource(), assignedToChild.getResource());\n         Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n           assignedToChild.getAssignmentInformation().getAllocated());\n         Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n             assignedToChild.getAssignmentInformation().getReserved());\n         assignment.getAssignmentInformation().incrAllocations(\n           assignedToChild.getAssignmentInformation().getNumAllocations());\n         assignment.getAssignmentInformation().incrReservations(\n           assignedToChild.getAssignmentInformation().getNumReservations());\n         assignment\n           .getAssignmentInformation()\n           .getAllocationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation().getAllocationDetails());\n         assignment\n           .getAssignmentInformation()\n           .getReservationDetails()\n           .addAll(\n               assignedToChild.getAssignmentInformation()\n                   .getReservationDetails());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits,\n      SchedulingMode schedulingMode) {\n    // if our queue cannot access this node, just return\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY\n        \u0026\u0026 !accessibleToPartition(node.getPartition())) {\n      return NULL_ASSIGNMENT;\n    }\n    \n    // Check if this queue need more resource, simply skip allocation if this\n    // queue doesn\u0027t need more resources.\n    if (!super.hasPendingResourceRequest(node.getPartition(),\n        clusterResource, schedulingMode)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skip this queue\u003d\" + getQueuePath()\n            + \", because it doesn\u0027t need more resource, schedulingMode\u003d\"\n            + schedulingMode.name() + \" node-partition\u003d\" + node.getPartition());\n      }\n      return NULL_ASSIGNMENT;\n    }\n    \n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, node.getPartition(),\n          resourceLimits, minimumAllocation, Resources.createResource(\n              getMetrics().getReservedMB(), getMetrics()\n                  .getReservedVirtualCores()), schedulingMode)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d\n          assignContainersToChildQueues(clusterResource, node, resourceLimits,\n              schedulingMode);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            node.getPartition());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3293. Track and display capacity scheduler health metrics in web\nUI. Contributed by Varun Vasudev\n",
      "commitDate": "09/04/15 11:38 PM",
      "commitName": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
      "commitAuthor": "Xuan",
      "commitDateOld": "17/03/15 10:24 AM",
      "commitNameOld": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 23.55,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,95 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n       FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n     \n     // if our queue cannot access this node, just return\n     if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n       return assignment;\n     }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       // This will also consider parent\u0027s limits and also continuous reservation\n       // looking\n       if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n           minimumAllocation, Resources.createResource(getMetrics()\n               .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node, resourceLimits);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n-        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n+        Resources\n+          .addTo(assignment.getResource(), assignedToChild.getResource());\n+        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n+          assignedToChild.getAssignmentInformation().getAllocated());\n+        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n+            assignedToChild.getAssignmentInformation().getReserved());\n+        assignment.getAssignmentInformation().incrAllocations(\n+          assignedToChild.getAssignmentInformation().getNumAllocations());\n+        assignment.getAssignmentInformation().incrReservations(\n+          assignedToChild.getAssignmentInformation().getNumReservations());\n+        assignment\n+          .getAssignmentInformation()\n+          .getAllocationDetails()\n+          .addAll(\n+              assignedToChild.getAssignmentInformation().getAllocationDetails());\n+        assignment\n+          .getAssignmentInformation()\n+          .getReservationDetails()\n+          .addAll(\n+              assignedToChild.getAssignmentInformation()\n+                  .getReservationDetails());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n          minimumAllocation, Resources.createResource(getMetrics()\n              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources\n          .addTo(assignment.getResource(), assignedToChild.getResource());\n        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),\n          assignedToChild.getAssignmentInformation().getAllocated());\n        Resources.addTo(assignment.getAssignmentInformation().getReserved(),\n            assignedToChild.getAssignmentInformation().getReserved());\n        assignment.getAssignmentInformation().incrAllocations(\n          assignedToChild.getAssignmentInformation().getNumAllocations());\n        assignment.getAssignmentInformation().incrReservations(\n          assignedToChild.getAssignmentInformation().getNumReservations());\n        assignment\n          .getAssignmentInformation()\n          .getAllocationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation().getAllocationDetails());\n        assignment\n          .getAssignmentInformation()\n          .getReservationDetails()\n          .addAll(\n              assignedToChild.getAssignmentInformation()\n                  .getReservationDetails());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
      "commitDate": "17/03/15 10:24 AM",
      "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,75 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n-      FiCaSchedulerNode node, boolean needToUnreserve,\n-      ResourceLimits resourceLimits) {\n+      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n     \n     // if our queue cannot access this node, just return\n     if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n       return assignment;\n     }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n-      boolean localNeedToUnreserve \u003d false;\n-      \n       // Are we over maximum-capacity for this queue?\n-      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n-        // check to see if we could if we unreserve first\n-        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n-        if (!localNeedToUnreserve) {\n-          break;\n-        }\n+      // This will also consider parent\u0027s limits and also continuous reservation\n+      // looking\n+      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n+          minimumAllocation, Resources.createResource(getMetrics()\n+              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n+        break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node,\n-              localNeedToUnreserve | needToUnreserve, resourceLimits);\n+          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n          minimumAllocation, Resources.createResource(getMetrics()\n              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode, needToUnreserve-boolean, resourceLimits-ResourceLimits]",
            "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode, resourceLimits-ResourceLimits]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,75 @@\n   public synchronized CSAssignment assignContainers(Resource clusterResource,\n-      FiCaSchedulerNode node, boolean needToUnreserve,\n-      ResourceLimits resourceLimits) {\n+      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n     \n     // if our queue cannot access this node, just return\n     if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n       return assignment;\n     }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n-      boolean localNeedToUnreserve \u003d false;\n-      \n       // Are we over maximum-capacity for this queue?\n-      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n-        // check to see if we could if we unreserve first\n-        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n-        if (!localNeedToUnreserve) {\n-          break;\n-        }\n+      // This will also consider parent\u0027s limits and also continuous reservation\n+      // looking\n+      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n+          minimumAllocation, Resources.createResource(getMetrics()\n+              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n+        break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node,\n-              localNeedToUnreserve | needToUnreserve, resourceLimits);\n+          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent\u0027s limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n          minimumAllocation, Resources.createResource(getMetrics()\n              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "14dd647c556016d351f425ee956ccf800ccb9ce2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
      "commitDate": "02/03/15 5:52 PM",
      "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
          "commitDate": "02/03/15 5:52 PM",
          "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/02/15 2:58 PM",
          "commitNameOld": "18a594257e052e8f10a03e5594e6cc6901dc56be",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 18.12,
          "commitsBetweenForRepo": 155,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,79 @@\n-  public synchronized CSAssignment assignContainers(\n-      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n+  public synchronized CSAssignment assignContainers(Resource clusterResource,\n+      FiCaSchedulerNode node, boolean needToUnreserve,\n+      ResourceLimits resourceLimits) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n     \n     // if our queue cannot access this node, just return\n     if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n       return assignment;\n     }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       boolean localNeedToUnreserve \u003d false;\n       \n       // Are we over maximum-capacity for this queue?\n       if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n         // check to see if we could if we unreserve first\n         localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n         if (!localNeedToUnreserve) {\n           break;\n         }\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n+          assignContainersToChildQueues(clusterResource, node,\n+              localNeedToUnreserve | needToUnreserve, resourceLimits);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, boolean needToUnreserve,\n      ResourceLimits resourceLimits) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      boolean localNeedToUnreserve \u003d false;\n      \n      // Are we over maximum-capacity for this queue?\n      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n        // check to see if we could if we unreserve first\n        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n        if (!localNeedToUnreserve) {\n          break;\n        }\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node,\n              localNeedToUnreserve | needToUnreserve, resourceLimits);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode, needToUnreserve-boolean]",
            "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode, needToUnreserve-boolean, resourceLimits-ResourceLimits]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
          "commitDate": "02/03/15 5:52 PM",
          "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/02/15 2:58 PM",
          "commitNameOld": "18a594257e052e8f10a03e5594e6cc6901dc56be",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 18.12,
          "commitsBetweenForRepo": 155,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,79 @@\n-  public synchronized CSAssignment assignContainers(\n-      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n+  public synchronized CSAssignment assignContainers(Resource clusterResource,\n+      FiCaSchedulerNode node, boolean needToUnreserve,\n+      ResourceLimits resourceLimits) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n     \n     // if our queue cannot access this node, just return\n     if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n       return assignment;\n     }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       boolean localNeedToUnreserve \u003d false;\n       \n       // Are we over maximum-capacity for this queue?\n       if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n         // check to see if we could if we unreserve first\n         localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n         if (!localNeedToUnreserve) {\n           break;\n         }\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n+          assignContainersToChildQueues(clusterResource, node,\n+              localNeedToUnreserve | needToUnreserve, resourceLimits);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, boolean needToUnreserve,\n      ResourceLimits resourceLimits) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      boolean localNeedToUnreserve \u003d false;\n      \n      // Are we over maximum-capacity for this queue?\n      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n        // check to see if we could if we unreserve first\n        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n        if (!localNeedToUnreserve) {\n          break;\n        }\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node,\n              localNeedToUnreserve | needToUnreserve, resourceLimits);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "86358221fc85a7743052a0b4c1647353508bf308": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3099. Capacity Scheduler LeafQueue/ParentQueue should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "30/01/15 3:15 PM",
      "commitName": "86358221fc85a7743052a0b4c1647353508bf308",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/01/15 2:15 PM",
      "commitNameOld": "dd57c2047bfd21910acc38c98153eedf1db75169",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 24.04,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   public synchronized CSAssignment assignContainers(\n       Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n     \n     // if our queue cannot access this node, just return\n     if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n       return assignment;\n     }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       boolean localNeedToUnreserve \u003d false;\n       \n       // Are we over maximum-capacity for this queue?\n       if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n         // check to see if we could if we unreserve first\n         localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n         if (!localNeedToUnreserve) {\n           break;\n         }\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n-            \" used\u003d\" + usedResources + \n+            \" used\u003d\" + queueUsage.getUsed() + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      boolean localNeedToUnreserve \u003d false;\n      \n      // Are we over maximum-capacity for this queue?\n      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n        // check to see if we could if we unreserve first\n        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n        if (!localNeedToUnreserve) {\n          break;\n        }\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + queueUsage.getUsed() + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2920. Changed CapacityScheduler to kill containers on nodes where node labels are changed. Contributed by  Wangda Tan\n",
      "commitDate": "22/12/14 4:51 PM",
      "commitName": "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
      "commitAuthor": "Jian He",
      "commitDateOld": "15/10/14 6:33 PM",
      "commitNameOld": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 67.97,
      "commitsBetweenForRepo": 558,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,77 @@\n   public synchronized CSAssignment assignContainers(\n       Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n+    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n     \n     // if our queue cannot access this node, just return\n-    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels,\n-        labelManager.getLabelsOnNode(node.getNodeID()))) {\n+    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n       return assignment;\n     }\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       boolean localNeedToUnreserve \u003d false;\n-      Set\u003cString\u003e nodeLabels \u003d labelManager.getLabelsOnNode(node.getNodeID()); \n       \n       // Are we over maximum-capacity for this queue?\n       if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n         // check to see if we could if we unreserve first\n         localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n         if (!localNeedToUnreserve) {\n           break;\n         }\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         super.allocateResource(clusterResource, assignedToChild.getResource(),\n             nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set\u003cString\u003e nodeLabels \u003d node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      boolean localNeedToUnreserve \u003d false;\n      \n      // Are we over maximum-capacity for this queue?\n      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n        // check to see if we could if we unreserve first\n        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n        if (!localNeedToUnreserve) {\n          break;\n        }\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/10/14 3:41 PM",
      "commitNameOld": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthorOld": "carlo curino",
      "daysBetweenCommits": 12.12,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,78 @@\n   public synchronized CSAssignment assignContainers(\n       Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n+    // if our queue cannot access this node, just return\n+    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels,\n+        labelManager.getLabelsOnNode(node.getNodeID()))) {\n+      return assignment;\n+    }\n+    \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       boolean localNeedToUnreserve \u003d false;\n+      Set\u003cString\u003e nodeLabels \u003d labelManager.getLabelsOnNode(node.getNodeID()); \n+      \n       // Are we over maximum-capacity for this queue?\n-      if (!assignToQueue(clusterResource)) {\n+      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n         // check to see if we could if we unreserve first\n         localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n         if (!localNeedToUnreserve) {\n           break;\n         }\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n-        allocateResource(clusterResource, assignedToChild.getResource());\n+        super.allocateResource(clusterResource, assignedToChild.getResource(),\n+            nodeLabels);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels,\n        labelManager.getLabelsOnNode(node.getNodeID()))) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      boolean localNeedToUnreserve \u003d false;\n      Set\u003cString\u003e nodeLabels \u003d labelManager.getLabelsOnNode(node.getNodeID()); \n      \n      // Are we over maximum-capacity for this queue?\n      if (!canAssignToThisQueue(clusterResource, nodeLabels)) {\n        // check to see if we could if we unreserve first\n        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n        if (!localNeedToUnreserve) {\n          break;\n        }\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "9c22065109a77681bc2534063eabe8692fbcb3cd": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
      "commitDate": "29/09/14 7:12 AM",
      "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
          "commitDate": "29/09/14 7:12 AM",
          "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "14/08/14 11:00 PM",
          "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 45.34,
          "commitsBetweenForRepo": 409,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,69 @@\n   public synchronized CSAssignment assignContainers(\n-      Resource clusterResource, FiCaSchedulerNode node) {\n+      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n+      boolean localNeedToUnreserve \u003d false;\n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n-        break;\n+        // check to see if we could if we unreserve first\n+        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n+        if (!localNeedToUnreserve) {\n+          break;\n+        }\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node);\n+          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      boolean localNeedToUnreserve \u003d false;\n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        // check to see if we could if we unreserve first\n        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n        if (!localNeedToUnreserve) {\n          break;\n        }\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode]",
            "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode, needToUnreserve-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
          "commitDate": "29/09/14 7:12 AM",
          "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "14/08/14 11:00 PM",
          "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 45.34,
          "commitsBetweenForRepo": 409,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,69 @@\n   public synchronized CSAssignment assignContainers(\n-      Resource clusterResource, FiCaSchedulerNode node) {\n+      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n+      boolean localNeedToUnreserve \u003d false;\n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n-        break;\n+        // check to see if we could if we unreserve first\n+        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n+        if (!localNeedToUnreserve) {\n+          break;\n+        }\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n-          assignContainersToChildQueues(clusterResource, node);\n+          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(\n               resourceCalculator, clusterResource, \n               assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      boolean localNeedToUnreserve \u003d false;\n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        // check to see if we could if we unreserve first\n        localNeedToUnreserve \u003d assignToQueueIfUnreserve(clusterResource);\n        if (!localNeedToUnreserve) {\n          break;\n        }\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node, localNeedToUnreserve | needToUnreserve);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "31/10/12 9:56 AM",
      "commitNameOld": "ab8fa651f736525c8e40229ee99859cee9c1ba33",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 69.51,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,64 @@\n   public synchronized CSAssignment assignContainers(\n       Resource clusterResource, FiCaSchedulerNode node) {\n     CSAssignment assignment \u003d \n-        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n+        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n     \n-    while (canAssign(node)) {\n+    while (canAssign(clusterResource, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n-      if (Resources.greaterThan(assignedToChild.getResource(), \n-              Resources.none())) {\n+      if (Resources.greaterThan(\n+              resourceCalculator, clusterResource, \n+              assignedToChild.getResource(), Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild.getResource(), \n              Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Yparameterchange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "19/06/12 6:06 AM",
      "commitNameOld": "01b61c76a85858a0bc0cba24cc00f961affa4922",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 27.53,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   public synchronized CSAssignment assignContainers(\n-      Resource clusterResource, SchedulerNode node) {\n+      Resource clusterResource, FiCaSchedulerNode node) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n     \n     while (canAssign(node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node);\n       assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(assignedToChild.getResource(), \n               Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n         if (LOG.isDebugEnabled()) {\n           if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n                 \" assignments so far: \" + assignment);\n           }\n         }\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, FiCaSchedulerNode node) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild.getResource(), \n              Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {
        "oldValue": "[clusterResource-Resource, node-SchedulerNode]",
        "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode]"
      }
    },
    "c76b264196d76a323ccf409acdd5fabe429e047c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4073. CS assigns multiple off-switch containers when using multi-level-queues (Siddharth Seth via bobby)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1310056 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/04/12 1:27 PM",
      "commitName": "c76b264196d76a323ccf409acdd5fabe429e047c",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "09/03/12 3:34 PM",
      "commitNameOld": "ed4c222d5c0aeb4a46a2dd8a6342c85e88f31d3b",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 26.87,
      "commitsBetweenForRepo": 184,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,63 @@\n   public synchronized CSAssignment assignContainers(\n       Resource clusterResource, SchedulerNode node) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n-    boolean assignedOffSwitch \u003d false;\n     \n     while (canAssign(node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node);\n-      assignedOffSwitch \u003d (assignedToChild.getType() \u003d\u003d NodeType.OFF_SWITCH);\n+      assignment.setType(assignedToChild.getType());\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(assignedToChild.getResource(), \n               Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" usedCapacity\u003d\" + getUsedCapacity() +\n             \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" usedCapacity\u003d\" + getUsedCapacity()\n           + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n-      if (rootQueue) {\n-        if (assignedOffSwitch) {\n-          if (LOG.isDebugEnabled()) {\n+      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n+        if (LOG.isDebugEnabled()) {\n+          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n-            \t\t\" assignments so far: \" + assignment);\n+                \" assignments so far: \" + assignment);\n           }\n-          break;\n         }\n-      } else {\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, SchedulerNode node) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n    \n    while (canAssign(node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild.getResource(), \n              Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (!rootQueue || assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue \u0026\u0026 assignment.getType() \u003d\u003d NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3816 capacity scheduler web ui bar graphs for used capacity wrong (tgraves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1294808 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/12 12:06 PM",
      "commitName": "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "07/02/12 2:08 PM",
      "commitNameOld": "59b88655bc15535d7bf765987cb9b82f17e16b80",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 20.92,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public synchronized CSAssignment assignContainers(\n       Resource clusterResource, SchedulerNode node) {\n     CSAssignment assignment \u003d \n         new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n     boolean assignedOffSwitch \u003d false;\n     \n     while (canAssign(node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n         break;\n       }\n       \n       // Schedule\n       CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node);\n       assignedOffSwitch \u003d (assignedToChild.getType() \u003d\u003d NodeType.OFF_SWITCH);\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(assignedToChild.getResource(), \n               Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n-            \" util\u003d\" + getUtilization() + \n+            \" usedCapacity\u003d\" + getUsedCapacity() +\n+            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n           + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n-          + \" utilization\u003d\" + getUtilization());\n+          + \" usedCapacity\u003d\" + getUsedCapacity()\n+          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n       // or if we\u0027ve already assigned an off-switch container\n       if (rootQueue) {\n         if (assignedOffSwitch) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Not assigning more than one off-switch container,\" +\n             \t\t\" assignments so far: \" + assignment);\n           }\n           break;\n         }\n       } else {\n         break;\n       }\n     } \n     \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, SchedulerNode node) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n    boolean assignedOffSwitch \u003d false;\n    \n    while (canAssign(node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      assignedOffSwitch \u003d (assignedToChild.getType() \u003d\u003d NodeType.OFF_SWITCH);\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild.getResource(), \n              Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" usedCapacity\u003d\" + getUsedCapacity() +\n            \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity() +\n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" usedCapacity\u003d\" + getUsedCapacity()\n          + \" absoluteUsedCapacity\u003d\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (rootQueue) {\n        if (assignedOffSwitch) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n            \t\t\" assignments so far: \" + assignment);\n          }\n          break;\n        }\n      } else {\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "4a343c9d4ab4c993b545f0c1062c6b5449b065f0": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3641. Making CapacityScheduler more conservative so as to assign only one off-switch container in a single scheduling iteration. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1232182 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/01/12 1:56 PM",
      "commitName": "4a343c9d4ab4c993b545f0c1062c6b5449b065f0",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "MAPREDUCE-3641. Making CapacityScheduler more conservative so as to assign only one off-switch container in a single scheduling iteration. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1232182 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/01/12 1:56 PM",
          "commitName": "4a343c9d4ab4c993b545f0c1062c6b5449b065f0",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/12/11 5:38 PM",
          "commitNameOld": "224fc101fdfa355b4ad842fc39192d8e4f1f2979",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 38.85,
          "commitsBetweenForRepo": 185,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,64 @@\n-  public synchronized Resource assignContainers(\n+  public synchronized CSAssignment assignContainers(\n       Resource clusterResource, SchedulerNode node) {\n-    Resource assigned \u003d Resources.createResource(0);\n-\n+    CSAssignment assignment \u003d \n+        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n+    boolean assignedOffSwitch \u003d false;\n+    \n     while (canAssign(node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n         break;\n       }\n       \n       // Schedule\n-      Resource assignedToChild \u003d \n+      CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node);\n+      assignedOffSwitch \u003d (assignedToChild.getType() \u003d\u003d NodeType.OFF_SWITCH);\n       \n       // Done if no child-queue assigned anything\n-      if (Resources.greaterThan(assignedToChild, Resources.none())) {\n+      if (Resources.greaterThan(assignedToChild.getResource(), \n+              Resources.none())) {\n         // Track resource utilization for the parent-queue\n-        allocateResource(clusterResource, assignedToChild);\n+        allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n-        Resources.addTo(assigned, assignedToChild);\n+        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" util\u003d\" + getUtilization() + \n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n-          + \" assignedSoFarInThisIteration\u003d\" + assigned\n+          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" utilization\u003d\" + getUtilization());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n-      if (!rootQueue) {\n+      // or if we\u0027ve already assigned an off-switch container\n+      if (rootQueue) {\n+        if (assignedOffSwitch) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Not assigning more than one off-switch container,\" +\n+            \t\t\" assignments so far: \" + assignment);\n+          }\n+          break;\n+        }\n+      } else {\n         break;\n       }\n     } \n     \n-    return assigned;\n+    return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, SchedulerNode node) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n    boolean assignedOffSwitch \u003d false;\n    \n    while (canAssign(node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      assignedOffSwitch \u003d (assignedToChild.getType() \u003d\u003d NodeType.OFF_SWITCH);\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild.getResource(), \n              Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" util\u003d\" + getUtilization() + \n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" utilization\u003d\" + getUtilization());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (rootQueue) {\n        if (assignedOffSwitch) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n            \t\t\" assignments so far: \" + assignment);\n          }\n          break;\n        }\n      } else {\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "Resource",
            "newValue": "CSAssignment"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3641. Making CapacityScheduler more conservative so as to assign only one off-switch container in a single scheduling iteration. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1232182 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/01/12 1:56 PM",
          "commitName": "4a343c9d4ab4c993b545f0c1062c6b5449b065f0",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/12/11 5:38 PM",
          "commitNameOld": "224fc101fdfa355b4ad842fc39192d8e4f1f2979",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 38.85,
          "commitsBetweenForRepo": 185,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,64 @@\n-  public synchronized Resource assignContainers(\n+  public synchronized CSAssignment assignContainers(\n       Resource clusterResource, SchedulerNode node) {\n-    Resource assigned \u003d Resources.createResource(0);\n-\n+    CSAssignment assignment \u003d \n+        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n+    boolean assignedOffSwitch \u003d false;\n+    \n     while (canAssign(node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Trying to assign containers to child-queue of \"\n           + getQueueName());\n       }\n       \n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n         break;\n       }\n       \n       // Schedule\n-      Resource assignedToChild \u003d \n+      CSAssignment assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node);\n+      assignedOffSwitch \u003d (assignedToChild.getType() \u003d\u003d NodeType.OFF_SWITCH);\n       \n       // Done if no child-queue assigned anything\n-      if (Resources.greaterThan(assignedToChild, Resources.none())) {\n+      if (Resources.greaterThan(assignedToChild.getResource(), \n+              Resources.none())) {\n         // Track resource utilization for the parent-queue\n-        allocateResource(clusterResource, assignedToChild);\n+        allocateResource(clusterResource, assignedToChild.getResource());\n         \n         // Track resource utilization in this pass of the scheduler\n-        Resources.addTo(assigned, assignedToChild);\n+        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" util\u003d\" + getUtilization() + \n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ParentQ\u003d\" + getQueueName()\n-          + \" assignedSoFarInThisIteration\u003d\" + assigned\n+          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n           + \" utilization\u003d\" + getUtilization());\n       }\n \n       // Do not assign more than one container if this isn\u0027t the root queue\n-      if (!rootQueue) {\n+      // or if we\u0027ve already assigned an off-switch container\n+      if (rootQueue) {\n+        if (assignedOffSwitch) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Not assigning more than one off-switch container,\" +\n+            \t\t\" assignments so far: \" + assignment);\n+          }\n+          break;\n+        }\n+      } else {\n         break;\n       }\n     } \n     \n-    return assigned;\n+    return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized CSAssignment assignContainers(\n      Resource clusterResource, SchedulerNode node) {\n    CSAssignment assignment \u003d \n        new CSAssignment(Resources.createResource(0), NodeType.NODE_LOCAL);\n    boolean assignedOffSwitch \u003d false;\n    \n    while (canAssign(node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      assignedOffSwitch \u003d (assignedToChild.getType() \u003d\u003d NodeType.OFF_SWITCH);\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild.getResource(), \n              Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild.getResource());\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" util\u003d\" + getUtilization() + \n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assignment.getResource()\n          + \" utilization\u003d\" + getUtilization());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      // or if we\u0027ve already assigned an off-switch container\n      if (rootQueue) {\n        if (assignedOffSwitch) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n            \t\t\" assignments so far: \" + assignment);\n          }\n          break;\n        }\n      } else {\n        break;\n      }\n    } \n    \n    return assignment;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "f24dcb3449c77da665058427bc7fa480cad507fc": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2907. Changed log level for various messages in ResourceManager from INFO to DEBUG. Contributed by Ravi Prakash.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1179178 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/10/11 4:56 AM",
      "commitName": "f24dcb3449c77da665058427bc7fa480cad507fc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/09/11 3:19 PM",
      "commitNameOld": "dcf9d475e0de05a2e1a7fe9239034c0a6d8a9456",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 4.57,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,51 @@\n   public synchronized Resource assignContainers(\n       Resource clusterResource, SchedulerNode node) {\n     Resource assigned \u003d Resources.createResource(0);\n \n     while (canAssign(node)) {\n-      LOG.info(\"DEBUG --- Trying to assign containers to child-queue of \" + \n-          getQueueName());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Trying to assign containers to child-queue of \"\n+          + getQueueName());\n+      }\n       \n       // Are we over maximum-capacity for this queue?\n       if (!assignToQueue(clusterResource)) {\n         break;\n       }\n       \n       // Schedule\n       Resource assignedToChild \u003d \n           assignContainersToChildQueues(clusterResource, node);\n       \n       // Done if no child-queue assigned anything\n       if (Resources.greaterThan(assignedToChild, Resources.none())) {\n         // Track resource utilization for the parent-queue\n         allocateResource(clusterResource, assignedToChild);\n         \n         // Track resource utilization in this pass of the scheduler\n         Resources.addTo(assigned, assignedToChild);\n         \n         LOG.info(\"assignedContainer\" +\n             \" queue\u003d\" + getQueueName() + \n             \" util\u003d\" + getUtilization() + \n             \" used\u003d\" + usedResources + \n             \" cluster\u003d\" + clusterResource);\n \n       } else {\n         break;\n       }\n \n-      LOG.info(\"DEBUG ---\" +\n-      \t\t\" parentQ\u003d\" + getQueueName() + \n-      \t\t\" assignedSoFarInThisIteration\u003d\" + assigned + \n-      \t\t\" utilization\u003d\" + getUtilization());\n-      \n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n+          + \" assignedSoFarInThisIteration\u003d\" + assigned\n+          + \" utilization\u003d\" + getUtilization());\n+      }\n+\n       // Do not assign more than one container if this isn\u0027t the root queue\n       if (!rootQueue) {\n         break;\n       }\n     } \n     \n     return assigned;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized Resource assignContainers(\n      Resource clusterResource, SchedulerNode node) {\n    Resource assigned \u003d Resources.createResource(0);\n\n    while (canAssign(node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      Resource assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild, Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assigned, assignedToChild);\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" util\u003d\" + getUtilization() + \n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ\u003d\" + getQueueName()\n          + \" assignedSoFarInThisIteration\u003d\" + assigned\n          + \" utilization\u003d\" + getUtilization());\n      }\n\n      // Do not assign more than one container if this isn\u0027t the root queue\n      if (!rootQueue) {\n        break;\n      }\n    } \n    \n    return assigned;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized Resource assignContainers(\n      Resource clusterResource, SchedulerNode node) {\n    Resource assigned \u003d Resources.createResource(0);\n\n    while (canAssign(node)) {\n      LOG.info(\"DEBUG --- Trying to assign containers to child-queue of \" + \n          getQueueName());\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      Resource assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild, Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assigned, assignedToChild);\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" util\u003d\" + getUtilization() + \n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      LOG.info(\"DEBUG ---\" +\n      \t\t\" parentQ\u003d\" + getQueueName() + \n      \t\t\" assignedSoFarInThisIteration\u003d\" + assigned + \n      \t\t\" utilization\u003d\" + getUtilization());\n      \n      // Do not assign more than one container if this isn\u0027t the root queue\n      if (!rootQueue) {\n        break;\n      }\n    } \n    \n    return assigned;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,48 @@\n+  public synchronized Resource assignContainers(\n+      Resource clusterResource, SchedulerNode node) {\n+    Resource assigned \u003d Resources.createResource(0);\n+\n+    while (canAssign(node)) {\n+      LOG.info(\"DEBUG --- Trying to assign containers to child-queue of \" + \n+          getQueueName());\n+      \n+      // Are we over maximum-capacity for this queue?\n+      if (!assignToQueue(clusterResource)) {\n+        break;\n+      }\n+      \n+      // Schedule\n+      Resource assignedToChild \u003d \n+          assignContainersToChildQueues(clusterResource, node);\n+      \n+      // Done if no child-queue assigned anything\n+      if (Resources.greaterThan(assignedToChild, Resources.none())) {\n+        // Track resource utilization for the parent-queue\n+        allocateResource(clusterResource, assignedToChild);\n+        \n+        // Track resource utilization in this pass of the scheduler\n+        Resources.addTo(assigned, assignedToChild);\n+        \n+        LOG.info(\"assignedContainer\" +\n+            \" queue\u003d\" + getQueueName() + \n+            \" util\u003d\" + getUtilization() + \n+            \" used\u003d\" + usedResources + \n+            \" cluster\u003d\" + clusterResource);\n+\n+      } else {\n+        break;\n+      }\n+\n+      LOG.info(\"DEBUG ---\" +\n+      \t\t\" parentQ\u003d\" + getQueueName() + \n+      \t\t\" assignedSoFarInThisIteration\u003d\" + assigned + \n+      \t\t\" utilization\u003d\" + getUtilization());\n+      \n+      // Do not assign more than one container if this isn\u0027t the root queue\n+      if (!rootQueue) {\n+        break;\n+      }\n+    } \n+    \n+    return assigned;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized Resource assignContainers(\n      Resource clusterResource, SchedulerNode node) {\n    Resource assigned \u003d Resources.createResource(0);\n\n    while (canAssign(node)) {\n      LOG.info(\"DEBUG --- Trying to assign containers to child-queue of \" + \n          getQueueName());\n      \n      // Are we over maximum-capacity for this queue?\n      if (!assignToQueue(clusterResource)) {\n        break;\n      }\n      \n      // Schedule\n      Resource assignedToChild \u003d \n          assignContainersToChildQueues(clusterResource, node);\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(assignedToChild, Resources.none())) {\n        // Track resource utilization for the parent-queue\n        allocateResource(clusterResource, assignedToChild);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assigned, assignedToChild);\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue\u003d\" + getQueueName() + \n            \" util\u003d\" + getUtilization() + \n            \" used\u003d\" + usedResources + \n            \" cluster\u003d\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      LOG.info(\"DEBUG ---\" +\n      \t\t\" parentQ\u003d\" + getQueueName() + \n      \t\t\" assignedSoFarInThisIteration\u003d\" + assigned + \n      \t\t\" utilization\u003d\" + getUtilization());\n      \n      // Do not assign more than one container if this isn\u0027t the root queue\n      if (!rootQueue) {\n        break;\n      }\n    } \n    \n    return assigned;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"
    }
  }
}