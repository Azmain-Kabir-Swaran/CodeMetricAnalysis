{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMClientImpl.java",
  "functionName": "getMatchingRequests",
  "functionId": "getMatchingRequests___priority-Priority__resourceName-String__executionType-ExecutionType__capability-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
  "functionStartLine": 734,
  "functionEndLine": 762,
  "numCommitsSeen": 102,
  "timeTaken": 4242,
  "changeHistory": [
    "aae629913cee0157c945a2c7384c7bf398f10616",
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
    "44fdf009642ae4e99b15f89ec0ca43834f991ef3",
    "19c743c1bbcaf3df8f1d63e557143c960a538c42",
    "51432779588fdd741b4840601f5db637ec783d92",
    "1fe8e2d7eed74453cfe172853881fafc360a10b6",
    "fe735f237c735a375d2bd194ed80ef9949fb1a68",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e"
  ],
  "changeHistoryShort": {
    "aae629913cee0157c945a2c7384c7bf398f10616": "Ybodychange",
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9": "Ybodychange",
    "44fdf009642ae4e99b15f89ec0ca43834f991ef3": "Ybodychange",
    "19c743c1bbcaf3df8f1d63e557143c960a538c42": "Ybodychange",
    "51432779588fdd741b4840601f5db637ec783d92": "Ymultichange(Yparameterchange,Ybodychange)",
    "1fe8e2d7eed74453cfe172853881fafc360a10b6": "Ybodychange",
    "fe735f237c735a375d2bd194ed80ef9949fb1a68": "Ybodychange",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": "Yfilerename",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "aae629913cee0157c945a2c7384c7bf398f10616": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7292. Retrospect Resource Profile Behavior for overriding capability. Contributed by Wangda Tan.\n",
      "commitDate": "15/02/18 11:07 PM",
      "commitName": "aae629913cee0157c945a2c7384c7bf398f10616",
      "commitAuthor": "Sunil G",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "29d9e4d5814900d5c59d77fe05d32186d4ad9385",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 15.9,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,8 +1,29 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n       Priority priority, String resourceName, ExecutionType executionType,\n       Resource capability) {\n-    ProfileCapability profileCapability \u003d\n-        ProfileCapability.newInstance(capability);\n-    return getMatchingRequests(priority, resourceName, executionType,\n-        profileCapability);\n+    Preconditions.checkArgument(capability !\u003d null,\n+        \"The Resource to be requested should not be null \");\n+    Preconditions.checkArgument(priority !\u003d null,\n+        \"The priority at which to request containers should not be null \");\n+    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003c\u003e();\n+\n+    RemoteRequestsTable remoteRequestsTable \u003d getTable(0);\n+\n+    if (null !\u003d remoteRequestsTable) {\n+      List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d remoteRequestsTable\n+          .getMatchingRequests(priority, resourceName, executionType,\n+              capability);\n+      if (null !\u003d matchingRequests) {\n+        // If no exact match. Container may be larger than what was requested.\n+        // get all resources \u003c\u003d capability. map is reverse sorted.\n+        for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n+          if (Resources.fitsIn(resReqInfo.remoteRequest.getCapability(),\n+              capability) \u0026\u0026 !resReqInfo.containerRequests.isEmpty()) {\n+            list.add(resReqInfo.containerRequests);\n+          }\n+        }\n+      }\n+    }\n+    // no match found\n+    return list;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n      Priority priority, String resourceName, ExecutionType executionType,\n      Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003c\u003e();\n\n    RemoteRequestsTable remoteRequestsTable \u003d getTable(0);\n\n    if (null !\u003d remoteRequestsTable) {\n      List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d remoteRequestsTable\n          .getMatchingRequests(priority, resourceName, executionType,\n              capability);\n      if (null !\u003d matchingRequests) {\n        // If no exact match. Container may be larger than what was requested.\n        // get all resources \u003c\u003d capability. map is reverse sorted.\n        for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n          if (Resources.fitsIn(resReqInfo.remoteRequest.getCapability(),\n              capability) \u0026\u0026 !resReqInfo.containerRequests.isEmpty()) {\n            list.add(resReqInfo.containerRequests);\n          }\n        }\n      }\n    }\n    // no match found\n    return list;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5587. Add support for resource profiles. (vvasudev via asuresh)\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "24/07/17 12:03 PM",
      "commitNameOld": "4c40cd451cbdbce5d2b94ad0e7e3cc991c3439c5",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 49.89,
      "commitsBetweenForRepo": 442,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,8 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n       Priority priority, String resourceName, ExecutionType executionType,\n       Resource capability) {\n-    Preconditions.checkArgument(capability !\u003d null,\n-        \"The Resource to be requested should not be null \");\n-    Preconditions.checkArgument(priority !\u003d null,\n-        \"The priority at which to request containers should not be null \");\n-    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n-\n-    RemoteRequestsTable remoteRequestsTable \u003d getTable(0);\n-\n-    if (null !\u003d remoteRequestsTable) {\n-      List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n-          remoteRequestsTable.getMatchingRequests(priority, resourceName,\n-              executionType, capability);\n-      if (null !\u003d matchingRequests) {\n-        // If no exact match. Container may be larger than what was requested.\n-        // get all resources \u003c\u003d capability. map is reverse sorted.\n-        for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n-          if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n-              !resReqInfo.containerRequests.isEmpty()) {\n-            list.add(resReqInfo.containerRequests);\n-          }\n-        }\n-      }\n-    }\n-    // no match found\n-    return list;          \n+    ProfileCapability profileCapability \u003d\n+        ProfileCapability.newInstance(capability);\n+    return getMatchingRequests(priority, resourceName, executionType,\n+        profileCapability);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n      Priority priority, String resourceName, ExecutionType executionType,\n      Resource capability) {\n    ProfileCapability profileCapability \u003d\n        ProfileCapability.newInstance(capability);\n    return getMatchingRequests(priority, resourceName, executionType,\n        profileCapability);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "44fdf009642ae4e99b15f89ec0ca43834f991ef3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5753. fix NPE in AMRMClientImpl.getMatchingRequests() (haibochen via rkanter)\n",
      "commitDate": "25/10/16 11:59 PM",
      "commitName": "44fdf009642ae4e99b15f89ec0ca43834f991ef3",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "30/09/16 1:30 PM",
      "commitNameOld": "2549ee9d4c4ddd3ebccdebb8623df30c0a8f27d2",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 25.44,
      "commitsBetweenForRepo": 184,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,29 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n       Priority priority, String resourceName, ExecutionType executionType,\n       Resource capability) {\n     Preconditions.checkArgument(capability !\u003d null,\n         \"The Resource to be requested should not be null \");\n     Preconditions.checkArgument(priority !\u003d null,\n         \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n \n     RemoteRequestsTable remoteRequestsTable \u003d getTable(0);\n-    List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n-        remoteRequestsTable.getMatchingRequests(priority, resourceName,\n-            executionType, capability);\n-    // If no exact match. Container may be larger than what was requested.\n-    // get all resources \u003c\u003d capability. map is reverse sorted.\n-    for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n-      if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n-        !resReqInfo.containerRequests.isEmpty()) {\n-        list.add(resReqInfo.containerRequests);\n+\n+    if (null !\u003d remoteRequestsTable) {\n+      List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n+          remoteRequestsTable.getMatchingRequests(priority, resourceName,\n+              executionType, capability);\n+      if (null !\u003d matchingRequests) {\n+        // If no exact match. Container may be larger than what was requested.\n+        // get all resources \u003c\u003d capability. map is reverse sorted.\n+        for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n+          if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n+              !resReqInfo.containerRequests.isEmpty()) {\n+            list.add(resReqInfo.containerRequests);\n+          }\n+        }\n       }\n     }\n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n      Priority priority, String resourceName, ExecutionType executionType,\n      Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n\n    RemoteRequestsTable remoteRequestsTable \u003d getTable(0);\n\n    if (null !\u003d remoteRequestsTable) {\n      List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n          remoteRequestsTable.getMatchingRequests(priority, resourceName,\n              executionType, capability);\n      if (null !\u003d matchingRequests) {\n        // If no exact match. Container may be larger than what was requested.\n        // get all resources \u003c\u003d capability. map is reverse sorted.\n        for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n          if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n              !resReqInfo.containerRequests.isEmpty()) {\n            list.add(resReqInfo.containerRequests);\n          }\n        }\n      }\n    }\n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "19c743c1bbcaf3df8f1d63e557143c960a538c42": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4889. Changes in AMRMClient for identifying resource-requests explicitly. (Arun Suresh via wangda)\n",
      "commitDate": "26/08/16 5:14 PM",
      "commitName": "19c743c1bbcaf3df8f1d63e557143c960a538c42",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/06/16 9:42 AM",
      "commitNameOld": "51432779588fdd741b4840601f5db637ec783d92",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 75.31,
      "commitsBetweenForRepo": 650,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n       Priority priority, String resourceName, ExecutionType executionType,\n       Resource capability) {\n     Preconditions.checkArgument(capability !\u003d null,\n         \"The Resource to be requested should not be null \");\n     Preconditions.checkArgument(priority !\u003d null,\n         \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n \n-    @SuppressWarnings(\"unchecked\")\n+    RemoteRequestsTable remoteRequestsTable \u003d getTable(0);\n     List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n-        this.remoteRequestsTable.getMatchingRequests(priority, resourceName,\n+        remoteRequestsTable.getMatchingRequests(priority, resourceName,\n             executionType, capability);\n     // If no exact match. Container may be larger than what was requested.\n     // get all resources \u003c\u003d capability. map is reverse sorted.\n     for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n       if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n         !resReqInfo.containerRequests.isEmpty()) {\n         list.add(resReqInfo.containerRequests);\n       }\n     }\n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n      Priority priority, String resourceName, ExecutionType executionType,\n      Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n\n    RemoteRequestsTable remoteRequestsTable \u003d getTable(0);\n    List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n        remoteRequestsTable.getMatchingRequests(priority, resourceName,\n            executionType, capability);\n    // If no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted.\n    for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n      if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n        !resReqInfo.containerRequests.isEmpty()) {\n        list.add(resReqInfo.containerRequests);\n      }\n    }\n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "51432779588fdd741b4840601f5db637ec783d92": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5124. Modify AMRMClient to set the ExecutionType in the ResourceRequest. (asuresh)\n",
      "commitDate": "12/06/16 9:42 AM",
      "commitName": "51432779588fdd741b4840601f5db637ec783d92",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5124. Modify AMRMClient to set the ExecutionType in the ResourceRequest. (asuresh)\n",
          "commitDate": "12/06/16 9:42 AM",
          "commitName": "51432779588fdd741b4840601f5db637ec783d92",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "29/05/16 8:54 AM",
          "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 14.03,
          "commitsBetweenForRepo": 85,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,24 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n-                                          Priority priority, \n-                                          String resourceName, \n-                                          Resource capability) {\n+      Priority priority, String resourceName, ExecutionType executionType,\n+      Resource capability) {\n     Preconditions.checkArgument(capability !\u003d null,\n         \"The Resource to be requested should not be null \");\n     Preconditions.checkArgument(priority !\u003d null,\n         \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n-    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n-        this.remoteRequestsTable.get(priority);\n-    if (remoteRequests \u003d\u003d null) {\n-      return list;\n-    }\n-    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n-        .get(resourceName);\n-    if (reqMap \u003d\u003d null) {\n-      return list;\n-    }\n \n-    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n-    if (resourceRequestInfo !\u003d null \u0026\u0026\n-        !resourceRequestInfo.containerRequests.isEmpty()) {\n-      list.add(resourceRequestInfo.containerRequests);\n-      return list;\n-    }\n-    \n-    // no exact match. Container may be larger than what was requested.\n-    // get all resources \u003c\u003d capability. map is reverse sorted. \n-    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n-                                                  reqMap.tailMap(capability);\n-    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n-      if (canFit(entry.getKey(), capability) \u0026\u0026\n-          !entry.getValue().containerRequests.isEmpty()) {\n-        // match found that fits in the larger resource\n-        list.add(entry.getValue().containerRequests);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n+        this.remoteRequestsTable.getMatchingRequests(priority, resourceName,\n+            executionType, capability);\n+    // If no exact match. Container may be larger than what was requested.\n+    // get all resources \u003c\u003d capability. map is reverse sorted.\n+    for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n+      if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n+        !resReqInfo.containerRequests.isEmpty()) {\n+        list.add(resReqInfo.containerRequests);\n       }\n     }\n-    \n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n      Priority priority, String resourceName, ExecutionType executionType,\n      Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n\n    @SuppressWarnings(\"unchecked\")\n    List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n        this.remoteRequestsTable.getMatchingRequests(priority, resourceName,\n            executionType, capability);\n    // If no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted.\n    for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n      if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n        !resReqInfo.containerRequests.isEmpty()) {\n        list.add(resReqInfo.containerRequests);\n      }\n    }\n    // no match found\n    return list;          \n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
          "extendedDetails": {
            "oldValue": "[priority-Priority, resourceName-String, capability-Resource]",
            "newValue": "[priority-Priority, resourceName-String, executionType-ExecutionType, capability-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5124. Modify AMRMClient to set the ExecutionType in the ResourceRequest. (asuresh)\n",
          "commitDate": "12/06/16 9:42 AM",
          "commitName": "51432779588fdd741b4840601f5db637ec783d92",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "29/05/16 8:54 AM",
          "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 14.03,
          "commitsBetweenForRepo": 85,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,24 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n-                                          Priority priority, \n-                                          String resourceName, \n-                                          Resource capability) {\n+      Priority priority, String resourceName, ExecutionType executionType,\n+      Resource capability) {\n     Preconditions.checkArgument(capability !\u003d null,\n         \"The Resource to be requested should not be null \");\n     Preconditions.checkArgument(priority !\u003d null,\n         \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n-    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n-        this.remoteRequestsTable.get(priority);\n-    if (remoteRequests \u003d\u003d null) {\n-      return list;\n-    }\n-    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n-        .get(resourceName);\n-    if (reqMap \u003d\u003d null) {\n-      return list;\n-    }\n \n-    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n-    if (resourceRequestInfo !\u003d null \u0026\u0026\n-        !resourceRequestInfo.containerRequests.isEmpty()) {\n-      list.add(resourceRequestInfo.containerRequests);\n-      return list;\n-    }\n-    \n-    // no exact match. Container may be larger than what was requested.\n-    // get all resources \u003c\u003d capability. map is reverse sorted. \n-    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n-                                                  reqMap.tailMap(capability);\n-    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n-      if (canFit(entry.getKey(), capability) \u0026\u0026\n-          !entry.getValue().containerRequests.isEmpty()) {\n-        // match found that fits in the larger resource\n-        list.add(entry.getValue().containerRequests);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n+        this.remoteRequestsTable.getMatchingRequests(priority, resourceName,\n+            executionType, capability);\n+    // If no exact match. Container may be larger than what was requested.\n+    // get all resources \u003c\u003d capability. map is reverse sorted.\n+    for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n+      if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n+        !resReqInfo.containerRequests.isEmpty()) {\n+        list.add(resReqInfo.containerRequests);\n       }\n     }\n-    \n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n      Priority priority, String resourceName, ExecutionType executionType,\n      Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n\n    @SuppressWarnings(\"unchecked\")\n    List\u003cResourceRequestInfo\u003cT\u003e\u003e matchingRequests \u003d\n        this.remoteRequestsTable.getMatchingRequests(priority, resourceName,\n            executionType, capability);\n    // If no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted.\n    for (ResourceRequestInfo\u003cT\u003e resReqInfo : matchingRequests) {\n      if (canFit(resReqInfo.remoteRequest.getCapability(), capability) \u0026\u0026\n        !resReqInfo.containerRequests.isEmpty()) {\n        list.add(resReqInfo.containerRequests);\n      }\n    }\n    // no match found\n    return list;          \n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "1fe8e2d7eed74453cfe172853881fafc360a10b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-521. Augment AM - RM client module to be able to request containers only at specific locations (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503526 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/13 5:23 PM",
      "commitName": "1fe8e2d7eed74453cfe172853881fafc360a10b6",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "15/07/13 10:13 AM",
      "commitNameOld": "fe735f237c735a375d2bd194ed80ef9949fb1a68",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,42 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                           Priority priority, \n                                           String resourceName, \n                                           Resource capability) {\n     Preconditions.checkArgument(capability !\u003d null,\n         \"The Resource to be requested should not be null \");\n     Preconditions.checkArgument(priority !\u003d null,\n         \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n     Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n         this.remoteRequestsTable.get(priority);\n     if (remoteRequests \u003d\u003d null) {\n       return list;\n     }\n     TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n         .get(resourceName);\n     if (reqMap \u003d\u003d null) {\n       return list;\n     }\n \n     ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n-    if (resourceRequestInfo !\u003d null) {\n+    if (resourceRequestInfo !\u003d null \u0026\u0026\n+        !resourceRequestInfo.containerRequests.isEmpty()) {\n       list.add(resourceRequestInfo.containerRequests);\n       return list;\n     }\n     \n     // no exact match. Container may be larger than what was requested.\n     // get all resources \u003c\u003d capability. map is reverse sorted. \n     SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                   reqMap.tailMap(capability);\n     for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n-      if(canFit(entry.getKey(), capability)) {\n+      if (canFit(entry.getKey(), capability) \u0026\u0026\n+          !entry.getValue().containerRequests.isEmpty()) {\n         // match found that fits in the larger resource\n         list.add(entry.getValue().containerRequests);\n       }\n     }\n     \n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null \u0026\u0026\n        !resourceRequestInfo.containerRequests.isEmpty()) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if (canFit(entry.getKey(), capability) \u0026\u0026\n          !entry.getValue().containerRequests.isEmpty()) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "fe735f237c735a375d2bd194ed80ef9949fb1a68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-654. AMRMClient: Perform sanity checks for parameters of public methods (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/13 10:13 AM",
      "commitName": "fe735f237c735a375d2bd194ed80ef9949fb1a68",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "13/07/13 3:31 PM",
      "commitNameOld": "2adee634269588b85c351e8a3bd2c0c26ad2ba1b",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,40 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                           Priority priority, \n                                           String resourceName, \n                                           Resource capability) {\n+    Preconditions.checkArgument(capability !\u003d null,\n+        \"The Resource to be requested should not be null \");\n+    Preconditions.checkArgument(priority !\u003d null,\n+        \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n     Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n         this.remoteRequestsTable.get(priority);\n     if (remoteRequests \u003d\u003d null) {\n       return list;\n     }\n     TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n         .get(resourceName);\n     if (reqMap \u003d\u003d null) {\n       return list;\n     }\n \n     ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n     if (resourceRequestInfo !\u003d null) {\n       list.add(resourceRequestInfo.containerRequests);\n       return list;\n     }\n     \n     // no exact match. Container may be larger than what was requested.\n     // get all resources \u003c\u003d capability. map is reverse sorted. \n     SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                   reqMap.tailMap(capability);\n     for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n       if(canFit(entry.getKey(), capability)) {\n         // match found that fits in the larger resource\n         list.add(entry.getValue().containerRequests);\n       }\n     }\n     \n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if(canFit(entry.getKey(), capability)) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": {
      "type": "Yfilerename",
      "commitMessage": "YARN-834. Fixed annotations for yarn-client module, reorganized packages and clearly differentiated *Async apis. Contributed by Arun C Murthy and Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494017 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 9:02 PM",
      "commitName": "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 8:10 PM",
      "commitNameOld": "2b14656ab5050dd75935b64681cdc25fb49db94f",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if(canFit(entry.getKey(), capability)) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java"
      }
    },
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-660. Improve AMRMClient with matching requests (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488485 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 1:23 AM",
      "commitName": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthor": "Bikas Saha",
      "diff": "@@ -0,0 +1,36 @@\n+  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n+                                          Priority priority, \n+                                          String resourceName, \n+                                          Resource capability) {\n+    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n+    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n+        this.remoteRequestsTable.get(priority);\n+    if (remoteRequests \u003d\u003d null) {\n+      return list;\n+    }\n+    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n+        .get(resourceName);\n+    if (reqMap \u003d\u003d null) {\n+      return list;\n+    }\n+\n+    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n+    if (resourceRequestInfo !\u003d null) {\n+      list.add(resourceRequestInfo.containerRequests);\n+      return list;\n+    }\n+    \n+    // no exact match. Container may be larger than what was requested.\n+    // get all resources \u003c\u003d capability. map is reverse sorted. \n+    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n+                                                  reqMap.tailMap(capability);\n+    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n+      if(canFit(entry.getKey(), capability)) {\n+        // match found that fits in the larger resource\n+        list.add(entry.getValue().containerRequests);\n+      }\n+    }\n+    \n+    // no match found\n+    return list;          \n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if(canFit(entry.getKey(), capability)) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java"
    }
  }
}