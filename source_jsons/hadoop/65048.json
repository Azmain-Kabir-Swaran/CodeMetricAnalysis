{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StagingCommitter.java",
  "functionName": "commitTaskInternal",
  "functionId": "commitTaskInternal___context-TaskAttemptContext(modifiers-final)__taskOutput-List__? extends FileStatus__",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/staging/StagingCommitter.java",
  "functionStartLine": 665,
  "functionEndLine": 761,
  "numCommitsSeen": 9,
  "timeTaken": 3254,
  "changeHistory": [
    "c77fc6971b5194c9dae184703caa87da271a85eb",
    "6574f27fa348542411bff888b184cd7ce34e5d9e",
    "f44abc3e11676579bdea94fce045d081ae38e6c3",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c"
  ],
  "changeHistoryShort": {
    "c77fc6971b5194c9dae184703caa87da271a85eb": "Ybodychange",
    "6574f27fa348542411bff888b184cd7ce34e5d9e": "Ybodychange",
    "f44abc3e11676579bdea94fce045d081ae38e6c3": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c77fc6971b5194c9dae184703caa87da271a85eb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15961. S3A committers: make sure there\u0027s regular progress() calls.\n\nContributed by lqjacklee.\n\nChange-Id: I13ca153e1e32b21dbe64d6fb25e260e0ff66154d\n",
      "commitDate": "17/02/20 2:06 PM",
      "commitName": "c77fc6971b5194c9dae184703caa87da271a85eb",
      "commitAuthor": "lqjacklee",
      "commitDateOld": "04/10/19 10:54 AM",
      "commitNameOld": "6574f27fa348542411bff888b184cd7ce34e5d9e",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 136.18,
      "commitsBetweenForRepo": 487,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,97 @@\n   protected int commitTaskInternal(final TaskAttemptContext context,\n       List\u003c? extends FileStatus\u003e taskOutput)\n       throws IOException {\n     LOG.debug(\"{}: commitTaskInternal\", getRole());\n     Configuration conf \u003d context.getConfiguration();\n \n     final Path attemptPath \u003d getTaskAttemptPath(context);\n     FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n     LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n \n     // add the commits file to the wrapped committer\u0027s task attempt location.\n     // of this method.\n     Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n     FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n \n     // keep track of unfinished commits in case one fails. if something fails,\n     // we will try to abort the ones that had already succeeded.\n     int commitCount \u003d taskOutput.size();\n     final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n     LOG.info(\"{}: uploading from staging directory to S3 {}\", getRole(),\n         attemptPath);\n     LOG.info(\"{}: Saving pending data information to {}\",\n         getRole(), commitsAttemptPath);\n     if (taskOutput.isEmpty()) {\n       // there is nothing to write. needsTaskCommit() should have caught\n       // this, so warn that there is some kind of problem in the protocol.\n       LOG.warn(\"{}: No files to commit\", getRole());\n     } else {\n       boolean threw \u003d true;\n       // before the uploads, report some progress\n       context.progress();\n \n       PendingSet pendingCommits \u003d new PendingSet(commitCount);\n       try {\n         Tasks.foreach(taskOutput)\n             .stopOnFailure()\n             .suppressExceptions(false)\n             .executeWith(buildThreadPool(context))\n             .run(stat -\u003e {\n               Path path \u003d stat.getPath();\n               File localFile \u003d new File(path.toUri().getPath());\n               String relative \u003d Paths.getRelativePath(attemptPath, path);\n               String partition \u003d Paths.getPartition(relative);\n               String key \u003d getFinalKey(relative, context);\n               Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n               SinglePendingCommit commit \u003d getCommitOperations()\n                   .uploadFileToPendingCommit(\n                       localFile,\n                       destPath,\n                       partition,\n-                      uploadPartSize);\n+                      uploadPartSize,\n+                      context);\n               LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n               commits.add(commit);\n             });\n \n         for (SinglePendingCommit commit : commits) {\n           pendingCommits.add(commit);\n         }\n \n         // save the data\n         // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n         // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n \n         LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n             pendingCommits.size(),\n             commitsAttemptPath);\n         pendingCommits.save(commitsFS, commitsAttemptPath, false);\n         threw \u003d false;\n \n       } finally {\n         if (threw) {\n           LOG.error(\n               \"{}: Exception during commit process, aborting {} commit(s)\",\n               getRole(), commits.size());\n           try(CommitOperations.CommitContext commitContext\n                   \u003d initiateCommitOperation();\n               DurationInfo ignored \u003d new DurationInfo(LOG,\n                   \"Aborting %s uploads\", commits.size())) {\n             Tasks.foreach(commits)\n                 .suppressExceptions()\n                 .run(commitContext::abortSingleCommit);\n           }\n           deleteTaskAttemptPathQuietly(context);\n         }\n       }\n       // always purge attempt information at this point.\n       Paths.clearTempFolderInfo(context.getTaskAttemptID());\n     }\n \n     LOG.debug(\"Committing wrapped task\");\n     wrappedCommitter.commitTask(context);\n \n     LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n     attemptFS.delete(attemptPath, true);\n     return commits.size();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected int commitTaskInternal(final TaskAttemptContext context,\n      List\u003c? extends FileStatus\u003e taskOutput)\n      throws IOException {\n    LOG.debug(\"{}: commitTaskInternal\", getRole());\n    Configuration conf \u003d context.getConfiguration();\n\n    final Path attemptPath \u003d getTaskAttemptPath(context);\n    FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n    LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n\n    // add the commits file to the wrapped committer\u0027s task attempt location.\n    // of this method.\n    Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n    FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n\n    // keep track of unfinished commits in case one fails. if something fails,\n    // we will try to abort the ones that had already succeeded.\n    int commitCount \u003d taskOutput.size();\n    final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n    LOG.info(\"{}: uploading from staging directory to S3 {}\", getRole(),\n        attemptPath);\n    LOG.info(\"{}: Saving pending data information to {}\",\n        getRole(), commitsAttemptPath);\n    if (taskOutput.isEmpty()) {\n      // there is nothing to write. needsTaskCommit() should have caught\n      // this, so warn that there is some kind of problem in the protocol.\n      LOG.warn(\"{}: No files to commit\", getRole());\n    } else {\n      boolean threw \u003d true;\n      // before the uploads, report some progress\n      context.progress();\n\n      PendingSet pendingCommits \u003d new PendingSet(commitCount);\n      try {\n        Tasks.foreach(taskOutput)\n            .stopOnFailure()\n            .suppressExceptions(false)\n            .executeWith(buildThreadPool(context))\n            .run(stat -\u003e {\n              Path path \u003d stat.getPath();\n              File localFile \u003d new File(path.toUri().getPath());\n              String relative \u003d Paths.getRelativePath(attemptPath, path);\n              String partition \u003d Paths.getPartition(relative);\n              String key \u003d getFinalKey(relative, context);\n              Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n              SinglePendingCommit commit \u003d getCommitOperations()\n                  .uploadFileToPendingCommit(\n                      localFile,\n                      destPath,\n                      partition,\n                      uploadPartSize,\n                      context);\n              LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n              commits.add(commit);\n            });\n\n        for (SinglePendingCommit commit : commits) {\n          pendingCommits.add(commit);\n        }\n\n        // save the data\n        // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n        // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n\n        LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n            pendingCommits.size(),\n            commitsAttemptPath);\n        pendingCommits.save(commitsFS, commitsAttemptPath, false);\n        threw \u003d false;\n\n      } finally {\n        if (threw) {\n          LOG.error(\n              \"{}: Exception during commit process, aborting {} commit(s)\",\n              getRole(), commits.size());\n          try(CommitOperations.CommitContext commitContext\n                  \u003d initiateCommitOperation();\n              DurationInfo ignored \u003d new DurationInfo(LOG,\n                  \"Aborting %s uploads\", commits.size())) {\n            Tasks.foreach(commits)\n                .suppressExceptions()\n                .run(commitContext::abortSingleCommit);\n          }\n          deleteTaskAttemptPathQuietly(context);\n        }\n      }\n      // always purge attempt information at this point.\n      Paths.clearTempFolderInfo(context.getTaskAttemptID());\n    }\n\n    LOG.debug(\"Committing wrapped task\");\n    wrappedCommitter.commitTask(context);\n\n    LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n    attemptFS.delete(attemptPath, true);\n    return commits.size();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/staging/StagingCommitter.java",
      "extendedDetails": {}
    },
    "6574f27fa348542411bff888b184cd7ce34e5d9e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16570. S3A committers encounter scale issues.\n\nContributed by Steve Loughran.\n\nThis addresses two scale issues which has surfaced in large scale benchmarks\nof the S3A Committers.\n\n* Thread pools are not cleaned up.\n  This now happens, with tests.\n\n* OOM on job commit for jobs with many thousands of tasks,\n  each generating tens of (very large) files.\n\nInstead of loading all pending commits into memory as a single list, the list\nof files to load is the sole list which is passed around; .pendingset files are\nloaded and processed in isolation -and reloaded if necessary for any\nabort/rollback operation.\n\nThe parallel commit/abort/revert operations now work at the .pendingset level,\nrather than that of individual pending commit files. The existing parallelized\nTasks API is still used to commit those files, but with a null thread pool, so\nas to serialize the operations.\n\nChange-Id: I5c8240cd31800eaa83d112358770ca0eb2bca797\n",
      "commitDate": "04/10/19 10:54 AM",
      "commitName": "6574f27fa348542411bff888b184cd7ce34e5d9e",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "04/10/19 6:12 AM",
      "commitNameOld": "f44abc3e11676579bdea94fce045d081ae38e6c3",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,96 @@\n   protected int commitTaskInternal(final TaskAttemptContext context,\n       List\u003c? extends FileStatus\u003e taskOutput)\n       throws IOException {\n     LOG.debug(\"{}: commitTaskInternal\", getRole());\n     Configuration conf \u003d context.getConfiguration();\n \n     final Path attemptPath \u003d getTaskAttemptPath(context);\n     FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n     LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n \n     // add the commits file to the wrapped committer\u0027s task attempt location.\n     // of this method.\n     Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n     FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n \n     // keep track of unfinished commits in case one fails. if something fails,\n     // we will try to abort the ones that had already succeeded.\n     int commitCount \u003d taskOutput.size();\n     final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n     LOG.info(\"{}: uploading from staging directory to S3 {}\", getRole(),\n         attemptPath);\n     LOG.info(\"{}: Saving pending data information to {}\",\n         getRole(), commitsAttemptPath);\n     if (taskOutput.isEmpty()) {\n       // there is nothing to write. needsTaskCommit() should have caught\n       // this, so warn that there is some kind of problem in the protocol.\n       LOG.warn(\"{}: No files to commit\", getRole());\n     } else {\n       boolean threw \u003d true;\n       // before the uploads, report some progress\n       context.progress();\n \n       PendingSet pendingCommits \u003d new PendingSet(commitCount);\n       try {\n         Tasks.foreach(taskOutput)\n             .stopOnFailure()\n+            .suppressExceptions(false)\n             .executeWith(buildThreadPool(context))\n             .run(stat -\u003e {\n               Path path \u003d stat.getPath();\n               File localFile \u003d new File(path.toUri().getPath());\n               String relative \u003d Paths.getRelativePath(attemptPath, path);\n               String partition \u003d Paths.getPartition(relative);\n               String key \u003d getFinalKey(relative, context);\n               Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n               SinglePendingCommit commit \u003d getCommitOperations()\n                   .uploadFileToPendingCommit(\n                       localFile,\n                       destPath,\n                       partition,\n                       uploadPartSize);\n               LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n               commits.add(commit);\n             });\n \n         for (SinglePendingCommit commit : commits) {\n           pendingCommits.add(commit);\n         }\n \n         // save the data\n         // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n         // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n \n         LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n             pendingCommits.size(),\n             commitsAttemptPath);\n         pendingCommits.save(commitsFS, commitsAttemptPath, false);\n         threw \u003d false;\n \n       } finally {\n         if (threw) {\n           LOG.error(\n               \"{}: Exception during commit process, aborting {} commit(s)\",\n               getRole(), commits.size());\n           try(CommitOperations.CommitContext commitContext\n                   \u003d initiateCommitOperation();\n               DurationInfo ignored \u003d new DurationInfo(LOG,\n                   \"Aborting %s uploads\", commits.size())) {\n             Tasks.foreach(commits)\n                 .suppressExceptions()\n                 .run(commitContext::abortSingleCommit);\n           }\n           deleteTaskAttemptPathQuietly(context);\n         }\n       }\n       // always purge attempt information at this point.\n       Paths.clearTempFolderInfo(context.getTaskAttemptID());\n     }\n \n     LOG.debug(\"Committing wrapped task\");\n     wrappedCommitter.commitTask(context);\n \n     LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n     attemptFS.delete(attemptPath, true);\n     return commits.size();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected int commitTaskInternal(final TaskAttemptContext context,\n      List\u003c? extends FileStatus\u003e taskOutput)\n      throws IOException {\n    LOG.debug(\"{}: commitTaskInternal\", getRole());\n    Configuration conf \u003d context.getConfiguration();\n\n    final Path attemptPath \u003d getTaskAttemptPath(context);\n    FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n    LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n\n    // add the commits file to the wrapped committer\u0027s task attempt location.\n    // of this method.\n    Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n    FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n\n    // keep track of unfinished commits in case one fails. if something fails,\n    // we will try to abort the ones that had already succeeded.\n    int commitCount \u003d taskOutput.size();\n    final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n    LOG.info(\"{}: uploading from staging directory to S3 {}\", getRole(),\n        attemptPath);\n    LOG.info(\"{}: Saving pending data information to {}\",\n        getRole(), commitsAttemptPath);\n    if (taskOutput.isEmpty()) {\n      // there is nothing to write. needsTaskCommit() should have caught\n      // this, so warn that there is some kind of problem in the protocol.\n      LOG.warn(\"{}: No files to commit\", getRole());\n    } else {\n      boolean threw \u003d true;\n      // before the uploads, report some progress\n      context.progress();\n\n      PendingSet pendingCommits \u003d new PendingSet(commitCount);\n      try {\n        Tasks.foreach(taskOutput)\n            .stopOnFailure()\n            .suppressExceptions(false)\n            .executeWith(buildThreadPool(context))\n            .run(stat -\u003e {\n              Path path \u003d stat.getPath();\n              File localFile \u003d new File(path.toUri().getPath());\n              String relative \u003d Paths.getRelativePath(attemptPath, path);\n              String partition \u003d Paths.getPartition(relative);\n              String key \u003d getFinalKey(relative, context);\n              Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n              SinglePendingCommit commit \u003d getCommitOperations()\n                  .uploadFileToPendingCommit(\n                      localFile,\n                      destPath,\n                      partition,\n                      uploadPartSize);\n              LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n              commits.add(commit);\n            });\n\n        for (SinglePendingCommit commit : commits) {\n          pendingCommits.add(commit);\n        }\n\n        // save the data\n        // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n        // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n\n        LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n            pendingCommits.size(),\n            commitsAttemptPath);\n        pendingCommits.save(commitsFS, commitsAttemptPath, false);\n        threw \u003d false;\n\n      } finally {\n        if (threw) {\n          LOG.error(\n              \"{}: Exception during commit process, aborting {} commit(s)\",\n              getRole(), commits.size());\n          try(CommitOperations.CommitContext commitContext\n                  \u003d initiateCommitOperation();\n              DurationInfo ignored \u003d new DurationInfo(LOG,\n                  \"Aborting %s uploads\", commits.size())) {\n            Tasks.foreach(commits)\n                .suppressExceptions()\n                .run(commitContext::abortSingleCommit);\n          }\n          deleteTaskAttemptPathQuietly(context);\n        }\n      }\n      // always purge attempt information at this point.\n      Paths.clearTempFolderInfo(context.getTaskAttemptID());\n    }\n\n    LOG.debug(\"Committing wrapped task\");\n    wrappedCommitter.commitTask(context);\n\n    LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n    attemptFS.delete(attemptPath, true);\n    return commits.size();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/staging/StagingCommitter.java",
      "extendedDetails": {}
    },
    "f44abc3e11676579bdea94fce045d081ae38e6c3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16207 Improved S3A MR tests.\n\nContributed by Steve Loughran.\n\nReplaces the committer-specific terasort and MR test jobs with parameterization\nof the (now single tests) and use of file:// over hdfs:// as the cluster FS.\n\nThe parameterization ensures that only one of the specific committer tests\nrun at a time -overloads of the test machines are less likely, and so the\nsuites can be pulled back into the parallel phase.\n\nThere\u0027s also more detailed validation of the stage outputs of the terasorting;\nif one test fails the rest are all skipped. This and the fact that job\noutput is stored under target/yarn-${timestamp} means failures should\nbe more debuggable.\n\nChange-Id: Iefa370ba73c6419496e6e69dd6673d00f37ff095\n",
      "commitDate": "04/10/19 6:12 AM",
      "commitName": "f44abc3e11676579bdea94fce045d081ae38e6c3",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "11/07/19 10:15 AM",
      "commitNameOld": "6a3433bffdbdefc5aa66705085bcf6fa089721b2",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 84.83,
      "commitsBetweenForRepo": 760,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,95 @@\n   protected int commitTaskInternal(final TaskAttemptContext context,\n       List\u003c? extends FileStatus\u003e taskOutput)\n       throws IOException {\n     LOG.debug(\"{}: commitTaskInternal\", getRole());\n     Configuration conf \u003d context.getConfiguration();\n \n     final Path attemptPath \u003d getTaskAttemptPath(context);\n     FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n     LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n \n     // add the commits file to the wrapped committer\u0027s task attempt location.\n     // of this method.\n     Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n     FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n \n     // keep track of unfinished commits in case one fails. if something fails,\n     // we will try to abort the ones that had already succeeded.\n     int commitCount \u003d taskOutput.size();\n     final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n-    LOG.info(\"{}: uploading from staging directory to S3\", getRole());\n+    LOG.info(\"{}: uploading from staging directory to S3 {}\", getRole(),\n+        attemptPath);\n     LOG.info(\"{}: Saving pending data information to {}\",\n         getRole(), commitsAttemptPath);\n     if (taskOutput.isEmpty()) {\n       // there is nothing to write. needsTaskCommit() should have caught\n       // this, so warn that there is some kind of problem in the protocol.\n       LOG.warn(\"{}: No files to commit\", getRole());\n     } else {\n       boolean threw \u003d true;\n       // before the uploads, report some progress\n       context.progress();\n \n       PendingSet pendingCommits \u003d new PendingSet(commitCount);\n       try {\n         Tasks.foreach(taskOutput)\n             .stopOnFailure()\n             .executeWith(buildThreadPool(context))\n             .run(stat -\u003e {\n               Path path \u003d stat.getPath();\n               File localFile \u003d new File(path.toUri().getPath());\n               String relative \u003d Paths.getRelativePath(attemptPath, path);\n               String partition \u003d Paths.getPartition(relative);\n               String key \u003d getFinalKey(relative, context);\n               Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n               SinglePendingCommit commit \u003d getCommitOperations()\n                   .uploadFileToPendingCommit(\n                       localFile,\n                       destPath,\n                       partition,\n                       uploadPartSize);\n               LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n               commits.add(commit);\n             });\n \n         for (SinglePendingCommit commit : commits) {\n           pendingCommits.add(commit);\n         }\n \n         // save the data\n         // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n         // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n \n         LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n             pendingCommits.size(),\n             commitsAttemptPath);\n         pendingCommits.save(commitsFS, commitsAttemptPath, false);\n         threw \u003d false;\n \n       } finally {\n         if (threw) {\n           LOG.error(\n               \"{}: Exception during commit process, aborting {} commit(s)\",\n               getRole(), commits.size());\n           try(CommitOperations.CommitContext commitContext\n                   \u003d initiateCommitOperation();\n               DurationInfo ignored \u003d new DurationInfo(LOG,\n                   \"Aborting %s uploads\", commits.size())) {\n             Tasks.foreach(commits)\n                 .suppressExceptions()\n                 .run(commitContext::abortSingleCommit);\n           }\n           deleteTaskAttemptPathQuietly(context);\n         }\n       }\n       // always purge attempt information at this point.\n       Paths.clearTempFolderInfo(context.getTaskAttemptID());\n     }\n \n     LOG.debug(\"Committing wrapped task\");\n     wrappedCommitter.commitTask(context);\n \n     LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n     attemptFS.delete(attemptPath, true);\n     return commits.size();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected int commitTaskInternal(final TaskAttemptContext context,\n      List\u003c? extends FileStatus\u003e taskOutput)\n      throws IOException {\n    LOG.debug(\"{}: commitTaskInternal\", getRole());\n    Configuration conf \u003d context.getConfiguration();\n\n    final Path attemptPath \u003d getTaskAttemptPath(context);\n    FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n    LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n\n    // add the commits file to the wrapped committer\u0027s task attempt location.\n    // of this method.\n    Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n    FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n\n    // keep track of unfinished commits in case one fails. if something fails,\n    // we will try to abort the ones that had already succeeded.\n    int commitCount \u003d taskOutput.size();\n    final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n    LOG.info(\"{}: uploading from staging directory to S3 {}\", getRole(),\n        attemptPath);\n    LOG.info(\"{}: Saving pending data information to {}\",\n        getRole(), commitsAttemptPath);\n    if (taskOutput.isEmpty()) {\n      // there is nothing to write. needsTaskCommit() should have caught\n      // this, so warn that there is some kind of problem in the protocol.\n      LOG.warn(\"{}: No files to commit\", getRole());\n    } else {\n      boolean threw \u003d true;\n      // before the uploads, report some progress\n      context.progress();\n\n      PendingSet pendingCommits \u003d new PendingSet(commitCount);\n      try {\n        Tasks.foreach(taskOutput)\n            .stopOnFailure()\n            .executeWith(buildThreadPool(context))\n            .run(stat -\u003e {\n              Path path \u003d stat.getPath();\n              File localFile \u003d new File(path.toUri().getPath());\n              String relative \u003d Paths.getRelativePath(attemptPath, path);\n              String partition \u003d Paths.getPartition(relative);\n              String key \u003d getFinalKey(relative, context);\n              Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n              SinglePendingCommit commit \u003d getCommitOperations()\n                  .uploadFileToPendingCommit(\n                      localFile,\n                      destPath,\n                      partition,\n                      uploadPartSize);\n              LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n              commits.add(commit);\n            });\n\n        for (SinglePendingCommit commit : commits) {\n          pendingCommits.add(commit);\n        }\n\n        // save the data\n        // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n        // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n\n        LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n            pendingCommits.size(),\n            commitsAttemptPath);\n        pendingCommits.save(commitsFS, commitsAttemptPath, false);\n        threw \u003d false;\n\n      } finally {\n        if (threw) {\n          LOG.error(\n              \"{}: Exception during commit process, aborting {} commit(s)\",\n              getRole(), commits.size());\n          try(CommitOperations.CommitContext commitContext\n                  \u003d initiateCommitOperation();\n              DurationInfo ignored \u003d new DurationInfo(LOG,\n                  \"Aborting %s uploads\", commits.size())) {\n            Tasks.foreach(commits)\n                .suppressExceptions()\n                .run(commitContext::abortSingleCommit);\n          }\n          deleteTaskAttemptPathQuietly(context);\n        }\n      }\n      // always purge attempt information at this point.\n      Paths.clearTempFolderInfo(context.getTaskAttemptID());\n    }\n\n    LOG.debug(\"Committing wrapped task\");\n    wrappedCommitter.commitTask(context);\n\n    LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n    attemptFS.delete(attemptPath, true);\n    return commits.size();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/staging/StagingCommitter.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/02/19 9:10 AM",
      "commitNameOld": "52b2eab575d0b4d8ce7fa57661aaca6b8a123cc2",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 113.66,
      "commitsBetweenForRepo": 786,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,94 @@\n   protected int commitTaskInternal(final TaskAttemptContext context,\n       List\u003c? extends FileStatus\u003e taskOutput)\n       throws IOException {\n     LOG.debug(\"{}: commitTaskInternal\", getRole());\n     Configuration conf \u003d context.getConfiguration();\n \n     final Path attemptPath \u003d getTaskAttemptPath(context);\n     FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n     LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n \n     // add the commits file to the wrapped committer\u0027s task attempt location.\n     // of this method.\n     Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n     FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n \n     // keep track of unfinished commits in case one fails. if something fails,\n     // we will try to abort the ones that had already succeeded.\n     int commitCount \u003d taskOutput.size();\n     final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n     LOG.info(\"{}: uploading from staging directory to S3\", getRole());\n     LOG.info(\"{}: Saving pending data information to {}\",\n         getRole(), commitsAttemptPath);\n     if (taskOutput.isEmpty()) {\n       // there is nothing to write. needsTaskCommit() should have caught\n       // this, so warn that there is some kind of problem in the protocol.\n       LOG.warn(\"{}: No files to commit\", getRole());\n     } else {\n       boolean threw \u003d true;\n       // before the uploads, report some progress\n       context.progress();\n \n       PendingSet pendingCommits \u003d new PendingSet(commitCount);\n       try {\n         Tasks.foreach(taskOutput)\n             .stopOnFailure()\n             .executeWith(buildThreadPool(context))\n             .run(stat -\u003e {\n               Path path \u003d stat.getPath();\n               File localFile \u003d new File(path.toUri().getPath());\n               String relative \u003d Paths.getRelativePath(attemptPath, path);\n               String partition \u003d Paths.getPartition(relative);\n               String key \u003d getFinalKey(relative, context);\n               Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n               SinglePendingCommit commit \u003d getCommitOperations()\n                   .uploadFileToPendingCommit(\n                       localFile,\n                       destPath,\n                       partition,\n                       uploadPartSize);\n               LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n               commits.add(commit);\n             });\n \n         for (SinglePendingCommit commit : commits) {\n           pendingCommits.add(commit);\n         }\n \n         // save the data\n         // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n         // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n \n         LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n             pendingCommits.size(),\n             commitsAttemptPath);\n         pendingCommits.save(commitsFS, commitsAttemptPath, false);\n         threw \u003d false;\n \n       } finally {\n         if (threw) {\n           LOG.error(\n               \"{}: Exception during commit process, aborting {} commit(s)\",\n               getRole(), commits.size());\n-          Tasks.foreach(commits)\n-              .suppressExceptions()\n-              .run(commit -\u003e getCommitOperations().abortSingleCommit(commit));\n+          try(CommitOperations.CommitContext commitContext\n+                  \u003d initiateCommitOperation();\n+              DurationInfo ignored \u003d new DurationInfo(LOG,\n+                  \"Aborting %s uploads\", commits.size())) {\n+            Tasks.foreach(commits)\n+                .suppressExceptions()\n+                .run(commitContext::abortSingleCommit);\n+          }\n           deleteTaskAttemptPathQuietly(context);\n         }\n       }\n       // always purge attempt information at this point.\n       Paths.clearTempFolderInfo(context.getTaskAttemptID());\n     }\n \n     LOG.debug(\"Committing wrapped task\");\n     wrappedCommitter.commitTask(context);\n \n     LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n     attemptFS.delete(attemptPath, true);\n     return commits.size();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected int commitTaskInternal(final TaskAttemptContext context,\n      List\u003c? extends FileStatus\u003e taskOutput)\n      throws IOException {\n    LOG.debug(\"{}: commitTaskInternal\", getRole());\n    Configuration conf \u003d context.getConfiguration();\n\n    final Path attemptPath \u003d getTaskAttemptPath(context);\n    FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n    LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n\n    // add the commits file to the wrapped committer\u0027s task attempt location.\n    // of this method.\n    Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n    FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n\n    // keep track of unfinished commits in case one fails. if something fails,\n    // we will try to abort the ones that had already succeeded.\n    int commitCount \u003d taskOutput.size();\n    final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n    LOG.info(\"{}: uploading from staging directory to S3\", getRole());\n    LOG.info(\"{}: Saving pending data information to {}\",\n        getRole(), commitsAttemptPath);\n    if (taskOutput.isEmpty()) {\n      // there is nothing to write. needsTaskCommit() should have caught\n      // this, so warn that there is some kind of problem in the protocol.\n      LOG.warn(\"{}: No files to commit\", getRole());\n    } else {\n      boolean threw \u003d true;\n      // before the uploads, report some progress\n      context.progress();\n\n      PendingSet pendingCommits \u003d new PendingSet(commitCount);\n      try {\n        Tasks.foreach(taskOutput)\n            .stopOnFailure()\n            .executeWith(buildThreadPool(context))\n            .run(stat -\u003e {\n              Path path \u003d stat.getPath();\n              File localFile \u003d new File(path.toUri().getPath());\n              String relative \u003d Paths.getRelativePath(attemptPath, path);\n              String partition \u003d Paths.getPartition(relative);\n              String key \u003d getFinalKey(relative, context);\n              Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n              SinglePendingCommit commit \u003d getCommitOperations()\n                  .uploadFileToPendingCommit(\n                      localFile,\n                      destPath,\n                      partition,\n                      uploadPartSize);\n              LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n              commits.add(commit);\n            });\n\n        for (SinglePendingCommit commit : commits) {\n          pendingCommits.add(commit);\n        }\n\n        // save the data\n        // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n        // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n\n        LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n            pendingCommits.size(),\n            commitsAttemptPath);\n        pendingCommits.save(commitsFS, commitsAttemptPath, false);\n        threw \u003d false;\n\n      } finally {\n        if (threw) {\n          LOG.error(\n              \"{}: Exception during commit process, aborting {} commit(s)\",\n              getRole(), commits.size());\n          try(CommitOperations.CommitContext commitContext\n                  \u003d initiateCommitOperation();\n              DurationInfo ignored \u003d new DurationInfo(LOG,\n                  \"Aborting %s uploads\", commits.size())) {\n            Tasks.foreach(commits)\n                .suppressExceptions()\n                .run(commitContext::abortSingleCommit);\n          }\n          deleteTaskAttemptPathQuietly(context);\n        }\n      }\n      // always purge attempt information at this point.\n      Paths.clearTempFolderInfo(context.getTaskAttemptID());\n    }\n\n    LOG.debug(\"Committing wrapped task\");\n    wrappedCommitter.commitTask(context);\n\n    LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n    attemptFS.delete(attemptPath, true);\n    return commits.size();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/staging/StagingCommitter.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,89 @@\n+  protected int commitTaskInternal(final TaskAttemptContext context,\n+      List\u003c? extends FileStatus\u003e taskOutput)\n+      throws IOException {\n+    LOG.debug(\"{}: commitTaskInternal\", getRole());\n+    Configuration conf \u003d context.getConfiguration();\n+\n+    final Path attemptPath \u003d getTaskAttemptPath(context);\n+    FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n+    LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n+\n+    // add the commits file to the wrapped committer\u0027s task attempt location.\n+    // of this method.\n+    Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n+    FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n+\n+    // keep track of unfinished commits in case one fails. if something fails,\n+    // we will try to abort the ones that had already succeeded.\n+    int commitCount \u003d taskOutput.size();\n+    final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n+    LOG.info(\"{}: uploading from staging directory to S3\", getRole());\n+    LOG.info(\"{}: Saving pending data information to {}\",\n+        getRole(), commitsAttemptPath);\n+    if (taskOutput.isEmpty()) {\n+      // there is nothing to write. needsTaskCommit() should have caught\n+      // this, so warn that there is some kind of problem in the protocol.\n+      LOG.warn(\"{}: No files to commit\", getRole());\n+    } else {\n+      boolean threw \u003d true;\n+      // before the uploads, report some progress\n+      context.progress();\n+\n+      PendingSet pendingCommits \u003d new PendingSet(commitCount);\n+      try {\n+        Tasks.foreach(taskOutput)\n+            .stopOnFailure()\n+            .executeWith(buildThreadPool(context))\n+            .run(stat -\u003e {\n+              Path path \u003d stat.getPath();\n+              File localFile \u003d new File(path.toUri().getPath());\n+              String relative \u003d Paths.getRelativePath(attemptPath, path);\n+              String partition \u003d Paths.getPartition(relative);\n+              String key \u003d getFinalKey(relative, context);\n+              Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n+              SinglePendingCommit commit \u003d getCommitOperations()\n+                  .uploadFileToPendingCommit(\n+                      localFile,\n+                      destPath,\n+                      partition,\n+                      uploadPartSize);\n+              LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n+              commits.add(commit);\n+            });\n+\n+        for (SinglePendingCommit commit : commits) {\n+          pendingCommits.add(commit);\n+        }\n+\n+        // save the data\n+        // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n+        // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n+\n+        LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n+            pendingCommits.size(),\n+            commitsAttemptPath);\n+        pendingCommits.save(commitsFS, commitsAttemptPath, false);\n+        threw \u003d false;\n+\n+      } finally {\n+        if (threw) {\n+          LOG.error(\n+              \"{}: Exception during commit process, aborting {} commit(s)\",\n+              getRole(), commits.size());\n+          Tasks.foreach(commits)\n+              .suppressExceptions()\n+              .run(commit -\u003e getCommitOperations().abortSingleCommit(commit));\n+          deleteTaskAttemptPathQuietly(context);\n+        }\n+      }\n+      // always purge attempt information at this point.\n+      Paths.clearTempFolderInfo(context.getTaskAttemptID());\n+    }\n+\n+    LOG.debug(\"Committing wrapped task\");\n+    wrappedCommitter.commitTask(context);\n+\n+    LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n+    attemptFS.delete(attemptPath, true);\n+    return commits.size();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected int commitTaskInternal(final TaskAttemptContext context,\n      List\u003c? extends FileStatus\u003e taskOutput)\n      throws IOException {\n    LOG.debug(\"{}: commitTaskInternal\", getRole());\n    Configuration conf \u003d context.getConfiguration();\n\n    final Path attemptPath \u003d getTaskAttemptPath(context);\n    FileSystem attemptFS \u003d getTaskAttemptFilesystem(context);\n    LOG.debug(\"{}: attempt path is {}\", getRole(), attemptPath);\n\n    // add the commits file to the wrapped committer\u0027s task attempt location.\n    // of this method.\n    Path commitsAttemptPath \u003d wrappedCommitter.getTaskAttemptPath(context);\n    FileSystem commitsFS \u003d commitsAttemptPath.getFileSystem(conf);\n\n    // keep track of unfinished commits in case one fails. if something fails,\n    // we will try to abort the ones that had already succeeded.\n    int commitCount \u003d taskOutput.size();\n    final Queue\u003cSinglePendingCommit\u003e commits \u003d new ConcurrentLinkedQueue\u003c\u003e();\n    LOG.info(\"{}: uploading from staging directory to S3\", getRole());\n    LOG.info(\"{}: Saving pending data information to {}\",\n        getRole(), commitsAttemptPath);\n    if (taskOutput.isEmpty()) {\n      // there is nothing to write. needsTaskCommit() should have caught\n      // this, so warn that there is some kind of problem in the protocol.\n      LOG.warn(\"{}: No files to commit\", getRole());\n    } else {\n      boolean threw \u003d true;\n      // before the uploads, report some progress\n      context.progress();\n\n      PendingSet pendingCommits \u003d new PendingSet(commitCount);\n      try {\n        Tasks.foreach(taskOutput)\n            .stopOnFailure()\n            .executeWith(buildThreadPool(context))\n            .run(stat -\u003e {\n              Path path \u003d stat.getPath();\n              File localFile \u003d new File(path.toUri().getPath());\n              String relative \u003d Paths.getRelativePath(attemptPath, path);\n              String partition \u003d Paths.getPartition(relative);\n              String key \u003d getFinalKey(relative, context);\n              Path destPath \u003d getDestS3AFS().keyToQualifiedPath(key);\n              SinglePendingCommit commit \u003d getCommitOperations()\n                  .uploadFileToPendingCommit(\n                      localFile,\n                      destPath,\n                      partition,\n                      uploadPartSize);\n              LOG.debug(\"{}: adding pending commit {}\", getRole(), commit);\n              commits.add(commit);\n            });\n\n        for (SinglePendingCommit commit : commits) {\n          pendingCommits.add(commit);\n        }\n\n        // save the data\n        // although overwrite\u003dfalse, there\u0027s still a risk of \u003e 1 entry being\n        // committed if the FS doesn\u0027t have create-no-overwrite consistency.\n\n        LOG.debug(\"Saving {} pending commit(s)) to file {}\",\n            pendingCommits.size(),\n            commitsAttemptPath);\n        pendingCommits.save(commitsFS, commitsAttemptPath, false);\n        threw \u003d false;\n\n      } finally {\n        if (threw) {\n          LOG.error(\n              \"{}: Exception during commit process, aborting {} commit(s)\",\n              getRole(), commits.size());\n          Tasks.foreach(commits)\n              .suppressExceptions()\n              .run(commit -\u003e getCommitOperations().abortSingleCommit(commit));\n          deleteTaskAttemptPathQuietly(context);\n        }\n      }\n      // always purge attempt information at this point.\n      Paths.clearTempFolderInfo(context.getTaskAttemptID());\n    }\n\n    LOG.debug(\"Committing wrapped task\");\n    wrappedCommitter.commitTask(context);\n\n    LOG.debug(\"Cleaning up attempt dir {}\", attemptPath);\n    attemptFS.delete(attemptPath, true);\n    return commits.size();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/staging/StagingCommitter.java"
    }
  }
}