{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "innerGet",
  "functionId": "innerGet___path-Path__wantEmptyDirectoryFlag-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 736,
  "functionEndLine": 794,
  "numCommitsSeen": 44,
  "timeTaken": 5950,
  "changeHistory": [
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "6f068cf53faef564ea6b63a0f4591feb8119cc5e",
    "82b798581d12a5cbc9ae17fa290aa81e8ebf6a45",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
    "d7232857d8d1e10cdac171acdc931187e45fd6be",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "6f068cf53faef564ea6b63a0f4591feb8119cc5e": "Ybodychange",
    "82b798581d12a5cbc9ae17fa290aa81e8ebf6a45": "Ybodychange",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": "Ybodychange",
    "d7232857d8d1e10cdac171acdc931187e45fd6be": "Ymultichange(Yreturntypechange,Ybodychange)",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/11/19 7:36 AM",
      "commitNameOld": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 44.82,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,59 @@\n   private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n     final DDBPathMetadata meta;\n     if (path.isRoot()) {\n       // Root does not persist in the table\n       meta \u003d\n           new DDBPathMetadata(makeDirStatus(username, path));\n     } else {\n       final Item item \u003d getConsistentItem(path);\n       meta \u003d itemToPathMetadata(item, username);\n       LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n           tableName, region, path, meta);\n     }\n \n-    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n+    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null \u0026\u0026 !meta.isDeleted()) {\n       final FileStatus status \u003d meta.getFileStatus();\n-      // for directory, we query its direct children to determine isEmpty bit\n+      // for a non-deleted directory, we query its direct undeleted children\n+      // to determine the isEmpty bit. There\u0027s no TTL checking going on here.\n       if (status.isDirectory()) {\n         final QuerySpec spec \u003d new QuerySpec()\n             .withHashKey(pathToParentKeyAttribute(path))\n             .withConsistentRead(true)\n             .withFilterExpression(IS_DELETED + \" \u003d :false\")\n             .withValueMap(DELETE_TRACKING_VALUE_MAP);\n         boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n             path.toString(),\n             true,\n-            () -\u003e table.query(spec).iterator().hasNext());\n+            () -\u003e {\n+              // issue the query\n+              final IteratorSupport\u003cItem, QueryOutcome\u003e it \u003d table.query(\n+                  spec).iterator();\n+              // if non empty, log the result to aid with some debugging\n+              if (it.hasNext()) {\n+                if (LOG.isDebugEnabled()) {\n+                  LOG.debug(\"Dir {} is non-empty\", status.getPath());\n+                  while(it.hasNext()) {\n+                    LOG.debug(\"{}\", itemToPathMetadata(it.next(), username));\n+                  }\n+                }\n+                return true;\n+              } else {\n+                return false;\n+              }\n+          });\n \n         // If directory is authoritative, we can set the empty directory flag\n         // to TRUE or FALSE. Otherwise FALSE, or UNKNOWN.\n-        if(meta.isAuthoritativeDir()) {\n+        if (meta.isAuthoritativeDir()) {\n           meta.setIsEmptyDirectory(\n               hasChildren ? Tristate.FALSE : Tristate.TRUE);\n         } else {\n           meta.setIsEmptyDirectory(\n               hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n         }\n       }\n     }\n \n     return meta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final DDBPathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d\n          new DDBPathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(path);\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null \u0026\u0026 !meta.isDeleted()) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for a non-deleted directory, we query its direct undeleted children\n      // to determine the isEmpty bit. There\u0027s no TTL checking going on here.\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(DELETE_TRACKING_VALUE_MAP);\n        boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n            path.toString(),\n            true,\n            () -\u003e {\n              // issue the query\n              final IteratorSupport\u003cItem, QueryOutcome\u003e it \u003d table.query(\n                  spec).iterator();\n              // if non empty, log the result to aid with some debugging\n              if (it.hasNext()) {\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"Dir {} is non-empty\", status.getPath());\n                  while(it.hasNext()) {\n                    LOG.debug(\"{}\", itemToPathMetadata(it.next(), username));\n                  }\n                }\n                return true;\n              } else {\n                return false;\n              }\n          });\n\n        // If directory is authoritative, we can set the empty directory flag\n        // to TRUE or FALSE. Otherwise FALSE, or UNKNOWN.\n        if (meta.isAuthoritativeDir()) {\n          meta.setIsEmptyDirectory(\n              hasChildren ? Tristate.FALSE : Tristate.TRUE);\n        } else {\n          meta.setIsEmptyDirectory(\n              hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n        }\n      }\n    }\n\n    return meta;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "6f068cf53faef564ea6b63a0f4591feb8119cc5e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16416. mark DynamoDBMetadataStore.deleteTrackingValueMap as final. Contributed by kevin su.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "27/08/19 4:17 PM",
      "commitName": "6f068cf53faef564ea6b63a0f4591feb8119cc5e",
      "commitAuthor": "HUAN-PING SU",
      "commitDateOld": "24/07/19 10:11 AM",
      "commitNameOld": "7b219778e05a50e33cca75d727e62783322b7f80",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 34.25,
      "commitsBetweenForRepo": 331,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n     final DDBPathMetadata meta;\n     if (path.isRoot()) {\n       // Root does not persist in the table\n       meta \u003d\n           new DDBPathMetadata(makeDirStatus(username, path));\n     } else {\n       final Item item \u003d getConsistentItem(path);\n       meta \u003d itemToPathMetadata(item, username);\n       LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n           tableName, region, path, meta);\n     }\n \n     if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n       final FileStatus status \u003d meta.getFileStatus();\n       // for directory, we query its direct children to determine isEmpty bit\n       if (status.isDirectory()) {\n         final QuerySpec spec \u003d new QuerySpec()\n             .withHashKey(pathToParentKeyAttribute(path))\n             .withConsistentRead(true)\n             .withFilterExpression(IS_DELETED + \" \u003d :false\")\n-            .withValueMap(deleteTrackingValueMap);\n+            .withValueMap(DELETE_TRACKING_VALUE_MAP);\n         boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n             path.toString(),\n             true,\n             () -\u003e table.query(spec).iterator().hasNext());\n \n         // If directory is authoritative, we can set the empty directory flag\n         // to TRUE or FALSE. Otherwise FALSE, or UNKNOWN.\n         if(meta.isAuthoritativeDir()) {\n           meta.setIsEmptyDirectory(\n               hasChildren ? Tristate.FALSE : Tristate.TRUE);\n         } else {\n           meta.setIsEmptyDirectory(\n               hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n         }\n       }\n     }\n \n     return meta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final DDBPathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d\n          new DDBPathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(path);\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(DELETE_TRACKING_VALUE_MAP);\n        boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n            path.toString(),\n            true,\n            () -\u003e table.query(spec).iterator().hasNext());\n\n        // If directory is authoritative, we can set the empty directory flag\n        // to TRUE or FALSE. Otherwise FALSE, or UNKNOWN.\n        if(meta.isAuthoritativeDir()) {\n          meta.setIsEmptyDirectory(\n              hasChildren ? Tristate.FALSE : Tristate.TRUE);\n        } else {\n          meta.setIsEmptyDirectory(\n              hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n        }\n      }\n    }\n\n    return meta;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "82b798581d12a5cbc9ae17fa290aa81e8ebf6a45": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15988. DynamoDBMetadataStore#innerGet should support empty directory flag when using authoritative listings. Contributed by Gabor Bota.\n",
      "commitDate": "12/12/18 8:30 AM",
      "commitName": "82b798581d12a5cbc9ae17fa290aa81e8ebf6a45",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "28/11/18 9:45 AM",
      "commitNameOld": "085f10e75dea5446861253cf63aced337536481c",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 13.95,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,42 @@\n   private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n     final DDBPathMetadata meta;\n     if (path.isRoot()) {\n       // Root does not persist in the table\n       meta \u003d\n           new DDBPathMetadata(makeDirStatus(username, path));\n     } else {\n       final Item item \u003d getConsistentItem(path);\n       meta \u003d itemToPathMetadata(item, username);\n       LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n           tableName, region, path, meta);\n     }\n \n     if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n       final FileStatus status \u003d meta.getFileStatus();\n       // for directory, we query its direct children to determine isEmpty bit\n       if (status.isDirectory()) {\n         final QuerySpec spec \u003d new QuerySpec()\n             .withHashKey(pathToParentKeyAttribute(path))\n             .withConsistentRead(true)\n             .withFilterExpression(IS_DELETED + \" \u003d :false\")\n             .withValueMap(deleteTrackingValueMap);\n         boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n             path.toString(),\n             true,\n             () -\u003e table.query(spec).iterator().hasNext());\n-        // When this class has support for authoritative\n-        // (fully-cached) directory listings, we may also be able to answer\n-        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n-        // not, thus the UNKNOWN here:\n-        meta.setIsEmptyDirectory(\n-            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n+\n+        // If directory is authoritative, we can set the empty directory flag\n+        // to TRUE or FALSE. Otherwise FALSE, or UNKNOWN.\n+        if(meta.isAuthoritativeDir()) {\n+          meta.setIsEmptyDirectory(\n+              hasChildren ? Tristate.FALSE : Tristate.TRUE);\n+        } else {\n+          meta.setIsEmptyDirectory(\n+              hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n+        }\n       }\n     }\n \n     return meta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final DDBPathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d\n          new DDBPathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(path);\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n            path.toString(),\n            true,\n            () -\u003e table.query(spec).iterator().hasNext());\n\n        // If directory is authoritative, we can set the empty directory flag\n        // to TRUE or FALSE. Otherwise FALSE, or UNKNOWN.\n        if(meta.isAuthoritativeDir()) {\n          meta.setIsEmptyDirectory(\n              hasChildren ? Tristate.FALSE : Tristate.TRUE);\n        } else {\n          meta.setIsEmptyDirectory(\n              hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n        }\n      }\n    }\n\n    return meta;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15426 Make S3guard client resilient to DDB throttle events and network failures (Contributed by Steve Loughran)\n",
      "commitDate": "12/09/18 9:04 PM",
      "commitName": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/09/18 4:36 PM",
      "commitNameOld": "d32a8d5d582725eb724b78f27310ad1efd33ed2a",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n   private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n     final DDBPathMetadata meta;\n     if (path.isRoot()) {\n       // Root does not persist in the table\n       meta \u003d\n           new DDBPathMetadata(makeDirStatus(username, path));\n     } else {\n-      final Item item \u003d getConsistentItem(pathToKey(path));\n+      final Item item \u003d getConsistentItem(path);\n       meta \u003d itemToPathMetadata(item, username);\n       LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n           tableName, region, path, meta);\n     }\n \n     if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n       final FileStatus status \u003d meta.getFileStatus();\n       // for directory, we query its direct children to determine isEmpty bit\n       if (status.isDirectory()) {\n         final QuerySpec spec \u003d new QuerySpec()\n             .withHashKey(pathToParentKeyAttribute(path))\n             .withConsistentRead(true)\n             .withFilterExpression(IS_DELETED + \" \u003d :false\")\n             .withValueMap(deleteTrackingValueMap);\n-        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n-        boolean hasChildren \u003d items.iterator().hasNext();\n+        boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n+            path.toString(),\n+            true,\n+            () -\u003e table.query(spec).iterator().hasNext());\n         // When this class has support for authoritative\n         // (fully-cached) directory listings, we may also be able to answer\n         // TRUE here.  Until then, we don\u0027t know if we have full listing or\n         // not, thus the UNKNOWN here:\n         meta.setIsEmptyDirectory(\n             hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n       }\n     }\n \n     return meta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final DDBPathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d\n          new DDBPathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(path);\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        boolean hasChildren \u003d readOp.retry(\"get/hasChildren\",\n            path.toString(),\n            true,\n            () -\u003e table.query(spec).iterator().hasNext());\n        // When this class has support for authoritative\n        // (fully-cached) directory listings, we may also be able to answer\n        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n        // not, thus the UNKNOWN here:\n        meta.setIsEmptyDirectory(\n            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n      }\n    }\n\n    return meta;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7232857d8d1e10cdac171acdc931187e45fd6be": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
      "commitDate": "17/08/18 10:15 AM",
      "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
      "commitAuthor": "Aaron Fabbri",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
          "commitDate": "17/08/18 10:15 AM",
          "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "08/08/18 10:57 PM",
          "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.47,
          "commitsBetweenForRepo": 126,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,36 @@\n-  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n+  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n-    final PathMetadata meta;\n+    final DDBPathMetadata meta;\n     if (path.isRoot()) {\n       // Root does not persist in the table\n-      meta \u003d new PathMetadata(makeDirStatus(username, path));\n+      meta \u003d\n+          new DDBPathMetadata(makeDirStatus(username, path));\n     } else {\n       final Item item \u003d getConsistentItem(pathToKey(path));\n       meta \u003d itemToPathMetadata(item, username);\n       LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n           tableName, region, path, meta);\n     }\n \n     if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n       final FileStatus status \u003d meta.getFileStatus();\n       // for directory, we query its direct children to determine isEmpty bit\n       if (status.isDirectory()) {\n         final QuerySpec spec \u003d new QuerySpec()\n             .withHashKey(pathToParentKeyAttribute(path))\n             .withConsistentRead(true)\n             .withFilterExpression(IS_DELETED + \" \u003d :false\")\n             .withValueMap(deleteTrackingValueMap);\n         final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n         boolean hasChildren \u003d items.iterator().hasNext();\n         // When this class has support for authoritative\n         // (fully-cached) directory listings, we may also be able to answer\n         // TRUE here.  Until then, we don\u0027t know if we have full listing or\n         // not, thus the UNKNOWN here:\n         meta.setIsEmptyDirectory(\n             hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n       }\n     }\n \n     return meta;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final DDBPathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d\n          new DDBPathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(pathToKey(path));\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n        boolean hasChildren \u003d items.iterator().hasNext();\n        // When this class has support for authoritative\n        // (fully-cached) directory listings, we may also be able to answer\n        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n        // not, thus the UNKNOWN here:\n        meta.setIsEmptyDirectory(\n            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n      }\n    }\n\n    return meta;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "PathMetadata",
            "newValue": "DDBPathMetadata"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
          "commitDate": "17/08/18 10:15 AM",
          "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "08/08/18 10:57 PM",
          "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.47,
          "commitsBetweenForRepo": 126,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,36 @@\n-  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n+  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n-    final PathMetadata meta;\n+    final DDBPathMetadata meta;\n     if (path.isRoot()) {\n       // Root does not persist in the table\n-      meta \u003d new PathMetadata(makeDirStatus(username, path));\n+      meta \u003d\n+          new DDBPathMetadata(makeDirStatus(username, path));\n     } else {\n       final Item item \u003d getConsistentItem(pathToKey(path));\n       meta \u003d itemToPathMetadata(item, username);\n       LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n           tableName, region, path, meta);\n     }\n \n     if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n       final FileStatus status \u003d meta.getFileStatus();\n       // for directory, we query its direct children to determine isEmpty bit\n       if (status.isDirectory()) {\n         final QuerySpec spec \u003d new QuerySpec()\n             .withHashKey(pathToParentKeyAttribute(path))\n             .withConsistentRead(true)\n             .withFilterExpression(IS_DELETED + \" \u003d :false\")\n             .withValueMap(deleteTrackingValueMap);\n         final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n         boolean hasChildren \u003d items.iterator().hasNext();\n         // When this class has support for authoritative\n         // (fully-cached) directory listings, we may also be able to answer\n         // TRUE here.  Until then, we don\u0027t know if we have full listing or\n         // not, thus the UNKNOWN here:\n         meta.setIsEmptyDirectory(\n             hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n       }\n     }\n \n     return meta;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private DDBPathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final DDBPathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d\n          new DDBPathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(pathToKey(path));\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n        boolean hasChildren \u003d items.iterator().hasNext();\n        // When this class has support for authoritative\n        // (fully-cached) directory listings, we may also be able to answer\n        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n        // not, thus the UNKNOWN here:\n        meta.setIsEmptyDirectory(\n            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n      }\n    }\n\n    return meta;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,35 @@\n-  private void innerDelete(Path path, boolean tombstone)\n+  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n-    path \u003d checkPath(path);\n-    LOG.debug(\"Deleting from table {} in region {}: {}\",\n-        tableName, region, path);\n-\n-    // deleting nonexistent item consumes 1 write capacity; skip it\n+    final PathMetadata meta;\n     if (path.isRoot()) {\n-      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n-      return;\n+      // Root does not persist in the table\n+      meta \u003d new PathMetadata(makeDirStatus(username, path));\n+    } else {\n+      final Item item \u003d getConsistentItem(pathToKey(path));\n+      meta \u003d itemToPathMetadata(item, username);\n+      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n+          tableName, region, path, meta);\n     }\n \n-    try {\n-      if (tombstone) {\n-        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-            PathMetadata.tombstone(path));\n-        table.putItem(item);\n-      } else {\n-        table.deleteItem(pathToKey(path));\n+    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n+      final FileStatus status \u003d meta.getFileStatus();\n+      // for directory, we query its direct children to determine isEmpty bit\n+      if (status.isDirectory()) {\n+        final QuerySpec spec \u003d new QuerySpec()\n+            .withHashKey(pathToParentKeyAttribute(path))\n+            .withConsistentRead(true)\n+            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n+            .withValueMap(deleteTrackingValueMap);\n+        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+        boolean hasChildren \u003d items.iterator().hasNext();\n+        // When this class has support for authoritative\n+        // (fully-cached) directory listings, we may also be able to answer\n+        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n+        // not, thus the UNKNOWN here:\n+        meta.setIsEmptyDirectory(\n+            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n       }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"delete\", path, e);\n     }\n+\n+    return meta;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final PathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d new PathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(pathToKey(path));\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n        boolean hasChildren \u003d items.iterator().hasNext();\n        // When this class has support for authoritative\n        // (fully-cached) directory listings, we may also be able to answer\n        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n        // not, thus the UNKNOWN here:\n        meta.setIsEmptyDirectory(\n            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n      }\n    }\n\n    return meta;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "innerDelete",
            "newValue": "innerGet"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,35 @@\n-  private void innerDelete(Path path, boolean tombstone)\n+  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n-    path \u003d checkPath(path);\n-    LOG.debug(\"Deleting from table {} in region {}: {}\",\n-        tableName, region, path);\n-\n-    // deleting nonexistent item consumes 1 write capacity; skip it\n+    final PathMetadata meta;\n     if (path.isRoot()) {\n-      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n-      return;\n+      // Root does not persist in the table\n+      meta \u003d new PathMetadata(makeDirStatus(username, path));\n+    } else {\n+      final Item item \u003d getConsistentItem(pathToKey(path));\n+      meta \u003d itemToPathMetadata(item, username);\n+      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n+          tableName, region, path, meta);\n     }\n \n-    try {\n-      if (tombstone) {\n-        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-            PathMetadata.tombstone(path));\n-        table.putItem(item);\n-      } else {\n-        table.deleteItem(pathToKey(path));\n+    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n+      final FileStatus status \u003d meta.getFileStatus();\n+      // for directory, we query its direct children to determine isEmpty bit\n+      if (status.isDirectory()) {\n+        final QuerySpec spec \u003d new QuerySpec()\n+            .withHashKey(pathToParentKeyAttribute(path))\n+            .withConsistentRead(true)\n+            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n+            .withValueMap(deleteTrackingValueMap);\n+        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+        boolean hasChildren \u003d items.iterator().hasNext();\n+        // When this class has support for authoritative\n+        // (fully-cached) directory listings, we may also be able to answer\n+        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n+        // not, thus the UNKNOWN here:\n+        meta.setIsEmptyDirectory(\n+            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n       }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"delete\", path, e);\n     }\n+\n+    return meta;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final PathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d new PathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(pathToKey(path));\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n        boolean hasChildren \u003d items.iterator().hasNext();\n        // When this class has support for authoritative\n        // (fully-cached) directory listings, we may also be able to answer\n        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n        // not, thus the UNKNOWN here:\n        meta.setIsEmptyDirectory(\n            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n      }\n    }\n\n    return meta;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path, tombstone-boolean]",
            "newValue": "[path-Path, wantEmptyDirectoryFlag-boolean]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,35 @@\n-  private void innerDelete(Path path, boolean tombstone)\n+  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n-    path \u003d checkPath(path);\n-    LOG.debug(\"Deleting from table {} in region {}: {}\",\n-        tableName, region, path);\n-\n-    // deleting nonexistent item consumes 1 write capacity; skip it\n+    final PathMetadata meta;\n     if (path.isRoot()) {\n-      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n-      return;\n+      // Root does not persist in the table\n+      meta \u003d new PathMetadata(makeDirStatus(username, path));\n+    } else {\n+      final Item item \u003d getConsistentItem(pathToKey(path));\n+      meta \u003d itemToPathMetadata(item, username);\n+      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n+          tableName, region, path, meta);\n     }\n \n-    try {\n-      if (tombstone) {\n-        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-            PathMetadata.tombstone(path));\n-        table.putItem(item);\n-      } else {\n-        table.deleteItem(pathToKey(path));\n+    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n+      final FileStatus status \u003d meta.getFileStatus();\n+      // for directory, we query its direct children to determine isEmpty bit\n+      if (status.isDirectory()) {\n+        final QuerySpec spec \u003d new QuerySpec()\n+            .withHashKey(pathToParentKeyAttribute(path))\n+            .withConsistentRead(true)\n+            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n+            .withValueMap(deleteTrackingValueMap);\n+        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+        boolean hasChildren \u003d items.iterator().hasNext();\n+        // When this class has support for authoritative\n+        // (fully-cached) directory listings, we may also be able to answer\n+        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n+        // not, thus the UNKNOWN here:\n+        meta.setIsEmptyDirectory(\n+            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n       }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"delete\", path, e);\n     }\n+\n+    return meta;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final PathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d new PathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(pathToKey(path));\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n        boolean hasChildren \u003d items.iterator().hasNext();\n        // When this class has support for authoritative\n        // (fully-cached) directory listings, we may also be able to answer\n        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n        // not, thus the UNKNOWN here:\n        meta.setIsEmptyDirectory(\n            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n      }\n    }\n\n    return meta;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "PathMetadata"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,35 @@\n-  private void innerDelete(Path path, boolean tombstone)\n+  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n       throws IOException {\n-    path \u003d checkPath(path);\n-    LOG.debug(\"Deleting from table {} in region {}: {}\",\n-        tableName, region, path);\n-\n-    // deleting nonexistent item consumes 1 write capacity; skip it\n+    final PathMetadata meta;\n     if (path.isRoot()) {\n-      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n-      return;\n+      // Root does not persist in the table\n+      meta \u003d new PathMetadata(makeDirStatus(username, path));\n+    } else {\n+      final Item item \u003d getConsistentItem(pathToKey(path));\n+      meta \u003d itemToPathMetadata(item, username);\n+      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n+          tableName, region, path, meta);\n     }\n \n-    try {\n-      if (tombstone) {\n-        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-            PathMetadata.tombstone(path));\n-        table.putItem(item);\n-      } else {\n-        table.deleteItem(pathToKey(path));\n+    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n+      final FileStatus status \u003d meta.getFileStatus();\n+      // for directory, we query its direct children to determine isEmpty bit\n+      if (status.isDirectory()) {\n+        final QuerySpec spec \u003d new QuerySpec()\n+            .withHashKey(pathToParentKeyAttribute(path))\n+            .withConsistentRead(true)\n+            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n+            .withValueMap(deleteTrackingValueMap);\n+        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+        boolean hasChildren \u003d items.iterator().hasNext();\n+        // When this class has support for authoritative\n+        // (fully-cached) directory listings, we may also be able to answer\n+        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n+        // not, thus the UNKNOWN here:\n+        meta.setIsEmptyDirectory(\n+            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n       }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"delete\", path, e);\n     }\n+\n+    return meta;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private PathMetadata innerGet(Path path, boolean wantEmptyDirectoryFlag)\n      throws IOException {\n    final PathMetadata meta;\n    if (path.isRoot()) {\n      // Root does not persist in the table\n      meta \u003d new PathMetadata(makeDirStatus(username, path));\n    } else {\n      final Item item \u003d getConsistentItem(pathToKey(path));\n      meta \u003d itemToPathMetadata(item, username);\n      LOG.debug(\"Get from table {} in region {} returning for {}: {}\",\n          tableName, region, path, meta);\n    }\n\n    if (wantEmptyDirectoryFlag \u0026\u0026 meta !\u003d null) {\n      final FileStatus status \u003d meta.getFileStatus();\n      // for directory, we query its direct children to determine isEmpty bit\n      if (status.isDirectory()) {\n        final QuerySpec spec \u003d new QuerySpec()\n            .withHashKey(pathToParentKeyAttribute(path))\n            .withConsistentRead(true)\n            .withFilterExpression(IS_DELETED + \" \u003d :false\")\n            .withValueMap(deleteTrackingValueMap);\n        final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n        boolean hasChildren \u003d items.iterator().hasNext();\n        // When this class has support for authoritative\n        // (fully-cached) directory listings, we may also be able to answer\n        // TRUE here.  Until then, we don\u0027t know if we have full listing or\n        // not, thus the UNKNOWN here:\n        meta.setIsEmptyDirectory(\n            hasChildren ? Tristate.FALSE : Tristate.UNKNOWN);\n      }\n    }\n\n    return meta;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,24 @@\n+  private void innerDelete(Path path, boolean tombstone)\n+      throws IOException {\n+    path \u003d checkPath(path);\n+    LOG.debug(\"Deleting from table {} in region {}: {}\",\n+        tableName, region, path);\n+\n+    // deleting nonexistent item consumes 1 write capacity; skip it\n+    if (path.isRoot()) {\n+      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n+      return;\n+    }\n+\n+    try {\n+      if (tombstone) {\n+        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n+            PathMetadata.tombstone(path));\n+        table.putItem(item);\n+      } else {\n+        table.deleteItem(pathToKey(path));\n+      }\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"delete\", path, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void innerDelete(Path path, boolean tombstone)\n      throws IOException {\n    path \u003d checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n\n    try {\n      if (tombstone) {\n        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n            PathMetadata.tombstone(path));\n        table.putItem(item);\n      } else {\n        table.deleteItem(pathToKey(path));\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", path, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}