{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogWebServiceUtils.java",
  "functionName": "write",
  "functionId": "write___os-OutputStream",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/LogWebServiceUtils.java",
  "functionStartLine": 108,
  "functionEndLine": 135,
  "numCommitsSeen": 29,
  "timeTaken": 4221,
  "changeHistory": [
    "8d1981806feb8278966c02a9eff42d72541bb35e",
    "91cc070d67533ebb3325b982eba2135e0d175a82",
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e",
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2",
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
    "e61d431275d7fe5641fe9da4903e285b10330fa0"
  ],
  "changeHistoryShort": {
    "8d1981806feb8278966c02a9eff42d72541bb35e": "Ymovefromfile",
    "91cc070d67533ebb3325b982eba2135e0d175a82": "Ybodychange",
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e": "Ybodychange",
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c": "Ybodychange",
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2": "Ybodychange",
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630": "Ybodychange",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": "Ybodychange",
    "e61d431275d7fe5641fe9da4903e285b10330fa0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8d1981806feb8278966c02a9eff42d72541bb35e": {
      "type": "Ymovefromfile",
      "commitMessage": "YARN-5742 Serve aggregated logs of historical apps from timeline service. Contributed by Rohith Sharma KS\n",
      "commitDate": "11/10/18 4:26 PM",
      "commitName": "8d1981806feb8278966c02a9eff42d72541bb35e",
      "commitAuthor": "Vrushali C",
      "commitDateOld": "11/10/18 3:35 PM",
      "commitNameOld": "d91d47bc739f23ca22a7e44fc83d449db57ab130",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n-      public void write(OutputStream os) throws IOException,\n-          WebApplicationException {\n+      @Override public void write(OutputStream os)\n+          throws IOException, WebApplicationException {\n         ContainerLogsRequest request \u003d new ContainerLogsRequest();\n         request.setAppId(appId);\n         request.setAppOwner(appOwner);\n         request.setContainerId(containerIdStr);\n         request.setBytes(bytes);\n         request.setNodeId(nodeId);\n         Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n         logTypes.add(logFile);\n         request.setLogTypes(logTypes);\n         boolean findLogs \u003d factory.getFileControllerForRead(appId, appOwner)\n             .readAggregatedLogs(request, os);\n         if (!findLogs) {\n-          os.write((\"Can not find logs for container:\"\n-              + containerIdStr).getBytes(Charset.forName(\"UTF-8\")));\n+          os.write((\"Can not find logs for container:\" + containerIdStr)\n+              .getBytes(Charset.forName(\"UTF-8\")));\n         } else {\n           if (printEmptyLocalContainerLog) {\n             StringBuilder sb \u003d new StringBuilder();\n             sb.append(containerIdStr + \"\\n\");\n-            sb.append(\"LogAggregationType: \"\n-                + ContainerLogAggregationType.LOCAL + \"\\n\");\n+            sb.append(\"LogAggregationType: \" + ContainerLogAggregationType.LOCAL\n+                + \"\\n\");\n             sb.append(\"LogContents:\\n\");\n             sb.append(getNoRedirectWarning() + \"\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n           }\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      @Override public void write(OutputStream os)\n          throws IOException, WebApplicationException {\n        ContainerLogsRequest request \u003d new ContainerLogsRequest();\n        request.setAppId(appId);\n        request.setAppOwner(appOwner);\n        request.setContainerId(containerIdStr);\n        request.setBytes(bytes);\n        request.setNodeId(nodeId);\n        Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n        logTypes.add(logFile);\n        request.setLogTypes(logTypes);\n        boolean findLogs \u003d factory.getFileControllerForRead(appId, appOwner)\n            .readAggregatedLogs(request, os);\n        if (!findLogs) {\n          os.write((\"Can not find logs for container:\" + containerIdStr)\n              .getBytes(Charset.forName(\"UTF-8\")));\n        } else {\n          if (printEmptyLocalContainerLog) {\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(containerIdStr + \"\\n\");\n            sb.append(\"LogAggregationType: \" + ContainerLogAggregationType.LOCAL\n                + \"\\n\");\n            sb.append(\"LogContents:\\n\");\n            sb.append(getNoRedirectWarning() + \"\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/LogWebServiceUtils.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/LogWebServiceUtils.java",
        "oldMethodName": "write",
        "newMethodName": "write"
      }
    },
    "91cc070d67533ebb3325b982eba2135e0d175a82": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "31/08/17 4:41 PM",
      "commitName": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthor": "Junping Du",
      "commitDateOld": "07/08/17 2:56 AM",
      "commitNameOld": "839e077faf4019d6efdcd89d95930023cd0b0a08",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 24.57,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,28 @@\n       public void write(OutputStream os) throws IOException,\n           WebApplicationException {\n-        byte[] buf \u003d new byte[65535];\n-        boolean findLogs \u003d LogToolUtils.outputAggregatedContainerLog(conf,\n-            appId, appOwner, containerIdStr, nodeId, logFile, bytes, os, buf);\n+        ContainerLogsRequest request \u003d new ContainerLogsRequest();\n+        request.setAppId(appId);\n+        request.setAppOwner(appOwner);\n+        request.setContainerId(containerIdStr);\n+        request.setBytes(bytes);\n+        request.setNodeId(nodeId);\n+        Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n+        logTypes.add(logFile);\n+        request.setLogTypes(logTypes);\n+        boolean findLogs \u003d factory.getFileControllerForRead(appId, appOwner)\n+            .readAggregatedLogs(request, os);\n         if (!findLogs) {\n           os.write((\"Can not find logs for container:\"\n               + containerIdStr).getBytes(Charset.forName(\"UTF-8\")));\n         } else {\n           if (printEmptyLocalContainerLog) {\n             StringBuilder sb \u003d new StringBuilder();\n             sb.append(containerIdStr + \"\\n\");\n             sb.append(\"LogAggregationType: \"\n                 + ContainerLogAggregationType.LOCAL + \"\\n\");\n             sb.append(\"LogContents:\\n\");\n             sb.append(getNoRedirectWarning() + \"\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n           }\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public void write(OutputStream os) throws IOException,\n          WebApplicationException {\n        ContainerLogsRequest request \u003d new ContainerLogsRequest();\n        request.setAppId(appId);\n        request.setAppOwner(appOwner);\n        request.setContainerId(containerIdStr);\n        request.setBytes(bytes);\n        request.setNodeId(nodeId);\n        Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n        logTypes.add(logFile);\n        request.setLogTypes(logTypes);\n        boolean findLogs \u003d factory.getFileControllerForRead(appId, appOwner)\n            .readAggregatedLogs(request, os);\n        if (!findLogs) {\n          os.write((\"Can not find logs for container:\"\n              + containerIdStr).getBytes(Charset.forName(\"UTF-8\")));\n        } else {\n          if (printEmptyLocalContainerLog) {\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(containerIdStr + \"\\n\");\n            sb.append(\"LogAggregationType: \"\n                + ContainerLogAggregationType.LOCAL + \"\\n\");\n            sb.append(\"LogContents:\\n\");\n            sb.append(getNoRedirectWarning() + \"\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java",
      "extendedDetails": {}
    },
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6174. Log files pattern should be same for both running and finished container. Contributed by Xuan Gong.\n",
      "commitDate": "15/02/17 9:05 AM",
      "commitName": "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e",
      "commitAuthor": "Junping Du",
      "commitDateOld": "07/02/17 2:13 AM",
      "commitNameOld": "9dbfab1284015af6983b4a55b79c9e65bc0194e5",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 8.29,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,20 @@\n       public void write(OutputStream os) throws IOException,\n           WebApplicationException {\n         byte[] buf \u003d new byte[65535];\n         boolean findLogs \u003d LogToolUtils.outputAggregatedContainerLog(conf,\n             appId, appOwner, containerIdStr, nodeId, logFile, bytes, os, buf);\n         if (!findLogs) {\n-          throw new IOException(\"Can not find logs for container:\"\n-              + containerIdStr);\n+          os.write((\"Can not find logs for container:\"\n+              + containerIdStr).getBytes(Charset.forName(\"UTF-8\")));\n         } else {\n           if (printEmptyLocalContainerLog) {\n             StringBuilder sb \u003d new StringBuilder();\n             sb.append(containerIdStr + \"\\n\");\n-            sb.append(\"LogType: \" + ContainerLogType.LOCAL + \"\\n\");\n+            sb.append(\"LogAggregationType: \"\n+                + ContainerLogAggregationType.LOCAL + \"\\n\");\n             sb.append(\"LogContents:\\n\");\n             sb.append(getNoRedirectWarning() + \"\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n           }\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public void write(OutputStream os) throws IOException,\n          WebApplicationException {\n        byte[] buf \u003d new byte[65535];\n        boolean findLogs \u003d LogToolUtils.outputAggregatedContainerLog(conf,\n            appId, appOwner, containerIdStr, nodeId, logFile, bytes, os, buf);\n        if (!findLogs) {\n          os.write((\"Can not find logs for container:\"\n              + containerIdStr).getBytes(Charset.forName(\"UTF-8\")));\n        } else {\n          if (printEmptyLocalContainerLog) {\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(containerIdStr + \"\\n\");\n            sb.append(\"LogAggregationType: \"\n                + ContainerLogAggregationType.LOCAL + \"\\n\");\n            sb.append(\"LogContents:\\n\");\n            sb.append(getNoRedirectWarning() + \"\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java",
      "extendedDetails": {}
    },
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6100. Improve YARN webservice to output aggregated container logs. Contributed by Xuan Gong.\n",
      "commitDate": "02/02/17 12:41 AM",
      "commitName": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
      "commitAuthor": "Junping Du",
      "commitDateOld": "24/01/17 3:26 PM",
      "commitNameOld": "8528d85a68c0e6ea71026df4d3026e7edc206b2d",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 8.39,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,19 @@\n       public void write(OutputStream os) throws IOException,\n           WebApplicationException {\n         byte[] buf \u003d new byte[65535];\n-        boolean findLogs \u003d false;\n-        while (nodeFiles.hasNext()) {\n-          final FileStatus thisNodeFile \u003d nodeFiles.next();\n-          String nodeName \u003d thisNodeFile.getPath().getName();\n-          if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n-              .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n-              LogAggregationUtils.TMP_FILE_SUFFIX)) {\n-            AggregatedLogFormat.LogReader reader \u003d null;\n-            try {\n-              reader \u003d new AggregatedLogFormat.LogReader(conf,\n-                  thisNodeFile.getPath());\n-              DataInputStream valueStream;\n-              LogKey key \u003d new LogKey();\n-              valueStream \u003d reader.next(key);\n-              while (valueStream !\u003d null \u0026\u0026 !key.toString()\n-                  .equals(containerIdStr)) {\n-                // Next container\n-                key \u003d new LogKey();\n-                valueStream \u003d reader.next(key);\n-              }\n-              if (valueStream \u003d\u003d null) {\n-                continue;\n-              }\n-              while (true) {\n-                try {\n-                  String fileType \u003d valueStream.readUTF();\n-                  String fileLengthStr \u003d valueStream.readUTF();\n-                  long fileLength \u003d Long.parseLong(fileLengthStr);\n-                  if (fileType.equalsIgnoreCase(logFile)) {\n-                    StringBuilder sb \u003d new StringBuilder();\n-                    sb.append(\"LogType:\");\n-                    sb.append(fileType + \"\\n\");\n-                    sb.append(\"Log Upload Time:\");\n-                    sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n-                    sb.append(\"LogLength:\");\n-                    sb.append(fileLengthStr + \"\\n\");\n-                    sb.append(\"Log Contents:\\n\");\n-                    byte[] b \u003d sb.toString().getBytes(\n-                        Charset.forName(\"UTF-8\"));\n-                    os.write(b, 0, b.length);\n-\n-                    long toSkip \u003d 0;\n-                    long totalBytesToRead \u003d fileLength;\n-                    long skipAfterRead \u003d 0;\n-                    if (bytes \u003c 0) {\n-                      long absBytes \u003d Math.abs(bytes);\n-                      if (absBytes \u003c fileLength) {\n-                        toSkip \u003d fileLength - absBytes;\n-                        totalBytesToRead \u003d absBytes;\n-                      }\n-                      org.apache.hadoop.io.IOUtils.skipFully(\n-                          valueStream, toSkip);\n-                    } else {\n-                      if (bytes \u003c fileLength) {\n-                        totalBytesToRead \u003d bytes;\n-                        skipAfterRead \u003d fileLength - bytes;\n-                      }\n-                    }\n-\n-                    long curRead \u003d 0;\n-                    long pendingRead \u003d totalBytesToRead - curRead;\n-                    int toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                        : (int) pendingRead;\n-                    int len \u003d valueStream.read(buf, 0, toRead);\n-                    while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n-                      os.write(buf, 0, len);\n-                      curRead +\u003d len;\n-\n-                      pendingRead \u003d totalBytesToRead - curRead;\n-                      toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                          : (int) pendingRead;\n-                      len \u003d valueStream.read(buf, 0, toRead);\n-                    }\n-                    org.apache.hadoop.io.IOUtils.skipFully(\n-                        valueStream, skipAfterRead);\n-                    sb \u003d new StringBuilder();\n-                    sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n-                    b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n-                    os.write(b, 0, b.length);\n-                    findLogs \u003d true;\n-                  } else {\n-                    long totalSkipped \u003d 0;\n-                    long currSkipped \u003d 0;\n-                    while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n-                      currSkipped \u003d valueStream.skip(\n-                          fileLength - totalSkipped);\n-                      totalSkipped +\u003d currSkipped;\n-                    }\n-                  }\n-                } catch (EOFException eof) {\n-                  break;\n-                }\n-              }\n-            } finally {\n-              if (reader !\u003d null) {\n-                reader.close();\n-              }\n-            }\n-          }\n-        }\n-        os.flush();\n+        boolean findLogs \u003d LogToolUtils.outputAggregatedContainerLog(conf,\n+            appId, appOwner, containerIdStr, nodeId, logFile, bytes, os, buf);\n         if (!findLogs) {\n           throw new IOException(\"Can not find logs for container:\"\n               + containerIdStr);\n+        } else {\n+          if (printEmptyLocalContainerLog) {\n+            StringBuilder sb \u003d new StringBuilder();\n+            sb.append(containerIdStr + \"\\n\");\n+            sb.append(\"LogType: \" + ContainerLogType.LOCAL + \"\\n\");\n+            sb.append(\"LogContents:\\n\");\n+            sb.append(getNoRedirectWarning() + \"\\n\");\n+            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n+          }\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public void write(OutputStream os) throws IOException,\n          WebApplicationException {\n        byte[] buf \u003d new byte[65535];\n        boolean findLogs \u003d LogToolUtils.outputAggregatedContainerLog(conf,\n            appId, appOwner, containerIdStr, nodeId, logFile, bytes, os, buf);\n        if (!findLogs) {\n          throw new IOException(\"Can not find logs for container:\"\n              + containerIdStr);\n        } else {\n          if (printEmptyLocalContainerLog) {\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(containerIdStr + \"\\n\");\n            sb.append(\"LogType: \" + ContainerLogType.LOCAL + \"\\n\");\n            sb.append(\"LogContents:\\n\");\n            sb.append(getNoRedirectWarning() + \"\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java",
      "extendedDetails": {}
    },
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5251. Yarn CLI to obtain App logs for last \u0027n\u0027 bytes fails. Contributed by Xuan Gong.\n",
      "commitDate": "17/06/16 8:24 AM",
      "commitName": "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2",
      "commitAuthor": "Junping Du",
      "commitDateOld": "09/06/16 12:30 PM",
      "commitNameOld": "9378d9428f127eff7acd6c13544016cdbf2d65fb",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.83,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,109 @@\n       public void write(OutputStream os) throws IOException,\n           WebApplicationException {\n         byte[] buf \u003d new byte[65535];\n         boolean findLogs \u003d false;\n         while (nodeFiles.hasNext()) {\n           final FileStatus thisNodeFile \u003d nodeFiles.next();\n           String nodeName \u003d thisNodeFile.getPath().getName();\n           if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n               .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n               LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             AggregatedLogFormat.LogReader reader \u003d null;\n             try {\n               reader \u003d new AggregatedLogFormat.LogReader(conf,\n                   thisNodeFile.getPath());\n               DataInputStream valueStream;\n               LogKey key \u003d new LogKey();\n               valueStream \u003d reader.next(key);\n               while (valueStream !\u003d null \u0026\u0026 !key.toString()\n                   .equals(containerIdStr)) {\n                 // Next container\n                 key \u003d new LogKey();\n                 valueStream \u003d reader.next(key);\n               }\n               if (valueStream \u003d\u003d null) {\n                 continue;\n               }\n               while (true) {\n                 try {\n                   String fileType \u003d valueStream.readUTF();\n                   String fileLengthStr \u003d valueStream.readUTF();\n                   long fileLength \u003d Long.parseLong(fileLengthStr);\n                   if (fileType.equalsIgnoreCase(logFile)) {\n                     StringBuilder sb \u003d new StringBuilder();\n                     sb.append(\"LogType:\");\n                     sb.append(fileType + \"\\n\");\n                     sb.append(\"Log Upload Time:\");\n                     sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n                     sb.append(\"LogLength:\");\n                     sb.append(fileLengthStr + \"\\n\");\n                     sb.append(\"Log Contents:\\n\");\n                     byte[] b \u003d sb.toString().getBytes(\n                         Charset.forName(\"UTF-8\"));\n                     os.write(b, 0, b.length);\n \n                     long toSkip \u003d 0;\n                     long totalBytesToRead \u003d fileLength;\n+                    long skipAfterRead \u003d 0;\n                     if (bytes \u003c 0) {\n                       long absBytes \u003d Math.abs(bytes);\n                       if (absBytes \u003c fileLength) {\n                         toSkip \u003d fileLength - absBytes;\n                         totalBytesToRead \u003d absBytes;\n                       }\n-                      long skippedBytes \u003d valueStream.skip(toSkip);\n-                      if (skippedBytes !\u003d toSkip) {\n-                        throw new IOException(\"The bytes were skipped are \"\n-                            + \"different from the caller requested\");\n-                      }\n+                      org.apache.hadoop.io.IOUtils.skipFully(\n+                          valueStream, toSkip);\n                     } else {\n                       if (bytes \u003c fileLength) {\n                         totalBytesToRead \u003d bytes;\n+                        skipAfterRead \u003d fileLength - bytes;\n                       }\n                     }\n \n                     long curRead \u003d 0;\n                     long pendingRead \u003d totalBytesToRead - curRead;\n                     int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                         : (int) pendingRead;\n                     int len \u003d valueStream.read(buf, 0, toRead);\n                     while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n                       os.write(buf, 0, len);\n                       curRead +\u003d len;\n \n                       pendingRead \u003d totalBytesToRead - curRead;\n                       toRead \u003d pendingRead \u003e buf.length ? buf.length\n                           : (int) pendingRead;\n                       len \u003d valueStream.read(buf, 0, toRead);\n                     }\n+                    org.apache.hadoop.io.IOUtils.skipFully(\n+                        valueStream, skipAfterRead);\n                     sb \u003d new StringBuilder();\n                     sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n                     b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                     os.write(b, 0, b.length);\n                     findLogs \u003d true;\n                   } else {\n                     long totalSkipped \u003d 0;\n                     long currSkipped \u003d 0;\n                     while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n                       currSkipped \u003d valueStream.skip(\n                           fileLength - totalSkipped);\n                       totalSkipped +\u003d currSkipped;\n                     }\n                   }\n                 } catch (EOFException eof) {\n                   break;\n                 }\n               }\n             } finally {\n               if (reader !\u003d null) {\n                 reader.close();\n               }\n             }\n           }\n         }\n         os.flush();\n         if (!findLogs) {\n           throw new IOException(\"Can not find logs for container:\"\n               + containerIdStr);\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public void write(OutputStream os) throws IOException,\n          WebApplicationException {\n        byte[] buf \u003d new byte[65535];\n        boolean findLogs \u003d false;\n        while (nodeFiles.hasNext()) {\n          final FileStatus thisNodeFile \u003d nodeFiles.next();\n          String nodeName \u003d thisNodeFile.getPath().getName();\n          if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n              .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n              LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            AggregatedLogFormat.LogReader reader \u003d null;\n            try {\n              reader \u003d new AggregatedLogFormat.LogReader(conf,\n                  thisNodeFile.getPath());\n              DataInputStream valueStream;\n              LogKey key \u003d new LogKey();\n              valueStream \u003d reader.next(key);\n              while (valueStream !\u003d null \u0026\u0026 !key.toString()\n                  .equals(containerIdStr)) {\n                // Next container\n                key \u003d new LogKey();\n                valueStream \u003d reader.next(key);\n              }\n              if (valueStream \u003d\u003d null) {\n                continue;\n              }\n              while (true) {\n                try {\n                  String fileType \u003d valueStream.readUTF();\n                  String fileLengthStr \u003d valueStream.readUTF();\n                  long fileLength \u003d Long.parseLong(fileLengthStr);\n                  if (fileType.equalsIgnoreCase(logFile)) {\n                    StringBuilder sb \u003d new StringBuilder();\n                    sb.append(\"LogType:\");\n                    sb.append(fileType + \"\\n\");\n                    sb.append(\"Log Upload Time:\");\n                    sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n                    sb.append(\"LogLength:\");\n                    sb.append(fileLengthStr + \"\\n\");\n                    sb.append(\"Log Contents:\\n\");\n                    byte[] b \u003d sb.toString().getBytes(\n                        Charset.forName(\"UTF-8\"));\n                    os.write(b, 0, b.length);\n\n                    long toSkip \u003d 0;\n                    long totalBytesToRead \u003d fileLength;\n                    long skipAfterRead \u003d 0;\n                    if (bytes \u003c 0) {\n                      long absBytes \u003d Math.abs(bytes);\n                      if (absBytes \u003c fileLength) {\n                        toSkip \u003d fileLength - absBytes;\n                        totalBytesToRead \u003d absBytes;\n                      }\n                      org.apache.hadoop.io.IOUtils.skipFully(\n                          valueStream, toSkip);\n                    } else {\n                      if (bytes \u003c fileLength) {\n                        totalBytesToRead \u003d bytes;\n                        skipAfterRead \u003d fileLength - bytes;\n                      }\n                    }\n\n                    long curRead \u003d 0;\n                    long pendingRead \u003d totalBytesToRead - curRead;\n                    int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                        : (int) pendingRead;\n                    int len \u003d valueStream.read(buf, 0, toRead);\n                    while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n                      os.write(buf, 0, len);\n                      curRead +\u003d len;\n\n                      pendingRead \u003d totalBytesToRead - curRead;\n                      toRead \u003d pendingRead \u003e buf.length ? buf.length\n                          : (int) pendingRead;\n                      len \u003d valueStream.read(buf, 0, toRead);\n                    }\n                    org.apache.hadoop.io.IOUtils.skipFully(\n                        valueStream, skipAfterRead);\n                    sb \u003d new StringBuilder();\n                    sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n                    b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                    os.write(b, 0, b.length);\n                    findLogs \u003d true;\n                  } else {\n                    long totalSkipped \u003d 0;\n                    long currSkipped \u003d 0;\n                    while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n                      currSkipped \u003d valueStream.skip(\n                          fileLength - totalSkipped);\n                      totalSkipped +\u003d currSkipped;\n                    }\n                  }\n                } catch (EOFException eof) {\n                  break;\n                }\n              }\n            } finally {\n              if (reader !\u003d null) {\n                reader.close();\n              }\n            }\n          }\n        }\n        os.flush();\n        if (!findLogs) {\n          throw new IOException(\"Can not find logs for container:\"\n              + containerIdStr);\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java",
      "extendedDetails": {}
    },
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5199. Close LogReader in in AHSWebServices#getStreamingOutput and\nFileInputStream in NMWebServices#getLogs. Contributed by Xuan Gong\n",
      "commitDate": "07/06/16 4:07 PM",
      "commitName": "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
      "commitAuthor": "Xuan",
      "commitDateOld": "01/06/16 1:44 PM",
      "commitNameOld": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,108 @@\n       public void write(OutputStream os) throws IOException,\n           WebApplicationException {\n         byte[] buf \u003d new byte[65535];\n         boolean findLogs \u003d false;\n         while (nodeFiles.hasNext()) {\n           final FileStatus thisNodeFile \u003d nodeFiles.next();\n           String nodeName \u003d thisNodeFile.getPath().getName();\n           if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n               .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n               LogAggregationUtils.TMP_FILE_SUFFIX)) {\n-            AggregatedLogFormat.LogReader reader \u003d\n-                new AggregatedLogFormat.LogReader(conf,\n-                    thisNodeFile.getPath());\n-            DataInputStream valueStream;\n-            LogKey key \u003d new LogKey();\n-            valueStream \u003d reader.next(key);\n-            while (valueStream !\u003d null \u0026\u0026 !key.toString()\n-                .equals(containerIdStr)) {\n-              // Next container\n-              key \u003d new LogKey();\n+            AggregatedLogFormat.LogReader reader \u003d null;\n+            try {\n+              reader \u003d new AggregatedLogFormat.LogReader(conf,\n+                  thisNodeFile.getPath());\n+              DataInputStream valueStream;\n+              LogKey key \u003d new LogKey();\n               valueStream \u003d reader.next(key);\n-            }\n-            if (valueStream \u003d\u003d null) {\n-              continue;\n-            }\n-            while (true) {\n-              try {\n-                String fileType \u003d valueStream.readUTF();\n-                String fileLengthStr \u003d valueStream.readUTF();\n-                long fileLength \u003d Long.parseLong(fileLengthStr);\n-                if (fileType.equalsIgnoreCase(logFile)) {\n-                  StringBuilder sb \u003d new StringBuilder();\n-                  sb.append(\"LogType:\");\n-                  sb.append(fileType + \"\\n\");\n-                  sb.append(\"Log Upload Time:\");\n-                  sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n-                  sb.append(\"LogLength:\");\n-                  sb.append(fileLengthStr + \"\\n\");\n-                  sb.append(\"Log Contents:\\n\");\n-                  byte[] b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n-                  os.write(b, 0, b.length);\n+              while (valueStream !\u003d null \u0026\u0026 !key.toString()\n+                  .equals(containerIdStr)) {\n+                // Next container\n+                key \u003d new LogKey();\n+                valueStream \u003d reader.next(key);\n+              }\n+              if (valueStream \u003d\u003d null) {\n+                continue;\n+              }\n+              while (true) {\n+                try {\n+                  String fileType \u003d valueStream.readUTF();\n+                  String fileLengthStr \u003d valueStream.readUTF();\n+                  long fileLength \u003d Long.parseLong(fileLengthStr);\n+                  if (fileType.equalsIgnoreCase(logFile)) {\n+                    StringBuilder sb \u003d new StringBuilder();\n+                    sb.append(\"LogType:\");\n+                    sb.append(fileType + \"\\n\");\n+                    sb.append(\"Log Upload Time:\");\n+                    sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n+                    sb.append(\"LogLength:\");\n+                    sb.append(fileLengthStr + \"\\n\");\n+                    sb.append(\"Log Contents:\\n\");\n+                    byte[] b \u003d sb.toString().getBytes(\n+                        Charset.forName(\"UTF-8\"));\n+                    os.write(b, 0, b.length);\n \n-                  long toSkip \u003d 0;\n-                  long totalBytesToRead \u003d fileLength;\n-                  if (bytes \u003c 0) {\n-                    long absBytes \u003d Math.abs(bytes);\n-                    if (absBytes \u003c fileLength) {\n-                      toSkip \u003d fileLength - absBytes;\n-                      totalBytesToRead \u003d absBytes;\n+                    long toSkip \u003d 0;\n+                    long totalBytesToRead \u003d fileLength;\n+                    if (bytes \u003c 0) {\n+                      long absBytes \u003d Math.abs(bytes);\n+                      if (absBytes \u003c fileLength) {\n+                        toSkip \u003d fileLength - absBytes;\n+                        totalBytesToRead \u003d absBytes;\n+                      }\n+                      long skippedBytes \u003d valueStream.skip(toSkip);\n+                      if (skippedBytes !\u003d toSkip) {\n+                        throw new IOException(\"The bytes were skipped are \"\n+                            + \"different from the caller requested\");\n+                      }\n+                    } else {\n+                      if (bytes \u003c fileLength) {\n+                        totalBytesToRead \u003d bytes;\n+                      }\n                     }\n-                    long skippedBytes \u003d valueStream.skip(toSkip);\n-                    if (skippedBytes !\u003d toSkip) {\n-                      throw new IOException(\"The bytes were skipped are \"\n-                          + \"different from the caller requested\");\n-                    }\n-                  } else {\n-                    if (bytes \u003c fileLength) {\n-                      totalBytesToRead \u003d bytes;\n-                    }\n-                  }\n \n-                  long curRead \u003d 0;\n-                  long pendingRead \u003d totalBytesToRead - curRead;\n-                  int toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                      : (int) pendingRead;\n-                  int len \u003d valueStream.read(buf, 0, toRead);\n-                  while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n-                    os.write(buf, 0, len);\n-                    curRead +\u003d len;\n-\n-                    pendingRead \u003d totalBytesToRead - curRead;\n-                    toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                    long curRead \u003d 0;\n+                    long pendingRead \u003d totalBytesToRead - curRead;\n+                    int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                         : (int) pendingRead;\n-                    len \u003d valueStream.read(buf, 0, toRead);\n+                    int len \u003d valueStream.read(buf, 0, toRead);\n+                    while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n+                      os.write(buf, 0, len);\n+                      curRead +\u003d len;\n+\n+                      pendingRead \u003d totalBytesToRead - curRead;\n+                      toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                          : (int) pendingRead;\n+                      len \u003d valueStream.read(buf, 0, toRead);\n+                    }\n+                    sb \u003d new StringBuilder();\n+                    sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n+                    b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n+                    os.write(b, 0, b.length);\n+                    findLogs \u003d true;\n+                  } else {\n+                    long totalSkipped \u003d 0;\n+                    long currSkipped \u003d 0;\n+                    while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n+                      currSkipped \u003d valueStream.skip(\n+                          fileLength - totalSkipped);\n+                      totalSkipped +\u003d currSkipped;\n+                    }\n                   }\n-                  sb \u003d new StringBuilder();\n-                  sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n-                  b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n-                  os.write(b, 0, b.length);\n-                  findLogs \u003d true;\n-                } else {\n-                  long totalSkipped \u003d 0;\n-                  long currSkipped \u003d 0;\n-                  while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n-                    currSkipped \u003d valueStream.skip(fileLength - totalSkipped);\n-                    totalSkipped +\u003d currSkipped;\n-                  }\n+                } catch (EOFException eof) {\n+                  break;\n                 }\n-              } catch (EOFException eof) {\n-                break;\n+              }\n+            } finally {\n+              if (reader !\u003d null) {\n+                reader.close();\n               }\n             }\n           }\n         }\n         os.flush();\n         if (!findLogs) {\n           throw new IOException(\"Can not find logs for container:\"\n               + containerIdStr);\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public void write(OutputStream os) throws IOException,\n          WebApplicationException {\n        byte[] buf \u003d new byte[65535];\n        boolean findLogs \u003d false;\n        while (nodeFiles.hasNext()) {\n          final FileStatus thisNodeFile \u003d nodeFiles.next();\n          String nodeName \u003d thisNodeFile.getPath().getName();\n          if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n              .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n              LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            AggregatedLogFormat.LogReader reader \u003d null;\n            try {\n              reader \u003d new AggregatedLogFormat.LogReader(conf,\n                  thisNodeFile.getPath());\n              DataInputStream valueStream;\n              LogKey key \u003d new LogKey();\n              valueStream \u003d reader.next(key);\n              while (valueStream !\u003d null \u0026\u0026 !key.toString()\n                  .equals(containerIdStr)) {\n                // Next container\n                key \u003d new LogKey();\n                valueStream \u003d reader.next(key);\n              }\n              if (valueStream \u003d\u003d null) {\n                continue;\n              }\n              while (true) {\n                try {\n                  String fileType \u003d valueStream.readUTF();\n                  String fileLengthStr \u003d valueStream.readUTF();\n                  long fileLength \u003d Long.parseLong(fileLengthStr);\n                  if (fileType.equalsIgnoreCase(logFile)) {\n                    StringBuilder sb \u003d new StringBuilder();\n                    sb.append(\"LogType:\");\n                    sb.append(fileType + \"\\n\");\n                    sb.append(\"Log Upload Time:\");\n                    sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n                    sb.append(\"LogLength:\");\n                    sb.append(fileLengthStr + \"\\n\");\n                    sb.append(\"Log Contents:\\n\");\n                    byte[] b \u003d sb.toString().getBytes(\n                        Charset.forName(\"UTF-8\"));\n                    os.write(b, 0, b.length);\n\n                    long toSkip \u003d 0;\n                    long totalBytesToRead \u003d fileLength;\n                    if (bytes \u003c 0) {\n                      long absBytes \u003d Math.abs(bytes);\n                      if (absBytes \u003c fileLength) {\n                        toSkip \u003d fileLength - absBytes;\n                        totalBytesToRead \u003d absBytes;\n                      }\n                      long skippedBytes \u003d valueStream.skip(toSkip);\n                      if (skippedBytes !\u003d toSkip) {\n                        throw new IOException(\"The bytes were skipped are \"\n                            + \"different from the caller requested\");\n                      }\n                    } else {\n                      if (bytes \u003c fileLength) {\n                        totalBytesToRead \u003d bytes;\n                      }\n                    }\n\n                    long curRead \u003d 0;\n                    long pendingRead \u003d totalBytesToRead - curRead;\n                    int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                        : (int) pendingRead;\n                    int len \u003d valueStream.read(buf, 0, toRead);\n                    while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n                      os.write(buf, 0, len);\n                      curRead +\u003d len;\n\n                      pendingRead \u003d totalBytesToRead - curRead;\n                      toRead \u003d pendingRead \u003e buf.length ? buf.length\n                          : (int) pendingRead;\n                      len \u003d valueStream.read(buf, 0, toRead);\n                    }\n                    sb \u003d new StringBuilder();\n                    sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n                    b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                    os.write(b, 0, b.length);\n                    findLogs \u003d true;\n                  } else {\n                    long totalSkipped \u003d 0;\n                    long currSkipped \u003d 0;\n                    while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n                      currSkipped \u003d valueStream.skip(\n                          fileLength - totalSkipped);\n                      totalSkipped +\u003d currSkipped;\n                    }\n                  }\n                } catch (EOFException eof) {\n                  break;\n                }\n              }\n            } finally {\n              if (reader !\u003d null) {\n                reader.close();\n              }\n            }\n          }\n        }\n        os.flush();\n        if (!findLogs) {\n          throw new IOException(\"Can not find logs for container:\"\n              + containerIdStr);\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java",
      "extendedDetails": {}
    },
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5088. Improve \"yarn log\" command-line to read the last K bytes for the log files. Contributed by Xuan Gong\n",
      "commitDate": "01/06/16 1:44 PM",
      "commitName": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthor": "Xuan",
      "commitDateOld": "25/05/16 6:31 AM",
      "commitNameOld": "9a31e5dfef42929951d305f31200ca4f80d86632",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 7.3,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,100 @@\n       public void write(OutputStream os) throws IOException,\n           WebApplicationException {\n         byte[] buf \u003d new byte[65535];\n         boolean findLogs \u003d false;\n         while (nodeFiles.hasNext()) {\n           final FileStatus thisNodeFile \u003d nodeFiles.next();\n           String nodeName \u003d thisNodeFile.getPath().getName();\n           if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n               .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n               LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             AggregatedLogFormat.LogReader reader \u003d\n                 new AggregatedLogFormat.LogReader(conf,\n                     thisNodeFile.getPath());\n             DataInputStream valueStream;\n             LogKey key \u003d new LogKey();\n             valueStream \u003d reader.next(key);\n             while (valueStream !\u003d null \u0026\u0026 !key.toString()\n                 .equals(containerIdStr)) {\n               // Next container\n               key \u003d new LogKey();\n               valueStream \u003d reader.next(key);\n             }\n             if (valueStream \u003d\u003d null) {\n               continue;\n             }\n             while (true) {\n               try {\n                 String fileType \u003d valueStream.readUTF();\n                 String fileLengthStr \u003d valueStream.readUTF();\n                 long fileLength \u003d Long.parseLong(fileLengthStr);\n                 if (fileType.equalsIgnoreCase(logFile)) {\n                   StringBuilder sb \u003d new StringBuilder();\n                   sb.append(\"LogType:\");\n                   sb.append(fileType + \"\\n\");\n                   sb.append(\"Log Upload Time:\");\n                   sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n                   sb.append(\"LogLength:\");\n                   sb.append(fileLengthStr + \"\\n\");\n                   sb.append(\"Log Contents:\\n\");\n                   byte[] b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                   os.write(b, 0, b.length);\n \n+                  long toSkip \u003d 0;\n+                  long totalBytesToRead \u003d fileLength;\n+                  if (bytes \u003c 0) {\n+                    long absBytes \u003d Math.abs(bytes);\n+                    if (absBytes \u003c fileLength) {\n+                      toSkip \u003d fileLength - absBytes;\n+                      totalBytesToRead \u003d absBytes;\n+                    }\n+                    long skippedBytes \u003d valueStream.skip(toSkip);\n+                    if (skippedBytes !\u003d toSkip) {\n+                      throw new IOException(\"The bytes were skipped are \"\n+                          + \"different from the caller requested\");\n+                    }\n+                  } else {\n+                    if (bytes \u003c fileLength) {\n+                      totalBytesToRead \u003d bytes;\n+                    }\n+                  }\n+\n                   long curRead \u003d 0;\n-                  long pendingRead \u003d fileLength - curRead;\n+                  long pendingRead \u003d totalBytesToRead - curRead;\n                   int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                       : (int) pendingRead;\n                   int len \u003d valueStream.read(buf, 0, toRead);\n-                  while (len !\u003d -1 \u0026\u0026 curRead \u003c fileLength) {\n+                  while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n                     os.write(buf, 0, len);\n                     curRead +\u003d len;\n \n-                    pendingRead \u003d fileLength - curRead;\n+                    pendingRead \u003d totalBytesToRead - curRead;\n                     toRead \u003d pendingRead \u003e buf.length ? buf.length\n                         : (int) pendingRead;\n                     len \u003d valueStream.read(buf, 0, toRead);\n                   }\n                   sb \u003d new StringBuilder();\n                   sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n                   b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                   os.write(b, 0, b.length);\n                   findLogs \u003d true;\n                 } else {\n                   long totalSkipped \u003d 0;\n                   long currSkipped \u003d 0;\n                   while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n                     currSkipped \u003d valueStream.skip(fileLength - totalSkipped);\n                     totalSkipped +\u003d currSkipped;\n                   }\n                 }\n               } catch (EOFException eof) {\n                 break;\n               }\n             }\n           }\n         }\n         os.flush();\n         if (!findLogs) {\n           throw new IOException(\"Can not find logs for container:\"\n               + containerIdStr);\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public void write(OutputStream os) throws IOException,\n          WebApplicationException {\n        byte[] buf \u003d new byte[65535];\n        boolean findLogs \u003d false;\n        while (nodeFiles.hasNext()) {\n          final FileStatus thisNodeFile \u003d nodeFiles.next();\n          String nodeName \u003d thisNodeFile.getPath().getName();\n          if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n              .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n              LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            AggregatedLogFormat.LogReader reader \u003d\n                new AggregatedLogFormat.LogReader(conf,\n                    thisNodeFile.getPath());\n            DataInputStream valueStream;\n            LogKey key \u003d new LogKey();\n            valueStream \u003d reader.next(key);\n            while (valueStream !\u003d null \u0026\u0026 !key.toString()\n                .equals(containerIdStr)) {\n              // Next container\n              key \u003d new LogKey();\n              valueStream \u003d reader.next(key);\n            }\n            if (valueStream \u003d\u003d null) {\n              continue;\n            }\n            while (true) {\n              try {\n                String fileType \u003d valueStream.readUTF();\n                String fileLengthStr \u003d valueStream.readUTF();\n                long fileLength \u003d Long.parseLong(fileLengthStr);\n                if (fileType.equalsIgnoreCase(logFile)) {\n                  StringBuilder sb \u003d new StringBuilder();\n                  sb.append(\"LogType:\");\n                  sb.append(fileType + \"\\n\");\n                  sb.append(\"Log Upload Time:\");\n                  sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n                  sb.append(\"LogLength:\");\n                  sb.append(fileLengthStr + \"\\n\");\n                  sb.append(\"Log Contents:\\n\");\n                  byte[] b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                  os.write(b, 0, b.length);\n\n                  long toSkip \u003d 0;\n                  long totalBytesToRead \u003d fileLength;\n                  if (bytes \u003c 0) {\n                    long absBytes \u003d Math.abs(bytes);\n                    if (absBytes \u003c fileLength) {\n                      toSkip \u003d fileLength - absBytes;\n                      totalBytesToRead \u003d absBytes;\n                    }\n                    long skippedBytes \u003d valueStream.skip(toSkip);\n                    if (skippedBytes !\u003d toSkip) {\n                      throw new IOException(\"The bytes were skipped are \"\n                          + \"different from the caller requested\");\n                    }\n                  } else {\n                    if (bytes \u003c fileLength) {\n                      totalBytesToRead \u003d bytes;\n                    }\n                  }\n\n                  long curRead \u003d 0;\n                  long pendingRead \u003d totalBytesToRead - curRead;\n                  int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                      : (int) pendingRead;\n                  int len \u003d valueStream.read(buf, 0, toRead);\n                  while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n                    os.write(buf, 0, len);\n                    curRead +\u003d len;\n\n                    pendingRead \u003d totalBytesToRead - curRead;\n                    toRead \u003d pendingRead \u003e buf.length ? buf.length\n                        : (int) pendingRead;\n                    len \u003d valueStream.read(buf, 0, toRead);\n                  }\n                  sb \u003d new StringBuilder();\n                  sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n                  b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                  os.write(b, 0, b.length);\n                  findLogs \u003d true;\n                } else {\n                  long totalSkipped \u003d 0;\n                  long currSkipped \u003d 0;\n                  while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n                    currSkipped \u003d valueStream.skip(fileLength - totalSkipped);\n                    totalSkipped +\u003d currSkipped;\n                  }\n                }\n              } catch (EOFException eof) {\n                break;\n              }\n            }\n          }\n        }\n        os.flush();\n        if (!findLogs) {\n          throw new IOException(\"Can not find logs for container:\"\n              + containerIdStr);\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java",
      "extendedDetails": {}
    },
    "e61d431275d7fe5641fe9da4903e285b10330fa0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4920. ATS/NM should support a link to dowload/get the logs in text format. Contributed by Xuan Gong.\n",
      "commitDate": "04/05/16 10:35 AM",
      "commitName": "e61d431275d7fe5641fe9da4903e285b10330fa0",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,81 @@\n+      public void write(OutputStream os) throws IOException,\n+          WebApplicationException {\n+        byte[] buf \u003d new byte[65535];\n+        boolean findLogs \u003d false;\n+        while (nodeFiles.hasNext()) {\n+          final FileStatus thisNodeFile \u003d nodeFiles.next();\n+          String nodeName \u003d thisNodeFile.getPath().getName();\n+          if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n+              .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n+              LogAggregationUtils.TMP_FILE_SUFFIX)) {\n+            AggregatedLogFormat.LogReader reader \u003d\n+                new AggregatedLogFormat.LogReader(conf,\n+                    thisNodeFile.getPath());\n+            DataInputStream valueStream;\n+            LogKey key \u003d new LogKey();\n+            valueStream \u003d reader.next(key);\n+            while (valueStream !\u003d null \u0026\u0026 !key.toString()\n+                .equals(containerIdStr)) {\n+              // Next container\n+              key \u003d new LogKey();\n+              valueStream \u003d reader.next(key);\n+            }\n+            if (valueStream \u003d\u003d null) {\n+              continue;\n+            }\n+            while (true) {\n+              try {\n+                String fileType \u003d valueStream.readUTF();\n+                String fileLengthStr \u003d valueStream.readUTF();\n+                long fileLength \u003d Long.parseLong(fileLengthStr);\n+                if (fileType.equalsIgnoreCase(logFile)) {\n+                  StringBuilder sb \u003d new StringBuilder();\n+                  sb.append(\"LogType:\");\n+                  sb.append(fileType + \"\\n\");\n+                  sb.append(\"Log Upload Time:\");\n+                  sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n+                  sb.append(\"LogLength:\");\n+                  sb.append(fileLengthStr + \"\\n\");\n+                  sb.append(\"Log Contents:\\n\");\n+                  byte[] b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n+                  os.write(b, 0, b.length);\n+\n+                  long curRead \u003d 0;\n+                  long pendingRead \u003d fileLength - curRead;\n+                  int toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                      : (int) pendingRead;\n+                  int len \u003d valueStream.read(buf, 0, toRead);\n+                  while (len !\u003d -1 \u0026\u0026 curRead \u003c fileLength) {\n+                    os.write(buf, 0, len);\n+                    curRead +\u003d len;\n+\n+                    pendingRead \u003d fileLength - curRead;\n+                    toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                        : (int) pendingRead;\n+                    len \u003d valueStream.read(buf, 0, toRead);\n+                  }\n+                  sb \u003d new StringBuilder();\n+                  sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n+                  b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n+                  os.write(b, 0, b.length);\n+                  findLogs \u003d true;\n+                } else {\n+                  long totalSkipped \u003d 0;\n+                  long currSkipped \u003d 0;\n+                  while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n+                    currSkipped \u003d valueStream.skip(fileLength - totalSkipped);\n+                    totalSkipped +\u003d currSkipped;\n+                  }\n+                }\n+              } catch (EOFException eof) {\n+                break;\n+              }\n+            }\n+          }\n+        }\n+        os.flush();\n+        if (!findLogs) {\n+          throw new IOException(\"Can not find logs for container:\"\n+              + containerIdStr);\n+        }\n+      }\n\\ No newline at end of file\n",
      "actualSource": "      public void write(OutputStream os) throws IOException,\n          WebApplicationException {\n        byte[] buf \u003d new byte[65535];\n        boolean findLogs \u003d false;\n        while (nodeFiles.hasNext()) {\n          final FileStatus thisNodeFile \u003d nodeFiles.next();\n          String nodeName \u003d thisNodeFile.getPath().getName();\n          if ((nodeId \u003d\u003d null || nodeName.contains(LogAggregationUtils\n              .getNodeString(nodeId))) \u0026\u0026 !nodeName.endsWith(\n              LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            AggregatedLogFormat.LogReader reader \u003d\n                new AggregatedLogFormat.LogReader(conf,\n                    thisNodeFile.getPath());\n            DataInputStream valueStream;\n            LogKey key \u003d new LogKey();\n            valueStream \u003d reader.next(key);\n            while (valueStream !\u003d null \u0026\u0026 !key.toString()\n                .equals(containerIdStr)) {\n              // Next container\n              key \u003d new LogKey();\n              valueStream \u003d reader.next(key);\n            }\n            if (valueStream \u003d\u003d null) {\n              continue;\n            }\n            while (true) {\n              try {\n                String fileType \u003d valueStream.readUTF();\n                String fileLengthStr \u003d valueStream.readUTF();\n                long fileLength \u003d Long.parseLong(fileLengthStr);\n                if (fileType.equalsIgnoreCase(logFile)) {\n                  StringBuilder sb \u003d new StringBuilder();\n                  sb.append(\"LogType:\");\n                  sb.append(fileType + \"\\n\");\n                  sb.append(\"Log Upload Time:\");\n                  sb.append(Times.format(System.currentTimeMillis()) + \"\\n\");\n                  sb.append(\"LogLength:\");\n                  sb.append(fileLengthStr + \"\\n\");\n                  sb.append(\"Log Contents:\\n\");\n                  byte[] b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                  os.write(b, 0, b.length);\n\n                  long curRead \u003d 0;\n                  long pendingRead \u003d fileLength - curRead;\n                  int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                      : (int) pendingRead;\n                  int len \u003d valueStream.read(buf, 0, toRead);\n                  while (len !\u003d -1 \u0026\u0026 curRead \u003c fileLength) {\n                    os.write(buf, 0, len);\n                    curRead +\u003d len;\n\n                    pendingRead \u003d fileLength - curRead;\n                    toRead \u003d pendingRead \u003e buf.length ? buf.length\n                        : (int) pendingRead;\n                    len \u003d valueStream.read(buf, 0, toRead);\n                  }\n                  sb \u003d new StringBuilder();\n                  sb.append(\"\\nEnd of LogType:\" + fileType + \"\\n\");\n                  b \u003d sb.toString().getBytes(Charset.forName(\"UTF-8\"));\n                  os.write(b, 0, b.length);\n                  findLogs \u003d true;\n                } else {\n                  long totalSkipped \u003d 0;\n                  long currSkipped \u003d 0;\n                  while (currSkipped !\u003d -1 \u0026\u0026 totalSkipped \u003c fileLength) {\n                    currSkipped \u003d valueStream.skip(fileLength - totalSkipped);\n                    totalSkipped +\u003d currSkipped;\n                  }\n                }\n              } catch (EOFException eof) {\n                break;\n              }\n            }\n          }\n        }\n        os.flush();\n        if (!findLogs) {\n          throw new IOException(\"Can not find logs for container:\"\n              + containerIdStr);\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/webapp/AHSWebServices.java"
    }
  }
}