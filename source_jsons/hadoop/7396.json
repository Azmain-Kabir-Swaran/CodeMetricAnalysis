{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TransferFsImage.java",
  "functionName": "copyFileToStream",
  "functionId": "copyFileToStream___out-OutputStream__localfile-File__infile-FileInputStream__throttler-DataTransferThrottler__canceler-Canceler",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
  "functionStartLine": 358,
  "functionEndLine": 422,
  "numCommitsSeen": 45,
  "timeTaken": 2386,
  "changeHistory": [
    "6a28a2b914664fbbb5267f13e82d42b3bb49610c",
    "4da8490b512a33a255ed27309860859388d7c168",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "faa4455be512e070fa420084be8d1be5c72f3b08",
    "01af3a31772ee820e932ac70973072e9509a30fa"
  ],
  "changeHistoryShort": {
    "6a28a2b914664fbbb5267f13e82d42b3bb49610c": "Ybodychange",
    "4da8490b512a33a255ed27309860859388d7c168": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "faa4455be512e070fa420084be8d1be5c72f3b08": "Ybodychange",
    "01af3a31772ee820e932ac70973072e9509a30fa": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6a28a2b914664fbbb5267f13e82d42b3bb49610c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11914. Add more diagnosis info for fsimage transfer failure. Contributed by Yongjun Zhang.\n",
      "commitDate": "05/06/17 4:31 PM",
      "commitName": "6a28a2b914664fbbb5267f13e82d42b3bb49610c",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "22/02/17 4:33 PM",
      "commitNameOld": "13d4bcfe3535a2df79c2a56e7578716d15497ff4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 102.96,
      "commitsBetweenForRepo": 580,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,65 @@\n   private static void copyFileToStream(OutputStream out, File localfile,\n       FileInputStream infile, DataTransferThrottler throttler,\n       Canceler canceler) throws IOException {\n     byte buf[] \u003d new byte[IO_FILE_BUFFER_SIZE];\n+    long total \u003d 0;\n+    int num \u003d 1;\n+    IOException ioe \u003d null;\n+    String reportStr \u003d \"Sending fileName: \" + localfile.getAbsolutePath()\n+      + \", fileSize: \" + localfile.length() + \".\";\n     try {\n       CheckpointFaultInjector.getInstance()\n           .aboutToSendFile(localfile);\n \n       if (CheckpointFaultInjector.getInstance().\n             shouldSendShortFile(localfile)) {\n           // Test sending image shorter than localfile\n           long len \u003d localfile.length();\n           buf \u003d new byte[(int)Math.min(len/2, IO_FILE_BUFFER_SIZE)];\n           // This will read at most half of the image\n           // and the rest of the image will be sent over the wire\n           infile.read(buf);\n       }\n-      int num \u003d 1;\n       while (num \u003e 0) {\n         if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n           throw new SaveNamespaceCancelledException(\n             canceler.getCancellationReason());\n         }\n         num \u003d infile.read(buf);\n         if (num \u003c\u003d 0) {\n           break;\n         }\n         if (CheckpointFaultInjector.getInstance()\n               .shouldCorruptAByte(localfile)) {\n           // Simulate a corrupted byte on the wire\n           LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n           buf[0]++;\n         }\n-        \n+\n         out.write(buf, 0, num);\n+        total +\u003d num;\n         if (throttler !\u003d null) {\n           throttler.throttle(num, canceler);\n         }\n       }\n     } catch (EofException e) {\n-      LOG.info(\"Connection closed by client\");\n+      reportStr +\u003d \" Connection closed by client.\";\n+      ioe \u003d e;\n       out \u003d null; // so we don\u0027t close in the finally\n+    } catch (IOException ie) {\n+      ioe \u003d ie;\n+      throw ie;\n     } finally {\n+      reportStr +\u003d \" Sent total: \" + total +\n+          \" bytes. Size of last segment intended to send: \" + num\n+          + \" bytes.\";\n+      if (ioe !\u003d null) {\n+        LOG.info(reportStr, ioe);\n+      } else {\n+        LOG.info(reportStr);\n+      }\n       if (out !\u003d null) {\n         out.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void copyFileToStream(OutputStream out, File localfile,\n      FileInputStream infile, DataTransferThrottler throttler,\n      Canceler canceler) throws IOException {\n    byte buf[] \u003d new byte[IO_FILE_BUFFER_SIZE];\n    long total \u003d 0;\n    int num \u003d 1;\n    IOException ioe \u003d null;\n    String reportStr \u003d \"Sending fileName: \" + localfile.getAbsolutePath()\n      + \", fileSize: \" + localfile.length() + \".\";\n    try {\n      CheckpointFaultInjector.getInstance()\n          .aboutToSendFile(localfile);\n\n      if (CheckpointFaultInjector.getInstance().\n            shouldSendShortFile(localfile)) {\n          // Test sending image shorter than localfile\n          long len \u003d localfile.length();\n          buf \u003d new byte[(int)Math.min(len/2, IO_FILE_BUFFER_SIZE)];\n          // This will read at most half of the image\n          // and the rest of the image will be sent over the wire\n          infile.read(buf);\n      }\n      while (num \u003e 0) {\n        if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n          throw new SaveNamespaceCancelledException(\n            canceler.getCancellationReason());\n        }\n        num \u003d infile.read(buf);\n        if (num \u003c\u003d 0) {\n          break;\n        }\n        if (CheckpointFaultInjector.getInstance()\n              .shouldCorruptAByte(localfile)) {\n          // Simulate a corrupted byte on the wire\n          LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n          buf[0]++;\n        }\n\n        out.write(buf, 0, num);\n        total +\u003d num;\n        if (throttler !\u003d null) {\n          throttler.throttle(num, canceler);\n        }\n      }\n    } catch (EofException e) {\n      reportStr +\u003d \" Connection closed by client.\";\n      ioe \u003d e;\n      out \u003d null; // so we don\u0027t close in the finally\n    } catch (IOException ie) {\n      ioe \u003d ie;\n      throw ie;\n    } finally {\n      reportStr +\u003d \" Sent total: \" + total +\n          \" bytes. Size of last segment intended to send: \" + num\n          + \" bytes.\";\n      if (ioe !\u003d null) {\n        LOG.info(reportStr, ioe);\n      } else {\n        LOG.info(reportStr);\n      }\n      if (out !\u003d null) {\n        out.close();\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "4da8490b512a33a255ed27309860859388d7c168": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8314. Move HdfsServerConstants#IO_FILE_BUFFER_SIZE and SMALL_BUFFER_SIZE to the users. Contributed by Li Lu.\n",
      "commitDate": "05/05/15 3:41 PM",
      "commitName": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   private static void copyFileToStream(OutputStream out, File localfile,\n       FileInputStream infile, DataTransferThrottler throttler,\n       Canceler canceler) throws IOException {\n-    byte buf[] \u003d new byte[HdfsServerConstants.IO_FILE_BUFFER_SIZE];\n+    byte buf[] \u003d new byte[IO_FILE_BUFFER_SIZE];\n     try {\n       CheckpointFaultInjector.getInstance()\n           .aboutToSendFile(localfile);\n \n       if (CheckpointFaultInjector.getInstance().\n             shouldSendShortFile(localfile)) {\n           // Test sending image shorter than localfile\n           long len \u003d localfile.length();\n-          buf \u003d new byte[(int)Math.min(len/2, HdfsServerConstants.IO_FILE_BUFFER_SIZE)];\n+          buf \u003d new byte[(int)Math.min(len/2, IO_FILE_BUFFER_SIZE)];\n           // This will read at most half of the image\n           // and the rest of the image will be sent over the wire\n           infile.read(buf);\n       }\n       int num \u003d 1;\n       while (num \u003e 0) {\n         if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n           throw new SaveNamespaceCancelledException(\n             canceler.getCancellationReason());\n         }\n         num \u003d infile.read(buf);\n         if (num \u003c\u003d 0) {\n           break;\n         }\n         if (CheckpointFaultInjector.getInstance()\n               .shouldCorruptAByte(localfile)) {\n           // Simulate a corrupted byte on the wire\n           LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n           buf[0]++;\n         }\n         \n         out.write(buf, 0, num);\n         if (throttler !\u003d null) {\n           throttler.throttle(num, canceler);\n         }\n       }\n     } catch (EofException e) {\n       LOG.info(\"Connection closed by client\");\n       out \u003d null; // so we don\u0027t close in the finally\n     } finally {\n       if (out !\u003d null) {\n         out.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void copyFileToStream(OutputStream out, File localfile,\n      FileInputStream infile, DataTransferThrottler throttler,\n      Canceler canceler) throws IOException {\n    byte buf[] \u003d new byte[IO_FILE_BUFFER_SIZE];\n    try {\n      CheckpointFaultInjector.getInstance()\n          .aboutToSendFile(localfile);\n\n      if (CheckpointFaultInjector.getInstance().\n            shouldSendShortFile(localfile)) {\n          // Test sending image shorter than localfile\n          long len \u003d localfile.length();\n          buf \u003d new byte[(int)Math.min(len/2, IO_FILE_BUFFER_SIZE)];\n          // This will read at most half of the image\n          // and the rest of the image will be sent over the wire\n          infile.read(buf);\n      }\n      int num \u003d 1;\n      while (num \u003e 0) {\n        if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n          throw new SaveNamespaceCancelledException(\n            canceler.getCancellationReason());\n        }\n        num \u003d infile.read(buf);\n        if (num \u003c\u003d 0) {\n          break;\n        }\n        if (CheckpointFaultInjector.getInstance()\n              .shouldCorruptAByte(localfile)) {\n          // Simulate a corrupted byte on the wire\n          LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n          buf[0]++;\n        }\n        \n        out.write(buf, 0, num);\n        if (throttler !\u003d null) {\n          throttler.throttle(num, canceler);\n        }\n      }\n    } catch (EofException e) {\n      LOG.info(\"Connection closed by client\");\n      out \u003d null; // so we don\u0027t close in the finally\n    } finally {\n      if (out !\u003d null) {\n        out.close();\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/03/15 3:35 PM",
      "commitNameOld": "c5eac9c6fe937ff32f4efed89d34c06974fac4d6",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 60.73,
      "commitsBetweenForRepo": 538,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   private static void copyFileToStream(OutputStream out, File localfile,\n       FileInputStream infile, DataTransferThrottler throttler,\n       Canceler canceler) throws IOException {\n-    byte buf[] \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n+    byte buf[] \u003d new byte[HdfsServerConstants.IO_FILE_BUFFER_SIZE];\n     try {\n       CheckpointFaultInjector.getInstance()\n           .aboutToSendFile(localfile);\n \n       if (CheckpointFaultInjector.getInstance().\n             shouldSendShortFile(localfile)) {\n           // Test sending image shorter than localfile\n           long len \u003d localfile.length();\n-          buf \u003d new byte[(int)Math.min(len/2, HdfsConstants.IO_FILE_BUFFER_SIZE)];\n+          buf \u003d new byte[(int)Math.min(len/2, HdfsServerConstants.IO_FILE_BUFFER_SIZE)];\n           // This will read at most half of the image\n           // and the rest of the image will be sent over the wire\n           infile.read(buf);\n       }\n       int num \u003d 1;\n       while (num \u003e 0) {\n         if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n           throw new SaveNamespaceCancelledException(\n             canceler.getCancellationReason());\n         }\n         num \u003d infile.read(buf);\n         if (num \u003c\u003d 0) {\n           break;\n         }\n         if (CheckpointFaultInjector.getInstance()\n               .shouldCorruptAByte(localfile)) {\n           // Simulate a corrupted byte on the wire\n           LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n           buf[0]++;\n         }\n         \n         out.write(buf, 0, num);\n         if (throttler !\u003d null) {\n           throttler.throttle(num, canceler);\n         }\n       }\n     } catch (EofException e) {\n       LOG.info(\"Connection closed by client\");\n       out \u003d null; // so we don\u0027t close in the finally\n     } finally {\n       if (out !\u003d null) {\n         out.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void copyFileToStream(OutputStream out, File localfile,\n      FileInputStream infile, DataTransferThrottler throttler,\n      Canceler canceler) throws IOException {\n    byte buf[] \u003d new byte[HdfsServerConstants.IO_FILE_BUFFER_SIZE];\n    try {\n      CheckpointFaultInjector.getInstance()\n          .aboutToSendFile(localfile);\n\n      if (CheckpointFaultInjector.getInstance().\n            shouldSendShortFile(localfile)) {\n          // Test sending image shorter than localfile\n          long len \u003d localfile.length();\n          buf \u003d new byte[(int)Math.min(len/2, HdfsServerConstants.IO_FILE_BUFFER_SIZE)];\n          // This will read at most half of the image\n          // and the rest of the image will be sent over the wire\n          infile.read(buf);\n      }\n      int num \u003d 1;\n      while (num \u003e 0) {\n        if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n          throw new SaveNamespaceCancelledException(\n            canceler.getCancellationReason());\n        }\n        num \u003d infile.read(buf);\n        if (num \u003c\u003d 0) {\n          break;\n        }\n        if (CheckpointFaultInjector.getInstance()\n              .shouldCorruptAByte(localfile)) {\n          // Simulate a corrupted byte on the wire\n          LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n          buf[0]++;\n        }\n        \n        out.write(buf, 0, num);\n        if (throttler !\u003d null) {\n          throttler.throttle(num, canceler);\n        }\n      }\n    } catch (EofException e) {\n      LOG.info(\"Connection closed by client\");\n      out \u003d null; // so we don\u0027t close in the finally\n    } finally {\n      if (out !\u003d null) {\n        out.close();\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "faa4455be512e070fa420084be8d1be5c72f3b08": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6634. inotify in HDFS. Contributed by James Thomas.\n",
      "commitDate": "02/09/14 2:02 PM",
      "commitName": "faa4455be512e070fa420084be8d1be5c72f3b08",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "28/05/14 2:24 PM",
      "commitNameOld": "66c5bcfc6df4dfe824b664be302f5ee3193b7187",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 96.98,
      "commitsBetweenForRepo": 735,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,48 @@\n   private static void copyFileToStream(OutputStream out, File localfile,\n       FileInputStream infile, DataTransferThrottler throttler,\n       Canceler canceler) throws IOException {\n     byte buf[] \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n     try {\n       CheckpointFaultInjector.getInstance()\n           .aboutToSendFile(localfile);\n \n       if (CheckpointFaultInjector.getInstance().\n             shouldSendShortFile(localfile)) {\n           // Test sending image shorter than localfile\n           long len \u003d localfile.length();\n           buf \u003d new byte[(int)Math.min(len/2, HdfsConstants.IO_FILE_BUFFER_SIZE)];\n           // This will read at most half of the image\n           // and the rest of the image will be sent over the wire\n           infile.read(buf);\n       }\n       int num \u003d 1;\n       while (num \u003e 0) {\n         if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n           throw new SaveNamespaceCancelledException(\n             canceler.getCancellationReason());\n         }\n         num \u003d infile.read(buf);\n         if (num \u003c\u003d 0) {\n           break;\n         }\n         if (CheckpointFaultInjector.getInstance()\n               .shouldCorruptAByte(localfile)) {\n           // Simulate a corrupted byte on the wire\n           LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n           buf[0]++;\n         }\n         \n         out.write(buf, 0, num);\n         if (throttler !\u003d null) {\n           throttler.throttle(num, canceler);\n         }\n       }\n+    } catch (EofException e) {\n+      LOG.info(\"Connection closed by client\");\n+      out \u003d null; // so we don\u0027t close in the finally\n     } finally {\n       if (out !\u003d null) {\n         out.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void copyFileToStream(OutputStream out, File localfile,\n      FileInputStream infile, DataTransferThrottler throttler,\n      Canceler canceler) throws IOException {\n    byte buf[] \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n    try {\n      CheckpointFaultInjector.getInstance()\n          .aboutToSendFile(localfile);\n\n      if (CheckpointFaultInjector.getInstance().\n            shouldSendShortFile(localfile)) {\n          // Test sending image shorter than localfile\n          long len \u003d localfile.length();\n          buf \u003d new byte[(int)Math.min(len/2, HdfsConstants.IO_FILE_BUFFER_SIZE)];\n          // This will read at most half of the image\n          // and the rest of the image will be sent over the wire\n          infile.read(buf);\n      }\n      int num \u003d 1;\n      while (num \u003e 0) {\n        if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n          throw new SaveNamespaceCancelledException(\n            canceler.getCancellationReason());\n        }\n        num \u003d infile.read(buf);\n        if (num \u003c\u003d 0) {\n          break;\n        }\n        if (CheckpointFaultInjector.getInstance()\n              .shouldCorruptAByte(localfile)) {\n          // Simulate a corrupted byte on the wire\n          LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n          buf[0]++;\n        }\n        \n        out.write(buf, 0, num);\n        if (throttler !\u003d null) {\n          throttler.throttle(num, canceler);\n        }\n      }\n    } catch (EofException e) {\n      LOG.info(\"Connection closed by client\");\n      out \u003d null; // so we don\u0027t close in the finally\n    } finally {\n      if (out !\u003d null) {\n        out.close();\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "01af3a31772ee820e932ac70973072e9509a30fa": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6243. HA NameNode transition to active or shutdown may leave lingering image transfer thread. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1587410 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/04/14 9:49 PM",
      "commitName": "01af3a31772ee820e932ac70973072e9509a30fa",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,45 @@\n+  private static void copyFileToStream(OutputStream out, File localfile,\n+      FileInputStream infile, DataTransferThrottler throttler,\n+      Canceler canceler) throws IOException {\n+    byte buf[] \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n+    try {\n+      CheckpointFaultInjector.getInstance()\n+          .aboutToSendFile(localfile);\n+\n+      if (CheckpointFaultInjector.getInstance().\n+            shouldSendShortFile(localfile)) {\n+          // Test sending image shorter than localfile\n+          long len \u003d localfile.length();\n+          buf \u003d new byte[(int)Math.min(len/2, HdfsConstants.IO_FILE_BUFFER_SIZE)];\n+          // This will read at most half of the image\n+          // and the rest of the image will be sent over the wire\n+          infile.read(buf);\n+      }\n+      int num \u003d 1;\n+      while (num \u003e 0) {\n+        if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n+          throw new SaveNamespaceCancelledException(\n+            canceler.getCancellationReason());\n+        }\n+        num \u003d infile.read(buf);\n+        if (num \u003c\u003d 0) {\n+          break;\n+        }\n+        if (CheckpointFaultInjector.getInstance()\n+              .shouldCorruptAByte(localfile)) {\n+          // Simulate a corrupted byte on the wire\n+          LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n+          buf[0]++;\n+        }\n+        \n+        out.write(buf, 0, num);\n+        if (throttler !\u003d null) {\n+          throttler.throttle(num, canceler);\n+        }\n+      }\n+    } finally {\n+      if (out !\u003d null) {\n+        out.close();\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static void copyFileToStream(OutputStream out, File localfile,\n      FileInputStream infile, DataTransferThrottler throttler,\n      Canceler canceler) throws IOException {\n    byte buf[] \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n    try {\n      CheckpointFaultInjector.getInstance()\n          .aboutToSendFile(localfile);\n\n      if (CheckpointFaultInjector.getInstance().\n            shouldSendShortFile(localfile)) {\n          // Test sending image shorter than localfile\n          long len \u003d localfile.length();\n          buf \u003d new byte[(int)Math.min(len/2, HdfsConstants.IO_FILE_BUFFER_SIZE)];\n          // This will read at most half of the image\n          // and the rest of the image will be sent over the wire\n          infile.read(buf);\n      }\n      int num \u003d 1;\n      while (num \u003e 0) {\n        if (canceler !\u003d null \u0026\u0026 canceler.isCancelled()) {\n          throw new SaveNamespaceCancelledException(\n            canceler.getCancellationReason());\n        }\n        num \u003d infile.read(buf);\n        if (num \u003c\u003d 0) {\n          break;\n        }\n        if (CheckpointFaultInjector.getInstance()\n              .shouldCorruptAByte(localfile)) {\n          // Simulate a corrupted byte on the wire\n          LOG.warn(\"SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!\");\n          buf[0]++;\n        }\n        \n        out.write(buf, 0, num);\n        if (throttler !\u003d null) {\n          throttler.throttle(num, canceler);\n        }\n      }\n    } finally {\n      if (out !\u003d null) {\n        out.close();\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java"
    }
  }
}