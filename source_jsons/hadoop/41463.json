{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "removeApplicationAttempt",
  "functionId": "removeApplicationAttempt___applicationAttemptId-ApplicationAttemptId__rmAppAttemptFinalState-RMAppAttemptState__keepContainers-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 642,
  "functionEndLine": 703,
  "numCommitsSeen": 447,
  "timeTaken": 9496,
  "changeHistory": [
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
    "9f5d2c4fff6d31acc8b422b52462ef4927c4eea1",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff",
    "adf260a728df427eb729abe8fb9ad7248991ea54",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
    "486e718fc1f5befd231494e2ec06bb360484f191",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "e6eccf20defcaf84a9566482371c7be196779c0d",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b",
    "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": "Ybodychange",
    "9f5d2c4fff6d31acc8b422b52462ef4927c4eea1": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": "Ybodychange",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": "Ybodychange",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": "Ybodychange",
    "adf260a728df427eb729abe8fb9ad7248991ea54": "Ybodychange",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": "Ybodychange",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "e6eccf20defcaf84a9566482371c7be196779c0d": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ymultichange(Yparameterchange,Ybodychange)",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": "Ybodychange",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": "Yrename",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": "Yrename",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": "Yrename",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": "Ybodychange",
    "2db1d4d4ee7838f2a8c0b3999b6055456798321d": "Ybodychange",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": "Ybodychange",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7133. Clean up lock-try order in fair scheduler. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "24/07/18 12:46 PM",
      "commitName": "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "11/06/18 11:12 AM",
      "commitNameOld": "c190ac2be88e574b3322cdc73a7c0af0cef708b2",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 43.07,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   private void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       LOG.info(\"Application \" + applicationAttemptId + \" is done. finalState\u003d\"\n               + rmAppAttemptFinalState);\n       FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n \n       if (attempt \u003d\u003d null) {\n         LOG.info(\n             \"Unknown application \" + applicationAttemptId + \" has completed!\");\n         return;\n       }\n \n       // Check if the attempt is already stopped and don\u0027t stop it twice.\n       if (attempt.isStopped()) {\n         LOG.info(\"Application \" + applicationAttemptId + \" has already been \"\n             + \"stopped!\");\n         return;\n       }\n \n       // Release all the running containers\n       for (RMContainer rmContainer : attempt.getLiveContainers()) {\n         if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n             RMContainerState.RUNNING)) {\n           // do not kill the running container in the case of work-preserving AM\n           // restart.\n           LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n           continue;\n         }\n         super.completedContainer(rmContainer, SchedulerUtils\n                 .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                     SchedulerUtils.COMPLETED_APPLICATION),\n             RMContainerEventType.KILL);\n       }\n \n       // Release all reserved containers\n       for (RMContainer rmContainer : attempt.getReservedContainers()) {\n         super.completedContainer(rmContainer, SchedulerUtils\n             .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                 \"Application Complete\"), RMContainerEventType.KILL);\n       }\n       // Clean up pending requests, metrics etc.\n       attempt.stop(rmAppAttemptFinalState);\n \n       // Inform the queue\n       FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n           attempt.getQueue().getQueueName(), false);\n       boolean wasRunnable \u003d queue.removeApp(attempt);\n \n       if (wasRunnable) {\n         maxRunningEnforcer.untrackRunnableApp(attempt);\n         maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n             attempt.getQueue());\n       } else{\n         maxRunningEnforcer.untrackNonRunnableApp(attempt);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    writeLock.lock();\n    try {\n      LOG.info(\"Application \" + applicationAttemptId + \" is done. finalState\u003d\"\n              + rmAppAttemptFinalState);\n      FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n\n      if (attempt \u003d\u003d null) {\n        LOG.info(\n            \"Unknown application \" + applicationAttemptId + \" has completed!\");\n        return;\n      }\n\n      // Check if the attempt is already stopped and don\u0027t stop it twice.\n      if (attempt.isStopped()) {\n        LOG.info(\"Application \" + applicationAttemptId + \" has already been \"\n            + \"stopped!\");\n        return;\n      }\n\n      // Release all the running containers\n      for (RMContainer rmContainer : attempt.getLiveContainers()) {\n        if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n            RMContainerState.RUNNING)) {\n          // do not kill the running container in the case of work-preserving AM\n          // restart.\n          LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n          continue;\n        }\n        super.completedContainer(rmContainer, SchedulerUtils\n                .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                    SchedulerUtils.COMPLETED_APPLICATION),\n            RMContainerEventType.KILL);\n      }\n\n      // Release all reserved containers\n      for (RMContainer rmContainer : attempt.getReservedContainers()) {\n        super.completedContainer(rmContainer, SchedulerUtils\n            .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                \"Application Complete\"), RMContainerEventType.KILL);\n      }\n      // Clean up pending requests, metrics etc.\n      attempt.stop(rmAppAttemptFinalState);\n\n      // Inform the queue\n      FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n          attempt.getQueue().getQueueName(), false);\n      boolean wasRunnable \u003d queue.removeApp(attempt);\n\n      if (wasRunnable) {\n        maxRunningEnforcer.untrackRunnableApp(attempt);\n        maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n            attempt.getQueue());\n      } else{\n        maxRunningEnforcer.untrackNonRunnableApp(attempt);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "9f5d2c4fff6d31acc8b422b52462ef4927c4eea1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5136. Error in handling event type APP_ATTEMPT_REMOVED to the scheduler\n(Contributed by Wilfred Spiegelenburg via Daniel Templeton)\n",
      "commitDate": "07/12/16 11:12 AM",
      "commitName": "9f5d2c4fff6d31acc8b422b52462ef4927c4eea1",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "06/12/16 9:09 PM",
      "commitNameOld": "563480dccd0136d82730f4228f1df44449ed5822",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 0.59,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,62 @@\n   private void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     try {\n       writeLock.lock();\n-      LOG.info(\n-          \"Application \" + applicationAttemptId + \" is done.\" + \" finalState\u003d\"\n+      LOG.info(\"Application \" + applicationAttemptId + \" is done. finalState\u003d\"\n               + rmAppAttemptFinalState);\n       FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n \n       if (attempt \u003d\u003d null) {\n         LOG.info(\n             \"Unknown application \" + applicationAttemptId + \" has completed!\");\n         return;\n       }\n \n+      // Check if the attempt is already stopped and don\u0027t stop it twice.\n+      if (attempt.isStopped()) {\n+        LOG.info(\"Application \" + applicationAttemptId + \" has already been \"\n+            + \"stopped!\");\n+        return;\n+      }\n+\n       // Release all the running containers\n       for (RMContainer rmContainer : attempt.getLiveContainers()) {\n         if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n             RMContainerState.RUNNING)) {\n           // do not kill the running container in the case of work-preserving AM\n           // restart.\n           LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n           continue;\n         }\n         super.completedContainer(rmContainer, SchedulerUtils\n                 .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                     SchedulerUtils.COMPLETED_APPLICATION),\n             RMContainerEventType.KILL);\n       }\n \n       // Release all reserved containers\n       for (RMContainer rmContainer : attempt.getReservedContainers()) {\n         super.completedContainer(rmContainer, SchedulerUtils\n             .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                 \"Application Complete\"), RMContainerEventType.KILL);\n       }\n       // Clean up pending requests, metrics etc.\n       attempt.stop(rmAppAttemptFinalState);\n \n       // Inform the queue\n       FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n           attempt.getQueue().getQueueName(), false);\n       boolean wasRunnable \u003d queue.removeApp(attempt);\n \n       if (wasRunnable) {\n         maxRunningEnforcer.untrackRunnableApp(attempt);\n         maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n             attempt.getQueue());\n       } else{\n         maxRunningEnforcer.untrackNonRunnableApp(attempt);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    try {\n      writeLock.lock();\n      LOG.info(\"Application \" + applicationAttemptId + \" is done. finalState\u003d\"\n              + rmAppAttemptFinalState);\n      FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n\n      if (attempt \u003d\u003d null) {\n        LOG.info(\n            \"Unknown application \" + applicationAttemptId + \" has completed!\");\n        return;\n      }\n\n      // Check if the attempt is already stopped and don\u0027t stop it twice.\n      if (attempt.isStopped()) {\n        LOG.info(\"Application \" + applicationAttemptId + \" has already been \"\n            + \"stopped!\");\n        return;\n      }\n\n      // Release all the running containers\n      for (RMContainer rmContainer : attempt.getLiveContainers()) {\n        if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n            RMContainerState.RUNNING)) {\n          // do not kill the running container in the case of work-preserving AM\n          // restart.\n          LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n          continue;\n        }\n        super.completedContainer(rmContainer, SchedulerUtils\n                .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                    SchedulerUtils.COMPLETED_APPLICATION),\n            RMContainerEventType.KILL);\n      }\n\n      // Release all reserved containers\n      for (RMContainer rmContainer : attempt.getReservedContainers()) {\n        super.completedContainer(rmContainer, SchedulerUtils\n            .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                \"Application Complete\"), RMContainerEventType.KILL);\n      }\n      // Clean up pending requests, metrics etc.\n      attempt.stop(rmAppAttemptFinalState);\n\n      // Inform the queue\n      FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n          attempt.getQueue().getQueueName(), false);\n      boolean wasRunnable \u003d queue.removeApp(attempt);\n\n      if (wasRunnable) {\n        maxRunningEnforcer.untrackRunnableApp(attempt);\n        maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n            attempt.getQueue());\n      } else{\n        maxRunningEnforcer.untrackNonRunnableApp(attempt);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,56 @@\n-  private synchronized void removeApplicationAttempt(\n+  private void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n-    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n-        \" finalState\u003d\" + rmAppAttemptFinalState);\n-    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-        applications.get(applicationAttemptId.getApplicationId());\n-    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n+    try {\n+      writeLock.lock();\n+      LOG.info(\n+          \"Application \" + applicationAttemptId + \" is done.\" + \" finalState\u003d\"\n+              + rmAppAttemptFinalState);\n+      FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n \n-    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n-      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n-      return;\n-    }\n-\n-    // Release all the running containers\n-    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n-      if (keepContainers\n-          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n-        // do not kill the running container in the case of work-preserving AM\n-        // restart.\n-        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n-        continue;\n+      if (attempt \u003d\u003d null) {\n+        LOG.info(\n+            \"Unknown application \" + applicationAttemptId + \" has completed!\");\n+        return;\n       }\n-      super.completedContainer(rmContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              rmContainer.getContainerId(),\n-              SchedulerUtils.COMPLETED_APPLICATION),\n-              RMContainerEventType.KILL);\n-    }\n \n-    // Release all reserved containers\n-    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n-      super.completedContainer(rmContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              rmContainer.getContainerId(),\n-              \"Application Complete\"),\n-              RMContainerEventType.KILL);\n-    }\n-    // Clean up pending requests, metrics etc.\n-    attempt.stop(rmAppAttemptFinalState);\n+      // Release all the running containers\n+      for (RMContainer rmContainer : attempt.getLiveContainers()) {\n+        if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n+            RMContainerState.RUNNING)) {\n+          // do not kill the running container in the case of work-preserving AM\n+          // restart.\n+          LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n+          continue;\n+        }\n+        super.completedContainer(rmContainer, SchedulerUtils\n+                .createAbnormalContainerStatus(rmContainer.getContainerId(),\n+                    SchedulerUtils.COMPLETED_APPLICATION),\n+            RMContainerEventType.KILL);\n+      }\n \n-    // Inform the queue\n-    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n-        .getQueueName(), false);\n-    boolean wasRunnable \u003d queue.removeApp(attempt);\n+      // Release all reserved containers\n+      for (RMContainer rmContainer : attempt.getReservedContainers()) {\n+        super.completedContainer(rmContainer, SchedulerUtils\n+            .createAbnormalContainerStatus(rmContainer.getContainerId(),\n+                \"Application Complete\"), RMContainerEventType.KILL);\n+      }\n+      // Clean up pending requests, metrics etc.\n+      attempt.stop(rmAppAttemptFinalState);\n \n-    if (wasRunnable) {\n-      maxRunningEnforcer.untrackRunnableApp(attempt);\n-      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n-          attempt.getQueue());\n-    } else {\n-      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n+      // Inform the queue\n+      FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n+          attempt.getQueue().getQueueName(), false);\n+      boolean wasRunnable \u003d queue.removeApp(attempt);\n+\n+      if (wasRunnable) {\n+        maxRunningEnforcer.untrackRunnableApp(attempt);\n+        maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n+            attempt.getQueue());\n+      } else{\n+        maxRunningEnforcer.untrackNonRunnableApp(attempt);\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    try {\n      writeLock.lock();\n      LOG.info(\n          \"Application \" + applicationAttemptId + \" is done.\" + \" finalState\u003d\"\n              + rmAppAttemptFinalState);\n      FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n\n      if (attempt \u003d\u003d null) {\n        LOG.info(\n            \"Unknown application \" + applicationAttemptId + \" has completed!\");\n        return;\n      }\n\n      // Release all the running containers\n      for (RMContainer rmContainer : attempt.getLiveContainers()) {\n        if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n            RMContainerState.RUNNING)) {\n          // do not kill the running container in the case of work-preserving AM\n          // restart.\n          LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n          continue;\n        }\n        super.completedContainer(rmContainer, SchedulerUtils\n                .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                    SchedulerUtils.COMPLETED_APPLICATION),\n            RMContainerEventType.KILL);\n      }\n\n      // Release all reserved containers\n      for (RMContainer rmContainer : attempt.getReservedContainers()) {\n        super.completedContainer(rmContainer, SchedulerUtils\n            .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                \"Application Complete\"), RMContainerEventType.KILL);\n      }\n      // Clean up pending requests, metrics etc.\n      attempt.stop(rmAppAttemptFinalState);\n\n      // Inform the queue\n      FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n          attempt.getQueue().getQueueName(), false);\n      boolean wasRunnable \u003d queue.removeApp(attempt);\n\n      if (wasRunnable) {\n        maxRunningEnforcer.untrackRunnableApp(attempt);\n        maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n            attempt.getQueue());\n      } else{\n        maxRunningEnforcer.untrackNonRunnableApp(attempt);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,56 @@\n-  private synchronized void removeApplicationAttempt(\n+  private void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n-    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n-        \" finalState\u003d\" + rmAppAttemptFinalState);\n-    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-        applications.get(applicationAttemptId.getApplicationId());\n-    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n+    try {\n+      writeLock.lock();\n+      LOG.info(\n+          \"Application \" + applicationAttemptId + \" is done.\" + \" finalState\u003d\"\n+              + rmAppAttemptFinalState);\n+      FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n \n-    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n-      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n-      return;\n-    }\n-\n-    // Release all the running containers\n-    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n-      if (keepContainers\n-          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n-        // do not kill the running container in the case of work-preserving AM\n-        // restart.\n-        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n-        continue;\n+      if (attempt \u003d\u003d null) {\n+        LOG.info(\n+            \"Unknown application \" + applicationAttemptId + \" has completed!\");\n+        return;\n       }\n-      super.completedContainer(rmContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              rmContainer.getContainerId(),\n-              SchedulerUtils.COMPLETED_APPLICATION),\n-              RMContainerEventType.KILL);\n-    }\n \n-    // Release all reserved containers\n-    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n-      super.completedContainer(rmContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              rmContainer.getContainerId(),\n-              \"Application Complete\"),\n-              RMContainerEventType.KILL);\n-    }\n-    // Clean up pending requests, metrics etc.\n-    attempt.stop(rmAppAttemptFinalState);\n+      // Release all the running containers\n+      for (RMContainer rmContainer : attempt.getLiveContainers()) {\n+        if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n+            RMContainerState.RUNNING)) {\n+          // do not kill the running container in the case of work-preserving AM\n+          // restart.\n+          LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n+          continue;\n+        }\n+        super.completedContainer(rmContainer, SchedulerUtils\n+                .createAbnormalContainerStatus(rmContainer.getContainerId(),\n+                    SchedulerUtils.COMPLETED_APPLICATION),\n+            RMContainerEventType.KILL);\n+      }\n \n-    // Inform the queue\n-    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n-        .getQueueName(), false);\n-    boolean wasRunnable \u003d queue.removeApp(attempt);\n+      // Release all reserved containers\n+      for (RMContainer rmContainer : attempt.getReservedContainers()) {\n+        super.completedContainer(rmContainer, SchedulerUtils\n+            .createAbnormalContainerStatus(rmContainer.getContainerId(),\n+                \"Application Complete\"), RMContainerEventType.KILL);\n+      }\n+      // Clean up pending requests, metrics etc.\n+      attempt.stop(rmAppAttemptFinalState);\n \n-    if (wasRunnable) {\n-      maxRunningEnforcer.untrackRunnableApp(attempt);\n-      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n-          attempt.getQueue());\n-    } else {\n-      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n+      // Inform the queue\n+      FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n+          attempt.getQueue().getQueueName(), false);\n+      boolean wasRunnable \u003d queue.removeApp(attempt);\n+\n+      if (wasRunnable) {\n+        maxRunningEnforcer.untrackRunnableApp(attempt);\n+        maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n+            attempt.getQueue());\n+      } else{\n+        maxRunningEnforcer.untrackNonRunnableApp(attempt);\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    try {\n      writeLock.lock();\n      LOG.info(\n          \"Application \" + applicationAttemptId + \" is done.\" + \" finalState\u003d\"\n              + rmAppAttemptFinalState);\n      FSAppAttempt attempt \u003d getApplicationAttempt(applicationAttemptId);\n\n      if (attempt \u003d\u003d null) {\n        LOG.info(\n            \"Unknown application \" + applicationAttemptId + \" has completed!\");\n        return;\n      }\n\n      // Release all the running containers\n      for (RMContainer rmContainer : attempt.getLiveContainers()) {\n        if (keepContainers \u0026\u0026 rmContainer.getState().equals(\n            RMContainerState.RUNNING)) {\n          // do not kill the running container in the case of work-preserving AM\n          // restart.\n          LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n          continue;\n        }\n        super.completedContainer(rmContainer, SchedulerUtils\n                .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                    SchedulerUtils.COMPLETED_APPLICATION),\n            RMContainerEventType.KILL);\n      }\n\n      // Release all reserved containers\n      for (RMContainer rmContainer : attempt.getReservedContainers()) {\n        super.completedContainer(rmContainer, SchedulerUtils\n            .createAbnormalContainerStatus(rmContainer.getContainerId(),\n                \"Application Complete\"), RMContainerEventType.KILL);\n      }\n      // Clean up pending requests, metrics etc.\n      attempt.stop(rmAppAttemptFinalState);\n\n      // Inform the queue\n      FSLeafQueue queue \u003d queueMgr.getLeafQueue(\n          attempt.getQueue().getQueueName(), false);\n      boolean wasRunnable \u003d queue.removeApp(attempt);\n\n      if (wasRunnable) {\n        maxRunningEnforcer.untrackRunnableApp(attempt);\n        maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n            attempt.getQueue());\n      } else{\n        maxRunningEnforcer.untrackNonRunnableApp(attempt);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "18/01/16 5:30 PM",
      "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:27 PM",
      "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n-      completedContainer(rmContainer,\n+      super.completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n-      completedContainer(rmContainer,\n+      super.completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.untrackRunnableApp(attempt);\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n           attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      super.completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      super.completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
      "commitDate": "18/01/16 5:27 PM",
      "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 1:58 AM",
      "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n-      super.completedContainer(rmContainer,\n+      completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n-      super.completedContainer(rmContainer,\n+      completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.untrackRunnableApp(attempt);\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n           attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
      "commitDate": "18/01/16 1:06 AM",
      "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 12:50 AM",
      "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n-      completedContainer(rmContainer,\n+      super.completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n-      completedContainer(rmContainer,\n+      super.completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.untrackRunnableApp(attempt);\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n           attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      super.completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      super.completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "adf260a728df427eb729abe8fb9ad7248991ea54": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
      "commitDate": "18/01/16 12:50 AM",
      "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/01/16 7:04 PM",
      "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n-      super.completedContainer(rmContainer,\n+      completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n-      super.completedContainer(rmContainer,\n+      completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.untrackRunnableApp(attempt);\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n           attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "17/01/16 7:04 PM",
      "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/12/15 10:52 AM",
      "commitNameOld": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 34.34,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n-      completedContainer(rmContainer,\n+      super.completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n-      completedContainer(rmContainer,\n+      super.completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.untrackRunnableApp(attempt);\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n           attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      super.completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      super.completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "08/08/14 7:17 AM",
      "commitNameOld": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.31,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n-    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n+    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n-    FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n+    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.untrackRunnableApp(attempt);\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n           attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSAppAttempt attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n-    SchedulerApplication application \u003d\n+    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.untrackRunnableApp(attempt);\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n           attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e6eccf20defcaf84a9566482371c7be196779c0d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1499. Fair Scheduler changes for moving apps between queues (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564856 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/02/14 10:09 AM",
      "commitName": "e6eccf20defcaf84a9566482371c7be196779c0d",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "31/01/14 8:03 PM",
      "commitNameOld": "1079c371289cd31478ed4bc123c1c4dd846c76ee",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 4.59,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,54 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n     SchedulerApplication application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n \n     if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : attempt.getLiveContainers()) {\n       if (keepContainers\n           \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n         // do not kill the running container in the case of work-preserving AM\n         // restart.\n         LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n         continue;\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : attempt.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n               RMContainerEventType.KILL);\n     }\n     // Clean up pending requests, metrics etc.\n     attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n-      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt);\n+      maxRunningEnforcer.untrackRunnableApp(attempt);\n+      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n+          attempt.getQueue());\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.untrackRunnableApp(attempt);\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt,\n          attempt.getQueue());\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/01/14 7:04 AM",
          "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "02/01/14 12:19 PM",
          "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.78,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,52 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n-      RMAppAttemptState rmAppAttemptFinalState) {\n+      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n+    SchedulerApplication application \u003d\n+        applications.get(applicationAttemptId.getApplicationId());\n+    FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n \n-    FSSchedulerApp application \u003d appAttempts.get(applicationAttemptId);\n-\n-    if (application \u003d\u003d null) {\n+    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n-    for (RMContainer rmContainer : application.getLiveContainers()) {\n+    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n+      if (keepContainers\n+          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n+        // do not kill the running container in the case of work-preserving AM\n+        // restart.\n+        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n+        continue;\n+      }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n-    for (RMContainer rmContainer : application.getReservedContainers()) {\n+    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n-          RMContainerEventType.KILL);\n+              RMContainerEventType.KILL);\n     }\n-\n     // Clean up pending requests, metrics etc.\n-    application.stop(rmAppAttemptFinalState);\n+    attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n-    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n+    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n-    boolean wasRunnable \u003d queue.removeApp(application);\n+    boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n-      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n+      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt);\n     } else {\n-      maxRunningEnforcer.untrackNonRunnableApp(application);\n+      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n-    \n-    // Remove from our data-structure\n-    appAttempts.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt);\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, rmAppAttemptFinalState-RMAppAttemptState]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, rmAppAttemptFinalState-RMAppAttemptState, keepContainers-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/01/14 7:04 AM",
          "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "02/01/14 12:19 PM",
          "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.78,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,52 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n-      RMAppAttemptState rmAppAttemptFinalState) {\n+      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n+    SchedulerApplication application \u003d\n+        applications.get(applicationAttemptId.getApplicationId());\n+    FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n \n-    FSSchedulerApp application \u003d appAttempts.get(applicationAttemptId);\n-\n-    if (application \u003d\u003d null) {\n+    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n-    for (RMContainer rmContainer : application.getLiveContainers()) {\n+    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n+      if (keepContainers\n+          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n+        // do not kill the running container in the case of work-preserving AM\n+        // restart.\n+        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n+        continue;\n+      }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n-    for (RMContainer rmContainer : application.getReservedContainers()) {\n+    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n-          RMContainerEventType.KILL);\n+              RMContainerEventType.KILL);\n     }\n-\n     // Clean up pending requests, metrics etc.\n-    application.stop(rmAppAttemptFinalState);\n+    attempt.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n-    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n+    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n         .getQueueName(), false);\n-    boolean wasRunnable \u003d queue.removeApp(application);\n+    boolean wasRunnable \u003d queue.removeApp(attempt);\n \n     if (wasRunnable) {\n-      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n+      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt);\n     } else {\n-      maxRunningEnforcer.untrackNonRunnableApp(application);\n+      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n     }\n-    \n-    // Remove from our data-structure\n-    appAttempts.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    FSSchedulerApp attempt \u003d getSchedulerApp(applicationAttemptId);\n\n    if (attempt \u003d\u003d null || application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : attempt.getLiveContainers()) {\n      if (keepContainers\n          \u0026\u0026 rmContainer.getState().equals(RMContainerState.RUNNING)) {\n        // do not kill the running container in the case of work-preserving AM\n        // restart.\n        LOG.info(\"Skip killing \" + rmContainer.getContainerId());\n        continue;\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : attempt.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n              RMContainerEventType.KILL);\n    }\n    // Clean up pending requests, metrics etc.\n    attempt.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(attempt.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(attempt);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(attempt);\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(attempt);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 12:19 PM",
      "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/12/13 5:44 PM",
      "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 20.77,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n-    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n+    FSSchedulerApp application \u003d appAttempts.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(application);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(application);\n     }\n     \n     // Remove from our data-structure\n-    applications.remove(applicationAttemptId);\n+    appAttempts.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d appAttempts.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(application);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(application);\n    }\n    \n    // Remove from our data-structure\n    appAttempts.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": {
      "type": "Yrename",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550613 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 5:44 PM",
      "commitName": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:45 PM",
      "commitNameOld": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n-  private synchronized void removeApplication(\n+  private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(application);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(application);\n     }\n     \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(application);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(application);\n    }\n    \n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "removeApplication",
        "newValue": "removeApplicationAttempt"
      }
    },
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": {
      "type": "Yrename",
      "commitMessage": "Reverting YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550594 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:45 PM",
      "commitName": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:07 PM",
      "commitNameOld": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n-  private synchronized void removeApplicationAttempt(\n+  private synchronized void removeApplication(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(application);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(application);\n     }\n     \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(application);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(application);\n    }\n    \n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "removeApplicationAttempt",
        "newValue": "removeApplication"
      }
    },
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": {
      "type": "Yrename",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550579 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:07 PM",
      "commitName": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthor": "Jian He",
      "commitDateOld": "07/12/13 7:09 PM",
      "commitNameOld": "e1d3670f4c233696dc673c37b578ce46b44a6876",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n-  private synchronized void removeApplication(\n+  private synchronized void removeApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n         .getQueueName(), false);\n     boolean wasRunnable \u003d queue.removeApp(application);\n \n     if (wasRunnable) {\n       maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n     } else {\n       maxRunningEnforcer.untrackNonRunnableApp(application);\n     }\n     \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(application);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(application);\n    }\n    \n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "removeApplication",
        "newValue": "removeApplicationAttempt"
      }
    },
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1241. In Fair Scheduler, maxRunningApps does not work for non-leaf queues. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546623 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/13 11:02 AM",
      "commitName": "7545d8bf996e5d060d5d613bf769ec52a62d428b",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "14/11/13 2:12 PM",
      "commitNameOld": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 14.87,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,48 @@\n   private synchronized void removeApplication(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n         .getQueueName(), false);\n-    queue.removeApp(application);\n+    boolean wasRunnable \u003d queue.removeApp(application);\n \n+    if (wasRunnable) {\n+      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n+    } else {\n+      maxRunningEnforcer.untrackNonRunnableApp(application);\n+    }\n+    \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n        .getQueueName(), false);\n    boolean wasRunnable \u003d queue.removeApp(application);\n\n    if (wasRunnable) {\n      maxRunningEnforcer.updateRunnabilityOnAppRemoval(application);\n    } else {\n      maxRunningEnforcer.untrackNonRunnableApp(application);\n    }\n    \n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "2db1d4d4ee7838f2a8c0b3999b6055456798321d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1213. Restore config to ban submitting to undeclared pools in the Fair Scheduler. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1528696 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/10/13 6:17 PM",
      "commitName": "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "01/10/13 12:54 PM",
      "commitNameOld": "ae05623a75803d4e12a902ac4a24187540f56699",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 1.22,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private synchronized void removeApplication(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n               RMContainerEventType.KILL);\n     }\n \n     // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n-        .getQueueName());\n+        .getQueueName(), false);\n     queue.removeApp(application);\n \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n        .getQueueName(), false);\n    queue.removeApp(application);\n\n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": {
      "type": "Ybodychange",
      "commitMessage": "YARN-187. Add hierarchical queues to the fair scheduler. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415592 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/12 4:03 AM",
      "commitName": "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
      "commitAuthor": "Thomas White",
      "commitDateOld": "28/11/12 5:56 PM",
      "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.42,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   private synchronized void removeApplication(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n-          RMContainerEventType.KILL);\n+              RMContainerEventType.KILL);\n     }\n \n-     // Release all reserved containers\n+    // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n-    FSQueue queue \u003d queueMgr.getQueue(application.getQueue().getQueueName());\n+    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n+        .getQueueName());\n     queue.removeApp(application);\n \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n              RMContainerEventType.KILL);\n    }\n\n    // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(application.getQueue()\n        .getQueueName());\n    queue.removeApp(application);\n\n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/12 4:38 AM",
      "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthor": "Thomas White",
      "commitDateOld": "26/10/12 1:55 PM",
      "commitNameOld": "b54e794fb059fa68b115c2ca5e58f11a0d7f3985",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 13.65,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private synchronized void removeApplication(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n           RMContainerEventType.KILL);\n     }\n \n      // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n-    FSQueue queue \u003d this.queueMgr.getQueue(application.getQueue().getQueueName());\n-    queue.removeJob(application);\n+    FSQueue queue \u003d queueMgr.getQueue(application.getQueue().getQueueName());\n+    queue.removeApp(application);\n \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n          RMContainerEventType.KILL);\n    }\n\n     // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSQueue queue \u003d queueMgr.getQueue(application.getQueue().getQueueName());\n    queue.removeApp(application);\n\n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n          RMContainerEventType.KILL);\n    }\n\n     // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSQueue queue \u003d this.queueMgr.getQueue(application.getQueue().getQueueName());\n    queue.removeJob(application);\n\n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "12/07/12 5:43 PM",
      "commitNameOld": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private synchronized void removeApplication(\n       ApplicationAttemptId applicationAttemptId,\n       RMAppAttemptState rmAppAttemptFinalState) {\n     LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n         \" finalState\u003d\" + rmAppAttemptFinalState);\n \n-    SchedulerApp application \u003d applications.get(applicationAttemptId);\n+    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n \n     if (application \u003d\u003d null) {\n       LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n       return;\n     }\n \n     // Release all the running containers\n     for (RMContainer rmContainer : application.getLiveContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               SchedulerUtils.COMPLETED_APPLICATION),\n           RMContainerEventType.KILL);\n     }\n \n      // Release all reserved containers\n     for (RMContainer rmContainer : application.getReservedContainers()) {\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               rmContainer.getContainerId(),\n               \"Application Complete\"),\n           RMContainerEventType.KILL);\n     }\n \n     // Clean up pending requests, metrics etc.\n     application.stop(rmAppAttemptFinalState);\n \n     // Inform the queue\n     FSQueue queue \u003d this.queueMgr.getQueue(application.getQueue().getQueueName());\n     queue.removeJob(application);\n \n     // Remove from our data-structure\n     applications.remove(applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n          RMContainerEventType.KILL);\n    }\n\n     // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSQueue queue \u003d this.queueMgr.getQueue(application.getQueue().getQueueName());\n    queue.removeJob(application);\n\n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,41 @@\n+  private synchronized void removeApplication(\n+      ApplicationAttemptId applicationAttemptId,\n+      RMAppAttemptState rmAppAttemptFinalState) {\n+    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n+        \" finalState\u003d\" + rmAppAttemptFinalState);\n+\n+    SchedulerApp application \u003d applications.get(applicationAttemptId);\n+\n+    if (application \u003d\u003d null) {\n+      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n+      return;\n+    }\n+\n+    // Release all the running containers\n+    for (RMContainer rmContainer : application.getLiveContainers()) {\n+      completedContainer(rmContainer,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+              rmContainer.getContainerId(),\n+              SchedulerUtils.COMPLETED_APPLICATION),\n+          RMContainerEventType.KILL);\n+    }\n+\n+     // Release all reserved containers\n+    for (RMContainer rmContainer : application.getReservedContainers()) {\n+      completedContainer(rmContainer,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+              rmContainer.getContainerId(),\n+              \"Application Complete\"),\n+          RMContainerEventType.KILL);\n+    }\n+\n+    // Clean up pending requests, metrics etc.\n+    application.stop(rmAppAttemptFinalState);\n+\n+    // Inform the queue\n+    FSQueue queue \u003d this.queueMgr.getQueue(application.getQueue().getQueueName());\n+    queue.removeJob(application);\n+\n+    // Remove from our data-structure\n+    applications.remove(applicationAttemptId);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeApplication(\n      ApplicationAttemptId applicationAttemptId,\n      RMAppAttemptState rmAppAttemptFinalState) {\n    LOG.info(\"Application \" + applicationAttemptId + \" is done.\" +\n        \" finalState\u003d\" + rmAppAttemptFinalState);\n\n    SchedulerApp application \u003d applications.get(applicationAttemptId);\n\n    if (application \u003d\u003d null) {\n      LOG.info(\"Unknown application \" + applicationAttemptId + \" has completed!\");\n      return;\n    }\n\n    // Release all the running containers\n    for (RMContainer rmContainer : application.getLiveContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              SchedulerUtils.COMPLETED_APPLICATION),\n          RMContainerEventType.KILL);\n    }\n\n     // Release all reserved containers\n    for (RMContainer rmContainer : application.getReservedContainers()) {\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              rmContainer.getContainerId(),\n              \"Application Complete\"),\n          RMContainerEventType.KILL);\n    }\n\n    // Clean up pending requests, metrics etc.\n    application.stop(rmAppAttemptFinalState);\n\n    // Inform the queue\n    FSQueue queue \u003d this.queueMgr.getQueue(application.getQueue().getQueueName());\n    queue.removeJob(application);\n\n    // Remove from our data-structure\n    applications.remove(applicationAttemptId);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}