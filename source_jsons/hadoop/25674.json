{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JobHistoryEventHandler.java",
  "functionName": "handleEvent",
  "functionId": "handleEvent___event-JobHistoryEvent",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
  "functionStartLine": 629,
  "functionEndLine": 736,
  "numCommitsSeen": 70,
  "timeTaken": 10531,
  "changeHistory": [
    "83e60cd2db20f655e272958ef43b1b5a084ef3e3",
    "d04f85f387e4a78816bc9966ee2b4a647ee05faf",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "b50a6d78f5e12cfb9e0f52e0af6efbab3618e2e5",
    "bf70c5ae2824a9139c1aa9d7c14020018881cec2",
    "971e91c8c03a23e4613ed3f071b4f982ee5a1b63",
    "6b2f11b54bc679b0715fe66bd129e340e8c61c5c",
    "6015e9594180f157472a88030c85c5599fdc289c",
    "db807057193311fc06caf912e13000193edd1bd8",
    "ee5351bf22e113d39db3839432bc7d6c743cc736",
    "2d614a916cc5958b709bddbee71d2dcb9cbb2bf9",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "0515b3322f9d94f1743504085967b29efe1dd7fe",
    "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43",
    "fffdf661e30afd10331d2153ff052c141b7ebe4b",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "83e60cd2db20f655e272958ef43b1b5a084ef3e3": "Ybodychange",
    "d04f85f387e4a78816bc9966ee2b4a647ee05faf": "Ybodychange",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "b50a6d78f5e12cfb9e0f52e0af6efbab3618e2e5": "Ybodychange",
    "bf70c5ae2824a9139c1aa9d7c14020018881cec2": "Ybodychange",
    "971e91c8c03a23e4613ed3f071b4f982ee5a1b63": "Ybodychange",
    "6b2f11b54bc679b0715fe66bd129e340e8c61c5c": "Ybodychange",
    "6015e9594180f157472a88030c85c5599fdc289c": "Ymultichange(Ymodifierchange,Ybodychange)",
    "db807057193311fc06caf912e13000193edd1bd8": "Ybodychange",
    "ee5351bf22e113d39db3839432bc7d6c743cc736": "Ybodychange",
    "2d614a916cc5958b709bddbee71d2dcb9cbb2bf9": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "0515b3322f9d94f1743504085967b29efe1dd7fe": "Ybodychange",
    "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43": "Ybodychange",
    "fffdf661e30afd10331d2153ff052c141b7ebe4b": "Ybodychange",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "83e60cd2db20f655e272958ef43b1b5a084ef3e3": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7042. Killed MR job data does not move to mapreduce.jobhistory.done-dir when ATS v2 is enabled. Contributed by Rohith Sharma K S.\n",
      "commitDate": "26/04/18 1:54 PM",
      "commitName": "83e60cd2db20f655e272958ef43b1b5a084ef3e3",
      "commitAuthor": "Sunil G",
      "commitDateOld": "04/04/18 3:08 PM",
      "commitNameOld": "345e7624d58a058a1bad666bd1e5ce4b346a9056",
      "commitAuthorOld": "Vrushali C",
      "daysBetweenCommits": 21.95,
      "commitsBetweenForRepo": 653,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,108 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n           setupEventWriter(event.getJobID(), amStartedEvent);\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       // (3) Process it for ATS (if enabled)\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n-        if (timelineV2Client !\u003d null) {\n-          processEventForNewTimelineService(historyEvent, event.getJobID(),\n-              event.getTimestamp());\n-        } else if (timelineClient !\u003d null) {\n-          processEventForTimelineServer(historyEvent, event.getJobID(),\n-              event.getTimestamp());\n-        }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getSucceededMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getSucceededReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), amStartedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS (if enabled)\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getSucceededMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getSucceededReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "d04f85f387e4a78816bc9966ee2b4a647ee05faf": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6892. Issues with the count of failed/killed tasks in the jhist file. (Peter Bacsko via Haibo Chen)\n",
      "commitDate": "30/08/17 10:07 AM",
      "commitName": "d04f85f387e4a78816bc9966ee2b4a647ee05faf",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "684de1a9025261dcb6ab3b5ec9ba69738c947ecc",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,115 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n           setupEventWriter(event.getJobID(), amStartedEvent);\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       // (3) Process it for ATS (if enabled)\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (timelineV2Client !\u003d null) {\n           processEventForNewTimelineService(historyEvent, event.getJobID(),\n               event.getTimestamp());\n         } else if (timelineClient !\u003d null) {\n           processEventForTimelineServer(historyEvent, event.getJobID(),\n               event.getTimestamp());\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n-          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n+          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getSucceededMaps());\n           mi.getJobIndexInfo().setNumReduces(\n-              jFinishedEvent.getFinishedReduces());\n+              jFinishedEvent.getSucceededReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n-          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n-          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n+          mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n+          mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n-          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n-          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n+          mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n+          mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), amStartedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS (if enabled)\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (timelineV2Client !\u003d null) {\n          processEventForNewTimelineService(historyEvent, event.getJobID(),\n              event.getTimestamp());\n        } else if (timelineClient !\u003d null) {\n          processEventForTimelineServer(historyEvent, event.getJobID(),\n              event.getTimestamp());\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getSucceededMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getSucceededReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getSucceededMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getSucceededReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "15/11/16 10:57 AM",
      "commitNameOld": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 93.03,
      "commitsBetweenForRepo": 475,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,115 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n           setupEventWriter(event.getJobID(), amStartedEvent);\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       // (3) Process it for ATS (if enabled)\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n-        if (timelineClient !\u003d null) {\n-          if (timelineServiceV2Enabled) {\n-            processEventForNewTimelineService(historyEvent, event.getJobID(),\n-                event.getTimestamp());\n-          } else {\n-            processEventForTimelineServer(historyEvent, event.getJobID(),\n-                event.getTimestamp());\n-          }\n+        if (timelineV2Client !\u003d null) {\n+          processEventForNewTimelineService(historyEvent, event.getJobID(),\n+              event.getTimestamp());\n+        } else if (timelineClient !\u003d null) {\n+          processEventForTimelineServer(historyEvent, event.getJobID(),\n+              event.getTimestamp());\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), amStartedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS (if enabled)\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (timelineV2Client !\u003d null) {\n          processEventForNewTimelineService(historyEvent, event.getJobID(),\n              event.getTimestamp());\n        } else if (timelineClient !\u003d null) {\n          processEventForTimelineServer(historyEvent, event.getJobID(),\n              event.getTimestamp());\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "b50a6d78f5e12cfb9e0f52e0af6efbab3618e2e5",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n           setupEventWriter(event.getJobID(), amStartedEvent);\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       // (3) Process it for ATS (if enabled)\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (timelineClient !\u003d null) {\n-          if (newTimelineServiceEnabled) {\n+          if (timelineServiceV2Enabled) {\n             processEventForNewTimelineService(historyEvent, event.getJobID(),\n                 event.getTimestamp());\n           } else {\n             processEventForTimelineServer(historyEvent, event.getJobID(),\n                 event.getTimestamp());\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), amStartedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS (if enabled)\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (timelineClient !\u003d null) {\n          if (timelineServiceV2Enabled) {\n            processEventForNewTimelineService(historyEvent, event.getJobID(),\n                event.getTimestamp());\n          } else {\n            processEventForTimelineServer(historyEvent, event.getJobID(),\n                event.getTimestamp());\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "b50a6d78f5e12cfb9e0f52e0af6efbab3618e2e5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6327. Made MR AM use timeline service v2 API to write history events and counters. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "b50a6d78f5e12cfb9e0f52e0af6efbab3618e2e5",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 41.99,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,117 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n           setupEventWriter(event.getJobID(), amStartedEvent);\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       // (3) Process it for ATS (if enabled)\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (timelineClient !\u003d null) {\n-          processEventForTimelineServer(historyEvent, event.getJobID(),\n-              event.getTimestamp());\n+          if (newTimelineServiceEnabled) {\n+            processEventForNewTimelineService(historyEvent, event.getJobID(),\n+                event.getTimestamp());\n+          } else {\n+            processEventForTimelineServer(historyEvent, event.getJobID(),\n+                event.getTimestamp());\n+          }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), amStartedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS (if enabled)\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (timelineClient !\u003d null) {\n          if (newTimelineServiceEnabled) {\n            processEventForNewTimelineService(historyEvent, event.getJobID(),\n                event.getTimestamp());\n          } else {\n            processEventForTimelineServer(historyEvent, event.getJobID(),\n                event.getTimestamp());\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "bf70c5ae2824a9139c1aa9d7c14020018881cec2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6259. IllegalArgumentException due to missing job submit time. Contributed by zhihai xu\n",
      "commitDate": "04/05/15 1:39 PM",
      "commitName": "bf70c5ae2824a9139c1aa9d7c14020018881cec2",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "30/04/15 12:03 AM",
      "commitNameOld": "f5b38477f9d0827b238fadd260c1dd2889531fd4",
      "commitAuthorOld": "Devaraj K",
      "daysBetweenCommits": 4.57,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,112 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n-          setupEventWriter(event.getJobID(),\n-              amStartedEvent.getForcedJobStateOnShutDown());\n+          setupEventWriter(event.getJobID(), amStartedEvent);\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       // (3) Process it for ATS (if enabled)\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (timelineClient !\u003d null) {\n           processEventForTimelineServer(historyEvent, event.getJobID(),\n               event.getTimestamp());\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), amStartedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS (if enabled)\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (timelineClient !\u003d null) {\n          processEventForTimelineServer(historyEvent, event.getJobID(),\n              event.getTimestamp());\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "971e91c8c03a23e4613ed3f071b4f982ee5a1b63": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6018. Added an MR specific config to enable emitting job history data to the timeline server. Contributed by Robert Kanter.\n",
      "commitDate": "27/10/14 9:03 PM",
      "commitName": "971e91c8c03a23e4613ed3f071b4f982ee5a1b63",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "27/10/14 8:35 PM",
      "commitNameOld": "6b2f11b54bc679b0715fe66bd129e340e8c61c5c",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,113 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n           setupEventWriter(event.getJobID(),\n               amStartedEvent.getForcedJobStateOnShutDown());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n-      // (3) Process it for ATS\n+      // (3) Process it for ATS (if enabled)\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n-        processEventForTimelineServer(historyEvent, event.getJobID(),\n-                event.getTimestamp());\n+        if (timelineClient !\u003d null) {\n+          processEventForTimelineServer(historyEvent, event.getJobID(),\n+              event.getTimestamp());\n+        }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(),\n              amStartedEvent.getForcedJobStateOnShutDown());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS (if enabled)\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (timelineClient !\u003d null) {\n          processEventForTimelineServer(historyEvent, event.getJobID(),\n              event.getTimestamp());\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "6b2f11b54bc679b0715fe66bd129e340e8c61c5c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5933. Enabled MR AM to post history events to the timeline server. Contributed by Robert Kanter.\n",
      "commitDate": "27/10/14 8:35 PM",
      "commitName": "6b2f11b54bc679b0715fe66bd129e340e8c61c5c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "15/08/14 1:17 PM",
      "commitNameOld": "84bc2fe4021be32e0ff8ba395359337904149034",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 73.3,
      "commitsBetweenForRepo": 704,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,111 @@\n   public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           AMStartedEvent amStartedEvent \u003d\n               (AMStartedEvent) event.getHistoryEvent();\n           setupEventWriter(event.getJobID(),\n               amStartedEvent.getForcedJobStateOnShutDown());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n+      // (3) Process it for ATS\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n+        processEventForTimelineServer(historyEvent, event.getJobID(),\n+                event.getTimestamp());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(),\n              amStartedEvent.getForcedJobStateOnShutDown());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      // (3) Process it for ATS\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        processEventForTimelineServer(historyEvent, event.getJobID(),\n                event.getTimestamp());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "6015e9594180f157472a88030c85c5599fdc289c": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5795. Fixed MRAppMaster to record the correct job-state after it recovers from a commit during a previous attempt. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 7:00 PM",
      "commitName": "6015e9594180f157472a88030c85c5599fdc289c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "MAPREDUCE-5795. Fixed MRAppMaster to record the correct job-state after it recovers from a commit during a previous attempt. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581180 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/03/14 7:00 PM",
          "commitName": "6015e9594180f157472a88030c85c5599fdc289c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "26/02/14 1:32 PM",
          "commitNameOld": "658b1bf561aa1c0f02fc0dbb079011f959709c25",
          "commitAuthorOld": "Jason Darrell Lowe",
          "daysBetweenCommits": 26.19,
          "commitsBetweenForRepo": 223,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,108 @@\n-  protected void handleEvent(JobHistoryEvent event) {\n+  public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n-          setupEventWriter(event.getJobID());\n+          AMStartedEvent amStartedEvent \u003d\n+              (AMStartedEvent) event.getHistoryEvent();\n+          setupEventWriter(event.getJobID(),\n+              amStartedEvent.getForcedJobStateOnShutDown());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(),\n              amStartedEvent.getForcedJobStateOnShutDown());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5795. Fixed MRAppMaster to record the correct job-state after it recovers from a commit during a previous attempt. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581180 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/03/14 7:00 PM",
          "commitName": "6015e9594180f157472a88030c85c5599fdc289c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "26/02/14 1:32 PM",
          "commitNameOld": "658b1bf561aa1c0f02fc0dbb079011f959709c25",
          "commitAuthorOld": "Jason Darrell Lowe",
          "daysBetweenCommits": 26.19,
          "commitsBetweenForRepo": 223,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,108 @@\n-  protected void handleEvent(JobHistoryEvent event) {\n+  public void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n-          setupEventWriter(event.getJobID());\n+          AMStartedEvent amStartedEvent \u003d\n+              (AMStartedEvent) event.getHistoryEvent();\n+          setupEventWriter(event.getJobID(),\n+              amStartedEvent.getForcedJobStateOnShutDown());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n       \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n         JobQueueChangeEvent jQueueEvent \u003d\n             (JobQueueChangeEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n       }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          AMStartedEvent amStartedEvent \u003d\n              (AMStartedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(),\n              amStartedEvent.getForcedJobStateOnShutDown());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
          "extendedDetails": {}
        }
      ]
    },
    "db807057193311fc06caf912e13000193edd1bd8": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5732. Report proper queue when job has been automatically placed (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1562641 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/01/14 3:51 PM",
      "commitName": "db807057193311fc06caf912e13000193edd1bd8",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "10/12/13 9:17 AM",
      "commitNameOld": "ee5351bf22e113d39db3839432bc7d6c743cc736",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 50.27,
      "commitsBetweenForRepo": 248,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,105 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n       //initialize the launchTime in the JobIndexInfo of MetaInfo\n       if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n         JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n       }\n+      \n+      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n+        JobQueueChangeEvent jQueueEvent \u003d\n+            (JobQueueChangeEvent) event.getHistoryEvent();\n+        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n+      }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n      \n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_QUEUE_CHANGED) {\n        JobQueueChangeEvent jQueueEvent \u003d\n            (JobQueueChangeEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setQueueName(jQueueEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "ee5351bf22e113d39db3839432bc7d6c743cc736": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5052. Job History UI and web services confusing job start time and job submit time (Chen He via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1549896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/12/13 9:17 AM",
      "commitName": "ee5351bf22e113d39db3839432bc7d6c743cc736",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "21/08/13 11:16 AM",
      "commitNameOld": "2d614a916cc5958b709bddbee71d2dcb9cbb2bf9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 110.96,
      "commitsBetweenForRepo": 668,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,99 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n+      //initialize the launchTime in the JobIndexInfo of MetaInfo\n+      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n+        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n+        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n+      }\n \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n       // In case of JOB_ERROR, only process all the Done files(e.g. job\n       // summary, job history file etc.) if it is last AM retry.\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d\n               (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           if(context.isLastAMRetry())\n             processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n           processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n      //initialize the launchTime in the JobIndexInfo of MetaInfo\n      if(event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_INITED ){\n        JobInitedEvent jie \u003d (JobInitedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setJobStartTime(jie.getLaunchTime());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "2d614a916cc5958b709bddbee71d2dcb9cbb2bf9": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5466. Changed MR AM to not promote history files of intermediate AMs in case they are exiting because of errors and thus help history-server pick up the right history file for the last successful AM. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1516238 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/13 11:16 AM",
      "commitName": "2d614a916cc5958b709bddbee71d2dcb9cbb2bf9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 65.48,
      "commitsBetweenForRepo": 390,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,94 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n-     \n+\n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n+          processDoneFiles(event.getJobID());\n+        } catch (IOException e) {\n+          throw new YarnRuntimeException(e);\n+        }\n+      }\n+      // In case of JOB_ERROR, only process all the Done files(e.g. job\n+      // summary, job history file etc.) if it is last AM retry.\n+      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n+        try {\n+          JobUnsuccessfulCompletionEvent jucEvent \u003d\n+              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n+          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n+          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n+          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n+          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n+          closeEventWriter(event.getJobID());\n+          if(context.isLastAMRetry())\n+            processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n+          processDoneFiles(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n      // In case of JOB_ERROR, only process all the Done files(e.g. job\n      // summary, job history file etc.) if it is last AM retry.\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_ERROR) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d\n              (JobUnsuccessfulCompletionEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          if(context.isLastAMRetry())\n            processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n          processDoneFiles(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/01/13 12:35 PM",
      "commitNameOld": "64e4fb983e022d8d3375a3e1b8facbf95f7ba403",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 150.31,
      "commitsBetweenForRepo": 892,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n-          throw new YarnException(ioe);\n+          throw new YarnRuntimeException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"In HistoryEventHandler \"\n               + event.getHistoryEvent().getEventType());\n         }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n-        throw new YarnException(e);\n+        throw new YarnRuntimeException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n      \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n-          throw new YarnException(e);\n+          throw new YarnRuntimeException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n-          throw new YarnException(e);\n+          throw new YarnRuntimeException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnRuntimeException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnRuntimeException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n     \n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnRuntimeException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "0515b3322f9d94f1743504085967b29efe1dd7fe": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3846. Addressed MR AM hanging issues during AM restart and then the recovery. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1243752 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/02/12 4:06 PM",
      "commitName": "0515b3322f9d94f1743504085967b29efe1dd7fe",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/01/12 5:42 PM",
      "commitNameOld": "74697f231772a556884feaf1c986631d02a9ae4e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 32.93,
      "commitsBetweenForRepo": 212,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,75 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n-        LOG.info(\"In HistoryEventHandler \"\n-            + event.getHistoryEvent().getEventType());\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"In HistoryEventHandler \"\n+              + event.getHistoryEvent().getEventType());\n+        }\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n         mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n      \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"In HistoryEventHandler \"\n              + event.getHistoryEvent().getEventType());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n     \n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3342. Fixed JobHistoryServer to also show the job\u0027s queue name. Contributed by Jonathan Eagles.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1199133 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/11 11:28 PM",
      "commitName": "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/10/11 11:26 PM",
      "commitNameOld": "fffdf661e30afd10331d2153ff052c141b7ebe4b",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 14.04,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,73 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         if (! (historyEvent instanceof NormalizedResourceEvent)) {\n           mi.writeEvent(historyEvent);\n         }\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n             event.getJobID());\n         LOG.info(\"In HistoryEventHandler \"\n             + event.getHistoryEvent().getEventType());\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n+        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n       }\n      \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d \n               (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        LOG.info(\"In HistoryEventHandler \"\n            + event.getHistoryEvent().getEventType());\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n        mi.getJobIndexInfo().setQueueName(jobSubmittedEvent.getJobQueueName());\n      }\n     \n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "fffdf661e30afd10331d2153ff052c141b7ebe4b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2821. Added missing fields (resourcePerMap \u0026 resourcePerReduce) to JobSummary logs. Contributed by Mahadev Konar.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1188528 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/10/11 11:26 PM",
      "commitName": "fffdf661e30afd10331d2153ff052c141b7ebe4b",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "18/10/11 10:21 PM",
      "commitNameOld": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.05,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,72 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n           setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n-        mi.writeEvent(historyEvent);\n-        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(), event.getJobID());\n+        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n+          mi.writeEvent(historyEvent);\n+        }\n+        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n+            event.getJobID());\n         LOG.info(\"In HistoryEventHandler \"\n             + event.getHistoryEvent().getEventType());\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnException(e);\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n         JobSubmittedEvent jobSubmittedEvent \u003d\n             (JobSubmittedEvent) event.getHistoryEvent();\n         mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n       }\n-\n+     \n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n-          JobUnsuccessfulCompletionEvent jucEvent \u003d (JobUnsuccessfulCompletionEvent) event\n+          JobUnsuccessfulCompletionEvent jucEvent \u003d \n+              (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        if (! (historyEvent instanceof NormalizedResourceEvent)) {\n          mi.writeEvent(historyEvent);\n        }\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(),\n            event.getJobID());\n        LOG.info(\"In HistoryEventHandler \"\n            + event.getHistoryEvent().getEventType());\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n      }\n     \n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d \n              (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3144. Augmented JobHistory with the information needed for serving aggregated logs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/11 10:21 PM",
      "commitName": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/09/11 12:16 AM",
      "commitNameOld": "61900651b1b85cf235e01142acf2a51727fc5537",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.92,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,68 @@\n   protected void handleEvent(JobHistoryEvent event) {\n     synchronized (lock) {\n \n       // If this is JobSubmitted Event, setup the writer\n-      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n+      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n         try {\n-          JobSubmittedEvent jobSubmittedEvent \u003d\n-              (JobSubmittedEvent) event.getHistoryEvent();\n-          setupEventWriter(event.getJobID(), jobSubmittedEvent);\n+          setupEventWriter(event.getJobID());\n         } catch (IOException ioe) {\n           LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n               ioe);\n           throw new YarnException(ioe);\n         }\n       }\n \n       // For all events\n       // (1) Write it out\n       // (2) Process it for JobSummary\n       MetaInfo mi \u003d fileMap.get(event.getJobID());\n       try {\n         HistoryEvent historyEvent \u003d event.getHistoryEvent();\n         mi.writeEvent(historyEvent);\n         processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(), event.getJobID());\n         LOG.info(\"In HistoryEventHandler \"\n             + event.getHistoryEvent().getEventType());\n       } catch (IOException e) {\n         LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n             e);\n         throw new YarnException(e);\n       }\n \n+      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n+        JobSubmittedEvent jobSubmittedEvent \u003d\n+            (JobSubmittedEvent) event.getHistoryEvent();\n+        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n+      }\n+\n       // If this is JobFinishedEvent, close the writer and setup the job-index\n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n         try {\n           JobFinishedEvent jFinishedEvent \u003d\n               (JobFinishedEvent) event.getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(\n               jFinishedEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n \n       if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n           || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n         try {\n           JobUnsuccessfulCompletionEvent jucEvent \u003d (JobUnsuccessfulCompletionEvent) event\n               .getHistoryEvent();\n           mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n           mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n           mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n           mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n           closeEventWriter(event.getJobID());\n         } catch (IOException e) {\n           throw new YarnException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.AM_STARTED) {\n        try {\n          setupEventWriter(event.getJobID());\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        mi.writeEvent(historyEvent);\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(), event.getJobID());\n        LOG.info(\"In HistoryEventHandler \"\n            + event.getHistoryEvent().getEventType());\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnException(e);\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        JobSubmittedEvent jobSubmittedEvent \u003d\n            (JobSubmittedEvent) event.getHistoryEvent();\n        mi.getJobIndexInfo().setSubmitTime(jobSubmittedEvent.getSubmitTime());\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        try {\n          JobSubmittedEvent jobSubmittedEvent \u003d\n              (JobSubmittedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), jobSubmittedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        mi.writeEvent(historyEvent);\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(), event.getJobID());\n        LOG.info(\"In HistoryEventHandler \"\n            + event.getHistoryEvent().getEventType());\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnException(e);\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,64 @@\n+  protected void handleEvent(JobHistoryEvent event) {\n+    synchronized (lock) {\n+\n+      // If this is JobSubmitted Event, setup the writer\n+      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n+        try {\n+          JobSubmittedEvent jobSubmittedEvent \u003d\n+              (JobSubmittedEvent) event.getHistoryEvent();\n+          setupEventWriter(event.getJobID(), jobSubmittedEvent);\n+        } catch (IOException ioe) {\n+          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n+              ioe);\n+          throw new YarnException(ioe);\n+        }\n+      }\n+\n+      // For all events\n+      // (1) Write it out\n+      // (2) Process it for JobSummary\n+      MetaInfo mi \u003d fileMap.get(event.getJobID());\n+      try {\n+        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n+        mi.writeEvent(historyEvent);\n+        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(), event.getJobID());\n+        LOG.info(\"In HistoryEventHandler \"\n+            + event.getHistoryEvent().getEventType());\n+      } catch (IOException e) {\n+        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n+            e);\n+        throw new YarnException(e);\n+      }\n+\n+      // If this is JobFinishedEvent, close the writer and setup the job-index\n+      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n+        try {\n+          JobFinishedEvent jFinishedEvent \u003d\n+              (JobFinishedEvent) event.getHistoryEvent();\n+          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n+          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n+          mi.getJobIndexInfo().setNumReduces(\n+              jFinishedEvent.getFinishedReduces());\n+          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n+          closeEventWriter(event.getJobID());\n+        } catch (IOException e) {\n+          throw new YarnException(e);\n+        }\n+      }\n+\n+      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n+          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n+        try {\n+          JobUnsuccessfulCompletionEvent jucEvent \u003d (JobUnsuccessfulCompletionEvent) event\n+              .getHistoryEvent();\n+          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n+          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n+          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n+          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n+          closeEventWriter(event.getJobID());\n+        } catch (IOException e) {\n+          throw new YarnException(e);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void handleEvent(JobHistoryEvent event) {\n    synchronized (lock) {\n\n      // If this is JobSubmitted Event, setup the writer\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_SUBMITTED) {\n        try {\n          JobSubmittedEvent jobSubmittedEvent \u003d\n              (JobSubmittedEvent) event.getHistoryEvent();\n          setupEventWriter(event.getJobID(), jobSubmittedEvent);\n        } catch (IOException ioe) {\n          LOG.error(\"Error JobHistoryEventHandler in handleEvent: \" + event,\n              ioe);\n          throw new YarnException(ioe);\n        }\n      }\n\n      // For all events\n      // (1) Write it out\n      // (2) Process it for JobSummary\n      MetaInfo mi \u003d fileMap.get(event.getJobID());\n      try {\n        HistoryEvent historyEvent \u003d event.getHistoryEvent();\n        mi.writeEvent(historyEvent);\n        processEventForJobSummary(event.getHistoryEvent(), mi.getJobSummary(), event.getJobID());\n        LOG.info(\"In HistoryEventHandler \"\n            + event.getHistoryEvent().getEventType());\n      } catch (IOException e) {\n        LOG.error(\"Error writing History Event: \" + event.getHistoryEvent(),\n            e);\n        throw new YarnException(e);\n      }\n\n      // If this is JobFinishedEvent, close the writer and setup the job-index\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FINISHED) {\n        try {\n          JobFinishedEvent jFinishedEvent \u003d\n              (JobFinishedEvent) event.getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jFinishedEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jFinishedEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(\n              jFinishedEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(JobState.SUCCEEDED.toString());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n\n      if (event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_FAILED\n          || event.getHistoryEvent().getEventType() \u003d\u003d EventType.JOB_KILLED) {\n        try {\n          JobUnsuccessfulCompletionEvent jucEvent \u003d (JobUnsuccessfulCompletionEvent) event\n              .getHistoryEvent();\n          mi.getJobIndexInfo().setFinishTime(jucEvent.getFinishTime());\n          mi.getJobIndexInfo().setNumMaps(jucEvent.getFinishedMaps());\n          mi.getJobIndexInfo().setNumReduces(jucEvent.getFinishedReduces());\n          mi.getJobIndexInfo().setJobStatus(jucEvent.getStatus());\n          closeEventWriter(event.getJobID());\n        } catch (IOException e) {\n          throw new YarnException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/jobhistory/JobHistoryEventHandler.java"
    }
  }
}