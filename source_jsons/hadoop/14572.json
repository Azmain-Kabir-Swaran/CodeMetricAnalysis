{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSUtil.java",
  "functionName": "getNameServiceUris",
  "functionId": "getNameServiceUris___conf-Configuration__nameServices-Collection__String____keys-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
  "functionStartLine": 814,
  "functionEndLine": 904,
  "numCommitsSeen": 272,
  "timeTaken": 5916,
  "changeHistory": [
    "a428d4f50e8caf553fb19a26200ec58f0b83da5d",
    "087290e6b1cb1082646d966b65494082712ebe3e",
    "15ed080e3610b7526eff12391de780948a75fa7b",
    "071733dc69a6f83c0cdca046b31ffd4f13304e93",
    "6f8003dc7bc9e8be7b0512c514d370c303faf003",
    "90c3700c5286cf2a5dcc850a386e2c674eb13acd",
    "05c5fcfb422ec6284e3c18531e91b206975616df"
  ],
  "changeHistoryShort": {
    "a428d4f50e8caf553fb19a26200ec58f0b83da5d": "Ybodychange",
    "087290e6b1cb1082646d966b65494082712ebe3e": "Ybodychange",
    "15ed080e3610b7526eff12391de780948a75fa7b": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "071733dc69a6f83c0cdca046b31ffd4f13304e93": "Ybodychange",
    "6f8003dc7bc9e8be7b0512c514d370c303faf003": "Ybodychange",
    "90c3700c5286cf2a5dcc850a386e2c674eb13acd": "Ybodychange",
    "05c5fcfb422ec6284e3c18531e91b206975616df": "Ybodychange"
  },
  "changeHistoryDetails": {
    "a428d4f50e8caf553fb19a26200ec58f0b83da5d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8897. Balancer should handle fs.defaultFS trailing slash in HA. Contributed by John Zhuge.\n",
      "commitDate": "10/08/16 10:17 PM",
      "commitName": "a428d4f50e8caf553fb19a26200ec58f0b83da5d",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "04/08/16 7:07 AM",
      "commitNameOld": "6ae39199dac6ac7be6802b31452552c76da16e24",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.63,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,91 @@\n   static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n       Collection\u003cString\u003e nameServices, String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n     for (String nsId : nameServices) {\n-      URI nsUri;\n-      try {\n-        nsUri \u003d new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId);\n-      } catch (URISyntaxException ue) {\n-        throw new IllegalArgumentException(ue);\n-      }\n+      URI nsUri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME, nsId, -1);\n       /**\n        * Determine whether the logical URI of the name service can be resolved\n        * by the configured failover proxy provider. If not, we should try to\n        * resolve the URI here\n        */\n       boolean useLogicalUri \u003d false;\n       try {\n         useLogicalUri \u003d HAUtil.useLogicalUri(conf, nsUri);\n       } catch (IOException e){\n         LOG.warn(\"Getting exception  while trying to determine if nameservice \"\n             + nsId + \" can use logical URI: \" + e);\n       }\n       if (HAUtil.isHAEnabled(conf, nsId) \u0026\u0026 useLogicalUri) {\n         // Add the logical URI of the nameservice.\n         ret.add(nsUri);\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n-        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n+        URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n+            NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n \n     // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n     // valid non-nameservice NN address yet.  Consider the servicerpc-address\n     // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n     // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n     // the defaultFS when neither the servicerpc-address (which is preferred)\n     // nor the rpc-address (which overrides defaultFS) is given.\n     if (!uriFound) {\n       URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n+      if (defaultUri !\u003d null) {\n+        // checks if defaultUri is ip:port format\n+        // and convert it to hostname:port format\n+        if (defaultUri.getPort() !\u003d -1) {\n+          defaultUri \u003d createUri(defaultUri.getScheme(),\n+              NetUtils.createSocketAddr(defaultUri.getHost(),\n+                  defaultUri.getPort()));\n+        }\n \n-      // checks if defaultUri is ip:port format\n-      // and convert it to hostname:port format\n-      if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n-        defaultUri \u003d createUri(defaultUri.getScheme(),\n-            NetUtils.createSocketAddr(defaultUri.getHost(),\n-                defaultUri.getPort()));\n-      }\n+        defaultUri \u003d trimUri(defaultUri);\n \n-      if (defaultUri !\u003d null \u0026\u0026\n-          HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n-          !nonPreferredUris.contains(defaultUri)) {\n-        ret.add(defaultUri);\n+        if (HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n+            !nonPreferredUris.contains(defaultUri)) {\n+          ret.add(defaultUri);\n+        }\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      Collection\u003cString\u003e nameServices, String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : nameServices) {\n      URI nsUri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME, nsId, -1);\n      /**\n       * Determine whether the logical URI of the name service can be resolved\n       * by the configured failover proxy provider. If not, we should try to\n       * resolve the URI here\n       */\n      boolean useLogicalUri \u003d false;\n      try {\n        useLogicalUri \u003d HAUtil.useLogicalUri(conf, nsUri);\n      } catch (IOException e){\n        LOG.warn(\"Getting exception  while trying to determine if nameservice \"\n            + nsId + \" can use logical URI: \" + e);\n      }\n      if (HAUtil.isHAEnabled(conf, nsId) \u0026\u0026 useLogicalUri) {\n        // Add the logical URI of the nameservice.\n        ret.add(nsUri);\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n            NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n\n    // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n    // valid non-nameservice NN address yet.  Consider the servicerpc-address\n    // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n    // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n    // the defaultFS when neither the servicerpc-address (which is preferred)\n    // nor the rpc-address (which overrides defaultFS) is given.\n    if (!uriFound) {\n      URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n      if (defaultUri !\u003d null) {\n        // checks if defaultUri is ip:port format\n        // and convert it to hostname:port format\n        if (defaultUri.getPort() !\u003d -1) {\n          defaultUri \u003d createUri(defaultUri.getScheme(),\n              NetUtils.createSocketAddr(defaultUri.getHost(),\n                  defaultUri.getPort()));\n        }\n\n        defaultUri \u003d trimUri(defaultUri);\n\n        if (HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n            !nonPreferredUris.contains(defaultUri)) {\n          ret.add(defaultUri);\n        }\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
      "extendedDetails": {}
    },
    "087290e6b1cb1082646d966b65494082712ebe3e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10544. Balancer doesn\u0027t work with IPFailoverProxyProvider.\n",
      "commitDate": "12/07/16 11:18 PM",
      "commitName": "087290e6b1cb1082646d966b65494082712ebe3e",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "24/05/16 12:49 PM",
      "commitNameOld": "15ed080e3610b7526eff12391de780948a75fa7b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 49.44,
      "commitsBetweenForRepo": 451,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,93 @@\n   static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n       Collection\u003cString\u003e nameServices, String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n     for (String nsId : nameServices) {\n-      if (HAUtil.isHAEnabled(conf, nsId)) {\n+      URI nsUri;\n+      try {\n+        nsUri \u003d new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId);\n+      } catch (URISyntaxException ue) {\n+        throw new IllegalArgumentException(ue);\n+      }\n+      /**\n+       * Determine whether the logical URI of the name service can be resolved\n+       * by the configured failover proxy provider. If not, we should try to\n+       * resolve the URI here\n+       */\n+      boolean useLogicalUri \u003d false;\n+      try {\n+        useLogicalUri \u003d HAUtil.useLogicalUri(conf, nsUri);\n+      } catch (IOException e){\n+        LOG.warn(\"Getting exception  while trying to determine if nameservice \"\n+            + nsId + \" can use logical URI: \" + e);\n+      }\n+      if (HAUtil.isHAEnabled(conf, nsId) \u0026\u0026 useLogicalUri) {\n         // Add the logical URI of the nameservice.\n-        try {\n-          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n-        } catch (URISyntaxException ue) {\n-          throw new IllegalArgumentException(ue);\n-        }\n+        ret.add(nsUri);\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n         URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n \n     // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n     // valid non-nameservice NN address yet.  Consider the servicerpc-address\n     // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n     // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n     // the defaultFS when neither the servicerpc-address (which is preferred)\n     // nor the rpc-address (which overrides defaultFS) is given.\n     if (!uriFound) {\n       URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n \n       // checks if defaultUri is ip:port format\n       // and convert it to hostname:port format\n       if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n         defaultUri \u003d createUri(defaultUri.getScheme(),\n             NetUtils.createSocketAddr(defaultUri.getHost(),\n                 defaultUri.getPort()));\n       }\n \n       if (defaultUri !\u003d null \u0026\u0026\n           HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n           !nonPreferredUris.contains(defaultUri)) {\n         ret.add(defaultUri);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      Collection\u003cString\u003e nameServices, String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : nameServices) {\n      URI nsUri;\n      try {\n        nsUri \u003d new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId);\n      } catch (URISyntaxException ue) {\n        throw new IllegalArgumentException(ue);\n      }\n      /**\n       * Determine whether the logical URI of the name service can be resolved\n       * by the configured failover proxy provider. If not, we should try to\n       * resolve the URI here\n       */\n      boolean useLogicalUri \u003d false;\n      try {\n        useLogicalUri \u003d HAUtil.useLogicalUri(conf, nsUri);\n      } catch (IOException e){\n        LOG.warn(\"Getting exception  while trying to determine if nameservice \"\n            + nsId + \" can use logical URI: \" + e);\n      }\n      if (HAUtil.isHAEnabled(conf, nsId) \u0026\u0026 useLogicalUri) {\n        // Add the logical URI of the nameservice.\n        ret.add(nsUri);\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n\n    // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n    // valid non-nameservice NN address yet.  Consider the servicerpc-address\n    // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n    // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n    // the defaultFS when neither the servicerpc-address (which is preferred)\n    // nor the rpc-address (which overrides defaultFS) is given.\n    if (!uriFound) {\n      URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n\n      // checks if defaultUri is ip:port format\n      // and convert it to hostname:port format\n      if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n        defaultUri \u003d createUri(defaultUri.getScheme(),\n            NetUtils.createSocketAddr(defaultUri.getHost(),\n                defaultUri.getPort()));\n      }\n\n      if (defaultUri !\u003d null \u0026\u0026\n          HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n          !nonPreferredUris.contains(defaultUri)) {\n        ret.add(defaultUri);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
      "extendedDetails": {}
    },
    "15ed080e3610b7526eff12391de780948a75fa7b": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-9365. Balaner does not work with the HDFS-6376 HA setup.\n",
      "commitDate": "24/05/16 12:49 PM",
      "commitName": "15ed080e3610b7526eff12391de780948a75fa7b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9365. Balaner does not work with the HDFS-6376 HA setup.\n",
          "commitDate": "24/05/16 12:49 PM",
          "commitName": "15ed080e3610b7526eff12391de780948a75fa7b",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "04/03/16 3:29 PM",
          "commitNameOld": "2759689d7d23001f007cb0dbe2521de90734dd5c",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 80.85,
          "commitsBetweenForRepo": 492,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,79 @@\n-  public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n-      String... keys) {\n+  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n+      Collection\u003cString\u003e nameServices, String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n-    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {\n+    for (String nsId : nameServices) {\n       if (HAUtil.isHAEnabled(conf, nsId)) {\n         // Add the logical URI of the nameservice.\n         try {\n           ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n         } catch (URISyntaxException ue) {\n           throw new IllegalArgumentException(ue);\n         }\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n         URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n \n     // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n     // valid non-nameservice NN address yet.  Consider the servicerpc-address\n     // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n     // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n     // the defaultFS when neither the servicerpc-address (which is preferred)\n     // nor the rpc-address (which overrides defaultFS) is given.\n     if (!uriFound) {\n       URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n \n       // checks if defaultUri is ip:port format\n       // and convert it to hostname:port format\n       if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n         defaultUri \u003d createUri(defaultUri.getScheme(),\n             NetUtils.createSocketAddr(defaultUri.getHost(),\n                 defaultUri.getPort()));\n       }\n \n       if (defaultUri !\u003d null \u0026\u0026\n           HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n           !nonPreferredUris.contains(defaultUri)) {\n         ret.add(defaultUri);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      Collection\u003cString\u003e nameServices, String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : nameServices) {\n      if (HAUtil.isHAEnabled(conf, nsId)) {\n        // Add the logical URI of the nameservice.\n        try {\n          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n        } catch (URISyntaxException ue) {\n          throw new IllegalArgumentException(ue);\n        }\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n\n    // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n    // valid non-nameservice NN address yet.  Consider the servicerpc-address\n    // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n    // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n    // the defaultFS when neither the servicerpc-address (which is preferred)\n    // nor the rpc-address (which overrides defaultFS) is given.\n    if (!uriFound) {\n      URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n\n      // checks if defaultUri is ip:port format\n      // and convert it to hostname:port format\n      if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n        defaultUri \u003d createUri(defaultUri.getScheme(),\n            NetUtils.createSocketAddr(defaultUri.getHost(),\n                defaultUri.getPort()));\n      }\n\n      if (defaultUri !\u003d null \u0026\u0026\n          HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n          !nonPreferredUris.contains(defaultUri)) {\n        ret.add(defaultUri);\n      }\n    }\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
          "extendedDetails": {
            "oldValue": "[conf-Configuration, keys-String]",
            "newValue": "[conf-Configuration, nameServices-Collection\u003cString\u003e, keys-String]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-9365. Balaner does not work with the HDFS-6376 HA setup.\n",
          "commitDate": "24/05/16 12:49 PM",
          "commitName": "15ed080e3610b7526eff12391de780948a75fa7b",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "04/03/16 3:29 PM",
          "commitNameOld": "2759689d7d23001f007cb0dbe2521de90734dd5c",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 80.85,
          "commitsBetweenForRepo": 492,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,79 @@\n-  public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n-      String... keys) {\n+  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n+      Collection\u003cString\u003e nameServices, String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n-    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {\n+    for (String nsId : nameServices) {\n       if (HAUtil.isHAEnabled(conf, nsId)) {\n         // Add the logical URI of the nameservice.\n         try {\n           ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n         } catch (URISyntaxException ue) {\n           throw new IllegalArgumentException(ue);\n         }\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n         URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n \n     // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n     // valid non-nameservice NN address yet.  Consider the servicerpc-address\n     // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n     // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n     // the defaultFS when neither the servicerpc-address (which is preferred)\n     // nor the rpc-address (which overrides defaultFS) is given.\n     if (!uriFound) {\n       URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n \n       // checks if defaultUri is ip:port format\n       // and convert it to hostname:port format\n       if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n         defaultUri \u003d createUri(defaultUri.getScheme(),\n             NetUtils.createSocketAddr(defaultUri.getHost(),\n                 defaultUri.getPort()));\n       }\n \n       if (defaultUri !\u003d null \u0026\u0026\n           HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n           !nonPreferredUris.contains(defaultUri)) {\n         ret.add(defaultUri);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      Collection\u003cString\u003e nameServices, String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : nameServices) {\n      if (HAUtil.isHAEnabled(conf, nsId)) {\n        // Add the logical URI of the nameservice.\n        try {\n          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n        } catch (URISyntaxException ue) {\n          throw new IllegalArgumentException(ue);\n        }\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n\n    // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n    // valid non-nameservice NN address yet.  Consider the servicerpc-address\n    // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n    // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n    // the defaultFS when neither the servicerpc-address (which is preferred)\n    // nor the rpc-address (which overrides defaultFS) is given.\n    if (!uriFound) {\n      URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n\n      // checks if defaultUri is ip:port format\n      // and convert it to hostname:port format\n      if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n        defaultUri \u003d createUri(defaultUri.getScheme(),\n            NetUtils.createSocketAddr(defaultUri.getHost(),\n                defaultUri.getPort()));\n      }\n\n      if (defaultUri !\u003d null \u0026\u0026\n          HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n          !nonPreferredUris.contains(defaultUri)) {\n        ret.add(defaultUri);\n      }\n    }\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9365. Balaner does not work with the HDFS-6376 HA setup.\n",
          "commitDate": "24/05/16 12:49 PM",
          "commitName": "15ed080e3610b7526eff12391de780948a75fa7b",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "04/03/16 3:29 PM",
          "commitNameOld": "2759689d7d23001f007cb0dbe2521de90734dd5c",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 80.85,
          "commitsBetweenForRepo": 492,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,79 @@\n-  public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n-      String... keys) {\n+  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n+      Collection\u003cString\u003e nameServices, String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n-    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {\n+    for (String nsId : nameServices) {\n       if (HAUtil.isHAEnabled(conf, nsId)) {\n         // Add the logical URI of the nameservice.\n         try {\n           ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n         } catch (URISyntaxException ue) {\n           throw new IllegalArgumentException(ue);\n         }\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n         URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n \n     // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n     // valid non-nameservice NN address yet.  Consider the servicerpc-address\n     // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n     // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n     // the defaultFS when neither the servicerpc-address (which is preferred)\n     // nor the rpc-address (which overrides defaultFS) is given.\n     if (!uriFound) {\n       URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n \n       // checks if defaultUri is ip:port format\n       // and convert it to hostname:port format\n       if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n         defaultUri \u003d createUri(defaultUri.getScheme(),\n             NetUtils.createSocketAddr(defaultUri.getHost(),\n                 defaultUri.getPort()));\n       }\n \n       if (defaultUri !\u003d null \u0026\u0026\n           HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n           !nonPreferredUris.contains(defaultUri)) {\n         ret.add(defaultUri);\n       }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      Collection\u003cString\u003e nameServices, String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : nameServices) {\n      if (HAUtil.isHAEnabled(conf, nsId)) {\n        // Add the logical URI of the nameservice.\n        try {\n          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n        } catch (URISyntaxException ue) {\n          throw new IllegalArgumentException(ue);\n        }\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n\n    // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n    // valid non-nameservice NN address yet.  Consider the servicerpc-address\n    // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n    // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n    // the defaultFS when neither the servicerpc-address (which is preferred)\n    // nor the rpc-address (which overrides defaultFS) is given.\n    if (!uriFound) {\n      URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n\n      // checks if defaultUri is ip:port format\n      // and convert it to hostname:port format\n      if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n        defaultUri \u003d createUri(defaultUri.getScheme(),\n            NetUtils.createSocketAddr(defaultUri.getHost(),\n                defaultUri.getPort()));\n      }\n\n      if (defaultUri !\u003d null \u0026\u0026\n          HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n          !nonPreferredUris.contains(defaultUri)) {\n        ret.add(defaultUri);\n      }\n    }\n    \n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "071733dc69a6f83c0cdca046b31ffd4f13304e93": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9001. DFSUtil.getNsServiceRpcUris() can return too many entries in a non-HA, non-federated cluster. Contributed by Daniel Templeton.\n",
      "commitDate": "29/09/15 6:19 PM",
      "commitName": "071733dc69a6f83c0cdca046b31ffd4f13304e93",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "26/09/15 11:08 AM",
      "commitNameOld": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.3,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,79 @@\n   public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n       String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n     for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {\n       if (HAUtil.isHAEnabled(conf, nsId)) {\n         // Add the logical URI of the nameservice.\n         try {\n           ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n         } catch (URISyntaxException ue) {\n           throw new IllegalArgumentException(ue);\n         }\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n         URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n-    \n-    // Add the default URI if it is an HDFS URI.\n-    URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n-    // checks if defaultUri is ip:port format\n-    // and convert it to hostname:port format\n-    if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n-      defaultUri \u003d createUri(defaultUri.getScheme(),\n-          NetUtils.createSocketAddr(defaultUri.getHost(), \n-              defaultUri.getPort()));\n-    }\n-    if (defaultUri !\u003d null \u0026\u0026\n-        HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n-        !nonPreferredUris.contains(defaultUri)) {\n-      ret.add(defaultUri);\n+\n+    // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n+    // valid non-nameservice NN address yet.  Consider the servicerpc-address\n+    // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n+    // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n+    // the defaultFS when neither the servicerpc-address (which is preferred)\n+    // nor the rpc-address (which overrides defaultFS) is given.\n+    if (!uriFound) {\n+      URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n+\n+      // checks if defaultUri is ip:port format\n+      // and convert it to hostname:port format\n+      if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n+        defaultUri \u003d createUri(defaultUri.getScheme(),\n+            NetUtils.createSocketAddr(defaultUri.getHost(),\n+                defaultUri.getPort()));\n+      }\n+\n+      if (defaultUri !\u003d null \u0026\u0026\n+          HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n+          !nonPreferredUris.contains(defaultUri)) {\n+        ret.add(defaultUri);\n+      }\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {\n      if (HAUtil.isHAEnabled(conf, nsId)) {\n        // Add the logical URI of the nameservice.\n        try {\n          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n        } catch (URISyntaxException ue) {\n          throw new IllegalArgumentException(ue);\n        }\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n\n    // Add the default URI if it is an HDFS URI and we haven\u0027t come up with a\n    // valid non-nameservice NN address yet.  Consider the servicerpc-address\n    // and rpc-address to be the \"unnamed\" nameservice.  defaultFS is our\n    // fallback when rpc-address isn\u0027t given.  We therefore only want to add\n    // the defaultFS when neither the servicerpc-address (which is preferred)\n    // nor the rpc-address (which overrides defaultFS) is given.\n    if (!uriFound) {\n      URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n\n      // checks if defaultUri is ip:port format\n      // and convert it to hostname:port format\n      if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n        defaultUri \u003d createUri(defaultUri.getScheme(),\n            NetUtils.createSocketAddr(defaultUri.getHost(),\n                defaultUri.getPort()));\n      }\n\n      if (defaultUri !\u003d null \u0026\u0026\n          HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n          !nonPreferredUris.contains(defaultUri)) {\n        ret.add(defaultUri);\n      }\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
      "extendedDetails": {}
    },
    "6f8003dc7bc9e8be7b0512c514d370c303faf003": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8185. Separate client related routines in HAUtil into a new class. Contributed by Haohui Mai.\n",
      "commitDate": "21/04/15 9:59 PM",
      "commitName": "6f8003dc7bc9e8be7b0512c514d370c303faf003",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "20/04/15 12:36 AM",
      "commitNameOld": "5c97db07fb306842f49d73a67a90cecec19a7833",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.89,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n       String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n-    for (String nsId : getNameServiceIds(conf)) {\n+    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {\n       if (HAUtil.isHAEnabled(conf, nsId)) {\n         // Add the logical URI of the nameservice.\n         try {\n           ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n         } catch (URISyntaxException ue) {\n           throw new IllegalArgumentException(ue);\n         }\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n-          String addr \u003d conf.get(concatSuffixes(key, nsId));\n+          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n         URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n     \n     // Add the default URI if it is an HDFS URI.\n     URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n     // checks if defaultUri is ip:port format\n     // and convert it to hostname:port format\n     if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n       defaultUri \u003d createUri(defaultUri.getScheme(),\n           NetUtils.createSocketAddr(defaultUri.getHost(), \n               defaultUri.getPort()));\n     }\n     if (defaultUri !\u003d null \u0026\u0026\n         HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n         !nonPreferredUris.contains(defaultUri)) {\n       ret.add(defaultUri);\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {\n      if (HAUtil.isHAEnabled(conf, nsId)) {\n        // Add the logical URI of the nameservice.\n        try {\n          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n        } catch (URISyntaxException ue) {\n          throw new IllegalArgumentException(ue);\n        }\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(DFSUtilClient.concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n    \n    // Add the default URI if it is an HDFS URI.\n    URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n    // checks if defaultUri is ip:port format\n    // and convert it to hostname:port format\n    if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n      defaultUri \u003d createUri(defaultUri.getScheme(),\n          NetUtils.createSocketAddr(defaultUri.getHost(), \n              defaultUri.getPort()));\n    }\n    if (defaultUri !\u003d null \u0026\u0026\n        HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n        !nonPreferredUris.contains(defaultUri)) {\n      ret.add(defaultUri);\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
      "extendedDetails": {}
    },
    "90c3700c5286cf2a5dcc850a386e2c674eb13acd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4458. In DFSUtil.getNameServiceUris(..), convert default fs URI using NetUtils.createSocketAddr(..) for being consistent with other addresses.  Contributed by Binglin Chang\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1443297 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/02/13 7:04 PM",
      "commitName": "90c3700c5286cf2a5dcc850a386e2c674eb13acd",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "05/02/13 5:13 PM",
      "commitNameOld": "e28edbffe15e9d176d14ea2af8d9460d807b3fc4",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,70 @@\n   public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n       String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n     \n     // We\u0027re passed multiple possible configuration keys for any given NN or HA\n     // nameservice, and search the config in order of these keys. In order to\n     // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n     // URI for a config key for which we\u0027ve already found a preferred entry, we\n     // keep track of non-preferred keys here.\n     Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n     \n     for (String nsId : getNameServiceIds(conf)) {\n       if (HAUtil.isHAEnabled(conf, nsId)) {\n         // Add the logical URI of the nameservice.\n         try {\n           ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n         } catch (URISyntaxException ue) {\n           throw new IllegalArgumentException(ue);\n         }\n       } else {\n         // Add the URI corresponding to the address of the NN.\n         boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n             URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                 NetUtils.createSocketAddr(addr));\n             if (!uriFound) {\n               uriFound \u003d true;\n               ret.add(uri);\n             } else {\n               nonPreferredUris.add(uri);\n             }\n           }\n         }\n       }\n     }\n     \n     // Add the generic configuration keys.\n     boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n         URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n         if (!uriFound) {\n           uriFound \u003d true;\n           ret.add(uri);\n         } else {\n           nonPreferredUris.add(uri);\n         }\n       }\n     }\n     \n     // Add the default URI if it is an HDFS URI.\n     URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n+    // checks if defaultUri is ip:port format\n+    // and convert it to hostname:port format\n+    if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n+      defaultUri \u003d createUri(defaultUri.getScheme(),\n+          NetUtils.createSocketAddr(defaultUri.getHost(), \n+              defaultUri.getPort()));\n+    }\n     if (defaultUri !\u003d null \u0026\u0026\n         HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n         !nonPreferredUris.contains(defaultUri)) {\n       ret.add(defaultUri);\n     }\n     \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : getNameServiceIds(conf)) {\n      if (HAUtil.isHAEnabled(conf, nsId)) {\n        // Add the logical URI of the nameservice.\n        try {\n          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n        } catch (URISyntaxException ue) {\n          throw new IllegalArgumentException(ue);\n        }\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n    \n    // Add the default URI if it is an HDFS URI.\n    URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n    // checks if defaultUri is ip:port format\n    // and convert it to hostname:port format\n    if (defaultUri !\u003d null \u0026\u0026 (defaultUri.getPort() !\u003d -1)) {\n      defaultUri \u003d createUri(defaultUri.getScheme(),\n          NetUtils.createSocketAddr(defaultUri.getHost(), \n              defaultUri.getPort()));\n    }\n    if (defaultUri !\u003d null \u0026\u0026\n        HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n        !nonPreferredUris.contains(defaultUri)) {\n      ret.add(defaultUri);\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
      "extendedDetails": {}
    },
    "05c5fcfb422ec6284e3c18531e91b206975616df": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3414. Balancer does not find NameNode if rpc-address or servicerpc-address are not set in client configs. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1338275 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/05/12 9:25 AM",
      "commitName": "05c5fcfb422ec6284e3c18531e91b206975616df",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "10/05/12 6:49 AM",
      "commitNameOld": "f5960f71d9dcdc237f08e41bf1ebfbd572ca83af",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,63 @@\n   public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n       String... keys) {\n     Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n+    \n+    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n+    // nameservice, and search the config in order of these keys. In order to\n+    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n+    // URI for a config key for which we\u0027ve already found a preferred entry, we\n+    // keep track of non-preferred keys here.\n+    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n+    \n     for (String nsId : getNameServiceIds(conf)) {\n       if (HAUtil.isHAEnabled(conf, nsId)) {\n         // Add the logical URI of the nameservice.\n         try {\n           ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n         } catch (URISyntaxException ue) {\n           throw new IllegalArgumentException(ue);\n         }\n       } else {\n         // Add the URI corresponding to the address of the NN.\n+        boolean uriFound \u003d false;\n         for (String key : keys) {\n           String addr \u003d conf.get(concatSuffixes(key, nsId));\n           if (addr !\u003d null) {\n-            ret.add(createUri(HdfsConstants.HDFS_URI_SCHEME,\n-                NetUtils.createSocketAddr(addr)));\n-            break;\n+            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n+                NetUtils.createSocketAddr(addr));\n+            if (!uriFound) {\n+              uriFound \u003d true;\n+              ret.add(uri);\n+            } else {\n+              nonPreferredUris.add(uri);\n+            }\n           }\n         }\n       }\n     }\n+    \n     // Add the generic configuration keys.\n+    boolean uriFound \u003d false;\n     for (String key : keys) {\n       String addr \u003d conf.get(key);\n       if (addr !\u003d null) {\n-        ret.add(createUri(\"hdfs\", NetUtils.createSocketAddr(addr)));\n-        break;\n+        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n+        if (!uriFound) {\n+          uriFound \u003d true;\n+          ret.add(uri);\n+        } else {\n+          nonPreferredUris.add(uri);\n+        }\n       }\n     }\n+    \n+    // Add the default URI if it is an HDFS URI.\n+    URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n+    if (defaultUri !\u003d null \u0026\u0026\n+        HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n+        !nonPreferredUris.contains(defaultUri)) {\n+      ret.add(defaultUri);\n+    }\n+    \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Collection\u003cURI\u003e getNameServiceUris(Configuration conf,\n      String... keys) {\n    Set\u003cURI\u003e ret \u003d new HashSet\u003cURI\u003e();\n    \n    // We\u0027re passed multiple possible configuration keys for any given NN or HA\n    // nameservice, and search the config in order of these keys. In order to\n    // make sure that a later config lookup (e.g. fs.defaultFS) doesn\u0027t add a\n    // URI for a config key for which we\u0027ve already found a preferred entry, we\n    // keep track of non-preferred keys here.\n    Set\u003cURI\u003e nonPreferredUris \u003d new HashSet\u003cURI\u003e();\n    \n    for (String nsId : getNameServiceIds(conf)) {\n      if (HAUtil.isHAEnabled(conf, nsId)) {\n        // Add the logical URI of the nameservice.\n        try {\n          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + \"://\" + nsId));\n        } catch (URISyntaxException ue) {\n          throw new IllegalArgumentException(ue);\n        }\n      } else {\n        // Add the URI corresponding to the address of the NN.\n        boolean uriFound \u003d false;\n        for (String key : keys) {\n          String addr \u003d conf.get(concatSuffixes(key, nsId));\n          if (addr !\u003d null) {\n            URI uri \u003d createUri(HdfsConstants.HDFS_URI_SCHEME,\n                NetUtils.createSocketAddr(addr));\n            if (!uriFound) {\n              uriFound \u003d true;\n              ret.add(uri);\n            } else {\n              nonPreferredUris.add(uri);\n            }\n          }\n        }\n      }\n    }\n    \n    // Add the generic configuration keys.\n    boolean uriFound \u003d false;\n    for (String key : keys) {\n      String addr \u003d conf.get(key);\n      if (addr !\u003d null) {\n        URI uri \u003d createUri(\"hdfs\", NetUtils.createSocketAddr(addr));\n        if (!uriFound) {\n          uriFound \u003d true;\n          ret.add(uri);\n        } else {\n          nonPreferredUris.add(uri);\n        }\n      }\n    }\n    \n    // Add the default URI if it is an HDFS URI.\n    URI defaultUri \u003d FileSystem.getDefaultUri(conf);\n    if (defaultUri !\u003d null \u0026\u0026\n        HdfsConstants.HDFS_URI_SCHEME.equals(defaultUri.getScheme()) \u0026\u0026\n        !nonPreferredUris.contains(defaultUri)) {\n      ret.add(defaultUri);\n    }\n    \n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSUtil.java",
      "extendedDetails": {}
    }
  }
}