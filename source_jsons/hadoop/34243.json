{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SharedCacheUploader.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/sharedcache/SharedCacheUploader.java",
  "functionStartLine": 116,
  "functionEndLine": 178,
  "numCommitsSeen": 5,
  "timeTaken": 1006,
  "changeHistory": [
    "a04143039e7fe310d807f40584633096181cfada"
  ],
  "changeHistoryShort": {
    "a04143039e7fe310d807f40584633096181cfada": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a04143039e7fe310d807f40584633096181cfada": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2236. [YARN-1492] Shared Cache uploader service on the Node Manager. (Chris Trezzo and Sanjin Lee via kasha)\n",
      "commitDate": "12/11/14 9:31 AM",
      "commitName": "a04143039e7fe310d807f40584633096181cfada",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,63 @@\n+  public Boolean call() throws Exception {\n+    Path tempPath \u003d null;\n+    try {\n+      if (!verifyAccess()) {\n+        LOG.warn(\"User \" + user + \" is not authorized to upload file \" +\n+            localPath.getName());\n+        return false;\n+      }\n+\n+      // first determine the actual local path that will be used for upload\n+      Path actualPath \u003d getActualPath();\n+      // compute the checksum\n+      String checksumVal \u003d computeChecksum(actualPath);\n+      // create the directory (if it doesn\u0027t exist)\n+      Path directoryPath \u003d\n+          new Path(SharedCacheUtil.getCacheEntryPath(nestedLevel,\n+              sharedCacheRootDir, checksumVal));\n+      // let\u0027s not check if the directory already exists: in the vast majority\n+      // of the cases, the directory does not exist; as long as mkdirs does not\n+      // error out if it exists, we should be fine\n+      fs.mkdirs(directoryPath, DIRECTORY_PERMISSION);\n+      // create the temporary file\n+      tempPath \u003d new Path(directoryPath, getTemporaryFileName(actualPath));\n+      if (!uploadFile(actualPath, tempPath)) {\n+        LOG.warn(\"Could not copy the file to the shared cache at \" + tempPath);\n+        return false;\n+      }\n+\n+      // set the permission so that it is readable but not writable\n+      fs.setPermission(tempPath, FILE_PERMISSION);\n+      // rename it to the final filename\n+      Path finalPath \u003d new Path(directoryPath, actualPath.getName());\n+      if (!fs.rename(tempPath, finalPath)) {\n+        LOG.warn(\"The file already exists under \" + finalPath +\n+            \". Ignoring this attempt.\");\n+        deleteTempFile(tempPath);\n+        return false;\n+      }\n+\n+      // notify the SCM\n+      if (!notifySharedCacheManager(checksumVal, actualPath.getName())) {\n+        // the shared cache manager rejected the upload (as it is likely\n+        // uploaded under a different name\n+        // clean up this file and exit\n+        fs.delete(finalPath, false);\n+        return false;\n+      }\n+\n+      // set the replication factor\n+      short replication \u003d\n+          (short)conf.getInt(YarnConfiguration.SHARED_CACHE_NM_UPLOADER_REPLICATION_FACTOR,\n+              YarnConfiguration.DEFAULT_SHARED_CACHE_NM_UPLOADER_REPLICATION_FACTOR);\n+      fs.setReplication(finalPath, replication);\n+      LOG.info(\"File \" + actualPath.getName() +\n+          \" was uploaded to the shared cache at \" + finalPath);\n+      return true;\n+    } catch (IOException e) {\n+      LOG.warn(\"Exception while uploading the file \" + localPath.getName(), e);\n+      // in case an exception is thrown, delete the temp file\n+      deleteTempFile(tempPath);\n+      throw e;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Boolean call() throws Exception {\n    Path tempPath \u003d null;\n    try {\n      if (!verifyAccess()) {\n        LOG.warn(\"User \" + user + \" is not authorized to upload file \" +\n            localPath.getName());\n        return false;\n      }\n\n      // first determine the actual local path that will be used for upload\n      Path actualPath \u003d getActualPath();\n      // compute the checksum\n      String checksumVal \u003d computeChecksum(actualPath);\n      // create the directory (if it doesn\u0027t exist)\n      Path directoryPath \u003d\n          new Path(SharedCacheUtil.getCacheEntryPath(nestedLevel,\n              sharedCacheRootDir, checksumVal));\n      // let\u0027s not check if the directory already exists: in the vast majority\n      // of the cases, the directory does not exist; as long as mkdirs does not\n      // error out if it exists, we should be fine\n      fs.mkdirs(directoryPath, DIRECTORY_PERMISSION);\n      // create the temporary file\n      tempPath \u003d new Path(directoryPath, getTemporaryFileName(actualPath));\n      if (!uploadFile(actualPath, tempPath)) {\n        LOG.warn(\"Could not copy the file to the shared cache at \" + tempPath);\n        return false;\n      }\n\n      // set the permission so that it is readable but not writable\n      fs.setPermission(tempPath, FILE_PERMISSION);\n      // rename it to the final filename\n      Path finalPath \u003d new Path(directoryPath, actualPath.getName());\n      if (!fs.rename(tempPath, finalPath)) {\n        LOG.warn(\"The file already exists under \" + finalPath +\n            \". Ignoring this attempt.\");\n        deleteTempFile(tempPath);\n        return false;\n      }\n\n      // notify the SCM\n      if (!notifySharedCacheManager(checksumVal, actualPath.getName())) {\n        // the shared cache manager rejected the upload (as it is likely\n        // uploaded under a different name\n        // clean up this file and exit\n        fs.delete(finalPath, false);\n        return false;\n      }\n\n      // set the replication factor\n      short replication \u003d\n          (short)conf.getInt(YarnConfiguration.SHARED_CACHE_NM_UPLOADER_REPLICATION_FACTOR,\n              YarnConfiguration.DEFAULT_SHARED_CACHE_NM_UPLOADER_REPLICATION_FACTOR);\n      fs.setReplication(finalPath, replication);\n      LOG.info(\"File \" + actualPath.getName() +\n          \" was uploaded to the shared cache at \" + finalPath);\n      return true;\n    } catch (IOException e) {\n      LOG.warn(\"Exception while uploading the file \" + localPath.getName(), e);\n      // in case an exception is thrown, delete the temp file\n      deleteTempFile(tempPath);\n      throw e;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/sharedcache/SharedCacheUploader.java"
    }
  }
}