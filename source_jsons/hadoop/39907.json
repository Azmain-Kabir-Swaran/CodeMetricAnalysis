{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueueAdminConfigurationMutationACLPolicy.java",
  "functionName": "isMutationAllowed",
  "functionId": "isMutationAllowed___user-UserGroupInformation__confUpdate-SchedConfUpdateInfo",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/QueueAdminConfigurationMutationACLPolicy.java",
  "functionStartLine": 57,
  "functionEndLine": 113,
  "numCommitsSeen": 5,
  "timeTaken": 2850,
  "changeHistory": [
    "92b28e38b7bcfb70a3e805ff40ef73d27ba24788",
    "e566fd8b58a6570593b21597aa5294d7b37cb388",
    "a4e62530469e4c3d5b339a06adeac2146fc15fa5"
  ],
  "changeHistoryShort": {
    "92b28e38b7bcfb70a3e805ff40ef73d27ba24788": "Ybodychange",
    "e566fd8b58a6570593b21597aa5294d7b37cb388": "Ymultichange(Yparameterchange,Ybodychange)",
    "a4e62530469e4c3d5b339a06adeac2146fc15fa5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "92b28e38b7bcfb70a3e805ff40ef73d27ba24788": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9996. Code cleanup in QueueAdminConfigurationMutationACLPolicy. Contributed by Siddharth Ahuja\n",
      "commitDate": "18/04/20 1:13 AM",
      "commitName": "92b28e38b7bcfb70a3e805ff40ef73d27ba24788",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "916bdbd6bedbc75000bb74e16c1e2ee692a4912c",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 921.58,
      "commitsBetweenForRepo": 6759,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,57 @@\n   public boolean isMutationAllowed(UserGroupInformation user,\n       SchedConfUpdateInfo confUpdate) {\n     // If there are global config changes, check if user is admin.\n     Map\u003cString, String\u003e globalParams \u003d confUpdate.getGlobalParams();\n     if (globalParams !\u003d null \u0026\u0026 globalParams.size() !\u003d 0) {\n       if (!authorizer.isAdmin(user)) {\n         return false;\n       }\n     }\n \n     // Check if user is admin of all modified queues.\n     Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n     for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n       queues.add(addQueueInfo.getQueue());\n     }\n     for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n       queues.add(removeQueue);\n     }\n     for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n       queues.add(updateQueueInfo.getQueue());\n     }\n+\n+    // Loop through all the queues.\n     for (String queuePath : queues) {\n-      String queueName \u003d queuePath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n-          queuePath.substring(queuePath.lastIndexOf(\u0027.\u0027) + 1) : queuePath;\n       QueueInfo queueInfo \u003d null;\n-      try {\n-        queueInfo \u003d rmContext.getScheduler()\n-            .getQueueInfo(queueName, false, false);\n-      } catch (IOException e) {\n-        // Queue is not found, do nothing.\n-      }\n       String parentPath \u003d queuePath;\n+\n+      // For this queue, check if queue information exists for its children\n+      // starting at the end of the queue.\n+      // Keep this check going by moving up in the queue hierarchy until\n+      // queue information has been found for one of its children.\n+      String queueName;\n       while (queueInfo \u003d\u003d null) {\n-        // We are adding a queue (whose parent we are possibly also adding).\n-        // Check ACL of lowest parent queue which already exists.\n-        parentPath \u003d parentPath.substring(0, parentPath.lastIndexOf(\u0027.\u0027));\n-        String parentName \u003d parentPath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n-            parentPath.substring(parentPath.lastIndexOf(\u0027.\u0027) + 1) : parentPath;\n+        queueName \u003d queueHasAChild(parentPath) ?\n+            getLastChildForQueue(parentPath) : parentPath;\n         try {\n           queueInfo \u003d rmContext.getScheduler()\n-              .getQueueInfo(parentName, false, false);\n+              .getQueueInfo(queueName, false, false);\n         } catch (IOException e) {\n           // Queue is not found, do nothing.\n         }\n+\n+        // Keep going up in the queue hierarchy.\n+        parentPath \u003d queueHasAChild(parentPath) ?\n+            getQueueBeforeLastChild(parentPath) : parentPath;\n       }\n+\n+      // check if user has Admin access to this queue.\n       Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n           .getQueue(queueInfo.getQueueName());\n       if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n         return false;\n       }\n     }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean isMutationAllowed(UserGroupInformation user,\n      SchedConfUpdateInfo confUpdate) {\n    // If there are global config changes, check if user is admin.\n    Map\u003cString, String\u003e globalParams \u003d confUpdate.getGlobalParams();\n    if (globalParams !\u003d null \u0026\u0026 globalParams.size() !\u003d 0) {\n      if (!authorizer.isAdmin(user)) {\n        return false;\n      }\n    }\n\n    // Check if user is admin of all modified queues.\n    Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n    for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n      queues.add(addQueueInfo.getQueue());\n    }\n    for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n      queues.add(removeQueue);\n    }\n    for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n      queues.add(updateQueueInfo.getQueue());\n    }\n\n    // Loop through all the queues.\n    for (String queuePath : queues) {\n      QueueInfo queueInfo \u003d null;\n      String parentPath \u003d queuePath;\n\n      // For this queue, check if queue information exists for its children\n      // starting at the end of the queue.\n      // Keep this check going by moving up in the queue hierarchy until\n      // queue information has been found for one of its children.\n      String queueName;\n      while (queueInfo \u003d\u003d null) {\n        queueName \u003d queueHasAChild(parentPath) ?\n            getLastChildForQueue(parentPath) : parentPath;\n        try {\n          queueInfo \u003d rmContext.getScheduler()\n              .getQueueInfo(queueName, false, false);\n        } catch (IOException e) {\n          // Queue is not found, do nothing.\n        }\n\n        // Keep going up in the queue hierarchy.\n        parentPath \u003d queueHasAChild(parentPath) ?\n            getQueueBeforeLastChild(parentPath) : parentPath;\n      }\n\n      // check if user has Admin access to this queue.\n      Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n          .getQueue(queueInfo.getQueueName());\n      if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/QueueAdminConfigurationMutationACLPolicy.java",
      "extendedDetails": {}
    },
    "e566fd8b58a6570593b21597aa5294d7b37cb388": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6575. Support global configuration mutation in MutableConfProvider. (Jonathan Hung via Xuan Gong)\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "e566fd8b58a6570593b21597aa5294d7b37cb388",
      "commitAuthor": "Xuan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6575. Support global configuration mutation in MutableConfProvider. (Jonathan Hung via Xuan Gong)\n",
          "commitDate": "09/10/17 11:11 AM",
          "commitName": "e566fd8b58a6570593b21597aa5294d7b37cb388",
          "commitAuthor": "Xuan",
          "commitDateOld": "09/10/17 11:11 AM",
          "commitNameOld": "a4e62530469e4c3d5b339a06adeac2146fc15fa5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,53 @@\n   public boolean isMutationAllowed(UserGroupInformation user,\n-      QueueConfigsUpdateInfo confUpdate) {\n+      SchedConfUpdateInfo confUpdate) {\n+    // If there are global config changes, check if user is admin.\n+    Map\u003cString, String\u003e globalParams \u003d confUpdate.getGlobalParams();\n+    if (globalParams !\u003d null \u0026\u0026 globalParams.size() !\u003d 0) {\n+      if (!authorizer.isAdmin(user)) {\n+        return false;\n+      }\n+    }\n+\n+    // Check if user is admin of all modified queues.\n     Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n     for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n       queues.add(addQueueInfo.getQueue());\n     }\n     for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n       queues.add(removeQueue);\n     }\n     for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n       queues.add(updateQueueInfo.getQueue());\n     }\n     for (String queuePath : queues) {\n       String queueName \u003d queuePath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n           queuePath.substring(queuePath.lastIndexOf(\u0027.\u0027) + 1) : queuePath;\n       QueueInfo queueInfo \u003d null;\n       try {\n         queueInfo \u003d rmContext.getScheduler()\n             .getQueueInfo(queueName, false, false);\n       } catch (IOException e) {\n         // Queue is not found, do nothing.\n       }\n       String parentPath \u003d queuePath;\n-      // TODO: handle global config change.\n       while (queueInfo \u003d\u003d null) {\n         // We are adding a queue (whose parent we are possibly also adding).\n         // Check ACL of lowest parent queue which already exists.\n         parentPath \u003d parentPath.substring(0, parentPath.lastIndexOf(\u0027.\u0027));\n         String parentName \u003d parentPath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n             parentPath.substring(parentPath.lastIndexOf(\u0027.\u0027) + 1) : parentPath;\n         try {\n           queueInfo \u003d rmContext.getScheduler()\n               .getQueueInfo(parentName, false, false);\n         } catch (IOException e) {\n           // Queue is not found, do nothing.\n         }\n       }\n       Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n           .getQueue(queueInfo.getQueueName());\n       if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n         return false;\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean isMutationAllowed(UserGroupInformation user,\n      SchedConfUpdateInfo confUpdate) {\n    // If there are global config changes, check if user is admin.\n    Map\u003cString, String\u003e globalParams \u003d confUpdate.getGlobalParams();\n    if (globalParams !\u003d null \u0026\u0026 globalParams.size() !\u003d 0) {\n      if (!authorizer.isAdmin(user)) {\n        return false;\n      }\n    }\n\n    // Check if user is admin of all modified queues.\n    Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n    for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n      queues.add(addQueueInfo.getQueue());\n    }\n    for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n      queues.add(removeQueue);\n    }\n    for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n      queues.add(updateQueueInfo.getQueue());\n    }\n    for (String queuePath : queues) {\n      String queueName \u003d queuePath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n          queuePath.substring(queuePath.lastIndexOf(\u0027.\u0027) + 1) : queuePath;\n      QueueInfo queueInfo \u003d null;\n      try {\n        queueInfo \u003d rmContext.getScheduler()\n            .getQueueInfo(queueName, false, false);\n      } catch (IOException e) {\n        // Queue is not found, do nothing.\n      }\n      String parentPath \u003d queuePath;\n      while (queueInfo \u003d\u003d null) {\n        // We are adding a queue (whose parent we are possibly also adding).\n        // Check ACL of lowest parent queue which already exists.\n        parentPath \u003d parentPath.substring(0, parentPath.lastIndexOf(\u0027.\u0027));\n        String parentName \u003d parentPath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n            parentPath.substring(parentPath.lastIndexOf(\u0027.\u0027) + 1) : parentPath;\n        try {\n          queueInfo \u003d rmContext.getScheduler()\n              .getQueueInfo(parentName, false, false);\n        } catch (IOException e) {\n          // Queue is not found, do nothing.\n        }\n      }\n      Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n          .getQueue(queueInfo.getQueueName());\n      if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/QueueAdminConfigurationMutationACLPolicy.java",
          "extendedDetails": {
            "oldValue": "[user-UserGroupInformation, confUpdate-QueueConfigsUpdateInfo]",
            "newValue": "[user-UserGroupInformation, confUpdate-SchedConfUpdateInfo]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6575. Support global configuration mutation in MutableConfProvider. (Jonathan Hung via Xuan Gong)\n",
          "commitDate": "09/10/17 11:11 AM",
          "commitName": "e566fd8b58a6570593b21597aa5294d7b37cb388",
          "commitAuthor": "Xuan",
          "commitDateOld": "09/10/17 11:11 AM",
          "commitNameOld": "a4e62530469e4c3d5b339a06adeac2146fc15fa5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,53 @@\n   public boolean isMutationAllowed(UserGroupInformation user,\n-      QueueConfigsUpdateInfo confUpdate) {\n+      SchedConfUpdateInfo confUpdate) {\n+    // If there are global config changes, check if user is admin.\n+    Map\u003cString, String\u003e globalParams \u003d confUpdate.getGlobalParams();\n+    if (globalParams !\u003d null \u0026\u0026 globalParams.size() !\u003d 0) {\n+      if (!authorizer.isAdmin(user)) {\n+        return false;\n+      }\n+    }\n+\n+    // Check if user is admin of all modified queues.\n     Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n     for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n       queues.add(addQueueInfo.getQueue());\n     }\n     for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n       queues.add(removeQueue);\n     }\n     for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n       queues.add(updateQueueInfo.getQueue());\n     }\n     for (String queuePath : queues) {\n       String queueName \u003d queuePath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n           queuePath.substring(queuePath.lastIndexOf(\u0027.\u0027) + 1) : queuePath;\n       QueueInfo queueInfo \u003d null;\n       try {\n         queueInfo \u003d rmContext.getScheduler()\n             .getQueueInfo(queueName, false, false);\n       } catch (IOException e) {\n         // Queue is not found, do nothing.\n       }\n       String parentPath \u003d queuePath;\n-      // TODO: handle global config change.\n       while (queueInfo \u003d\u003d null) {\n         // We are adding a queue (whose parent we are possibly also adding).\n         // Check ACL of lowest parent queue which already exists.\n         parentPath \u003d parentPath.substring(0, parentPath.lastIndexOf(\u0027.\u0027));\n         String parentName \u003d parentPath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n             parentPath.substring(parentPath.lastIndexOf(\u0027.\u0027) + 1) : parentPath;\n         try {\n           queueInfo \u003d rmContext.getScheduler()\n               .getQueueInfo(parentName, false, false);\n         } catch (IOException e) {\n           // Queue is not found, do nothing.\n         }\n       }\n       Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n           .getQueue(queueInfo.getQueueName());\n       if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n         return false;\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean isMutationAllowed(UserGroupInformation user,\n      SchedConfUpdateInfo confUpdate) {\n    // If there are global config changes, check if user is admin.\n    Map\u003cString, String\u003e globalParams \u003d confUpdate.getGlobalParams();\n    if (globalParams !\u003d null \u0026\u0026 globalParams.size() !\u003d 0) {\n      if (!authorizer.isAdmin(user)) {\n        return false;\n      }\n    }\n\n    // Check if user is admin of all modified queues.\n    Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n    for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n      queues.add(addQueueInfo.getQueue());\n    }\n    for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n      queues.add(removeQueue);\n    }\n    for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n      queues.add(updateQueueInfo.getQueue());\n    }\n    for (String queuePath : queues) {\n      String queueName \u003d queuePath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n          queuePath.substring(queuePath.lastIndexOf(\u0027.\u0027) + 1) : queuePath;\n      QueueInfo queueInfo \u003d null;\n      try {\n        queueInfo \u003d rmContext.getScheduler()\n            .getQueueInfo(queueName, false, false);\n      } catch (IOException e) {\n        // Queue is not found, do nothing.\n      }\n      String parentPath \u003d queuePath;\n      while (queueInfo \u003d\u003d null) {\n        // We are adding a queue (whose parent we are possibly also adding).\n        // Check ACL of lowest parent queue which already exists.\n        parentPath \u003d parentPath.substring(0, parentPath.lastIndexOf(\u0027.\u0027));\n        String parentName \u003d parentPath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n            parentPath.substring(parentPath.lastIndexOf(\u0027.\u0027) + 1) : parentPath;\n        try {\n          queueInfo \u003d rmContext.getScheduler()\n              .getQueueInfo(parentName, false, false);\n        } catch (IOException e) {\n          // Queue is not found, do nothing.\n        }\n      }\n      Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n          .getQueue(queueInfo.getQueueName());\n      if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/QueueAdminConfigurationMutationACLPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "a4e62530469e4c3d5b339a06adeac2146fc15fa5": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5949. Add pluggable configuration ACL policy interface and implementation. (Jonathan Hung via wangda)\n\nChange-Id: Ib98e82ff753bede21fcab2e6ca9ec1e7a5a2008f\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "a4e62530469e4c3d5b339a06adeac2146fc15fa5",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,45 @@\n+  public boolean isMutationAllowed(UserGroupInformation user,\n+      QueueConfigsUpdateInfo confUpdate) {\n+    Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n+    for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n+      queues.add(addQueueInfo.getQueue());\n+    }\n+    for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n+      queues.add(removeQueue);\n+    }\n+    for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n+      queues.add(updateQueueInfo.getQueue());\n+    }\n+    for (String queuePath : queues) {\n+      String queueName \u003d queuePath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n+          queuePath.substring(queuePath.lastIndexOf(\u0027.\u0027) + 1) : queuePath;\n+      QueueInfo queueInfo \u003d null;\n+      try {\n+        queueInfo \u003d rmContext.getScheduler()\n+            .getQueueInfo(queueName, false, false);\n+      } catch (IOException e) {\n+        // Queue is not found, do nothing.\n+      }\n+      String parentPath \u003d queuePath;\n+      // TODO: handle global config change.\n+      while (queueInfo \u003d\u003d null) {\n+        // We are adding a queue (whose parent we are possibly also adding).\n+        // Check ACL of lowest parent queue which already exists.\n+        parentPath \u003d parentPath.substring(0, parentPath.lastIndexOf(\u0027.\u0027));\n+        String parentName \u003d parentPath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n+            parentPath.substring(parentPath.lastIndexOf(\u0027.\u0027) + 1) : parentPath;\n+        try {\n+          queueInfo \u003d rmContext.getScheduler()\n+              .getQueueInfo(parentName, false, false);\n+        } catch (IOException e) {\n+          // Queue is not found, do nothing.\n+        }\n+      }\n+      Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n+          .getQueue(queueInfo.getQueueName());\n+      if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean isMutationAllowed(UserGroupInformation user,\n      QueueConfigsUpdateInfo confUpdate) {\n    Set\u003cString\u003e queues \u003d new HashSet\u003c\u003e();\n    for (QueueConfigInfo addQueueInfo : confUpdate.getAddQueueInfo()) {\n      queues.add(addQueueInfo.getQueue());\n    }\n    for (String removeQueue : confUpdate.getRemoveQueueInfo()) {\n      queues.add(removeQueue);\n    }\n    for (QueueConfigInfo updateQueueInfo : confUpdate.getUpdateQueueInfo()) {\n      queues.add(updateQueueInfo.getQueue());\n    }\n    for (String queuePath : queues) {\n      String queueName \u003d queuePath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n          queuePath.substring(queuePath.lastIndexOf(\u0027.\u0027) + 1) : queuePath;\n      QueueInfo queueInfo \u003d null;\n      try {\n        queueInfo \u003d rmContext.getScheduler()\n            .getQueueInfo(queueName, false, false);\n      } catch (IOException e) {\n        // Queue is not found, do nothing.\n      }\n      String parentPath \u003d queuePath;\n      // TODO: handle global config change.\n      while (queueInfo \u003d\u003d null) {\n        // We are adding a queue (whose parent we are possibly also adding).\n        // Check ACL of lowest parent queue which already exists.\n        parentPath \u003d parentPath.substring(0, parentPath.lastIndexOf(\u0027.\u0027));\n        String parentName \u003d parentPath.lastIndexOf(\u0027.\u0027) !\u003d -1 ?\n            parentPath.substring(parentPath.lastIndexOf(\u0027.\u0027) + 1) : parentPath;\n        try {\n          queueInfo \u003d rmContext.getScheduler()\n              .getQueueInfo(parentName, false, false);\n        } catch (IOException e) {\n          // Queue is not found, do nothing.\n        }\n      }\n      Queue queue \u003d ((MutableConfScheduler) rmContext.getScheduler())\n          .getQueue(queueInfo.getQueueName());\n      if (queue !\u003d null \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, user)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/QueueAdminConfigurationMutationACLPolicy.java"
    }
  }
}