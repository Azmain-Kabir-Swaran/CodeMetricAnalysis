{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HadoopArchiveLogs.java",
  "functionName": "checkFilesAndSeedApps",
  "functionId": "checkFilesAndSeedApps___fs-FileSystem__remoteRootLogDir-Path__suffix-String__workingDir-Path",
  "sourceFilePath": "hadoop-tools/hadoop-archive-logs/src/main/java/org/apache/hadoop/tools/HadoopArchiveLogs.java",
  "functionStartLine": 365,
  "functionEndLine": 437,
  "numCommitsSeen": 21,
  "timeTaken": 3296,
  "changeHistory": [
    "f47659fb9709f69846f08c489bcafd1e36f5bf09",
    "d3c49e76624b7e42a1321c649a1d7bb9906b3073",
    "119cc75e7ebd723790f6326498383304aba384a2"
  ],
  "changeHistoryShort": {
    "f47659fb9709f69846f08c489bcafd1e36f5bf09": "Ymultichange(Yparameterchange,Ybodychange)",
    "d3c49e76624b7e42a1321c649a1d7bb9906b3073": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
    "119cc75e7ebd723790f6326498383304aba384a2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f47659fb9709f69846f08c489bcafd1e36f5bf09": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-7047. Make HAR tool support IndexedLogAggregtionController. (Xuan Gong via wangda)\n\nChange-Id: Ice5ae1c706f2476361997dcbb29f2c33c77d4f0c\n",
      "commitDate": "15/03/18 1:26 PM",
      "commitName": "f47659fb9709f69846f08c489bcafd1e36f5bf09",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-7047. Make HAR tool support IndexedLogAggregtionController. (Xuan Gong via wangda)\n\nChange-Id: Ice5ae1c706f2476361997dcbb29f2c33c77d4f0c\n",
          "commitDate": "15/03/18 1:26 PM",
          "commitName": "f47659fb9709f69846f08c489bcafd1e36f5bf09",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "15/11/16 10:57 AM",
          "commitNameOld": "5af572b6443715b7a741296c1bd520a1840f9a7c",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 485.06,
          "commitsBetweenForRepo": 3078,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,73 @@\n   void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n-       String suffix) throws IOException {\n+       String suffix, Path workingDir) throws IOException {\n     for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n          fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n       Path userLogPath \u003d userIt.next().getPath();\n       try {\n         for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n              fs.listStatusIterator(new Path(userLogPath, suffix));\n              appIt.hasNext();) {\n           Path appLogPath \u003d appIt.next().getPath();\n           try {\n             FileStatus[] files \u003d fs.listStatus(appLogPath);\n             if (files.length \u003e\u003d minNumLogFiles) {\n               boolean eligible \u003d true;\n               long totalFileSize \u003d 0L;\n               for (FileStatus file : files) {\n                 if (file.getPath().getName().equals(appLogPath.getName()\n                     + \".har\")) {\n                   eligible \u003d false;\n                   if (verbose) {\n                     LOG.info(\"Skipping \" + appLogPath.getName() +\n                         \" due to existing .har file\");\n                   }\n                   break;\n                 }\n                 totalFileSize +\u003d file.getLen();\n                 if (totalFileSize \u003e maxTotalLogsSize) {\n                   eligible \u003d false;\n                   if (verbose) {\n                     LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n                         \"total file size being too large (\" + totalFileSize +\n                         \" \u003e \" + maxTotalLogsSize + \")\");\n                   }\n                   break;\n                 }\n               }\n               if (eligible) {\n                 if (verbose) {\n                   LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n                       userLogPath.getName());\n                 }\n-                eligibleApplications.add(\n-                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n+                AppInfo context \u003d new AppInfo();\n+                context.setAppId(appLogPath.getName());\n+                context.setUser(userLogPath.getName());\n+                context.setSuffix(suffix);\n+                context.setRemoteRootLogDir(remoteRootLogDir);\n+                context.setWorkingDir(workingDir);\n+                eligibleApplications.add(context);\n               }\n             } else {\n               if (verbose) {\n                 LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n                     \"having enough log files (\" + files.length + \" \u003c \" +\n                     minNumLogFiles + \")\");\n               }\n             }\n           } catch (IOException ioe) {\n             // Ignore any apps we can\u0027t read\n             if (verbose) {\n               LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n                   ioe.getMessage());\n             }\n           }\n         }\n       } catch (IOException ioe) {\n         // Ignore any apps we can\u0027t read\n         if (verbose) {\n           LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n               ioe.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n       String suffix, Path workingDir) throws IOException {\n    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n      Path userLogPath \u003d userIt.next().getPath();\n      try {\n        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n             fs.listStatusIterator(new Path(userLogPath, suffix));\n             appIt.hasNext();) {\n          Path appLogPath \u003d appIt.next().getPath();\n          try {\n            FileStatus[] files \u003d fs.listStatus(appLogPath);\n            if (files.length \u003e\u003d minNumLogFiles) {\n              boolean eligible \u003d true;\n              long totalFileSize \u003d 0L;\n              for (FileStatus file : files) {\n                if (file.getPath().getName().equals(appLogPath.getName()\n                    + \".har\")) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() +\n                        \" due to existing .har file\");\n                  }\n                  break;\n                }\n                totalFileSize +\u003d file.getLen();\n                if (totalFileSize \u003e maxTotalLogsSize) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n                        \"total file size being too large (\" + totalFileSize +\n                        \" \u003e \" + maxTotalLogsSize + \")\");\n                  }\n                  break;\n                }\n              }\n              if (eligible) {\n                if (verbose) {\n                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n                      userLogPath.getName());\n                }\n                AppInfo context \u003d new AppInfo();\n                context.setAppId(appLogPath.getName());\n                context.setUser(userLogPath.getName());\n                context.setSuffix(suffix);\n                context.setRemoteRootLogDir(remoteRootLogDir);\n                context.setWorkingDir(workingDir);\n                eligibleApplications.add(context);\n              }\n            } else {\n              if (verbose) {\n                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n                    \"having enough log files (\" + files.length + \" \u003c \" +\n                    minNumLogFiles + \")\");\n              }\n            }\n          } catch (IOException ioe) {\n            // Ignore any apps we can\u0027t read\n            if (verbose) {\n              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n                  ioe.getMessage());\n            }\n          }\n        }\n      } catch (IOException ioe) {\n        // Ignore any apps we can\u0027t read\n        if (verbose) {\n          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n              ioe.getMessage());\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-archive-logs/src/main/java/org/apache/hadoop/tools/HadoopArchiveLogs.java",
          "extendedDetails": {
            "oldValue": "[fs-FileSystem, remoteRootLogDir-Path, suffix-String]",
            "newValue": "[fs-FileSystem, remoteRootLogDir-Path, suffix-String, workingDir-Path]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-7047. Make HAR tool support IndexedLogAggregtionController. (Xuan Gong via wangda)\n\nChange-Id: Ice5ae1c706f2476361997dcbb29f2c33c77d4f0c\n",
          "commitDate": "15/03/18 1:26 PM",
          "commitName": "f47659fb9709f69846f08c489bcafd1e36f5bf09",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "15/11/16 10:57 AM",
          "commitNameOld": "5af572b6443715b7a741296c1bd520a1840f9a7c",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 485.06,
          "commitsBetweenForRepo": 3078,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,73 @@\n   void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n-       String suffix) throws IOException {\n+       String suffix, Path workingDir) throws IOException {\n     for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n          fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n       Path userLogPath \u003d userIt.next().getPath();\n       try {\n         for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n              fs.listStatusIterator(new Path(userLogPath, suffix));\n              appIt.hasNext();) {\n           Path appLogPath \u003d appIt.next().getPath();\n           try {\n             FileStatus[] files \u003d fs.listStatus(appLogPath);\n             if (files.length \u003e\u003d minNumLogFiles) {\n               boolean eligible \u003d true;\n               long totalFileSize \u003d 0L;\n               for (FileStatus file : files) {\n                 if (file.getPath().getName().equals(appLogPath.getName()\n                     + \".har\")) {\n                   eligible \u003d false;\n                   if (verbose) {\n                     LOG.info(\"Skipping \" + appLogPath.getName() +\n                         \" due to existing .har file\");\n                   }\n                   break;\n                 }\n                 totalFileSize +\u003d file.getLen();\n                 if (totalFileSize \u003e maxTotalLogsSize) {\n                   eligible \u003d false;\n                   if (verbose) {\n                     LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n                         \"total file size being too large (\" + totalFileSize +\n                         \" \u003e \" + maxTotalLogsSize + \")\");\n                   }\n                   break;\n                 }\n               }\n               if (eligible) {\n                 if (verbose) {\n                   LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n                       userLogPath.getName());\n                 }\n-                eligibleApplications.add(\n-                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n+                AppInfo context \u003d new AppInfo();\n+                context.setAppId(appLogPath.getName());\n+                context.setUser(userLogPath.getName());\n+                context.setSuffix(suffix);\n+                context.setRemoteRootLogDir(remoteRootLogDir);\n+                context.setWorkingDir(workingDir);\n+                eligibleApplications.add(context);\n               }\n             } else {\n               if (verbose) {\n                 LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n                     \"having enough log files (\" + files.length + \" \u003c \" +\n                     minNumLogFiles + \")\");\n               }\n             }\n           } catch (IOException ioe) {\n             // Ignore any apps we can\u0027t read\n             if (verbose) {\n               LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n                   ioe.getMessage());\n             }\n           }\n         }\n       } catch (IOException ioe) {\n         // Ignore any apps we can\u0027t read\n         if (verbose) {\n           LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n               ioe.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n       String suffix, Path workingDir) throws IOException {\n    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n      Path userLogPath \u003d userIt.next().getPath();\n      try {\n        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n             fs.listStatusIterator(new Path(userLogPath, suffix));\n             appIt.hasNext();) {\n          Path appLogPath \u003d appIt.next().getPath();\n          try {\n            FileStatus[] files \u003d fs.listStatus(appLogPath);\n            if (files.length \u003e\u003d minNumLogFiles) {\n              boolean eligible \u003d true;\n              long totalFileSize \u003d 0L;\n              for (FileStatus file : files) {\n                if (file.getPath().getName().equals(appLogPath.getName()\n                    + \".har\")) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() +\n                        \" due to existing .har file\");\n                  }\n                  break;\n                }\n                totalFileSize +\u003d file.getLen();\n                if (totalFileSize \u003e maxTotalLogsSize) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n                        \"total file size being too large (\" + totalFileSize +\n                        \" \u003e \" + maxTotalLogsSize + \")\");\n                  }\n                  break;\n                }\n              }\n              if (eligible) {\n                if (verbose) {\n                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n                      userLogPath.getName());\n                }\n                AppInfo context \u003d new AppInfo();\n                context.setAppId(appLogPath.getName());\n                context.setUser(userLogPath.getName());\n                context.setSuffix(suffix);\n                context.setRemoteRootLogDir(remoteRootLogDir);\n                context.setWorkingDir(workingDir);\n                eligibleApplications.add(context);\n              }\n            } else {\n              if (verbose) {\n                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n                    \"having enough log files (\" + files.length + \" \u003c \" +\n                    minNumLogFiles + \")\");\n              }\n            }\n          } catch (IOException ioe) {\n            // Ignore any apps we can\u0027t read\n            if (verbose) {\n              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n                  ioe.getMessage());\n            }\n          }\n        }\n      } catch (IOException ioe) {\n        // Ignore any apps we can\u0027t read\n        if (verbose) {\n          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n              ioe.getMessage());\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-archive-logs/src/main/java/org/apache/hadoop/tools/HadoopArchiveLogs.java",
          "extendedDetails": {}
        }
      ]
    },
    "d3c49e76624b7e42a1321c649a1d7bb9906b3073": {
      "type": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
      "commitMessage": "MAPREDUCE-6480. archive-logs tool may miss applications (rkanter)\n",
      "commitDate": "25/09/15 3:02 PM",
      "commitName": "d3c49e76624b7e42a1321c649a1d7bb9906b3073",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "MAPREDUCE-6480. archive-logs tool may miss applications (rkanter)\n",
          "commitDate": "25/09/15 3:02 PM",
          "commitName": "d3c49e76624b7e42a1321c649a1d7bb9906b3073",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "09/09/15 5:45 PM",
          "commitNameOld": "119cc75e7ebd723790f6326498383304aba384a2",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 15.89,
          "commitsBetweenForRepo": 119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,68 @@\n-  void checkFiles(FileSystem fs, Path remoteRootLogDir, String suffix) {\n-    for (Iterator\u003cApplicationReport\u003e reportIt \u003d eligibleApplications.iterator();\n-         reportIt.hasNext(); ) {\n-      ApplicationReport report \u003d reportIt.next();\n-      long totalFileSize \u003d 0L;\n+  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n+       String suffix) throws IOException {\n+    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n+         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n+      Path userLogPath \u003d userIt.next().getPath();\n       try {\n-        FileStatus[] files \u003d fs.listStatus(\n-            LogAggregationUtils.getRemoteAppLogDir(remoteRootLogDir,\n-                report.getApplicationId(), report.getUser(), suffix));\n-        if (files.length \u003c minNumLogFiles) {\n-          reportIt.remove();\n-        } else {\n-          for (FileStatus file : files) {\n-            if (file.getPath().getName().equals(report.getApplicationId()\n-                + \".har\")) {\n-              reportIt.remove();\n-              break;\n+        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n+             fs.listStatusIterator(new Path(userLogPath, suffix));\n+             appIt.hasNext();) {\n+          Path appLogPath \u003d appIt.next().getPath();\n+          try {\n+            FileStatus[] files \u003d fs.listStatus(appLogPath);\n+            if (files.length \u003e\u003d minNumLogFiles) {\n+              boolean eligible \u003d true;\n+              long totalFileSize \u003d 0L;\n+              for (FileStatus file : files) {\n+                if (file.getPath().getName().equals(appLogPath.getName()\n+                    + \".har\")) {\n+                  eligible \u003d false;\n+                  if (verbose) {\n+                    LOG.info(\"Skipping \" + appLogPath.getName() +\n+                        \" due to existing .har file\");\n+                  }\n+                  break;\n+                }\n+                totalFileSize +\u003d file.getLen();\n+                if (totalFileSize \u003e maxTotalLogsSize) {\n+                  eligible \u003d false;\n+                  if (verbose) {\n+                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n+                        \"total file size being too large (\" + totalFileSize +\n+                        \" \u003e \" + maxTotalLogsSize + \")\");\n+                  }\n+                  break;\n+                }\n+              }\n+              if (eligible) {\n+                if (verbose) {\n+                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n+                      userLogPath.getName());\n+                }\n+                eligibleApplications.add(\n+                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n+              }\n+            } else {\n+              if (verbose) {\n+                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n+                    \"having enough log files (\" + files.length + \" \u003c \" +\n+                    minNumLogFiles + \")\");\n+              }\n             }\n-            totalFileSize +\u003d file.getLen();\n-          }\n-          if (totalFileSize \u003e maxTotalLogsSize) {\n-            reportIt.remove();\n+          } catch (IOException ioe) {\n+            // Ignore any apps we can\u0027t read\n+            if (verbose) {\n+              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n+                  ioe.getMessage());\n+            }\n           }\n         }\n       } catch (IOException ioe) {\n-        // If the user doesn\u0027t have permission or it doesn\u0027t exist, then skip it\n-        reportIt.remove();\n+        // Ignore any apps we can\u0027t read\n+        if (verbose) {\n+          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n+              ioe.getMessage());\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n       String suffix) throws IOException {\n    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n      Path userLogPath \u003d userIt.next().getPath();\n      try {\n        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n             fs.listStatusIterator(new Path(userLogPath, suffix));\n             appIt.hasNext();) {\n          Path appLogPath \u003d appIt.next().getPath();\n          try {\n            FileStatus[] files \u003d fs.listStatus(appLogPath);\n            if (files.length \u003e\u003d minNumLogFiles) {\n              boolean eligible \u003d true;\n              long totalFileSize \u003d 0L;\n              for (FileStatus file : files) {\n                if (file.getPath().getName().equals(appLogPath.getName()\n                    + \".har\")) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() +\n                        \" due to existing .har file\");\n                  }\n                  break;\n                }\n                totalFileSize +\u003d file.getLen();\n                if (totalFileSize \u003e maxTotalLogsSize) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n                        \"total file size being too large (\" + totalFileSize +\n                        \" \u003e \" + maxTotalLogsSize + \")\");\n                  }\n                  break;\n                }\n              }\n              if (eligible) {\n                if (verbose) {\n                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n                      userLogPath.getName());\n                }\n                eligibleApplications.add(\n                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n              }\n            } else {\n              if (verbose) {\n                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n                    \"having enough log files (\" + files.length + \" \u003c \" +\n                    minNumLogFiles + \")\");\n              }\n            }\n          } catch (IOException ioe) {\n            // Ignore any apps we can\u0027t read\n            if (verbose) {\n              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n                  ioe.getMessage());\n            }\n          }\n        }\n      } catch (IOException ioe) {\n        // Ignore any apps we can\u0027t read\n        if (verbose) {\n          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n              ioe.getMessage());\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-archive-logs/src/main/java/org/apache/hadoop/tools/HadoopArchiveLogs.java",
          "extendedDetails": {
            "oldValue": "checkFiles",
            "newValue": "checkFilesAndSeedApps"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "MAPREDUCE-6480. archive-logs tool may miss applications (rkanter)\n",
          "commitDate": "25/09/15 3:02 PM",
          "commitName": "d3c49e76624b7e42a1321c649a1d7bb9906b3073",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "09/09/15 5:45 PM",
          "commitNameOld": "119cc75e7ebd723790f6326498383304aba384a2",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 15.89,
          "commitsBetweenForRepo": 119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,68 @@\n-  void checkFiles(FileSystem fs, Path remoteRootLogDir, String suffix) {\n-    for (Iterator\u003cApplicationReport\u003e reportIt \u003d eligibleApplications.iterator();\n-         reportIt.hasNext(); ) {\n-      ApplicationReport report \u003d reportIt.next();\n-      long totalFileSize \u003d 0L;\n+  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n+       String suffix) throws IOException {\n+    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n+         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n+      Path userLogPath \u003d userIt.next().getPath();\n       try {\n-        FileStatus[] files \u003d fs.listStatus(\n-            LogAggregationUtils.getRemoteAppLogDir(remoteRootLogDir,\n-                report.getApplicationId(), report.getUser(), suffix));\n-        if (files.length \u003c minNumLogFiles) {\n-          reportIt.remove();\n-        } else {\n-          for (FileStatus file : files) {\n-            if (file.getPath().getName().equals(report.getApplicationId()\n-                + \".har\")) {\n-              reportIt.remove();\n-              break;\n+        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n+             fs.listStatusIterator(new Path(userLogPath, suffix));\n+             appIt.hasNext();) {\n+          Path appLogPath \u003d appIt.next().getPath();\n+          try {\n+            FileStatus[] files \u003d fs.listStatus(appLogPath);\n+            if (files.length \u003e\u003d minNumLogFiles) {\n+              boolean eligible \u003d true;\n+              long totalFileSize \u003d 0L;\n+              for (FileStatus file : files) {\n+                if (file.getPath().getName().equals(appLogPath.getName()\n+                    + \".har\")) {\n+                  eligible \u003d false;\n+                  if (verbose) {\n+                    LOG.info(\"Skipping \" + appLogPath.getName() +\n+                        \" due to existing .har file\");\n+                  }\n+                  break;\n+                }\n+                totalFileSize +\u003d file.getLen();\n+                if (totalFileSize \u003e maxTotalLogsSize) {\n+                  eligible \u003d false;\n+                  if (verbose) {\n+                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n+                        \"total file size being too large (\" + totalFileSize +\n+                        \" \u003e \" + maxTotalLogsSize + \")\");\n+                  }\n+                  break;\n+                }\n+              }\n+              if (eligible) {\n+                if (verbose) {\n+                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n+                      userLogPath.getName());\n+                }\n+                eligibleApplications.add(\n+                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n+              }\n+            } else {\n+              if (verbose) {\n+                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n+                    \"having enough log files (\" + files.length + \" \u003c \" +\n+                    minNumLogFiles + \")\");\n+              }\n             }\n-            totalFileSize +\u003d file.getLen();\n-          }\n-          if (totalFileSize \u003e maxTotalLogsSize) {\n-            reportIt.remove();\n+          } catch (IOException ioe) {\n+            // Ignore any apps we can\u0027t read\n+            if (verbose) {\n+              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n+                  ioe.getMessage());\n+            }\n           }\n         }\n       } catch (IOException ioe) {\n-        // If the user doesn\u0027t have permission or it doesn\u0027t exist, then skip it\n-        reportIt.remove();\n+        // Ignore any apps we can\u0027t read\n+        if (verbose) {\n+          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n+              ioe.getMessage());\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n       String suffix) throws IOException {\n    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n      Path userLogPath \u003d userIt.next().getPath();\n      try {\n        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n             fs.listStatusIterator(new Path(userLogPath, suffix));\n             appIt.hasNext();) {\n          Path appLogPath \u003d appIt.next().getPath();\n          try {\n            FileStatus[] files \u003d fs.listStatus(appLogPath);\n            if (files.length \u003e\u003d minNumLogFiles) {\n              boolean eligible \u003d true;\n              long totalFileSize \u003d 0L;\n              for (FileStatus file : files) {\n                if (file.getPath().getName().equals(appLogPath.getName()\n                    + \".har\")) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() +\n                        \" due to existing .har file\");\n                  }\n                  break;\n                }\n                totalFileSize +\u003d file.getLen();\n                if (totalFileSize \u003e maxTotalLogsSize) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n                        \"total file size being too large (\" + totalFileSize +\n                        \" \u003e \" + maxTotalLogsSize + \")\");\n                  }\n                  break;\n                }\n              }\n              if (eligible) {\n                if (verbose) {\n                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n                      userLogPath.getName());\n                }\n                eligibleApplications.add(\n                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n              }\n            } else {\n              if (verbose) {\n                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n                    \"having enough log files (\" + files.length + \" \u003c \" +\n                    minNumLogFiles + \")\");\n              }\n            }\n          } catch (IOException ioe) {\n            // Ignore any apps we can\u0027t read\n            if (verbose) {\n              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n                  ioe.getMessage());\n            }\n          }\n        }\n      } catch (IOException ioe) {\n        // Ignore any apps we can\u0027t read\n        if (verbose) {\n          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n              ioe.getMessage());\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-archive-logs/src/main/java/org/apache/hadoop/tools/HadoopArchiveLogs.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-6480. archive-logs tool may miss applications (rkanter)\n",
          "commitDate": "25/09/15 3:02 PM",
          "commitName": "d3c49e76624b7e42a1321c649a1d7bb9906b3073",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "09/09/15 5:45 PM",
          "commitNameOld": "119cc75e7ebd723790f6326498383304aba384a2",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 15.89,
          "commitsBetweenForRepo": 119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,68 @@\n-  void checkFiles(FileSystem fs, Path remoteRootLogDir, String suffix) {\n-    for (Iterator\u003cApplicationReport\u003e reportIt \u003d eligibleApplications.iterator();\n-         reportIt.hasNext(); ) {\n-      ApplicationReport report \u003d reportIt.next();\n-      long totalFileSize \u003d 0L;\n+  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n+       String suffix) throws IOException {\n+    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n+         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n+      Path userLogPath \u003d userIt.next().getPath();\n       try {\n-        FileStatus[] files \u003d fs.listStatus(\n-            LogAggregationUtils.getRemoteAppLogDir(remoteRootLogDir,\n-                report.getApplicationId(), report.getUser(), suffix));\n-        if (files.length \u003c minNumLogFiles) {\n-          reportIt.remove();\n-        } else {\n-          for (FileStatus file : files) {\n-            if (file.getPath().getName().equals(report.getApplicationId()\n-                + \".har\")) {\n-              reportIt.remove();\n-              break;\n+        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n+             fs.listStatusIterator(new Path(userLogPath, suffix));\n+             appIt.hasNext();) {\n+          Path appLogPath \u003d appIt.next().getPath();\n+          try {\n+            FileStatus[] files \u003d fs.listStatus(appLogPath);\n+            if (files.length \u003e\u003d minNumLogFiles) {\n+              boolean eligible \u003d true;\n+              long totalFileSize \u003d 0L;\n+              for (FileStatus file : files) {\n+                if (file.getPath().getName().equals(appLogPath.getName()\n+                    + \".har\")) {\n+                  eligible \u003d false;\n+                  if (verbose) {\n+                    LOG.info(\"Skipping \" + appLogPath.getName() +\n+                        \" due to existing .har file\");\n+                  }\n+                  break;\n+                }\n+                totalFileSize +\u003d file.getLen();\n+                if (totalFileSize \u003e maxTotalLogsSize) {\n+                  eligible \u003d false;\n+                  if (verbose) {\n+                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n+                        \"total file size being too large (\" + totalFileSize +\n+                        \" \u003e \" + maxTotalLogsSize + \")\");\n+                  }\n+                  break;\n+                }\n+              }\n+              if (eligible) {\n+                if (verbose) {\n+                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n+                      userLogPath.getName());\n+                }\n+                eligibleApplications.add(\n+                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n+              }\n+            } else {\n+              if (verbose) {\n+                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n+                    \"having enough log files (\" + files.length + \" \u003c \" +\n+                    minNumLogFiles + \")\");\n+              }\n             }\n-            totalFileSize +\u003d file.getLen();\n-          }\n-          if (totalFileSize \u003e maxTotalLogsSize) {\n-            reportIt.remove();\n+          } catch (IOException ioe) {\n+            // Ignore any apps we can\u0027t read\n+            if (verbose) {\n+              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n+                  ioe.getMessage());\n+            }\n           }\n         }\n       } catch (IOException ioe) {\n-        // If the user doesn\u0027t have permission or it doesn\u0027t exist, then skip it\n-        reportIt.remove();\n+        // Ignore any apps we can\u0027t read\n+        if (verbose) {\n+          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n+              ioe.getMessage());\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkFilesAndSeedApps(FileSystem fs, Path remoteRootLogDir,\n       String suffix) throws IOException {\n    for (RemoteIterator\u003cFileStatus\u003e userIt \u003d\n         fs.listStatusIterator(remoteRootLogDir); userIt.hasNext();) {\n      Path userLogPath \u003d userIt.next().getPath();\n      try {\n        for (RemoteIterator\u003cFileStatus\u003e appIt \u003d\n             fs.listStatusIterator(new Path(userLogPath, suffix));\n             appIt.hasNext();) {\n          Path appLogPath \u003d appIt.next().getPath();\n          try {\n            FileStatus[] files \u003d fs.listStatus(appLogPath);\n            if (files.length \u003e\u003d minNumLogFiles) {\n              boolean eligible \u003d true;\n              long totalFileSize \u003d 0L;\n              for (FileStatus file : files) {\n                if (file.getPath().getName().equals(appLogPath.getName()\n                    + \".har\")) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() +\n                        \" due to existing .har file\");\n                  }\n                  break;\n                }\n                totalFileSize +\u003d file.getLen();\n                if (totalFileSize \u003e maxTotalLogsSize) {\n                  eligible \u003d false;\n                  if (verbose) {\n                    LOG.info(\"Skipping \" + appLogPath.getName() + \" due to \" +\n                        \"total file size being too large (\" + totalFileSize +\n                        \" \u003e \" + maxTotalLogsSize + \")\");\n                  }\n                  break;\n                }\n              }\n              if (eligible) {\n                if (verbose) {\n                  LOG.info(\"Adding \" + appLogPath.getName() + \" for user \" +\n                      userLogPath.getName());\n                }\n                eligibleApplications.add(\n                    new AppInfo(appLogPath.getName(), userLogPath.getName()));\n              }\n            } else {\n              if (verbose) {\n                LOG.info(\"Skipping \" + appLogPath.getName() + \" due to not \" +\n                    \"having enough log files (\" + files.length + \" \u003c \" +\n                    minNumLogFiles + \")\");\n              }\n            }\n          } catch (IOException ioe) {\n            // Ignore any apps we can\u0027t read\n            if (verbose) {\n              LOG.info(\"Skipping logs under \" + appLogPath + \" due to \" +\n                  ioe.getMessage());\n            }\n          }\n        }\n      } catch (IOException ioe) {\n        // Ignore any apps we can\u0027t read\n        if (verbose) {\n          LOG.info(\"Skipping all logs under \" + userLogPath + \" due to \" +\n              ioe.getMessage());\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-archive-logs/src/main/java/org/apache/hadoop/tools/HadoopArchiveLogs.java",
          "extendedDetails": {}
        }
      ]
    },
    "119cc75e7ebd723790f6326498383304aba384a2": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-6415. Create a tool to combine aggregated logs into HAR files. (Robert Kanter via kasha)\n",
      "commitDate": "09/09/15 5:45 PM",
      "commitName": "119cc75e7ebd723790f6326498383304aba384a2",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,30 @@\n+  void checkFiles(FileSystem fs, Path remoteRootLogDir, String suffix) {\n+    for (Iterator\u003cApplicationReport\u003e reportIt \u003d eligibleApplications.iterator();\n+         reportIt.hasNext(); ) {\n+      ApplicationReport report \u003d reportIt.next();\n+      long totalFileSize \u003d 0L;\n+      try {\n+        FileStatus[] files \u003d fs.listStatus(\n+            LogAggregationUtils.getRemoteAppLogDir(remoteRootLogDir,\n+                report.getApplicationId(), report.getUser(), suffix));\n+        if (files.length \u003c minNumLogFiles) {\n+          reportIt.remove();\n+        } else {\n+          for (FileStatus file : files) {\n+            if (file.getPath().getName().equals(report.getApplicationId()\n+                + \".har\")) {\n+              reportIt.remove();\n+              break;\n+            }\n+            totalFileSize +\u003d file.getLen();\n+          }\n+          if (totalFileSize \u003e maxTotalLogsSize) {\n+            reportIt.remove();\n+          }\n+        }\n+      } catch (IOException ioe) {\n+        // If the user doesn\u0027t have permission or it doesn\u0027t exist, then skip it\n+        reportIt.remove();\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void checkFiles(FileSystem fs, Path remoteRootLogDir, String suffix) {\n    for (Iterator\u003cApplicationReport\u003e reportIt \u003d eligibleApplications.iterator();\n         reportIt.hasNext(); ) {\n      ApplicationReport report \u003d reportIt.next();\n      long totalFileSize \u003d 0L;\n      try {\n        FileStatus[] files \u003d fs.listStatus(\n            LogAggregationUtils.getRemoteAppLogDir(remoteRootLogDir,\n                report.getApplicationId(), report.getUser(), suffix));\n        if (files.length \u003c minNumLogFiles) {\n          reportIt.remove();\n        } else {\n          for (FileStatus file : files) {\n            if (file.getPath().getName().equals(report.getApplicationId()\n                + \".har\")) {\n              reportIt.remove();\n              break;\n            }\n            totalFileSize +\u003d file.getLen();\n          }\n          if (totalFileSize \u003e maxTotalLogsSize) {\n            reportIt.remove();\n          }\n        }\n      } catch (IOException ioe) {\n        // If the user doesn\u0027t have permission or it doesn\u0027t exist, then skip it\n        reportIt.remove();\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-archive-logs/src/main/java/org/apache/hadoop/tools/HadoopArchiveLogs.java"
    }
  }
}