{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CSQueueUtils.java",
  "functionName": "updateQueueStatistics",
  "functionId": "updateQueueStatistics___rc-ResourceCalculator(modifiers-final)__cluster-Resource(modifiers-final)__childQueue-AbstractCSQueue(modifiers-final)__nlm-RMNodeLabelsManager(modifiers-final)__nodePartition-String(modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
  "functionStartLine": 290,
  "functionEndLine": 323,
  "numCommitsSeen": 31,
  "timeTaken": 2438,
  "changeHistory": [
    "42683aef1a694af883c14842bf41f30b91e039f3",
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "e9c2aa1bc383cb08784846534415bf17667d6e41"
  ],
  "changeHistoryShort": {
    "42683aef1a694af883c14842bf41f30b91e039f3": "Ybodychange",
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "e9c2aa1bc383cb08784846534415bf17667d6e41": "Ybodychange"
  },
  "changeHistoryDetails": {
    "42683aef1a694af883c14842bf41f30b91e039f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9596: QueueMetrics has incorrect metrics when labelled partitions are involved. Contributed by  Muhammad Samir Khan.\n",
      "commitDate": "30/07/19 11:58 AM",
      "commitName": "42683aef1a694af883c14842bf41f30b91e039f3",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "10/04/19 7:51 AM",
      "commitNameOld": "8c1bba375b144fd515b389174ddb349f2d9246fa",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 111.17,
      "commitsBetweenForRepo": 772,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,34 @@\n   public static void updateQueueStatistics(\n       final ResourceCalculator rc, final Resource cluster,\n       final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n       final String nodePartition) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n \n     if (nodePartition \u003d\u003d null) {\n       for (String partition : Sets.union(queueCapacities.getNodePartitionsSet(),\n           queueResourceUsage.getNodePartitionsSet())) {\n         updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n             partition, childQueue);\n+\n+        // Update queue metrics w.r.t node labels.\n+        // In QueueMetrics, null label is handled the same as NO_LABEL.\n+        // This is because queue metrics for partitions are not tracked.\n+        // In the future, will have to change this when/if queue metrics\n+        // for partitions also get tracked.\n+        childQueue.getMetrics().setAvailableResourcesToQueue(\n+            partition,\n+            getMaxAvailableResourceToQueuePartition(rc, childQueue,\n+                cluster, partition));\n       }\n     } else {\n       updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n           nodePartition, childQueue);\n-    }\n \n-    // Update queue metrics w.r.t node labels. In a generic way, we can\n-    // calculate available resource from all labels in cluster.\n-    childQueue.getMetrics().setAvailableResourcesToQueue(nodePartition,\n-        getMaxAvailableResourceToQueue(rc, nlm, childQueue, cluster));\n+      // Same as above.\n+      childQueue.getMetrics().setAvailableResourcesToQueue(\n+          nodePartition,\n+          getMaxAvailableResourceToQueuePartition(rc, childQueue,\n+              cluster, nodePartition));\n+    }\n    }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateQueueStatistics(\n      final ResourceCalculator rc, final Resource cluster,\n      final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n      final String nodePartition) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n\n    if (nodePartition \u003d\u003d null) {\n      for (String partition : Sets.union(queueCapacities.getNodePartitionsSet(),\n          queueResourceUsage.getNodePartitionsSet())) {\n        updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n            partition, childQueue);\n\n        // Update queue metrics w.r.t node labels.\n        // In QueueMetrics, null label is handled the same as NO_LABEL.\n        // This is because queue metrics for partitions are not tracked.\n        // In the future, will have to change this when/if queue metrics\n        // for partitions also get tracked.\n        childQueue.getMetrics().setAvailableResourcesToQueue(\n            partition,\n            getMaxAvailableResourceToQueuePartition(rc, childQueue,\n                cluster, partition));\n      }\n    } else {\n      updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n          nodePartition, childQueue);\n\n      // Same as above.\n      childQueue.getMetrics().setAvailableResourcesToQueue(\n          nodePartition,\n          getMaxAvailableResourceToQueuePartition(rc, childQueue,\n              cluster, nodePartition));\n    }\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    },
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7538. Fix performance regression introduced by Capacity Scheduler absolute min/max resource refactoring. (Sunil G via wangda)\n\nChange-Id: Ic9bd7e599c56970fe01cb0e1bba6df7d1f77eb29\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   public static void updateQueueStatistics(\n       final ResourceCalculator rc, final Resource cluster,\n       final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n       final String nodePartition) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n \n     if (nodePartition \u003d\u003d null) {\n       for (String partition : Sets.union(queueCapacities.getNodePartitionsSet(),\n           queueResourceUsage.getNodePartitionsSet())) {\n         updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n-            cluster, partition, childQueue);\n+            partition, childQueue);\n       }\n     } else {\n       updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n-          cluster, nodePartition, childQueue);\n+          nodePartition, childQueue);\n     }\n \n     // Update queue metrics w.r.t node labels. In a generic way, we can\n     // calculate available resource from all labels in cluster.\n     childQueue.getMetrics().setAvailableResourcesToQueue(nodePartition,\n         getMaxAvailableResourceToQueue(rc, nlm, childQueue, cluster));\n    }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateQueueStatistics(\n      final ResourceCalculator rc, final Resource cluster,\n      final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n      final String nodePartition) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n\n    if (nodePartition \u003d\u003d null) {\n      for (String partition : Sets.union(queueCapacities.getNodePartitionsSet(),\n          queueResourceUsage.getNodePartitionsSet())) {\n        updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n            partition, childQueue);\n      }\n    } else {\n      updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n          nodePartition, childQueue);\n    }\n\n    // Update queue metrics w.r.t node labels. In a generic way, we can\n    // calculate available resource from all labels in cluster.\n    childQueue.getMetrics().setAvailableResourcesToQueue(nodePartition,\n        getMaxAvailableResourceToQueue(rc, nlm, childQueue, cluster));\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "19/06/17 9:01 AM",
      "commitNameOld": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 171.46,
      "commitsBetweenForRepo": 1316,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,23 @@\n   public static void updateQueueStatistics(\n       final ResourceCalculator rc, final Resource cluster,\n       final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n       final String nodePartition) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n \n     if (nodePartition \u003d\u003d null) {\n-      for (String partition : Sets.union(\n-          queueCapacities.getNodePartitionsSet(),\n+      for (String partition : Sets.union(queueCapacities.getNodePartitionsSet(),\n           queueResourceUsage.getNodePartitionsSet())) {\n         updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n-            partition, childQueue);\n+            cluster, partition, childQueue);\n       }\n     } else {\n       updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n-          nodePartition, childQueue);\n+          cluster, nodePartition, childQueue);\n     }\n \n     // Update queue metrics w.r.t node labels. In a generic way, we can\n     // calculate available resource from all labels in cluster.\n     childQueue.getMetrics().setAvailableResourcesToQueue(nodePartition,\n         getMaxAvailableResourceToQueue(rc, nlm, childQueue, cluster));\n    }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateQueueStatistics(\n      final ResourceCalculator rc, final Resource cluster,\n      final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n      final String nodePartition) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n\n    if (nodePartition \u003d\u003d null) {\n      for (String partition : Sets.union(queueCapacities.getNodePartitionsSet(),\n          queueResourceUsage.getNodePartitionsSet())) {\n        updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n            cluster, partition, childQueue);\n      }\n    } else {\n      updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n          cluster, nodePartition, childQueue);\n    }\n\n    // Update queue metrics w.r.t node labels. In a generic way, we can\n    // calculate available resource from all labels in cluster.\n    childQueue.getMetrics().setAvailableResourcesToQueue(nodePartition,\n        getMaxAvailableResourceToQueue(rc, nlm, childQueue, cluster));\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    },
    "e9c2aa1bc383cb08784846534415bf17667d6e41": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6467. CSQueueMetrics needs to update the current metrics for default partition only. Contributed by Manikandan R.\n",
      "commitDate": "19/06/17 9:01 AM",
      "commitName": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "11/04/17 6:44 AM",
      "commitNameOld": "0e065f2edead41f6f894c9d70def389af1c0f239",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 69.1,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,24 +1,24 @@\n   public static void updateQueueStatistics(\n       final ResourceCalculator rc, final Resource cluster,\n       final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n       final String nodePartition) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n \n     if (nodePartition \u003d\u003d null) {\n       for (String partition : Sets.union(\n           queueCapacities.getNodePartitionsSet(),\n           queueResourceUsage.getNodePartitionsSet())) {\n         updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n             partition, childQueue);\n       }\n     } else {\n       updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n           nodePartition, childQueue);\n     }\n \n     // Update queue metrics w.r.t node labels. In a generic way, we can\n     // calculate available resource from all labels in cluster.\n-    childQueue.getMetrics().setAvailableResourcesToQueue(\n+    childQueue.getMetrics().setAvailableResourcesToQueue(nodePartition,\n         getMaxAvailableResourceToQueue(rc, nlm, childQueue, cluster));\n    }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateQueueStatistics(\n      final ResourceCalculator rc, final Resource cluster,\n      final AbstractCSQueue childQueue, final RMNodeLabelsManager nlm,\n      final String nodePartition) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n\n    if (nodePartition \u003d\u003d null) {\n      for (String partition : Sets.union(\n          queueCapacities.getNodePartitionsSet(),\n          queueResourceUsage.getNodePartitionsSet())) {\n        updateUsedCapacity(rc, nlm.getResourceByLabel(partition, cluster),\n            partition, childQueue);\n      }\n    } else {\n      updateUsedCapacity(rc, nlm.getResourceByLabel(nodePartition, cluster),\n          nodePartition, childQueue);\n    }\n\n    // Update queue metrics w.r.t node labels. In a generic way, we can\n    // calculate available resource from all labels in cluster.\n    childQueue.getMetrics().setAvailableResourcesToQueue(nodePartition,\n        getMaxAvailableResourceToQueue(rc, nlm, childQueue, cluster));\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    }
  }
}