{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImageFormatProtobuf.java",
  "functionName": "loadInternal",
  "functionId": "loadInternal___raFile-RandomAccessFile__fin-FileInputStream",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
  "functionStartLine": 350,
  "functionEndLine": 489,
  "numCommitsSeen": 38,
  "timeTaken": 5373,
  "changeHistory": [
    "b67812ea2111fa11bdd76096b923c93e1bdf2923",
    "177131793a88960b734038f6e646476d568c3626",
    "ae8f55b93243560bd891962d6c64320ddc62a7d7",
    "af9bdbe447b119bff10ec5281993bfc36b6dea71",
    "e965dcec378cb807856372425307598792977604",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "18620649f96d9e378fb7ea40de216284a9d525c7",
    "077adb25b7fb3d8d0dbd93096a3f72418ea6521c",
    "bf5971b86a042076ff50add2ec8f90ae6198d3ca",
    "2624b20291629b4565ea45590b66f2c38f96df67",
    "ea0b21af158016651cb77560778834eb95e6b68d",
    "d03acc756094a332f98167426a39db8faf38f450",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305"
  ],
  "changeHistoryShort": {
    "b67812ea2111fa11bdd76096b923c93e1bdf2923": "Ybodychange",
    "177131793a88960b734038f6e646476d568c3626": "Ybodychange",
    "ae8f55b93243560bd891962d6c64320ddc62a7d7": "Ybodychange",
    "af9bdbe447b119bff10ec5281993bfc36b6dea71": "Ybodychange",
    "e965dcec378cb807856372425307598792977604": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "18620649f96d9e378fb7ea40de216284a9d525c7": "Ybodychange",
    "077adb25b7fb3d8d0dbd93096a3f72418ea6521c": "Ybodychange",
    "bf5971b86a042076ff50add2ec8f90ae6198d3ca": "Ybodychange",
    "2624b20291629b4565ea45590b66f2c38f96df67": "Ybodychange",
    "ea0b21af158016651cb77560778834eb95e6b68d": "Ybodychange",
    "d03acc756094a332f98167426a39db8faf38f450": "Ybodychange",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b67812ea2111fa11bdd76096b923c93e1bdf2923": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14617. Improve fsimage load time by writing sub-sections to the fsimage index (#1028). Contributed by  Stephen O\u0027Donnell.\n\nReviewed-by: He Xiaoqiao \u003chexiaoqiao@apache.org\u003e",
      "commitDate": "22/08/19 5:09 PM",
      "commitName": "b67812ea2111fa11bdd76096b923c93e1bdf2923",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "05/07/19 10:17 AM",
      "commitNameOld": "9c907294860a48f0d1676a31bda15795b7a6771a",
      "commitAuthorOld": "leosunli",
      "daysBetweenCommits": 48.29,
      "commitsBetweenForRepo": 420,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,140 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n       if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n           HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n         throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n             \" is not equal to the software version \" +\n             HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       }\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n+      boolean loadInParallel \u003d enableParallelSaveAndLoad(conf);\n+\n+      ExecutorService executorService \u003d null;\n+      ArrayList\u003cFileSummary.Section\u003e subSections \u003d\n+          getAndRemoveSubSections(sections);\n+      if (loadInParallel) {\n+        executorService \u003d getParallelExecutorService();\n+      }\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n         SectionName sectionName \u003d SectionName.fromString(n);\n         if (sectionName \u003d\u003d null) {\n           throw new IOException(\"Unrecognized section \" + n);\n         }\n+\n+        ArrayList\u003cFileSummary.Section\u003e stageSubSections;\n         switch (sectionName) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n-          inodeLoader.loadINodeSection(in, prog, currentStep);\n+          stageSubSections \u003d getSubSectionsOfName(\n+              subSections, SectionName.INODE_SUB);\n+          if (loadInParallel \u0026\u0026 (stageSubSections.size() \u003e 0)) {\n+            inodeLoader.loadINodeSectionInParallel(executorService,\n+                stageSubSections, summary.getCodec(), prog, currentStep);\n+          } else {\n+            inodeLoader.loadINodeSection(in, prog, currentStep);\n+          }\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n-          inodeLoader.loadINodeDirectorySection(in);\n+          stageSubSections \u003d getSubSectionsOfName(\n+              subSections, SectionName.INODE_DIR_SUB);\n+          if (loadInParallel \u0026\u0026 stageSubSections.size() \u003e 0) {\n+            inodeLoader.loadINodeDirectorySectionInParallel(executorService,\n+                stageSubSections, summary.getCodec());\n+          } else {\n+            inodeLoader.loadINodeDirectorySection(in);\n+          }\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case ERASURE_CODING:\n           Step step \u003d new Step(StepType.ERASURE_CODING_POLICIES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadErasureCodingSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n           break;\n         default:\n           LOG.warn(\"Unrecognized section {}\", n);\n           break;\n         }\n       }\n+      if (executorService !\u003d null) {\n+        executorService.shutdown();\n+      }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n          HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n            \" is not equal to the software version \" +\n            HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      }\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n      boolean loadInParallel \u003d enableParallelSaveAndLoad(conf);\n\n      ExecutorService executorService \u003d null;\n      ArrayList\u003cFileSummary.Section\u003e subSections \u003d\n          getAndRemoveSubSections(sections);\n      if (loadInParallel) {\n        executorService \u003d getParallelExecutorService();\n      }\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n        SectionName sectionName \u003d SectionName.fromString(n);\n        if (sectionName \u003d\u003d null) {\n          throw new IOException(\"Unrecognized section \" + n);\n        }\n\n        ArrayList\u003cFileSummary.Section\u003e stageSubSections;\n        switch (sectionName) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          stageSubSections \u003d getSubSectionsOfName(\n              subSections, SectionName.INODE_SUB);\n          if (loadInParallel \u0026\u0026 (stageSubSections.size() \u003e 0)) {\n            inodeLoader.loadINodeSectionInParallel(executorService,\n                stageSubSections, summary.getCodec(), prog, currentStep);\n          } else {\n            inodeLoader.loadINodeSection(in, prog, currentStep);\n          }\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          stageSubSections \u003d getSubSectionsOfName(\n              subSections, SectionName.INODE_DIR_SUB);\n          if (loadInParallel \u0026\u0026 stageSubSections.size() \u003e 0) {\n            inodeLoader.loadINodeDirectorySectionInParallel(executorService,\n                stageSubSections, summary.getCodec());\n          } else {\n            inodeLoader.loadINodeDirectorySection(in);\n          }\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case ERASURE_CODING:\n          Step step \u003d new Step(StepType.ERASURE_CODING_POLICIES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadErasureCodingSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n          break;\n        default:\n          LOG.warn(\"Unrecognized section {}\", n);\n          break;\n        }\n      }\n      if (executorService !\u003d null) {\n        executorService.shutdown();\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "177131793a88960b734038f6e646476d568c3626": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14172. Avoid NPE when SectionName#fromString returns null. Contributed by Xiang Li.\n",
      "commitDate": "08/02/19 4:51 AM",
      "commitName": "177131793a88960b734038f6e646476d568c3626",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "08/11/18 10:01 AM",
      "commitNameOld": "8d99648c203004045a9339ad27258092969145d6",
      "commitAuthorOld": "Kitti Nanasi",
      "daysBetweenCommits": 91.78,
      "commitsBetweenForRepo": 608,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,113 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n       if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n           HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n         throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n             \" is not equal to the software version \" +\n             HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       }\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n-\n-        switch (SectionName.fromString(n)) {\n+        SectionName sectionName \u003d SectionName.fromString(n);\n+        if (sectionName \u003d\u003d null) {\n+          throw new IOException(\"Unrecognized section \" + n);\n+        }\n+        switch (sectionName) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in, prog, currentStep);\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case ERASURE_CODING:\n           Step step \u003d new Step(StepType.ERASURE_CODING_POLICIES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadErasureCodingSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n           break;\n         default:\n           LOG.warn(\"Unrecognized section {}\", n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n          HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n            \" is not equal to the software version \" +\n            HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      }\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n        SectionName sectionName \u003d SectionName.fromString(n);\n        if (sectionName \u003d\u003d null) {\n          throw new IOException(\"Unrecognized section \" + n);\n        }\n        switch (sectionName) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in, prog, currentStep);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case ERASURE_CODING:\n          Step step \u003d new Step(StepType.ERASURE_CODING_POLICIES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadErasureCodingSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n          break;\n        default:\n          LOG.warn(\"Unrecognized section {}\", n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "ae8f55b93243560bd891962d6c64320ddc62a7d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7859. Erasure Coding: Persist erasure coding policies in NameNode. Contributed by Sammi Chen\n",
      "commitDate": "14/09/17 6:08 PM",
      "commitName": "ae8f55b93243560bd891962d6c64320ddc62a7d7",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "20/12/16 7:24 AM",
      "commitNameOld": "1b401f6a734df4e23a79b3bd89c816a1fc0de574",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 268.41,
      "commitsBetweenForRepo": 1619,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,110 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n       if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n           HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n         throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n             \" is not equal to the software version \" +\n             HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       }\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in, prog, currentStep);\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n+        case ERASURE_CODING:\n+          Step step \u003d new Step(StepType.ERASURE_CODING_POLICIES);\n+          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n+          loadErasureCodingSection(in);\n+          prog.endStep(Phase.LOADING_FSIMAGE, step);\n+          break;\n         default:\n           LOG.warn(\"Unrecognized section {}\", n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n          HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n            \" is not equal to the software version \" +\n            HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      }\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in, prog, currentStep);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case ERASURE_CODING:\n          Step step \u003d new Step(StepType.ERASURE_CODING_POLICIES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadErasureCodingSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n          break;\n        default:\n          LOG.warn(\"Unrecognized section {}\", n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "af9bdbe447b119bff10ec5281993bfc36b6dea71": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10264. Logging improvements in FSImageFormatProtobuf.Saver. (Contributed by Xiaobing Zhou)\n",
      "commitDate": "19/04/16 11:26 AM",
      "commitName": "af9bdbe447b119bff10ec5281993bfc36b6dea71",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "27/01/16 4:34 PM",
      "commitNameOld": "ec25c7f9c7e60c077d8c4143253c20445fcdaecf",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 82.74,
      "commitsBetweenForRepo": 524,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n       if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n           HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n         throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n             \" is not equal to the software version \" +\n             HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       }\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in, prog, currentStep);\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n-          LOG.warn(\"Unrecognized section \" + n);\n+          LOG.warn(\"Unrecognized section {}\", n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n          HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n            \" is not equal to the software version \" +\n            HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      }\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in, prog, currentStep);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unrecognized section {}\", n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "e965dcec378cb807856372425307598792977604": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8470. fsimage loading progress should update inode, delegation token and cache pool count. (Contributed by surendra singh lilhore)\n",
      "commitDate": "03/06/15 1:54 AM",
      "commitName": "e965dcec378cb807856372425307598792977604",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 31.66,
      "commitsBetweenForRepo": 326,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n       if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n           HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n         throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n             \" is not equal to the software version \" +\n             HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       }\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n-          inodeLoader.loadINodeSection(in);\n+          inodeLoader.loadINodeSection(in, prog, currentStep);\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n-          loadSecretManagerSection(in);\n+          loadSecretManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n-          loadCacheManagerSection(in);\n+          loadCacheManagerSection(in, prog, step);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n           LOG.warn(\"Unrecognized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n          HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n            \" is not equal to the software version \" +\n            HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      }\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in, prog, currentStep);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in, prog, step);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unrecognized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "11/11/14 12:42 PM",
      "commitNameOld": "571e9c623241106dad5521a870fb8daef3f2b00a",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 171.85,
      "commitsBetweenForRepo": 1359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n       if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n-          HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n+          HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n         throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n             \" is not equal to the software version \" +\n-            HdfsConstants.NAMENODE_LAYOUT_VERSION);\n+            HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       }\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in);\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n           LOG.warn(\"Unrecognized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n          HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n            \" is not equal to the software version \" +\n            HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      }\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unrecognized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "18620649f96d9e378fb7ea40de216284a9d525c7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7185. The active NameNode will not accept an fsimage sent from the standby during rolling upgrade. Contributed by Jing Zhao.\n",
      "commitDate": "15/10/14 10:27 AM",
      "commitName": "18620649f96d9e378fb7ea40de216284a9d525c7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "28/05/14 2:24 PM",
      "commitNameOld": "66c5bcfc6df4dfe824b664be302f5ee3193b7187",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 139.84,
      "commitsBetweenForRepo": 1251,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,104 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n+      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n+          HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n+        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n+            \" is not equal to the software version \" +\n+            HdfsConstants.NAMENODE_LAYOUT_VERSION);\n+      }\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in);\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n           LOG.warn(\"Unrecognized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n      if (requireSameLayoutVersion \u0026\u0026 summary.getLayoutVersion() !\u003d\n          HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n        throw new IOException(\"Image version \" + summary.getLayoutVersion() +\n            \" is not equal to the software version \" +\n            HdfsConstants.NAMENODE_LAYOUT_VERSION);\n      }\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unrecognized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "077adb25b7fb3d8d0dbd93096a3f72418ea6521c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5979. Typo and logger fix for fsimage PB code. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/02/14 7:25 PM",
      "commitName": "077adb25b7fb3d8d0dbd93096a3f72418ea6521c",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/02/14 9:24 AM",
      "commitNameOld": "909eb7e4f1bf40d910555ab8c1d4fe1a46ef47bd",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in);\n         }\n           break;\n         case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n-          LOG.warn(\"Unregconized section \" + n);\n+          LOG.warn(\"Unrecognized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unrecognized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "bf5971b86a042076ff50add2ec8f90ae6198d3ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5959. Fix typo at section name in FSImageFormatProtobuf.java. Contributed by Akira Ajisaka.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1569156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/02/14 5:06 PM",
      "commitName": "bf5971b86a042076ff50add2ec8f90ae6198d3ca",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "12/02/14 4:00 PM",
      "commitNameOld": "2624b20291629b4565ea45590b66f2c38f96df67",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.05,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in);\n         }\n           break;\n-        case INODE_REFRENCE:\n+        case INODE_REFERENCE:\n           snapshotLoader.loadINodeReferenceSection(in);\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n           LOG.warn(\"Unregconized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_REFERENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unregconized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "2624b20291629b4565ea45590b66f2c38f96df67": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5847. Consolidate INodeReference into a separate section. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567812 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 4:00 PM",
      "commitName": "2624b20291629b4565ea45590b66f2c38f96df67",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "10/02/14 3:13 PM",
      "commitNameOld": "5c978a43c3052cc1466b23653c354399186b4e10",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 2.03,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,98 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in);\n         }\n           break;\n+        case INODE_REFRENCE:\n+          snapshotLoader.loadINodeReferenceSection(in);\n+          break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n           LOG.warn(\"Unregconized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_REFRENCE:\n          snapshotLoader.loadINodeReferenceSection(in);\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unregconized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "ea0b21af158016651cb77560778834eb95e6b68d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5933. Optimize the FSImage layout for ACLs. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1567785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 2:56 PM",
      "commitName": "ea0b21af158016651cb77560778834eb95e6b68d",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "10/02/14 10:25 PM",
      "commitNameOld": "d03acc756094a332f98167426a39db8faf38f450",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,95 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n-        case EXTENDED_ACL:\n-          loadExtendedAclSection(in);\n-          break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in);\n         }\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n           LOG.warn(\"Unregconized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unregconized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "d03acc756094a332f98167426a39db8faf38f450": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5914. Incorporate ACLs with the changes from HDFS-5698. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1566991 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/02/14 10:25 PM",
      "commitName": "d03acc756094a332f98167426a39db8faf38f450",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "10/02/14 3:13 PM",
      "commitNameOld": "5c978a43c3052cc1466b23653c354399186b4e10",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,98 @@\n     private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n         throws IOException {\n       if (!FSImageUtil.checkFileFormat(raFile)) {\n         throw new IOException(\"Unrecognized file format\");\n       }\n       FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n \n       FileChannel channel \u003d fin.getChannel();\n \n       FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n           fsn, this);\n       FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n           fsn, this);\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       /**\n        * beginStep() and the endStep() calls do not match the boundary of the\n        * sections. This is because that the current implementation only allows\n        * a particular step to be started for once.\n        */\n       Step currentStep \u003d null;\n \n       for (FileSummary.Section s : sections) {\n         channel.position(s.getOffset());\n         InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n             s.getLength()));\n \n         in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), in);\n \n         String n \u003d s.getName();\n \n         switch (SectionName.fromString(n)) {\n         case NS_INFO:\n           loadNameSystemSection(in);\n           break;\n         case STRING_TABLE:\n           loadStringTableSection(in);\n           break;\n+        case EXTENDED_ACL:\n+          loadExtendedAclSection(in);\n+          break;\n         case INODE: {\n           currentStep \u003d new Step(StepType.INODES);\n           prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n           inodeLoader.loadINodeSection(in);\n         }\n           break;\n         case INODE_DIR:\n           inodeLoader.loadINodeDirectorySection(in);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           inodeLoader.loadFilesUnderConstructionSection(in);\n           break;\n         case SNAPSHOT:\n           snapshotLoader.loadSnapshotSection(in);\n           break;\n         case SNAPSHOT_DIFF:\n           snapshotLoader.loadSnapshotDiffSection(in);\n           break;\n         case SECRET_MANAGER: {\n           prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n           Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadSecretManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         case CACHE_MANAGER: {\n           Step step \u003d new Step(StepType.CACHE_POOLS);\n           prog.beginStep(Phase.LOADING_FSIMAGE, step);\n           loadCacheManagerSection(in);\n           prog.endStep(Phase.LOADING_FSIMAGE, step);\n         }\n           break;\n         default:\n           LOG.warn(\"Unregconized section \" + n);\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case EXTENDED_ACL:\n          loadExtendedAclSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unregconized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java",
      "extendedDetails": {}
    },
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5698. Use protobuf to serialize / deserialize FSImage. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1566359 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/02/14 11:18 AM",
      "commitName": "a2edb11b68ae01a44092cb14ac2717a6aad93305",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,95 @@\n+    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n+        throws IOException {\n+      if (!FSImageUtil.checkFileFormat(raFile)) {\n+        throw new IOException(\"Unrecognized file format\");\n+      }\n+      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n+\n+      FileChannel channel \u003d fin.getChannel();\n+\n+      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n+          fsn, this);\n+      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n+          fsn, this);\n+\n+      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n+          .getSectionsList());\n+      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n+        @Override\n+        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n+          SectionName n1 \u003d SectionName.fromString(s1.getName());\n+          SectionName n2 \u003d SectionName.fromString(s2.getName());\n+          if (n1 \u003d\u003d null) {\n+            return n2 \u003d\u003d null ? 0 : -1;\n+          } else if (n2 \u003d\u003d null) {\n+            return -1;\n+          } else {\n+            return n1.ordinal() - n2.ordinal();\n+          }\n+        }\n+      });\n+\n+      StartupProgress prog \u003d NameNode.getStartupProgress();\n+      /**\n+       * beginStep() and the endStep() calls do not match the boundary of the\n+       * sections. This is because that the current implementation only allows\n+       * a particular step to be started for once.\n+       */\n+      Step currentStep \u003d null;\n+\n+      for (FileSummary.Section s : sections) {\n+        channel.position(s.getOffset());\n+        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n+            s.getLength()));\n+\n+        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n+            summary.getCodec(), in);\n+\n+        String n \u003d s.getName();\n+\n+        switch (SectionName.fromString(n)) {\n+        case NS_INFO:\n+          loadNameSystemSection(in);\n+          break;\n+        case STRING_TABLE:\n+          loadStringTableSection(in);\n+          break;\n+        case INODE: {\n+          currentStep \u003d new Step(StepType.INODES);\n+          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n+          inodeLoader.loadINodeSection(in);\n+        }\n+          break;\n+        case INODE_DIR:\n+          inodeLoader.loadINodeDirectorySection(in);\n+          break;\n+        case FILES_UNDERCONSTRUCTION:\n+          inodeLoader.loadFilesUnderConstructionSection(in);\n+          break;\n+        case SNAPSHOT:\n+          snapshotLoader.loadSnapshotSection(in);\n+          break;\n+        case SNAPSHOT_DIFF:\n+          snapshotLoader.loadSnapshotDiffSection(in);\n+          break;\n+        case SECRET_MANAGER: {\n+          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n+          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n+          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n+          loadSecretManagerSection(in);\n+          prog.endStep(Phase.LOADING_FSIMAGE, step);\n+        }\n+          break;\n+        case CACHE_MANAGER: {\n+          Step step \u003d new Step(StepType.CACHE_POOLS);\n+          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n+          loadCacheManagerSection(in);\n+          prog.endStep(Phase.LOADING_FSIMAGE, step);\n+        }\n+          break;\n+        default:\n+          LOG.warn(\"Unregconized section \" + n);\n+          break;\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadInternal(RandomAccessFile raFile, FileInputStream fin)\n        throws IOException {\n      if (!FSImageUtil.checkFileFormat(raFile)) {\n        throw new IOException(\"Unrecognized file format\");\n      }\n      FileSummary summary \u003d FSImageUtil.loadSummary(raFile);\n\n      FileChannel channel \u003d fin.getChannel();\n\n      FSImageFormatPBINode.Loader inodeLoader \u003d new FSImageFormatPBINode.Loader(\n          fsn, this);\n      FSImageFormatPBSnapshot.Loader snapshotLoader \u003d new FSImageFormatPBSnapshot.Loader(\n          fsn, this);\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      /**\n       * beginStep() and the endStep() calls do not match the boundary of the\n       * sections. This is because that the current implementation only allows\n       * a particular step to be started for once.\n       */\n      Step currentStep \u003d null;\n\n      for (FileSummary.Section s : sections) {\n        channel.position(s.getOffset());\n        InputStream in \u003d new BufferedInputStream(new LimitInputStream(fin,\n            s.getLength()));\n\n        in \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), in);\n\n        String n \u003d s.getName();\n\n        switch (SectionName.fromString(n)) {\n        case NS_INFO:\n          loadNameSystemSection(in);\n          break;\n        case STRING_TABLE:\n          loadStringTableSection(in);\n          break;\n        case INODE: {\n          currentStep \u003d new Step(StepType.INODES);\n          prog.beginStep(Phase.LOADING_FSIMAGE, currentStep);\n          inodeLoader.loadINodeSection(in);\n        }\n          break;\n        case INODE_DIR:\n          inodeLoader.loadINodeDirectorySection(in);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          inodeLoader.loadFilesUnderConstructionSection(in);\n          break;\n        case SNAPSHOT:\n          snapshotLoader.loadSnapshotSection(in);\n          break;\n        case SNAPSHOT_DIFF:\n          snapshotLoader.loadSnapshotDiffSection(in);\n          break;\n        case SECRET_MANAGER: {\n          prog.endStep(Phase.LOADING_FSIMAGE, currentStep);\n          Step step \u003d new Step(StepType.DELEGATION_TOKENS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadSecretManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        case CACHE_MANAGER: {\n          Step step \u003d new Step(StepType.CACHE_POOLS);\n          prog.beginStep(Phase.LOADING_FSIMAGE, step);\n          loadCacheManagerSection(in);\n          prog.endStep(Phase.LOADING_FSIMAGE, step);\n        }\n          break;\n        default:\n          LOG.warn(\"Unregconized section \" + n);\n          break;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatProtobuf.java"
    }
  }
}