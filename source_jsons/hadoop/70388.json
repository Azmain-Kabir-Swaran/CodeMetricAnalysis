{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "rename",
  "functionId": "rename___src-Path__dst-Path",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 3100,
  "functionEndLine": 3291,
  "numCommitsSeen": 66,
  "timeTaken": 5731,
  "changeHistory": [
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
    "52babbb4a0e3c89f2025bf6e9a1b51a96e8f8fb0",
    "3de574413c4d5554213d02bd0ad343ba82cf82aa",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
    "686823529be09bea2a6cecb3503ef722017475bc",
    "52d7d5aa1a303cf70519a61487641211f4267c6f",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
    "5f6edb30c2bb648d5564c951edc25645e17e6636",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
    "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": "Ybodychange",
    "52babbb4a0e3c89f2025bf6e9a1b51a96e8f8fb0": "Ybodychange",
    "3de574413c4d5554213d02bd0ad343ba82cf82aa": "Ybodychange",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": "Ybodychange",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": "Ybodychange",
    "686823529be09bea2a6cecb3503ef722017475bc": "Ybodychange",
    "52d7d5aa1a303cf70519a61487641211f4267c6f": "Ybodychange",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": "Ybodychange",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": "Ybodychange",
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5f6edb30c2bb648d5564c951edc25645e17e6636": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Ybodychange",
    "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15547/ WASB: improve listStatus performance.\nContributed by Thomas Marquardt.\n\n(cherry picked from commit 749fff577ed9afb4ef8a54b8948f74be083cc620)\n",
      "commitDate": "19/07/18 12:31 PM",
      "commitName": "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.58,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,192 +1,192 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absoluteSrcPath \u003d makeAbsolute(src);\n     Path srcParentFolder \u003d absoluteSrcPath.getParent();\n \n     if (srcParentFolder \u003d\u003d null) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     String srcKey \u003d pathToKey(absoluteSrcPath);\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\",\n         absoluteSrcPath);\n \n     if (this.azureAuthorization) {\n       try {\n         performStickyBitCheckForRenameOperation(absoluteSrcPath, srcParentFolder);\n       } catch (FileNotFoundException ex) {\n         return false;\n       } catch (IOException ex) {\n         Throwable innerException \u003d checkForAzureStorageException(ex);\n         if (innerException instanceof StorageException\n           \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"Encountered FileNotFound Exception when performing sticky bit check \"\n             + \"on {}. Failing rename\", srcKey);\n           return false;\n         }\n         throw ex;\n       }\n     }\n \n     // Figure out the final destination\n     Path absoluteDstPath \u003d makeAbsolute(dst);\n     Path dstParentFolder \u003d absoluteDstPath.getParent();\n \n     String dstKey \u003d pathToKey(absoluteDstPath);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n-    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n+    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDirectory()) {\n       // It\u0027s an existing directory.\n       performAuthCheck(absoluteDstPath, WasbAuthorizationOperations.WRITE, \"rename\",\n           absoluteDstPath);\n \n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n-      } else if (!parentOfDestMetadata.isDir()) {\n+      } else if (!parentOfDestMetadata.isDirectory()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       } else {\n         performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE,\n           \"rename\", absoluteDstPath);\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n-    } else if (!srcMetadata.isDir()) {\n+    } else if (!srcMetadata.isDirectory()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         // HADOOP-15086 - file rename must ensure that the destination does\n         // not exist.  The fix is targeted to this call only to avoid\n         // regressions.  Other call sites are attempting to rename temporary\n         // files, redo a failed rename operation, or rename a directory\n         // recursively; for these cases the destination may exist.\n         store.rename(srcKey, dstKey, false, null,\n             false);\n       } catch(IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException) {\n           if (NativeAzureFileSystemHelper.isFileNotFoundException(\n               (StorageException) innerException)) {\n             LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n             return false;\n           }\n           if (NativeAzureFileSystemHelper.isBlobAlreadyExistsConflict(\n               (StorageException) innerException)) {\n             LOG.debug(\"Destination BlobAlreadyExists. Failing rename\", src);\n             return false;\n           }\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absoluteSrcPath \u003d makeAbsolute(src);\n    Path srcParentFolder \u003d absoluteSrcPath.getParent();\n\n    if (srcParentFolder \u003d\u003d null) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    String srcKey \u003d pathToKey(absoluteSrcPath);\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\",\n        absoluteSrcPath);\n\n    if (this.azureAuthorization) {\n      try {\n        performStickyBitCheckForRenameOperation(absoluteSrcPath, srcParentFolder);\n      } catch (FileNotFoundException ex) {\n        return false;\n      } catch (IOException ex) {\n        Throwable innerException \u003d checkForAzureStorageException(ex);\n        if (innerException instanceof StorageException\n          \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"Encountered FileNotFound Exception when performing sticky bit check \"\n            + \"on {}. Failing rename\", srcKey);\n          return false;\n        }\n        throw ex;\n      }\n    }\n\n    // Figure out the final destination\n    Path absoluteDstPath \u003d makeAbsolute(dst);\n    Path dstParentFolder \u003d absoluteDstPath.getParent();\n\n    String dstKey \u003d pathToKey(absoluteDstPath);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDirectory()) {\n      // It\u0027s an existing directory.\n      performAuthCheck(absoluteDstPath, WasbAuthorizationOperations.WRITE, \"rename\",\n          absoluteDstPath);\n\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDirectory()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      } else {\n        performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE,\n          \"rename\", absoluteDstPath);\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDirectory()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        // HADOOP-15086 - file rename must ensure that the destination does\n        // not exist.  The fix is targeted to this call only to avoid\n        // regressions.  Other call sites are attempting to rename temporary\n        // files, redo a failed rename operation, or rename a directory\n        // recursively; for these cases the destination may exist.\n        store.rename(srcKey, dstKey, false, null,\n            false);\n      } catch(IOException ex) {\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException) {\n          if (NativeAzureFileSystemHelper.isFileNotFoundException(\n              (StorageException) innerException)) {\n            LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n            return false;\n          }\n          if (NativeAzureFileSystemHelper.isBlobAlreadyExistsConflict(\n              (StorageException) innerException)) {\n            LOG.debug(\"Destination BlobAlreadyExists. Failing rename\", src);\n            return false;\n          }\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "52babbb4a0e3c89f2025bf6e9a1b51a96e8f8fb0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15086. NativeAzureFileSystem file rename is not atomic.\nContributed by Thomas Marquardt\n",
      "commitDate": "22/12/17 3:39 AM",
      "commitName": "52babbb4a0e3c89f2025bf6e9a1b51a96e8f8fb0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/10/17 8:01 AM",
      "commitNameOld": "9fcc3a1fc8cab873034f5c308ceb2d5671a954e8",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 66.86,
      "commitsBetweenForRepo": 532,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,181 +1,192 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absoluteSrcPath \u003d makeAbsolute(src);\n     Path srcParentFolder \u003d absoluteSrcPath.getParent();\n \n     if (srcParentFolder \u003d\u003d null) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     String srcKey \u003d pathToKey(absoluteSrcPath);\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\",\n         absoluteSrcPath);\n \n     if (this.azureAuthorization) {\n       try {\n         performStickyBitCheckForRenameOperation(absoluteSrcPath, srcParentFolder);\n       } catch (FileNotFoundException ex) {\n         return false;\n       } catch (IOException ex) {\n         Throwable innerException \u003d checkForAzureStorageException(ex);\n         if (innerException instanceof StorageException\n           \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"Encountered FileNotFound Exception when performing sticky bit check \"\n             + \"on {}. Failing rename\", srcKey);\n           return false;\n         }\n         throw ex;\n       }\n     }\n \n     // Figure out the final destination\n     Path absoluteDstPath \u003d makeAbsolute(dst);\n     Path dstParentFolder \u003d absoluteDstPath.getParent();\n \n     String dstKey \u003d pathToKey(absoluteDstPath);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       performAuthCheck(absoluteDstPath, WasbAuthorizationOperations.WRITE, \"rename\",\n           absoluteDstPath);\n \n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       } else {\n         performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE,\n           \"rename\", absoluteDstPath);\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n-        store.rename(srcKey, dstKey);\n+        // HADOOP-15086 - file rename must ensure that the destination does\n+        // not exist.  The fix is targeted to this call only to avoid\n+        // regressions.  Other call sites are attempting to rename temporary\n+        // files, redo a failed rename operation, or rename a directory\n+        // recursively; for these cases the destination may exist.\n+        store.rename(srcKey, dstKey, false, null,\n+            false);\n       } catch(IOException ex) {\n-\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n-        if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-\n-          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n-          return false;\n+        if (innerException instanceof StorageException) {\n+          if (NativeAzureFileSystemHelper.isFileNotFoundException(\n+              (StorageException) innerException)) {\n+            LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n+            return false;\n+          }\n+          if (NativeAzureFileSystemHelper.isBlobAlreadyExistsConflict(\n+              (StorageException) innerException)) {\n+            LOG.debug(\"Destination BlobAlreadyExists. Failing rename\", src);\n+            return false;\n+          }\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absoluteSrcPath \u003d makeAbsolute(src);\n    Path srcParentFolder \u003d absoluteSrcPath.getParent();\n\n    if (srcParentFolder \u003d\u003d null) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    String srcKey \u003d pathToKey(absoluteSrcPath);\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\",\n        absoluteSrcPath);\n\n    if (this.azureAuthorization) {\n      try {\n        performStickyBitCheckForRenameOperation(absoluteSrcPath, srcParentFolder);\n      } catch (FileNotFoundException ex) {\n        return false;\n      } catch (IOException ex) {\n        Throwable innerException \u003d checkForAzureStorageException(ex);\n        if (innerException instanceof StorageException\n          \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"Encountered FileNotFound Exception when performing sticky bit check \"\n            + \"on {}. Failing rename\", srcKey);\n          return false;\n        }\n        throw ex;\n      }\n    }\n\n    // Figure out the final destination\n    Path absoluteDstPath \u003d makeAbsolute(dst);\n    Path dstParentFolder \u003d absoluteDstPath.getParent();\n\n    String dstKey \u003d pathToKey(absoluteDstPath);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      performAuthCheck(absoluteDstPath, WasbAuthorizationOperations.WRITE, \"rename\",\n          absoluteDstPath);\n\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      } else {\n        performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE,\n          \"rename\", absoluteDstPath);\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        // HADOOP-15086 - file rename must ensure that the destination does\n        // not exist.  The fix is targeted to this call only to avoid\n        // regressions.  Other call sites are attempting to rename temporary\n        // files, redo a failed rename operation, or rename a directory\n        // recursively; for these cases the destination may exist.\n        store.rename(srcKey, dstKey, false, null,\n            false);\n      } catch(IOException ex) {\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException) {\n          if (NativeAzureFileSystemHelper.isFileNotFoundException(\n              (StorageException) innerException)) {\n            LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n            return false;\n          }\n          if (NativeAzureFileSystemHelper.isBlobAlreadyExistsConflict(\n              (StorageException) innerException)) {\n            LOG.debug(\"Destination BlobAlreadyExists. Failing rename\", src);\n            return false;\n          }\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "3de574413c4d5554213d02bd0ad343ba82cf82aa": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14913. Sticky bit implementation for rename() operation in Azure WASB.\nContributed by Varada Hemeswari.\n",
      "commitDate": "11/10/17 10:06 AM",
      "commitName": "3de574413c4d5554213d02bd0ad343ba82cf82aa",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "06/10/17 9:43 AM",
      "commitNameOld": "572cdb54632d8a29c4d9900f9e988ada8e3fe2ec",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.02,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,159 +1,181 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absoluteSrcPath \u003d makeAbsolute(src);\n     Path srcParentFolder \u003d absoluteSrcPath.getParent();\n \n     if (srcParentFolder \u003d\u003d null) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n-    performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\", absoluteSrcPath);\n-\n     String srcKey \u003d pathToKey(absoluteSrcPath);\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n+    performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\",\n+        absoluteSrcPath);\n+\n+    if (this.azureAuthorization) {\n+      try {\n+        performStickyBitCheckForRenameOperation(absoluteSrcPath, srcParentFolder);\n+      } catch (FileNotFoundException ex) {\n+        return false;\n+      } catch (IOException ex) {\n+        Throwable innerException \u003d checkForAzureStorageException(ex);\n+        if (innerException instanceof StorageException\n+          \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n+          LOG.debug(\"Encountered FileNotFound Exception when performing sticky bit check \"\n+            + \"on {}. Failing rename\", srcKey);\n+          return false;\n+        }\n+        throw ex;\n+      }\n+    }\n+\n     // Figure out the final destination\n     Path absoluteDstPath \u003d makeAbsolute(dst);\n     Path dstParentFolder \u003d absoluteDstPath.getParent();\n \n-    performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE, \"rename\", absoluteDstPath);\n-\n     String dstKey \u003d pathToKey(absoluteDstPath);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n+      performAuthCheck(absoluteDstPath, WasbAuthorizationOperations.WRITE, \"rename\",\n+          absoluteDstPath);\n+\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n+      } else {\n+        performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE,\n+          \"rename\", absoluteDstPath);\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         store.rename(srcKey, dstKey);\n       } catch(IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n           return false;\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absoluteSrcPath \u003d makeAbsolute(src);\n    Path srcParentFolder \u003d absoluteSrcPath.getParent();\n\n    if (srcParentFolder \u003d\u003d null) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    String srcKey \u003d pathToKey(absoluteSrcPath);\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\",\n        absoluteSrcPath);\n\n    if (this.azureAuthorization) {\n      try {\n        performStickyBitCheckForRenameOperation(absoluteSrcPath, srcParentFolder);\n      } catch (FileNotFoundException ex) {\n        return false;\n      } catch (IOException ex) {\n        Throwable innerException \u003d checkForAzureStorageException(ex);\n        if (innerException instanceof StorageException\n          \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"Encountered FileNotFound Exception when performing sticky bit check \"\n            + \"on {}. Failing rename\", srcKey);\n          return false;\n        }\n        throw ex;\n      }\n    }\n\n    // Figure out the final destination\n    Path absoluteDstPath \u003d makeAbsolute(dst);\n    Path dstParentFolder \u003d absoluteDstPath.getParent();\n\n    String dstKey \u003d pathToKey(absoluteDstPath);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      performAuthCheck(absoluteDstPath, WasbAuthorizationOperations.WRITE, \"rename\",\n          absoluteDstPath);\n\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      } else {\n        performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE,\n          \"rename\", absoluteDstPath);\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14416. Path starting with \u0027wasb:///\u0027 not resolved correctly while authorizing with WASB-Ranger. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "16/05/17 11:22 AM",
      "commitName": "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "10/05/17 3:05 PM",
      "commitNameOld": "eed731496f63537350206274af09d2118b116a17",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,159 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absoluteSrcPath \u003d makeAbsolute(src);\n     Path srcParentFolder \u003d absoluteSrcPath.getParent();\n \n     if (srcParentFolder \u003d\u003d null) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n-    performAuthCheck(srcParentFolder.toString(), WasbAuthorizationOperations.WRITE, \"rename\",\n-        absoluteSrcPath.toString());\n+    performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\", absoluteSrcPath);\n \n     String srcKey \u003d pathToKey(absoluteSrcPath);\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDstPath \u003d makeAbsolute(dst);\n     Path dstParentFolder \u003d absoluteDstPath.getParent();\n \n-    performAuthCheck(dstParentFolder.toString(), WasbAuthorizationOperations.WRITE, \"rename\",\n-        absoluteDstPath.toString());\n+    performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE, \"rename\", absoluteDstPath);\n \n     String dstKey \u003d pathToKey(absoluteDstPath);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         store.rename(srcKey, dstKey);\n       } catch(IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n           return false;\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absoluteSrcPath \u003d makeAbsolute(src);\n    Path srcParentFolder \u003d absoluteSrcPath.getParent();\n\n    if (srcParentFolder \u003d\u003d null) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    performAuthCheck(srcParentFolder, WasbAuthorizationOperations.WRITE, \"rename\", absoluteSrcPath);\n\n    String srcKey \u003d pathToKey(absoluteSrcPath);\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDstPath \u003d makeAbsolute(dst);\n    Path dstParentFolder \u003d absoluteDstPath.getParent();\n\n    performAuthCheck(dstParentFolder, WasbAuthorizationOperations.WRITE, \"rename\", absoluteDstPath);\n\n    String dstKey \u003d pathToKey(absoluteDstPath);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14274. Azure: Simplify Ranger-WASB policy model. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "12/04/17 4:07 PM",
      "commitName": "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "04/04/17 11:10 AM",
      "commitNameOld": "56ab02eed9b61e1c80605104dfc4c87fc6abac96",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 8.21,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,161 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n-    Path absolutePath \u003d makeAbsolute(src);\n+    Path absoluteSrcPath \u003d makeAbsolute(src);\n+    Path srcParentFolder \u003d absoluteSrcPath.getParent();\n \n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.EXECUTE.toString(), \"rename\");\n+    if (srcParentFolder \u003d\u003d null) {\n+      // Cannot rename root of file system\n+      return false;\n+    }\n \n-    String srcKey \u003d pathToKey(absolutePath);\n+    performAuthCheck(srcParentFolder.toString(), WasbAuthorizationOperations.WRITE, \"rename\",\n+        absoluteSrcPath.toString());\n+\n+    String srcKey \u003d pathToKey(absoluteSrcPath);\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n-    Path absoluteDst \u003d makeAbsolute(dst);\n-    String dstKey \u003d pathToKey(absoluteDst);\n+    Path absoluteDstPath \u003d makeAbsolute(dst);\n+    Path dstParentFolder \u003d absoluteDstPath.getParent();\n+\n+    performAuthCheck(dstParentFolder.toString(), WasbAuthorizationOperations.WRITE, \"rename\",\n+        absoluteDstPath.toString());\n+\n+    String dstKey \u003d pathToKey(absoluteDstPath);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n-      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n+      // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n-              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n+              + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n-        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n+        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         store.rename(srcKey, dstKey);\n       } catch(IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n           return false;\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absoluteSrcPath \u003d makeAbsolute(src);\n    Path srcParentFolder \u003d absoluteSrcPath.getParent();\n\n    if (srcParentFolder \u003d\u003d null) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    performAuthCheck(srcParentFolder.toString(), WasbAuthorizationOperations.WRITE, \"rename\",\n        absoluteSrcPath.toString());\n\n    String srcKey \u003d pathToKey(absoluteSrcPath);\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDstPath \u003d makeAbsolute(dst);\n    Path dstParentFolder \u003d absoluteDstPath.getParent();\n\n    performAuthCheck(dstParentFolder.toString(), WasbAuthorizationOperations.WRITE, \"rename\",\n        absoluteDstPath.toString());\n\n    String dstKey \u003d pathToKey(absoluteDstPath);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetadata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowing the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDstPath.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "686823529be09bea2a6cecb3503ef722017475bc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "06/03/17 5:16 PM",
      "commitName": "686823529be09bea2a6cecb3503ef722017475bc",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:10 PM",
      "commitNameOld": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,150 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n-    String srcKey \u003d pathToKey(makeAbsolute(src));\n+    Path absolutePath \u003d makeAbsolute(src);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.EXECUTE.toString(), \"rename\");\n+\n+    String srcKey \u003d pathToKey(absolutePath);\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         store.rename(srcKey, dstKey);\n       } catch(IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n           return false;\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(src);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.EXECUTE.toString(), \"rename\");\n\n    String srcKey \u003d pathToKey(absolutePath);\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "52d7d5aa1a303cf70519a61487641211f4267c6f": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\"\n\nThis reverts commit 6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f.\n",
      "commitDate": "06/03/17 5:10 PM",
      "commitName": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:00 PM",
      "commitNameOld": "c571cda5c7d929477961dfff4176d7de4944d874",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,145 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n-    Path absolutePath \u003d makeAbsolute(src);\n-\n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.EXECUTE.toString(), \"rename\");\n-\n-    String srcKey \u003d pathToKey(absolutePath);\n+    String srcKey \u003d pathToKey(makeAbsolute(src));\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         store.rename(srcKey, dstKey);\n       } catch(IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n           return false;\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "03/03/17 5:09 PM",
      "commitName": "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "29/12/16 4:24 PM",
      "commitNameOld": "c6a5b689db573046819f0e9193cb042e6c7298f4",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 64.03,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,150 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n-    String srcKey \u003d pathToKey(makeAbsolute(src));\n+    Path absolutePath \u003d makeAbsolute(src);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.EXECUTE.toString(), \"rename\");\n+\n+    String srcKey \u003d pathToKey(absolutePath);\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n         if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         store.rename(srcKey, dstKey);\n       } catch(IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n           return false;\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(src);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.EXECUTE.toString(), \"rename\");\n\n    String srcKey \u003d pathToKey(absolutePath);\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12635. Adding Append API support for WASB. Contributed by Dushyanth.\n",
      "commitDate": "18/01/16 9:08 AM",
      "commitName": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
      "commitAuthor": "cnauroth",
      "commitDateOld": "09/01/16 10:18 PM",
      "commitNameOld": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 8.45,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     String srcKey \u003d pathToKey(makeAbsolute(src));\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n     FileMetadata dstMetadata \u003d null;\n     try {\n       dstMetadata \u003d store.retrieveMetadata(dstKey);\n     } catch (IOException ex) {\n \n-      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n       // there is a race condition. If there is another thread which deletes the destination\n       // file or folder, then this thread calling rename should be able to continue with\n       // rename gracefully. Hence the StorageException is swallowed here.\n       if (innerException instanceof StorageException) {\n-        if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n               + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n         }\n       } else {\n         throw ex;\n       }\n     }\n \n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d null;\n       try {\n         parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n       } catch (IOException ex) {\n \n-        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n           return false;\n         }\n \n         throw ex;\n       }\n \n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n     FileMetadata srcMetadata \u003d null;\n     try {\n       srcMetadata \u003d store.retrieveMetadata(srcKey);\n     } catch (IOException ex) {\n-      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n-          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n         return false;\n       }\n \n       throw ex;\n     }\n \n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n       try {\n         store.rename(srcKey, dstKey);\n       } catch(IOException ex) {\n \n-        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n           LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n           return false;\n         }\n \n         throw ex;\n       }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-12551. Introduce FileNotFoundException for WASB FileSystem API. Contributed by Dushyanth.\n",
      "commitDate": "09/01/16 10:18 PM",
      "commitName": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-12551. Introduce FileNotFoundException for WASB FileSystem API. Contributed by Dushyanth.\n",
          "commitDate": "09/01/16 10:18 PM",
          "commitName": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
          "commitAuthor": "cnauroth",
          "commitDateOld": "08/01/16 8:18 PM",
          "commitNameOld": "f0fa6d869b9abb5a900ea1c9eb4eb19ec9831dc4",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.08,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,145 @@\n-  public boolean rename(Path src, Path dst) throws IOException {\n+  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     String srcKey \u003d pathToKey(makeAbsolute(src));\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n-    FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n+    FileMetadata dstMetadata \u003d null;\n+    try {\n+      dstMetadata \u003d store.retrieveMetadata(dstKey);\n+    } catch (IOException ex) {\n+\n+      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n+      // there is a race condition. If there is another thread which deletes the destination\n+      // file or folder, then this thread calling rename should be able to continue with\n+      // rename gracefully. Hence the StorageException is swallowed here.\n+      if (innerException instanceof StorageException) {\n+        if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n+              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n+        }\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n-      FileMetadata parentOfDestMetadata \u003d\n-          store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n+      FileMetadata parentOfDestMetadata \u003d null;\n+      try {\n+        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n+      } catch (IOException ex) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n+          return false;\n+        }\n+\n+        throw ex;\n+      }\n+\n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n-    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n+    FileMetadata srcMetadata \u003d null;\n+    try {\n+      srcMetadata \u003d store.retrieveMetadata(srcKey);\n+    } catch (IOException ex) {\n+      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+      if (innerException instanceof StorageException\n+          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n+        return false;\n+      }\n+\n+      throw ex;\n+    }\n+\n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n-      store.rename(srcKey, dstKey);\n+      try {\n+        store.rename(srcKey, dstKey);\n+      } catch(IOException ex) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n+          return false;\n+        }\n+\n+        throw ex;\n+      }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[FileNotFoundException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12551. Introduce FileNotFoundException for WASB FileSystem API. Contributed by Dushyanth.\n",
          "commitDate": "09/01/16 10:18 PM",
          "commitName": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
          "commitAuthor": "cnauroth",
          "commitDateOld": "08/01/16 8:18 PM",
          "commitNameOld": "f0fa6d869b9abb5a900ea1c9eb4eb19ec9831dc4",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.08,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,145 @@\n-  public boolean rename(Path src, Path dst) throws IOException {\n+  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n     LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     String srcKey \u003d pathToKey(makeAbsolute(src));\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n-    FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n+    FileMetadata dstMetadata \u003d null;\n+    try {\n+      dstMetadata \u003d store.retrieveMetadata(dstKey);\n+    } catch (IOException ex) {\n+\n+      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n+      // there is a race condition. If there is another thread which deletes the destination\n+      // file or folder, then this thread calling rename should be able to continue with\n+      // rename gracefully. Hence the StorageException is swallowed here.\n+      if (innerException instanceof StorageException) {\n+        if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n+              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n+        }\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       LOG.debug(\"Destination {} \"\n           + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n       LOG.debug(\"Destination {}\"\n           + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n-      FileMetadata parentOfDestMetadata \u003d\n-          store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n+      FileMetadata parentOfDestMetadata \u003d null;\n+      try {\n+        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n+      } catch (IOException ex) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n+          return false;\n+        }\n+\n+        throw ex;\n+      }\n+\n       if (parentOfDestMetadata \u003d\u003d null) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         LOG.debug(\"Parent of the destination {}\"\n             + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n-    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n+    FileMetadata srcMetadata \u003d null;\n+    try {\n+      srcMetadata \u003d store.retrieveMetadata(srcKey);\n+    } catch (IOException ex) {\n+      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+      if (innerException instanceof StorageException\n+          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n+        return false;\n+      }\n+\n+      throw ex;\n+    }\n+\n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n       LOG.debug(\"Source {} found as a file, renaming.\", src);\n-      store.rename(srcKey, dstKey);\n+      try {\n+        store.rename(srcKey, dstKey);\n+      } catch(IOException ex) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n+          return false;\n+        }\n+\n+        throw ex;\n+      }\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n \n       LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n     LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean rename(Path src, Path dst) throws FileNotFoundException, IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d null;\n    try {\n      dstMetadata \u003d store.retrieveMetadata(dstKey);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n      // A BlobNotFound storage exception in only thrown from retrieveMetdata API when\n      // there is a race condition. If there is another thread which deletes the destination\n      // file or folder, then this thread calling rename should be able to continue with\n      // rename gracefully. Hence the StorageException is swallowed here.\n      if (innerException instanceof StorageException) {\n        if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n          LOG.debug(\"BlobNotFound exception encountered for Destination key : {}. \"\n              + \"Swallowin the exception to handle race condition gracefully\", dstKey);\n        }\n      } else {\n        throw ex;\n      }\n    }\n\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d null;\n      try {\n        parentOfDestMetadata \u003d store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"Parent of destination {} doesn\u0027t exists. Failing rename\", dst);\n          return false;\n        }\n\n        throw ex;\n      }\n\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d null;\n    try {\n      srcMetadata \u003d store.retrieveMetadata(srcKey);\n    } catch (IOException ex) {\n      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n        LOG.debug(\"Source {} doesn\u0027t exists. Failing rename\", src);\n        return false;\n      }\n\n      throw ex;\n    }\n\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      try {\n        store.rename(srcKey, dstKey);\n      } catch(IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n          LOG.debug(\"BlobNotFoundException encountered. Failing rename\", src);\n          return false;\n        }\n\n        throw ex;\n      }\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "5f6edb30c2bb648d5564c951edc25645e17e6636": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12350. WASB Logging: Improve WASB Logging around deletes, reads and writes. Contributed by Dushyanth.\n",
      "commitDate": "05/10/15 8:11 PM",
      "commitName": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthor": "cnauroth",
      "commitDateOld": "28/09/15 3:31 PM",
      "commitNameOld": "3abbdc929bde05f8819f5410cef1eaeb8940203f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.19,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,81 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n \n     FolderRenamePending renamePending \u003d null;\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Moving \" + src + \" to \" + dst);\n-    }\n+    LOG.debug(\"Moving {} to {}\", src, dst);\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     String srcKey \u003d pathToKey(makeAbsolute(src));\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n     FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Destination \" + dst\n-            + \" is a directory, adjusted the destination to be \" + dstKey);\n-      }\n+      LOG.debug(\"Destination {} \"\n+          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n     } else if (dstMetadata !\u003d null) {\n       // Attempting to overwrite a file using rename()\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Destination \" + dst\n-            + \" is an already existing file, failing the rename.\");\n-      }\n+      LOG.debug(\"Destination {}\"\n+          + \" is an already existing file, failing the rename.\", dst);\n       return false;\n     } else {\n       // Check that the parent directory exists.\n       FileMetadata parentOfDestMetadata \u003d\n           store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n       if (parentOfDestMetadata \u003d\u003d null) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Parent of the destination \" + dst\n-              + \" doesn\u0027t exist, failing the rename.\");\n-        }\n+        LOG.debug(\"Parent of the destination {}\"\n+            + \" doesn\u0027t exist, failing the rename.\", dst);\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Parent of the destination \" + dst\n-              + \" is a file, failing the rename.\");\n-        }\n+        LOG.debug(\"Parent of the destination {}\"\n+            + \" is a file, failing the rename.\", dst);\n         return false;\n       }\n     }\n     FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n-      }\n+      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n       return false;\n     } else if (!srcMetadata.isDir()) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Source \" + src + \" found as a file, renaming.\");\n-      }\n+      LOG.debug(\"Source {} found as a file, renaming.\", src);\n       store.rename(srcKey, dstKey);\n     } else {\n \n       // Prepare for, execute and clean up after of all files in folder, and\n       // the root file, and update the last modified time of the source and\n       // target parent folders. The operation can be redone if it fails part\n       // way through, by applying the \"Rename Pending\" file.\n \n       // The following code (internally) only does atomic rename preparation\n       // and lease management for page blob folders, limiting the scope of the\n       // operation to HBase log file folders, where atomic rename is required.\n       // In the future, we could generalize it easily to all folders.\n       renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n       renamePending.execute();\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n-      }\n+\n+      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n       renamePending.cleanup();\n       return true;\n     }\n \n     // Update the last-modified time of the parent folders of both source\n     // and destination.\n     updateParentFolderLastModifiedTime(srcKey);\n     updateParentFolderLastModifiedTime(dstKey);\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n-    }\n+    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    LOG.debug(\"Moving {} to {}\", src, dst);\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      LOG.debug(\"Destination {} \"\n          + \" is a directory, adjusted the destination to be {}\", dst, dstKey);\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      LOG.debug(\"Destination {}\"\n          + \" is an already existing file, failing the rename.\", dst);\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d\n          store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      if (parentOfDestMetadata \u003d\u003d null) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" doesn\u0027t exist, failing the rename.\", dst);\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        LOG.debug(\"Parent of the destination {}\"\n            + \" is a file, failing the rename.\", dst);\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      LOG.debug(\"Source {} doesn\u0027t exist, failing the rename.\", src);\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      LOG.debug(\"Source {} found as a file, renaming.\", src);\n      store.rename(srcKey, dstKey);\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n\n      LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    LOG.debug(\"Renamed {} to {} successfully.\", src, dst);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "commitDateOld": "19/09/14 11:33 AM",
      "commitNameOld": "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 19.12,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,190 +1,98 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n \n+    FolderRenamePending renamePending \u003d null;\n+\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Moving \" + src + \" to \" + dst);\n     }\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     String srcKey \u003d pathToKey(makeAbsolute(src));\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n-    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n-    if (srcMetadata \u003d\u003d null) {\n-      // Source doesn\u0027t exist\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n-      }\n-      return false;\n-    }\n-\n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n     FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n-\n-    // directory rename validations\n-    if (srcMetadata.isDir()) {\n-\n-      // rename dir to self is an error\n-      if (srcKey.equals(dstKey)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n-        }\n-        return false;\n-      }\n-\n-      // rename dir to (sub-)child of self is an error. see\n-      // FileSystemContractBaseTest.testRenameChildDirForbidden\n-      if (dstKey.startsWith(srcKey + PATH_DELIMITER)) {\n-\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Renaming directory to itself is disallowed. src\u003d\" + src\n-              + \" dest\u003d\" + dst);\n-        }\n-        return false;\n-      }\n-    }\n-\n-    // file rename early checks\n-    if (!srcMetadata.isDir()) {\n-      if (srcKey.equals(dstKey)) {\n-        // rename file to self is OK\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Renaming file to itself. This is allowed and is treated as no-op. path\u003d\"\n-              + src);\n-        }\n-        return true;\n-      }\n-    }\n-\n-    // More validations..\n-    // If target is dir but target already exists, alter the dst to be a\n-    // subfolder.\n-    // eg move(\"/a/file.txt\", \"/b\") where \"/b\" already exists causes the target\n-    // to be \"/c/file.txt\n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n+      // It\u0027s an existing directory.\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n-      // Best would be to update dstMetadata, but it is not used further, so set\n-      // it to null and skip the additional cost\n-      dstMetadata \u003d null;\n-      // dstMetadata \u003d store.retrieveMetadata(dstKey);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Destination \" + dst\n             + \" is a directory, adjusted the destination to be \" + dstKey);\n       }\n-\n-      // rename dir to self is an error\n-      if (srcKey.equals(dstKey)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n-        }\n-        return false;\n-      }\n-\n     } else if (dstMetadata !\u003d null) {\n-      // Otherwise, attempting to overwrite a file is error\n+      // Attempting to overwrite a file using rename()\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Destination \" + dst\n             + \" is an already existing file, failing the rename.\");\n       }\n       return false;\n     } else {\n-      // Either dir or file and target doesn\u0027t exist.. Check that the parent\n-      // directory exists.\n-      FileMetadata parentOfDestMetadata \u003d store\n-          .retrieveMetadata(pathToKey(absoluteDst.getParent()));\n+      // Check that the parent directory exists.\n+      FileMetadata parentOfDestMetadata \u003d\n+          store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n       if (parentOfDestMetadata \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Parent of the destination \" + dst\n               + \" doesn\u0027t exist, failing the rename.\");\n         }\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Parent of the destination \" + dst\n               + \" is a file, failing the rename.\");\n         }\n         return false;\n       }\n     }\n-\n-    // Validations complete, do the move.\n-    if (!srcMetadata.isDir()) {\n+    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n+    if (srcMetadata \u003d\u003d null) {\n+      // Source doesn\u0027t exist\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n+      }\n+      return false;\n+    } else if (!srcMetadata.isDir()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Source \" + src + \" found as a file, renaming.\");\n       }\n       store.rename(srcKey, dstKey);\n     } else {\n-      // Move everything inside the folder.\n-      String priorLastKey \u003d null;\n \n-      // Calculate the index of the part of the string to be moved. That\n-      // is everything on the path up to the folder name.\n-      do {\n-        // List all blobs rooted at the source folder.\n-        PartialListing listing \u003d store.listAll(srcKey, AZURE_LIST_ALL,\n-            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n+      // Prepare for, execute and clean up after of all files in folder, and\n+      // the root file, and update the last modified time of the source and\n+      // target parent folders. The operation can be redone if it fails part\n+      // way through, by applying the \"Rename Pending\" file.\n \n-        // Rename all the files in the folder.\n-        for (FileMetadata file : listing.getFiles()) {\n-          // Rename all materialized entries under the folder to point to the\n-          // final destination.\n-          if (file.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n-            String srcName \u003d file.getKey();\n-            String suffix \u003d srcName.substring(srcKey.length());\n-            String dstName \u003d dstKey + suffix;\n-            store.rename(srcName, dstName);\n-          }\n-        }\n-        priorLastKey \u003d listing.getPriorLastKey();\n-      } while (priorLastKey !\u003d null);\n-      // Rename the top level empty blob for the folder.\n-      if (srcMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n-        store.rename(srcKey, dstKey);\n+      // The following code (internally) only does atomic rename preparation\n+      // and lease management for page blob folders, limiting the scope of the\n+      // operation to HBase log file folders, where atomic rename is required.\n+      // In the future, we could generalize it easily to all folders.\n+      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n+      renamePending.execute();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n       }\n+      renamePending.cleanup();\n+      return true;\n     }\n \n-    // Update both source and destination parent folder last modified time.\n-    Path srcParent \u003d makeAbsolute(keyToPath(srcKey)).getParent();\n-    if (srcParent !\u003d null \u0026\u0026 srcParent.getParent() !\u003d null) { // not root\n-      String srcParentKey \u003d pathToKey(srcParent);\n-\n-      // ensure the srcParent is a materialized folder\n-      FileMetadata srcParentMetadata \u003d store.retrieveMetadata(srcParentKey);\n-      if (srcParentMetadata.isDir()\n-          \u0026\u0026 srcParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-        store.storeEmptyFolder(srcParentKey,\n-            createPermissionStatus(FsPermission.getDefault()));\n-      }\n-\n-      store.updateFolderLastModifiedTime(srcParentKey);\n-    }\n-\n-    Path destParent \u003d makeAbsolute(keyToPath(dstKey)).getParent();\n-    if (destParent !\u003d null \u0026\u0026 destParent.getParent() !\u003d null) { // not root\n-      String dstParentKey \u003d pathToKey(destParent);\n-\n-      // ensure the dstParent is a materialized folder\n-      FileMetadata dstParentMetadata \u003d store.retrieveMetadata(dstParentKey);\n-      if (dstParentMetadata.isDir()\n-          \u0026\u0026 dstParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-        store.storeEmptyFolder(dstParentKey,\n-            createPermissionStatus(FsPermission.getDefault()));\n-      }\n-\n-      store.updateFolderLastModifiedTime(dstParentKey);\n-    }\n+    // Update the last-modified time of the parent folders of both source\n+    // and destination.\n+    updateParentFolderLastModifiedTime(srcKey);\n+    updateParentFolderLastModifiedTime(dstKey);\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n\n    FolderRenamePending renamePending \u003d null;\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Moving \" + src + \" to \" + dst);\n    }\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      // It\u0027s an existing directory.\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Destination \" + dst\n            + \" is a directory, adjusted the destination to be \" + dstKey);\n      }\n    } else if (dstMetadata !\u003d null) {\n      // Attempting to overwrite a file using rename()\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Destination \" + dst\n            + \" is an already existing file, failing the rename.\");\n      }\n      return false;\n    } else {\n      // Check that the parent directory exists.\n      FileMetadata parentOfDestMetadata \u003d\n          store.retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      if (parentOfDestMetadata \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent of the destination \" + dst\n              + \" doesn\u0027t exist, failing the rename.\");\n        }\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent of the destination \" + dst\n              + \" is a file, failing the rename.\");\n        }\n        return false;\n      }\n    }\n    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n      }\n      return false;\n    } else if (!srcMetadata.isDir()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Source \" + src + \" found as a file, renaming.\");\n      }\n      store.rename(srcKey, dstKey);\n    } else {\n\n      // Prepare for, execute and clean up after of all files in folder, and\n      // the root file, and update the last modified time of the source and\n      // target parent folders. The operation can be redone if it fails part\n      // way through, by applying the \"Rename Pending\" file.\n\n      // The following code (internally) only does atomic rename preparation\n      // and lease management for page blob folders, limiting the scope of the\n      // operation to HBase log file folders, where atomic rename is required.\n      // In the future, we could generalize it easily to all folders.\n      renamePending \u003d prepareAtomicFolderRename(srcKey, dstKey);\n      renamePending.execute();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n      }\n      renamePending.cleanup();\n      return true;\n    }\n\n    // Update the last-modified time of the parent folders of both source\n    // and destination.\n    updateParentFolderLastModifiedTime(srcKey);\n    updateParentFolderLastModifiedTime(dstKey);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10946. Fix a bunch of typos in log messages (Ray Chiang via aw)\n",
      "commitDate": "19/09/14 11:33 AM",
      "commitName": "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "16/07/14 10:04 PM",
      "commitNameOld": "0a02b5a19bcca8d0c49d2adfc3909aebdf9d606e",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 64.56,
      "commitsBetweenForRepo": 614,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,190 +1,190 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Moving \" + src + \" to \" + dst);\n     }\n \n     if (containsColon(dst)) {\n       throw new IOException(\"Cannot rename to file \" + dst\n           + \" through WASB that has colons in the name\");\n     }\n \n     String srcKey \u003d pathToKey(makeAbsolute(src));\n \n     if (srcKey.length() \u003d\u003d 0) {\n       // Cannot rename root of file system\n       return false;\n     }\n \n     FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n     if (srcMetadata \u003d\u003d null) {\n       // Source doesn\u0027t exist\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n       }\n       return false;\n     }\n \n     // Figure out the final destination\n     Path absoluteDst \u003d makeAbsolute(dst);\n     String dstKey \u003d pathToKey(absoluteDst);\n     FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n \n     // directory rename validations\n     if (srcMetadata.isDir()) {\n \n       // rename dir to self is an error\n       if (srcKey.equals(dstKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n         }\n         return false;\n       }\n \n       // rename dir to (sub-)child of self is an error. see\n       // FileSystemContractBaseTest.testRenameChildDirForbidden\n       if (dstKey.startsWith(srcKey + PATH_DELIMITER)) {\n \n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Renaming directory to a itself is disallowed. src\u003d\" + src\n+          LOG.debug(\"Renaming directory to itself is disallowed. src\u003d\" + src\n               + \" dest\u003d\" + dst);\n         }\n         return false;\n       }\n     }\n \n     // file rename early checks\n     if (!srcMetadata.isDir()) {\n       if (srcKey.equals(dstKey)) {\n         // rename file to self is OK\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Renaming file to itself. This is allowed and is treated as no-op. path\u003d\"\n               + src);\n         }\n         return true;\n       }\n     }\n \n     // More validations..\n     // If target is dir but target already exists, alter the dst to be a\n     // subfolder.\n     // eg move(\"/a/file.txt\", \"/b\") where \"/b\" already exists causes the target\n     // to be \"/c/file.txt\n     if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n       dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n       // Best would be to update dstMetadata, but it is not used further, so set\n       // it to null and skip the additional cost\n       dstMetadata \u003d null;\n       // dstMetadata \u003d store.retrieveMetadata(dstKey);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Destination \" + dst\n             + \" is a directory, adjusted the destination to be \" + dstKey);\n       }\n \n       // rename dir to self is an error\n       if (srcKey.equals(dstKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n         }\n         return false;\n       }\n \n     } else if (dstMetadata !\u003d null) {\n       // Otherwise, attempting to overwrite a file is error\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Destination \" + dst\n             + \" is an already existing file, failing the rename.\");\n       }\n       return false;\n     } else {\n       // Either dir or file and target doesn\u0027t exist.. Check that the parent\n       // directory exists.\n       FileMetadata parentOfDestMetadata \u003d store\n           .retrieveMetadata(pathToKey(absoluteDst.getParent()));\n       if (parentOfDestMetadata \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Parent of the destination \" + dst\n               + \" doesn\u0027t exist, failing the rename.\");\n         }\n         return false;\n       } else if (!parentOfDestMetadata.isDir()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Parent of the destination \" + dst\n               + \" is a file, failing the rename.\");\n         }\n         return false;\n       }\n     }\n \n     // Validations complete, do the move.\n     if (!srcMetadata.isDir()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Source \" + src + \" found as a file, renaming.\");\n       }\n       store.rename(srcKey, dstKey);\n     } else {\n       // Move everything inside the folder.\n       String priorLastKey \u003d null;\n \n       // Calculate the index of the part of the string to be moved. That\n       // is everything on the path up to the folder name.\n       do {\n         // List all blobs rooted at the source folder.\n         PartialListing listing \u003d store.listAll(srcKey, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n \n         // Rename all the files in the folder.\n         for (FileMetadata file : listing.getFiles()) {\n           // Rename all materialized entries under the folder to point to the\n           // final destination.\n           if (file.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n             String srcName \u003d file.getKey();\n             String suffix \u003d srcName.substring(srcKey.length());\n             String dstName \u003d dstKey + suffix;\n             store.rename(srcName, dstName);\n           }\n         }\n         priorLastKey \u003d listing.getPriorLastKey();\n       } while (priorLastKey !\u003d null);\n       // Rename the top level empty blob for the folder.\n       if (srcMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         store.rename(srcKey, dstKey);\n       }\n     }\n \n     // Update both source and destination parent folder last modified time.\n     Path srcParent \u003d makeAbsolute(keyToPath(srcKey)).getParent();\n     if (srcParent !\u003d null \u0026\u0026 srcParent.getParent() !\u003d null) { // not root\n       String srcParentKey \u003d pathToKey(srcParent);\n \n       // ensure the srcParent is a materialized folder\n       FileMetadata srcParentMetadata \u003d store.retrieveMetadata(srcParentKey);\n       if (srcParentMetadata.isDir()\n           \u0026\u0026 srcParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n         store.storeEmptyFolder(srcParentKey,\n             createPermissionStatus(FsPermission.getDefault()));\n       }\n \n       store.updateFolderLastModifiedTime(srcParentKey);\n     }\n \n     Path destParent \u003d makeAbsolute(keyToPath(dstKey)).getParent();\n     if (destParent !\u003d null \u0026\u0026 destParent.getParent() !\u003d null) { // not root\n       String dstParentKey \u003d pathToKey(destParent);\n \n       // ensure the dstParent is a materialized folder\n       FileMetadata dstParentMetadata \u003d store.retrieveMetadata(dstParentKey);\n       if (dstParentMetadata.isDir()\n           \u0026\u0026 dstParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n         store.storeEmptyFolder(dstParentKey,\n             createPermissionStatus(FsPermission.getDefault()));\n       }\n \n       store.updateFolderLastModifiedTime(dstParentKey);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Moving \" + src + \" to \" + dst);\n    }\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n      }\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n\n    // directory rename validations\n    if (srcMetadata.isDir()) {\n\n      // rename dir to self is an error\n      if (srcKey.equals(dstKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n        }\n        return false;\n      }\n\n      // rename dir to (sub-)child of self is an error. see\n      // FileSystemContractBaseTest.testRenameChildDirForbidden\n      if (dstKey.startsWith(srcKey + PATH_DELIMITER)) {\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming directory to itself is disallowed. src\u003d\" + src\n              + \" dest\u003d\" + dst);\n        }\n        return false;\n      }\n    }\n\n    // file rename early checks\n    if (!srcMetadata.isDir()) {\n      if (srcKey.equals(dstKey)) {\n        // rename file to self is OK\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming file to itself. This is allowed and is treated as no-op. path\u003d\"\n              + src);\n        }\n        return true;\n      }\n    }\n\n    // More validations..\n    // If target is dir but target already exists, alter the dst to be a\n    // subfolder.\n    // eg move(\"/a/file.txt\", \"/b\") where \"/b\" already exists causes the target\n    // to be \"/c/file.txt\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      // Best would be to update dstMetadata, but it is not used further, so set\n      // it to null and skip the additional cost\n      dstMetadata \u003d null;\n      // dstMetadata \u003d store.retrieveMetadata(dstKey);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Destination \" + dst\n            + \" is a directory, adjusted the destination to be \" + dstKey);\n      }\n\n      // rename dir to self is an error\n      if (srcKey.equals(dstKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n        }\n        return false;\n      }\n\n    } else if (dstMetadata !\u003d null) {\n      // Otherwise, attempting to overwrite a file is error\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Destination \" + dst\n            + \" is an already existing file, failing the rename.\");\n      }\n      return false;\n    } else {\n      // Either dir or file and target doesn\u0027t exist.. Check that the parent\n      // directory exists.\n      FileMetadata parentOfDestMetadata \u003d store\n          .retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      if (parentOfDestMetadata \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent of the destination \" + dst\n              + \" doesn\u0027t exist, failing the rename.\");\n        }\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent of the destination \" + dst\n              + \" is a file, failing the rename.\");\n        }\n        return false;\n      }\n    }\n\n    // Validations complete, do the move.\n    if (!srcMetadata.isDir()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Source \" + src + \" found as a file, renaming.\");\n      }\n      store.rename(srcKey, dstKey);\n    } else {\n      // Move everything inside the folder.\n      String priorLastKey \u003d null;\n\n      // Calculate the index of the part of the string to be moved. That\n      // is everything on the path up to the folder name.\n      do {\n        // List all blobs rooted at the source folder.\n        PartialListing listing \u003d store.listAll(srcKey, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n\n        // Rename all the files in the folder.\n        for (FileMetadata file : listing.getFiles()) {\n          // Rename all materialized entries under the folder to point to the\n          // final destination.\n          if (file.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n            String srcName \u003d file.getKey();\n            String suffix \u003d srcName.substring(srcKey.length());\n            String dstName \u003d dstKey + suffix;\n            store.rename(srcName, dstName);\n          }\n        }\n        priorLastKey \u003d listing.getPriorLastKey();\n      } while (priorLastKey !\u003d null);\n      // Rename the top level empty blob for the folder.\n      if (srcMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        store.rename(srcKey, dstKey);\n      }\n    }\n\n    // Update both source and destination parent folder last modified time.\n    Path srcParent \u003d makeAbsolute(keyToPath(srcKey)).getParent();\n    if (srcParent !\u003d null \u0026\u0026 srcParent.getParent() !\u003d null) { // not root\n      String srcParentKey \u003d pathToKey(srcParent);\n\n      // ensure the srcParent is a materialized folder\n      FileMetadata srcParentMetadata \u003d store.retrieveMetadata(srcParentKey);\n      if (srcParentMetadata.isDir()\n          \u0026\u0026 srcParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n        store.storeEmptyFolder(srcParentKey,\n            createPermissionStatus(FsPermission.getDefault()));\n      }\n\n      store.updateFolderLastModifiedTime(srcParentKey);\n    }\n\n    Path destParent \u003d makeAbsolute(keyToPath(dstKey)).getParent();\n    if (destParent !\u003d null \u0026\u0026 destParent.getParent() !\u003d null) { // not root\n      String dstParentKey \u003d pathToKey(destParent);\n\n      // ensure the dstParent is a materialized folder\n      FileMetadata dstParentMetadata \u003d store.retrieveMetadata(dstParentKey);\n      if (dstParentMetadata.isDir()\n          \u0026\u0026 dstParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n        store.storeEmptyFolder(dstParentKey,\n            createPermissionStatus(FsPermission.getDefault()));\n      }\n\n      store.updateFolderLastModifiedTime(dstParentKey);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,190 @@\n+  public boolean rename(Path src, Path dst) throws IOException {\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Moving \" + src + \" to \" + dst);\n+    }\n+\n+    if (containsColon(dst)) {\n+      throw new IOException(\"Cannot rename to file \" + dst\n+          + \" through WASB that has colons in the name\");\n+    }\n+\n+    String srcKey \u003d pathToKey(makeAbsolute(src));\n+\n+    if (srcKey.length() \u003d\u003d 0) {\n+      // Cannot rename root of file system\n+      return false;\n+    }\n+\n+    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n+    if (srcMetadata \u003d\u003d null) {\n+      // Source doesn\u0027t exist\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n+      }\n+      return false;\n+    }\n+\n+    // Figure out the final destination\n+    Path absoluteDst \u003d makeAbsolute(dst);\n+    String dstKey \u003d pathToKey(absoluteDst);\n+    FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n+\n+    // directory rename validations\n+    if (srcMetadata.isDir()) {\n+\n+      // rename dir to self is an error\n+      if (srcKey.equals(dstKey)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n+        }\n+        return false;\n+      }\n+\n+      // rename dir to (sub-)child of self is an error. see\n+      // FileSystemContractBaseTest.testRenameChildDirForbidden\n+      if (dstKey.startsWith(srcKey + PATH_DELIMITER)) {\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Renaming directory to a itself is disallowed. src\u003d\" + src\n+              + \" dest\u003d\" + dst);\n+        }\n+        return false;\n+      }\n+    }\n+\n+    // file rename early checks\n+    if (!srcMetadata.isDir()) {\n+      if (srcKey.equals(dstKey)) {\n+        // rename file to self is OK\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Renaming file to itself. This is allowed and is treated as no-op. path\u003d\"\n+              + src);\n+        }\n+        return true;\n+      }\n+    }\n+\n+    // More validations..\n+    // If target is dir but target already exists, alter the dst to be a\n+    // subfolder.\n+    // eg move(\"/a/file.txt\", \"/b\") where \"/b\" already exists causes the target\n+    // to be \"/c/file.txt\n+    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n+      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n+      // Best would be to update dstMetadata, but it is not used further, so set\n+      // it to null and skip the additional cost\n+      dstMetadata \u003d null;\n+      // dstMetadata \u003d store.retrieveMetadata(dstKey);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Destination \" + dst\n+            + \" is a directory, adjusted the destination to be \" + dstKey);\n+      }\n+\n+      // rename dir to self is an error\n+      if (srcKey.equals(dstKey)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n+        }\n+        return false;\n+      }\n+\n+    } else if (dstMetadata !\u003d null) {\n+      // Otherwise, attempting to overwrite a file is error\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Destination \" + dst\n+            + \" is an already existing file, failing the rename.\");\n+      }\n+      return false;\n+    } else {\n+      // Either dir or file and target doesn\u0027t exist.. Check that the parent\n+      // directory exists.\n+      FileMetadata parentOfDestMetadata \u003d store\n+          .retrieveMetadata(pathToKey(absoluteDst.getParent()));\n+      if (parentOfDestMetadata \u003d\u003d null) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Parent of the destination \" + dst\n+              + \" doesn\u0027t exist, failing the rename.\");\n+        }\n+        return false;\n+      } else if (!parentOfDestMetadata.isDir()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Parent of the destination \" + dst\n+              + \" is a file, failing the rename.\");\n+        }\n+        return false;\n+      }\n+    }\n+\n+    // Validations complete, do the move.\n+    if (!srcMetadata.isDir()) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Source \" + src + \" found as a file, renaming.\");\n+      }\n+      store.rename(srcKey, dstKey);\n+    } else {\n+      // Move everything inside the folder.\n+      String priorLastKey \u003d null;\n+\n+      // Calculate the index of the part of the string to be moved. That\n+      // is everything on the path up to the folder name.\n+      do {\n+        // List all blobs rooted at the source folder.\n+        PartialListing listing \u003d store.listAll(srcKey, AZURE_LIST_ALL,\n+            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n+\n+        // Rename all the files in the folder.\n+        for (FileMetadata file : listing.getFiles()) {\n+          // Rename all materialized entries under the folder to point to the\n+          // final destination.\n+          if (file.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n+            String srcName \u003d file.getKey();\n+            String suffix \u003d srcName.substring(srcKey.length());\n+            String dstName \u003d dstKey + suffix;\n+            store.rename(srcName, dstName);\n+          }\n+        }\n+        priorLastKey \u003d listing.getPriorLastKey();\n+      } while (priorLastKey !\u003d null);\n+      // Rename the top level empty blob for the folder.\n+      if (srcMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n+        store.rename(srcKey, dstKey);\n+      }\n+    }\n+\n+    // Update both source and destination parent folder last modified time.\n+    Path srcParent \u003d makeAbsolute(keyToPath(srcKey)).getParent();\n+    if (srcParent !\u003d null \u0026\u0026 srcParent.getParent() !\u003d null) { // not root\n+      String srcParentKey \u003d pathToKey(srcParent);\n+\n+      // ensure the srcParent is a materialized folder\n+      FileMetadata srcParentMetadata \u003d store.retrieveMetadata(srcParentKey);\n+      if (srcParentMetadata.isDir()\n+          \u0026\u0026 srcParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+        store.storeEmptyFolder(srcParentKey,\n+            createPermissionStatus(FsPermission.getDefault()));\n+      }\n+\n+      store.updateFolderLastModifiedTime(srcParentKey);\n+    }\n+\n+    Path destParent \u003d makeAbsolute(keyToPath(dstKey)).getParent();\n+    if (destParent !\u003d null \u0026\u0026 destParent.getParent() !\u003d null) { // not root\n+      String dstParentKey \u003d pathToKey(destParent);\n+\n+      // ensure the dstParent is a materialized folder\n+      FileMetadata dstParentMetadata \u003d store.retrieveMetadata(dstParentKey);\n+      if (dstParentMetadata.isDir()\n+          \u0026\u0026 dstParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+        store.storeEmptyFolder(dstParentKey,\n+            createPermissionStatus(FsPermission.getDefault()));\n+      }\n+\n+      store.updateFolderLastModifiedTime(dstParentKey);\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n+    }\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Moving \" + src + \" to \" + dst);\n    }\n\n    if (containsColon(dst)) {\n      throw new IOException(\"Cannot rename to file \" + dst\n          + \" through WASB that has colons in the name\");\n    }\n\n    String srcKey \u003d pathToKey(makeAbsolute(src));\n\n    if (srcKey.length() \u003d\u003d 0) {\n      // Cannot rename root of file system\n      return false;\n    }\n\n    FileMetadata srcMetadata \u003d store.retrieveMetadata(srcKey);\n    if (srcMetadata \u003d\u003d null) {\n      // Source doesn\u0027t exist\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Source \" + src + \" doesn\u0027t exist, failing the rename.\");\n      }\n      return false;\n    }\n\n    // Figure out the final destination\n    Path absoluteDst \u003d makeAbsolute(dst);\n    String dstKey \u003d pathToKey(absoluteDst);\n    FileMetadata dstMetadata \u003d store.retrieveMetadata(dstKey);\n\n    // directory rename validations\n    if (srcMetadata.isDir()) {\n\n      // rename dir to self is an error\n      if (srcKey.equals(dstKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n        }\n        return false;\n      }\n\n      // rename dir to (sub-)child of self is an error. see\n      // FileSystemContractBaseTest.testRenameChildDirForbidden\n      if (dstKey.startsWith(srcKey + PATH_DELIMITER)) {\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming directory to a itself is disallowed. src\u003d\" + src\n              + \" dest\u003d\" + dst);\n        }\n        return false;\n      }\n    }\n\n    // file rename early checks\n    if (!srcMetadata.isDir()) {\n      if (srcKey.equals(dstKey)) {\n        // rename file to self is OK\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming file to itself. This is allowed and is treated as no-op. path\u003d\"\n              + src);\n        }\n        return true;\n      }\n    }\n\n    // More validations..\n    // If target is dir but target already exists, alter the dst to be a\n    // subfolder.\n    // eg move(\"/a/file.txt\", \"/b\") where \"/b\" already exists causes the target\n    // to be \"/c/file.txt\n    if (dstMetadata !\u003d null \u0026\u0026 dstMetadata.isDir()) {\n      dstKey \u003d pathToKey(makeAbsolute(new Path(dst, src.getName())));\n      // Best would be to update dstMetadata, but it is not used further, so set\n      // it to null and skip the additional cost\n      dstMetadata \u003d null;\n      // dstMetadata \u003d store.retrieveMetadata(dstKey);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Destination \" + dst\n            + \" is a directory, adjusted the destination to be \" + dstKey);\n      }\n\n      // rename dir to self is an error\n      if (srcKey.equals(dstKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renaming directory to itself is disallowed. path\u003d\" + src);\n        }\n        return false;\n      }\n\n    } else if (dstMetadata !\u003d null) {\n      // Otherwise, attempting to overwrite a file is error\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Destination \" + dst\n            + \" is an already existing file, failing the rename.\");\n      }\n      return false;\n    } else {\n      // Either dir or file and target doesn\u0027t exist.. Check that the parent\n      // directory exists.\n      FileMetadata parentOfDestMetadata \u003d store\n          .retrieveMetadata(pathToKey(absoluteDst.getParent()));\n      if (parentOfDestMetadata \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent of the destination \" + dst\n              + \" doesn\u0027t exist, failing the rename.\");\n        }\n        return false;\n      } else if (!parentOfDestMetadata.isDir()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent of the destination \" + dst\n              + \" is a file, failing the rename.\");\n        }\n        return false;\n      }\n    }\n\n    // Validations complete, do the move.\n    if (!srcMetadata.isDir()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Source \" + src + \" found as a file, renaming.\");\n      }\n      store.rename(srcKey, dstKey);\n    } else {\n      // Move everything inside the folder.\n      String priorLastKey \u003d null;\n\n      // Calculate the index of the part of the string to be moved. That\n      // is everything on the path up to the folder name.\n      do {\n        // List all blobs rooted at the source folder.\n        PartialListing listing \u003d store.listAll(srcKey, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n\n        // Rename all the files in the folder.\n        for (FileMetadata file : listing.getFiles()) {\n          // Rename all materialized entries under the folder to point to the\n          // final destination.\n          if (file.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n            String srcName \u003d file.getKey();\n            String suffix \u003d srcName.substring(srcKey.length());\n            String dstName \u003d dstKey + suffix;\n            store.rename(srcName, dstName);\n          }\n        }\n        priorLastKey \u003d listing.getPriorLastKey();\n      } while (priorLastKey !\u003d null);\n      // Rename the top level empty blob for the folder.\n      if (srcMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        store.rename(srcKey, dstKey);\n      }\n    }\n\n    // Update both source and destination parent folder last modified time.\n    Path srcParent \u003d makeAbsolute(keyToPath(srcKey)).getParent();\n    if (srcParent !\u003d null \u0026\u0026 srcParent.getParent() !\u003d null) { // not root\n      String srcParentKey \u003d pathToKey(srcParent);\n\n      // ensure the srcParent is a materialized folder\n      FileMetadata srcParentMetadata \u003d store.retrieveMetadata(srcParentKey);\n      if (srcParentMetadata.isDir()\n          \u0026\u0026 srcParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n        store.storeEmptyFolder(srcParentKey,\n            createPermissionStatus(FsPermission.getDefault()));\n      }\n\n      store.updateFolderLastModifiedTime(srcParentKey);\n    }\n\n    Path destParent \u003d makeAbsolute(keyToPath(dstKey)).getParent();\n    if (destParent !\u003d null \u0026\u0026 destParent.getParent() !\u003d null) { // not root\n      String dstParentKey \u003d pathToKey(destParent);\n\n      // ensure the dstParent is a materialized folder\n      FileMetadata dstParentMetadata \u003d store.retrieveMetadata(dstParentKey);\n      if (dstParentMetadata.isDir()\n          \u0026\u0026 dstParentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n        store.storeEmptyFolder(dstParentKey,\n            createPermissionStatus(FsPermission.getDefault()));\n      }\n\n      store.updateFolderLastModifiedTime(dstParentKey);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Renamed \" + src + \" to \" + dst + \" successfully.\");\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}