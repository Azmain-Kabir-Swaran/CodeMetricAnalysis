{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KeyFieldHelper.java",
  "functionName": "parseKey",
  "functionId": "parseKey___arg-String__args-StringTokenizer",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java",
  "functionStartLine": 196,
  "functionEndLine": 286,
  "numCommitsSeen": 3,
  "timeTaken": 4218,
  "changeHistory": [
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private KeyDescription parseKey(String arg, StringTokenizer args) {\n    //we allow for -k\u003carg\u003e and -k \u003carg\u003e\n    String keyArgs \u003d null;\n    if (arg.length() \u003d\u003d 2) {\n      if (args.hasMoreTokens()) {\n        keyArgs \u003d args.nextToken();\n      }\n    } else {\n      keyArgs \u003d arg.substring(2);\n    }\n    if (keyArgs \u003d\u003d null || keyArgs.length() \u003d\u003d 0) {\n      return null;\n    }\n    StringTokenizer st \u003d new StringTokenizer(keyArgs,\"nr.,\",true);\n       \n    KeyDescription key \u003d new KeyDescription();\n    \n    String token;\n    //the key is of the form 1[.3][nr][,1.5][nr]\n    if (st.hasMoreTokens()) {\n      token \u003d st.nextToken();\n      //the first token must be a number\n      key.beginFieldIdx \u003d Integer.parseInt(token);\n    }\n    if (st.hasMoreTokens()) {\n      token \u003d st.nextToken();\n      if (token.equals(\".\")) {\n        token \u003d st.nextToken();\n        key.beginChar \u003d Integer.parseInt(token);\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n        } else {\n          return key;\n        }\n      } \n      do {\n        if (token.equals(\"n\")) {\n          key.numeric \u003d true;\n        }\n        else if (token.equals(\"r\")) {\n          key.reverse \u003d true;\n        }\n        else break;\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n        } else {\n          return key;\n        }\n      } while (true);\n      if (token.equals(\",\")) {\n        token \u003d st.nextToken();\n        //the first token must be a number\n        key.endFieldIdx \u003d Integer.parseInt(token);\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n          if (token.equals(\".\")) {\n            token \u003d st.nextToken();\n            key.endChar \u003d Integer.parseInt(token);\n            if (st.hasMoreTokens()) {\n              token \u003d st.nextToken();\n            } else {\n              return key;\n            }\n          }\n          do {\n            if (token.equals(\"n\")) {\n              key.numeric \u003d true;\n            }\n            else if (token.equals(\"r\")) {\n              key.reverse \u003d true;\n            }\n            else { \n              throw new IllegalArgumentException(\"Invalid -k argument. \" +\n               \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n               \"f[.c]nr\");\n            }\n            if (st.hasMoreTokens()) {\n              token \u003d st.nextToken();\n            } else {\n              break;\n            }\n          } while (true);\n        }\n        return key;\n      }\n      throw new IllegalArgumentException(\"Invalid -k argument. \" +\n          \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n          \"f[.c]nr\");\n    }\n    return key;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yfilerename",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/08/11 8:02 PM",
      "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private KeyDescription parseKey(String arg, StringTokenizer args) {\n    //we allow for -k\u003carg\u003e and -k \u003carg\u003e\n    String keyArgs \u003d null;\n    if (arg.length() \u003d\u003d 2) {\n      if (args.hasMoreTokens()) {\n        keyArgs \u003d args.nextToken();\n      }\n    } else {\n      keyArgs \u003d arg.substring(2);\n    }\n    if (keyArgs \u003d\u003d null || keyArgs.length() \u003d\u003d 0) {\n      return null;\n    }\n    StringTokenizer st \u003d new StringTokenizer(keyArgs,\"nr.,\",true);\n       \n    KeyDescription key \u003d new KeyDescription();\n    \n    String token;\n    //the key is of the form 1[.3][nr][,1.5][nr]\n    if (st.hasMoreTokens()) {\n      token \u003d st.nextToken();\n      //the first token must be a number\n      key.beginFieldIdx \u003d Integer.parseInt(token);\n    }\n    if (st.hasMoreTokens()) {\n      token \u003d st.nextToken();\n      if (token.equals(\".\")) {\n        token \u003d st.nextToken();\n        key.beginChar \u003d Integer.parseInt(token);\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n        } else {\n          return key;\n        }\n      } \n      do {\n        if (token.equals(\"n\")) {\n          key.numeric \u003d true;\n        }\n        else if (token.equals(\"r\")) {\n          key.reverse \u003d true;\n        }\n        else break;\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n        } else {\n          return key;\n        }\n      } while (true);\n      if (token.equals(\",\")) {\n        token \u003d st.nextToken();\n        //the first token must be a number\n        key.endFieldIdx \u003d Integer.parseInt(token);\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n          if (token.equals(\".\")) {\n            token \u003d st.nextToken();\n            key.endChar \u003d Integer.parseInt(token);\n            if (st.hasMoreTokens()) {\n              token \u003d st.nextToken();\n            } else {\n              return key;\n            }\n          }\n          do {\n            if (token.equals(\"n\")) {\n              key.numeric \u003d true;\n            }\n            else if (token.equals(\"r\")) {\n              key.reverse \u003d true;\n            }\n            else { \n              throw new IllegalArgumentException(\"Invalid -k argument. \" +\n               \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n               \"f[.c]nr\");\n            }\n            if (st.hasMoreTokens()) {\n              token \u003d st.nextToken();\n            } else {\n              break;\n            }\n          } while (true);\n        }\n        return key;\n      }\n      throw new IllegalArgumentException(\"Invalid -k argument. \" +\n          \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n          \"f[.c]nr\");\n    }\n    return key;\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java",
      "extendedDetails": {
        "oldPath": "mapreduce/src/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java",
        "newPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,91 @@\n+  private KeyDescription parseKey(String arg, StringTokenizer args) {\n+    //we allow for -k\u003carg\u003e and -k \u003carg\u003e\n+    String keyArgs \u003d null;\n+    if (arg.length() \u003d\u003d 2) {\n+      if (args.hasMoreTokens()) {\n+        keyArgs \u003d args.nextToken();\n+      }\n+    } else {\n+      keyArgs \u003d arg.substring(2);\n+    }\n+    if (keyArgs \u003d\u003d null || keyArgs.length() \u003d\u003d 0) {\n+      return null;\n+    }\n+    StringTokenizer st \u003d new StringTokenizer(keyArgs,\"nr.,\",true);\n+       \n+    KeyDescription key \u003d new KeyDescription();\n+    \n+    String token;\n+    //the key is of the form 1[.3][nr][,1.5][nr]\n+    if (st.hasMoreTokens()) {\n+      token \u003d st.nextToken();\n+      //the first token must be a number\n+      key.beginFieldIdx \u003d Integer.parseInt(token);\n+    }\n+    if (st.hasMoreTokens()) {\n+      token \u003d st.nextToken();\n+      if (token.equals(\".\")) {\n+        token \u003d st.nextToken();\n+        key.beginChar \u003d Integer.parseInt(token);\n+        if (st.hasMoreTokens()) {\n+          token \u003d st.nextToken();\n+        } else {\n+          return key;\n+        }\n+      } \n+      do {\n+        if (token.equals(\"n\")) {\n+          key.numeric \u003d true;\n+        }\n+        else if (token.equals(\"r\")) {\n+          key.reverse \u003d true;\n+        }\n+        else break;\n+        if (st.hasMoreTokens()) {\n+          token \u003d st.nextToken();\n+        } else {\n+          return key;\n+        }\n+      } while (true);\n+      if (token.equals(\",\")) {\n+        token \u003d st.nextToken();\n+        //the first token must be a number\n+        key.endFieldIdx \u003d Integer.parseInt(token);\n+        if (st.hasMoreTokens()) {\n+          token \u003d st.nextToken();\n+          if (token.equals(\".\")) {\n+            token \u003d st.nextToken();\n+            key.endChar \u003d Integer.parseInt(token);\n+            if (st.hasMoreTokens()) {\n+              token \u003d st.nextToken();\n+            } else {\n+              return key;\n+            }\n+          }\n+          do {\n+            if (token.equals(\"n\")) {\n+              key.numeric \u003d true;\n+            }\n+            else if (token.equals(\"r\")) {\n+              key.reverse \u003d true;\n+            }\n+            else { \n+              throw new IllegalArgumentException(\"Invalid -k argument. \" +\n+               \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n+               \"f[.c]nr\");\n+            }\n+            if (st.hasMoreTokens()) {\n+              token \u003d st.nextToken();\n+            } else {\n+              break;\n+            }\n+          } while (true);\n+        }\n+        return key;\n+      }\n+      throw new IllegalArgumentException(\"Invalid -k argument. \" +\n+          \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n+          \"f[.c]nr\");\n+    }\n+    return key;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private KeyDescription parseKey(String arg, StringTokenizer args) {\n    //we allow for -k\u003carg\u003e and -k \u003carg\u003e\n    String keyArgs \u003d null;\n    if (arg.length() \u003d\u003d 2) {\n      if (args.hasMoreTokens()) {\n        keyArgs \u003d args.nextToken();\n      }\n    } else {\n      keyArgs \u003d arg.substring(2);\n    }\n    if (keyArgs \u003d\u003d null || keyArgs.length() \u003d\u003d 0) {\n      return null;\n    }\n    StringTokenizer st \u003d new StringTokenizer(keyArgs,\"nr.,\",true);\n       \n    KeyDescription key \u003d new KeyDescription();\n    \n    String token;\n    //the key is of the form 1[.3][nr][,1.5][nr]\n    if (st.hasMoreTokens()) {\n      token \u003d st.nextToken();\n      //the first token must be a number\n      key.beginFieldIdx \u003d Integer.parseInt(token);\n    }\n    if (st.hasMoreTokens()) {\n      token \u003d st.nextToken();\n      if (token.equals(\".\")) {\n        token \u003d st.nextToken();\n        key.beginChar \u003d Integer.parseInt(token);\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n        } else {\n          return key;\n        }\n      } \n      do {\n        if (token.equals(\"n\")) {\n          key.numeric \u003d true;\n        }\n        else if (token.equals(\"r\")) {\n          key.reverse \u003d true;\n        }\n        else break;\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n        } else {\n          return key;\n        }\n      } while (true);\n      if (token.equals(\",\")) {\n        token \u003d st.nextToken();\n        //the first token must be a number\n        key.endFieldIdx \u003d Integer.parseInt(token);\n        if (st.hasMoreTokens()) {\n          token \u003d st.nextToken();\n          if (token.equals(\".\")) {\n            token \u003d st.nextToken();\n            key.endChar \u003d Integer.parseInt(token);\n            if (st.hasMoreTokens()) {\n              token \u003d st.nextToken();\n            } else {\n              return key;\n            }\n          }\n          do {\n            if (token.equals(\"n\")) {\n              key.numeric \u003d true;\n            }\n            else if (token.equals(\"r\")) {\n              key.reverse \u003d true;\n            }\n            else { \n              throw new IllegalArgumentException(\"Invalid -k argument. \" +\n               \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n               \"f[.c]nr\");\n            }\n            if (st.hasMoreTokens()) {\n              token \u003d st.nextToken();\n            } else {\n              break;\n            }\n          } while (true);\n        }\n        return key;\n      }\n      throw new IllegalArgumentException(\"Invalid -k argument. \" +\n          \"Must be of the form -k pos1,[pos2], where pos is of the form \" +\n          \"f[.c]nr\");\n    }\n    return key;\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldHelper.java"
    }
  }
}