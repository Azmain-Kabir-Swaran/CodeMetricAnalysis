{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractYarnScheduler.java",
  "functionName": "completedContainer",
  "functionId": "completedContainer___rmContainer-RMContainer__containerStatus-ContainerStatus__event-RMContainerEventType",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
  "functionStartLine": 695,
  "functionEndLine": 734,
  "numCommitsSeen": 779,
  "timeTaken": 12893,
  "changeHistory": [
    "ed3747c1ccc303e206de50c2b74f3c318cb1c416",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "cfe89e6f963ba25b5fff1ce48cad36d74b3c789c",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
    "945db55f2e6521d33d4f90bbb09179b0feba5e7a",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
    "0aafc122d401a2f49d0f9ca556343f9ba871e979",
    "99e5dd68d0f44109c169d74824fa45a7396a5990",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff",
    "adf260a728df427eb729abe8fb9ad7248991ea54",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
    "105afd54779852c518b978101f23526143e234a5",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78",
    "486e718fc1f5befd231494e2ec06bb360484f191",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
    "51ccb87031eda6a2b75be098a88f1d89ea82c610",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "ed3747c1ccc303e206de50c2b74f3c318cb1c416": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "cfe89e6f963ba25b5fff1ce48cad36d74b3c789c": "Ybodychange",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": "Ybodychange",
    "945db55f2e6521d33d4f90bbb09179b0feba5e7a": "Ybodychange",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": "Ybodychange",
    "0aafc122d401a2f49d0f9ca556343f9ba871e979": "Ybodychange",
    "99e5dd68d0f44109c169d74824fa45a7396a5990": "Ybodychange",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": "Ymultichange(Yrename,Ybodychange)",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": "Ymultichange(Yrename,Ybodychange)",
    "adf260a728df427eb729abe8fb9ad7248991ea54": "Ymultichange(Yrename,Ybodychange)",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": "Ymultichange(Yrename,Ybodychange)",
    "105afd54779852c518b978101f23526143e234a5": "Ybodychange",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": "Ymodifierchange",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ybodychange",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": "Ybodychange",
    "51ccb87031eda6a2b75be098a88f1d89ea82c610": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ed3747c1ccc303e206de50c2b74f3c318cb1c416": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9435. Add Opportunistic Scheduler metrics in ResourceManager. Contributed by Abhishek Modi.\n",
      "commitDate": "11/04/19 11:49 AM",
      "commitName": "ed3747c1ccc303e206de50c2b74f3c318cb1c416",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "09/04/19 10:59 AM",
      "commitNameOld": "cfec455c452d85229ef2f9d83e6f7fc827946b59",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 2.03,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,40 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n     if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n       completedContainerInternal(rmContainer, containerStatus, event);\n       completeOustandingUpdatesWhichAreReserved(\n           rmContainer, containerStatus, event);\n     } else {\n       ContainerId containerId \u003d rmContainer.getContainerId();\n       // Inform the container\n       rmContainer.handle(\n           new RMContainerFinishedEvent(containerId, containerStatus, event));\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           getCurrentAttemptForContainer(containerId);\n       if (schedulerAttempt !\u003d null) {\n         schedulerAttempt.removeRMContainer(containerId);\n       }\n       LOG.debug(\"Completed container: {} in state: {} event:{}\",\n           rmContainer.getContainerId(), rmContainer.getState(), event);\n \n       SchedulerNode node \u003d getSchedulerNode(rmContainer.getNodeId());\n       if (node !\u003d null) {\n         node.releaseContainer(rmContainer.getContainerId(), false);\n       }\n+      OpportunisticSchedulerMetrics.getMetrics().incrReleasedOppContainers(1);\n     }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n      completeOustandingUpdatesWhichAreReserved(\n          rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      LOG.debug(\"Completed container: {} in state: {} event:{}\",\n          rmContainer.getContainerId(), rmContainer.getState(), event);\n\n      SchedulerNode node \u003d getSchedulerNode(rmContainer.getNodeId());\n      if (node !\u003d null) {\n        node.releaseContainer(rmContainer.getContainerId(), false);\n      }\n      OpportunisticSchedulerMetrics.getMetrics().incrReleasedOppContainers(1);\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,39 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n     if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n       completedContainerInternal(rmContainer, containerStatus, event);\n       completeOustandingUpdatesWhichAreReserved(\n           rmContainer, containerStatus, event);\n     } else {\n       ContainerId containerId \u003d rmContainer.getContainerId();\n       // Inform the container\n       rmContainer.handle(\n           new RMContainerFinishedEvent(containerId, containerStatus, event));\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           getCurrentAttemptForContainer(containerId);\n       if (schedulerAttempt !\u003d null) {\n         schedulerAttempt.removeRMContainer(containerId);\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n-            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n-      }\n+      LOG.debug(\"Completed container: {} in state: {} event:{}\",\n+          rmContainer.getContainerId(), rmContainer.getState(), event);\n+\n       SchedulerNode node \u003d getSchedulerNode(rmContainer.getNodeId());\n       if (node !\u003d null) {\n         node.releaseContainer(rmContainer.getContainerId(), false);\n       }\n     }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n      completeOustandingUpdatesWhichAreReserved(\n          rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      LOG.debug(\"Completed container: {} in state: {} event:{}\",\n          rmContainer.getContainerId(), rmContainer.getState(), event);\n\n      SchedulerNode node \u003d getSchedulerNode(rmContainer.getNodeId());\n      if (node !\u003d null) {\n        node.releaseContainer(rmContainer.getContainerId(), false);\n      }\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "cfe89e6f963ba25b5fff1ce48cad36d74b3c789c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9164. Shutdown NM may cause NPE when opportunistic container scheduling is enabled. Contributed by lujie.\n",
      "commitDate": "03/01/19 7:56 AM",
      "commitName": "cfe89e6f963ba25b5fff1ce48cad36d74b3c789c",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "21/12/18 4:44 PM",
      "commitNameOld": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 12.63,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n     if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n       completedContainerInternal(rmContainer, containerStatus, event);\n       completeOustandingUpdatesWhichAreReserved(\n           rmContainer, containerStatus, event);\n     } else {\n       ContainerId containerId \u003d rmContainer.getContainerId();\n       // Inform the container\n       rmContainer.handle(\n           new RMContainerFinishedEvent(containerId, containerStatus, event));\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           getCurrentAttemptForContainer(containerId);\n       if (schedulerAttempt !\u003d null) {\n         schedulerAttempt.removeRMContainer(containerId);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n             \" in state: \" + rmContainer.getState() + \" event:\" + event);\n       }\n-      getSchedulerNode(rmContainer.getNodeId()).releaseContainer(\n-          rmContainer.getContainerId(), false);\n+      SchedulerNode node \u003d getSchedulerNode(rmContainer.getNodeId());\n+      if (node !\u003d null) {\n+        node.releaseContainer(rmContainer.getContainerId(), false);\n+      }\n     }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n      completeOustandingUpdatesWhichAreReserved(\n          rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n      }\n      SchedulerNode node \u003d getSchedulerNode(rmContainer.getNodeId());\n      if (node !\u003d null) {\n        node.releaseContainer(rmContainer.getContainerId(), false);\n      }\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
      "commitDate": "28/02/17 10:35 AM",
      "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "15/02/17 11:16 PM",
      "commitNameOld": "6c25dbcdc0517a825b92fb16444aa1d3761e160c",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 12.47,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n     if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n       completedContainerInternal(rmContainer, containerStatus, event);\n+      completeOustandingUpdatesWhichAreReserved(\n+          rmContainer, containerStatus, event);\n     } else {\n       ContainerId containerId \u003d rmContainer.getContainerId();\n       // Inform the container\n       rmContainer.handle(\n           new RMContainerFinishedEvent(containerId, containerStatus, event));\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           getCurrentAttemptForContainer(containerId);\n       if (schedulerAttempt !\u003d null) {\n         schedulerAttempt.removeRMContainer(containerId);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n             \" in state: \" + rmContainer.getState() + \" event:\" + event);\n       }\n       getSchedulerNode(rmContainer.getNodeId()).releaseContainer(\n           rmContainer.getContainerId(), false);\n     }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n      completeOustandingUpdatesWhichAreReserved(\n          rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n      }\n      getSchedulerNode(rmContainer.getNodeId()).releaseContainer(\n          rmContainer.getContainerId(), false);\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "945db55f2e6521d33d4f90bbb09179b0feba5e7a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4148. When killing app, RM releases app\u0027s resource before they are released by NM. Contributed by Jason Lowe.\n",
      "commitDate": "09/01/17 6:14 PM",
      "commitName": "945db55f2e6521d33d4f90bbb09179b0feba5e7a",
      "commitAuthor": "Junping Du",
      "commitDateOld": "09/01/17 8:40 AM",
      "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.4,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n     if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n       completedContainerInternal(rmContainer, containerStatus, event);\n     } else {\n       ContainerId containerId \u003d rmContainer.getContainerId();\n       // Inform the container\n       rmContainer.handle(\n           new RMContainerFinishedEvent(containerId, containerStatus, event));\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           getCurrentAttemptForContainer(containerId);\n       if (schedulerAttempt !\u003d null) {\n         schedulerAttempt.removeRMContainer(containerId);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n             \" in state: \" + rmContainer.getState() + \" event:\" + event);\n       }\n       getSchedulerNode(rmContainer.getNodeId()).releaseContainer(\n-          rmContainer.getContainer());\n+          rmContainer.getContainerId(), false);\n     }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n      }\n      getSchedulerNode(rmContainer.getNodeId()).releaseContainer(\n          rmContainer.getContainerId(), false);\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4597. Introduce ContainerScheduler and a SCHEDULED state to NodeManager container lifecycle. (asuresh)\n",
      "commitDate": "15/11/16 7:56 AM",
      "commitName": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "04/11/16 7:31 AM",
      "commitNameOld": "0aafc122d401a2f49d0f9ca556343f9ba871e979",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 11.06,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,36 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n     if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n       completedContainerInternal(rmContainer, containerStatus, event);\n     } else {\n       ContainerId containerId \u003d rmContainer.getContainerId();\n       // Inform the container\n       rmContainer.handle(\n           new RMContainerFinishedEvent(containerId, containerStatus, event));\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           getCurrentAttemptForContainer(containerId);\n       if (schedulerAttempt !\u003d null) {\n         schedulerAttempt.removeRMContainer(containerId);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n             \" in state: \" + rmContainer.getState() + \" event:\" + event);\n       }\n+      getSchedulerNode(rmContainer.getNodeId()).releaseContainer(\n+          rmContainer.getContainer());\n     }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n      }\n      getSchedulerNode(rmContainer.getNodeId()).releaseContainer(\n          rmContainer.getContainer());\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "0aafc122d401a2f49d0f9ca556343f9ba871e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2995. Enhance UI to show cluster resource utilization of various container Execution types. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "04/11/16 7:31 AM",
      "commitName": "0aafc122d401a2f49d0f9ca556343f9ba871e979",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "03/11/16 6:54 AM",
      "commitNameOld": "352cbaa7a54a94bad2bed131d6a250c5b21a7701",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.03,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n-    if (!rmContainer.isRemotelyAllocated()) {\n+    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n       completedContainerInternal(rmContainer, containerStatus, event);\n     } else {\n       ContainerId containerId \u003d rmContainer.getContainerId();\n       // Inform the container\n       rmContainer.handle(\n           new RMContainerFinishedEvent(containerId, containerStatus, event));\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           getCurrentAttemptForContainer(containerId);\n       if (schedulerAttempt !\u003d null) {\n         schedulerAttempt.removeRMContainer(containerId);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n             \" in state: \" + rmContainer.getState() + \" event:\" + event);\n       }\n     }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (rmContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n      }\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "99e5dd68d0f44109c169d74824fa45a7396a5990": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5171. Extend DistributedSchedulerProtocol to notify RM of containers allocated by the Node. (Inigo Goiri via asuresh)\n",
      "commitDate": "22/06/16 7:04 PM",
      "commitName": "99e5dd68d0f44109c169d74824fa45a7396a5990",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "07/06/16 3:06 PM",
      "commitNameOld": "620325e81696fca140195b74929ed9eda2d5eb16",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 15.17,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,18 +1,34 @@\n   public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n \n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n           + \" completed with event \" + event\n           + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n-    completedContainerInternal(rmContainer, containerStatus, event);\n+    if (!rmContainer.isRemotelyAllocated()) {\n+      completedContainerInternal(rmContainer, containerStatus, event);\n+    } else {\n+      ContainerId containerId \u003d rmContainer.getContainerId();\n+      // Inform the container\n+      rmContainer.handle(\n+          new RMContainerFinishedEvent(containerId, containerStatus, event));\n+      SchedulerApplicationAttempt schedulerAttempt \u003d\n+          getCurrentAttemptForContainer(containerId);\n+      if (schedulerAttempt !\u003d null) {\n+        schedulerAttempt.removeRMContainer(containerId);\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n+            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n+      }\n+    }\n \n     // If the container is getting killed in ACQUIRED state, the requester (AM\n     // for regular containers and RM itself for AM container) will not know what\n     // happened. Simply add the ResourceRequest back again so that requester\n     // doesn\u0027t need to do anything conditionally.\n     recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    if (!rmContainer.isRemotelyAllocated()) {\n      completedContainerInternal(rmContainer, containerStatus, event);\n    } else {\n      ContainerId containerId \u003d rmContainer.getContainerId();\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerFinishedEvent(containerId, containerStatus, event));\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          getCurrentAttemptForContainer(containerId);\n      if (schedulerAttempt !\u003d null) {\n        schedulerAttempt.removeRMContainer(containerId);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Completed container: \" + rmContainer.getContainerId() +\n            \" in state: \" + rmContainer.getState() + \" event:\" + event);\n      }\n    }\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "18/01/16 5:30 PM",
      "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
          "commitDate": "18/01/16 5:30 PM",
          "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "18/01/16 5:27 PM",
          "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,18 @@\n-  protected synchronized void completedContainer(RMContainer rmContainer,\n+  public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n+\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n-          + \" completed with event \" + event);\n+          + \" completed with event \" + event\n+          + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n-    Container container \u003d rmContainer.getContainer();\n+    completedContainerInternal(rmContainer, containerStatus, event);\n \n-    // Get the application for the finished container\n-    FSAppAttempt application \u003d\n-        getCurrentAttemptForContainer(container.getId());\n-    ApplicationId appId \u003d\n-        container.getId().getApplicationAttemptId().getApplicationId();\n-    if (application \u003d\u003d null) {\n-      LOG.info(\"Container \" + container + \" of\" +\n-          \" finished application \" + appId +\n-          \" completed with event \" + event);\n-      return;\n-    }\n-\n-    // Get the node on which the container was allocated\n-    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n-\n-    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n-      application.unreserve(rmContainer.getReservedPriority(), node);\n-    } else {\n-      application.containerCompleted(rmContainer, containerStatus, event);\n-      node.releaseContainer(container);\n-      updateRootQueueMetrics();\n-    }\n-\n-    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n-        + \" released container \" + container.getId() + \" on node: \" + node\n-        + \" with event: \" + event);\n+    // If the container is getting killed in ACQUIRED state, the requester (AM\n+    // for regular containers and RM itself for AM container) will not know what\n+    // happened. Simply add the ResourceRequest back again so that requester\n+    // doesn\u0027t need to do anything conditionally.\n+    recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    completedContainerInternal(rmContainer, containerStatus, event);\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
            "oldMethodName": "completedContainer",
            "newMethodName": "completedContainer"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
          "commitDate": "18/01/16 5:30 PM",
          "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "18/01/16 5:27 PM",
          "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,18 @@\n-  protected synchronized void completedContainer(RMContainer rmContainer,\n+  public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n+\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n-          + \" completed with event \" + event);\n+          + \" completed with event \" + event\n+          + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n-    Container container \u003d rmContainer.getContainer();\n+    completedContainerInternal(rmContainer, containerStatus, event);\n \n-    // Get the application for the finished container\n-    FSAppAttempt application \u003d\n-        getCurrentAttemptForContainer(container.getId());\n-    ApplicationId appId \u003d\n-        container.getId().getApplicationAttemptId().getApplicationId();\n-    if (application \u003d\u003d null) {\n-      LOG.info(\"Container \" + container + \" of\" +\n-          \" finished application \" + appId +\n-          \" completed with event \" + event);\n-      return;\n-    }\n-\n-    // Get the node on which the container was allocated\n-    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n-\n-    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n-      application.unreserve(rmContainer.getReservedPriority(), node);\n-    } else {\n-      application.containerCompleted(rmContainer, containerStatus, event);\n-      node.releaseContainer(container);\n-      updateRootQueueMetrics();\n-    }\n-\n-    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n-        + \" released container \" + container.getId() + \" on node: \" + node\n-        + \" with event: \" + event);\n+    // If the container is getting killed in ACQUIRED state, the requester (AM\n+    // for regular containers and RM itself for AM container) will not know what\n+    // happened. Simply add the ResourceRequest back again so that requester\n+    // doesn\u0027t need to do anything conditionally.\n+    recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    completedContainerInternal(rmContainer, containerStatus, event);\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {
            "oldValue": "[protected, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
          "commitDate": "18/01/16 5:30 PM",
          "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "18/01/16 5:27 PM",
          "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,18 @@\n-  protected synchronized void completedContainer(RMContainer rmContainer,\n+  public void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n+\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Container \" + containerStatus.getContainerId()\n-          + \" completed with event \" + event);\n+          + \" completed with event \" + event\n+          + \", but corresponding RMContainer doesn\u0027t exist.\");\n       return;\n     }\n \n-    Container container \u003d rmContainer.getContainer();\n+    completedContainerInternal(rmContainer, containerStatus, event);\n \n-    // Get the application for the finished container\n-    FSAppAttempt application \u003d\n-        getCurrentAttemptForContainer(container.getId());\n-    ApplicationId appId \u003d\n-        container.getId().getApplicationAttemptId().getApplicationId();\n-    if (application \u003d\u003d null) {\n-      LOG.info(\"Container \" + container + \" of\" +\n-          \" finished application \" + appId +\n-          \" completed with event \" + event);\n-      return;\n-    }\n-\n-    // Get the node on which the container was allocated\n-    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n-\n-    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n-      application.unreserve(rmContainer.getReservedPriority(), node);\n-    } else {\n-      application.containerCompleted(rmContainer, containerStatus, event);\n-      node.releaseContainer(container);\n-      updateRootQueueMetrics();\n-    }\n-\n-    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n-        + \" released container \" + container.getId() + \" on node: \" + node\n-        + \" with event: \" + event);\n+    // If the container is getting killed in ACQUIRED state, the requester (AM\n+    // for regular containers and RM itself for AM container) will not know what\n+    // happened. Simply add the ResourceRequest back again so that requester\n+    // doesn\u0027t need to do anything conditionally.\n+    recoverResourceRequestForContainer(rmContainer);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event\n          + \", but corresponding RMContainer doesn\u0027t exist.\");\n      return;\n    }\n\n    completedContainerInternal(rmContainer, containerStatus, event);\n\n    // If the container is getting killed in ACQUIRED state, the requester (AM\n    // for regular containers and RM itself for AM container) will not know what\n    // happened. Simply add the ResourceRequest back again so that requester\n    // doesn\u0027t need to do anything conditionally.\n    recoverResourceRequestForContainer(rmContainer);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
      "commitDate": "18/01/16 5:27 PM",
      "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
          "commitDate": "18/01/16 5:27 PM",
          "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "18/01/16 1:58 AM",
          "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 0.65,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,37 @@\n-  protected synchronized void completedContainerInternal(\n-      RMContainer rmContainer, ContainerStatus containerStatus,\n-      RMContainerEventType event) {\n+  protected synchronized void completedContainer(RMContainer rmContainer,\n+      ContainerStatus containerStatus, RMContainerEventType event) {\n+    if (rmContainer \u003d\u003d null) {\n+      LOG.info(\"Container \" + containerStatus.getContainerId()\n+          + \" completed with event \" + event);\n+      return;\n+    }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event);\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "completedContainerInternal",
            "newValue": "completedContainer"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
          "commitDate": "18/01/16 5:27 PM",
          "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "18/01/16 1:58 AM",
          "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 0.65,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,37 @@\n-  protected synchronized void completedContainerInternal(\n-      RMContainer rmContainer, ContainerStatus containerStatus,\n-      RMContainerEventType event) {\n+  protected synchronized void completedContainer(RMContainer rmContainer,\n+      ContainerStatus containerStatus, RMContainerEventType event) {\n+    if (rmContainer \u003d\u003d null) {\n+      LOG.info(\"Container \" + containerStatus.getContainerId()\n+          + \" completed with event \" + event);\n+      return;\n+    }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event);\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
      "commitDate": "18/01/16 1:06 AM",
      "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
          "commitDate": "18/01/16 1:06 AM",
          "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "18/01/16 12:50 AM",
          "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,33 @@\n-  protected synchronized void completedContainer(RMContainer rmContainer,\n-      ContainerStatus containerStatus, RMContainerEventType event) {\n-    if (rmContainer \u003d\u003d null) {\n-      LOG.info(\"Container \" + containerStatus.getContainerId()\n-          + \" completed with event \" + event);\n-      return;\n-    }\n+  protected synchronized void completedContainerInternal(\n+      RMContainer rmContainer, ContainerStatus containerStatus,\n+      RMContainerEventType event) {\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainerInternal(\n      RMContainer rmContainer, ContainerStatus containerStatus,\n      RMContainerEventType event) {\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "completedContainer",
            "newValue": "completedContainerInternal"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
          "commitDate": "18/01/16 1:06 AM",
          "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "18/01/16 12:50 AM",
          "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,33 @@\n-  protected synchronized void completedContainer(RMContainer rmContainer,\n-      ContainerStatus containerStatus, RMContainerEventType event) {\n-    if (rmContainer \u003d\u003d null) {\n-      LOG.info(\"Container \" + containerStatus.getContainerId()\n-          + \" completed with event \" + event);\n-      return;\n-    }\n+  protected synchronized void completedContainerInternal(\n+      RMContainer rmContainer, ContainerStatus containerStatus,\n+      RMContainerEventType event) {\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainerInternal(\n      RMContainer rmContainer, ContainerStatus containerStatus,\n      RMContainerEventType event) {\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "adf260a728df427eb729abe8fb9ad7248991ea54": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
      "commitDate": "18/01/16 12:50 AM",
      "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
          "commitDate": "18/01/16 12:50 AM",
          "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "17/01/16 7:04 PM",
          "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,37 @@\n-  protected synchronized void completedContainerInternal(\n-      RMContainer rmContainer, ContainerStatus containerStatus,\n-      RMContainerEventType event) {\n+  protected synchronized void completedContainer(RMContainer rmContainer,\n+      ContainerStatus containerStatus, RMContainerEventType event) {\n+    if (rmContainer \u003d\u003d null) {\n+      LOG.info(\"Container \" + containerStatus.getContainerId()\n+          + \" completed with event \" + event);\n+      return;\n+    }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event);\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "completedContainerInternal",
            "newValue": "completedContainer"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
          "commitDate": "18/01/16 12:50 AM",
          "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "17/01/16 7:04 PM",
          "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,37 @@\n-  protected synchronized void completedContainerInternal(\n-      RMContainer rmContainer, ContainerStatus containerStatus,\n-      RMContainerEventType event) {\n+  protected synchronized void completedContainer(RMContainer rmContainer,\n+      ContainerStatus containerStatus, RMContainerEventType event) {\n+    if (rmContainer \u003d\u003d null) {\n+      LOG.info(\"Container \" + containerStatus.getContainerId()\n+          + \" completed with event \" + event);\n+      return;\n+    }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event);\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "17/01/16 7:04 PM",
      "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
          "commitDate": "17/01/16 7:04 PM",
          "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "14/12/15 10:52 AM",
          "commitNameOld": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 34.34,
          "commitsBetweenForRepo": 200,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,33 @@\n-  protected synchronized void completedContainer(RMContainer rmContainer,\n-      ContainerStatus containerStatus, RMContainerEventType event) {\n-    if (rmContainer \u003d\u003d null) {\n-      LOG.info(\"Container \" + containerStatus.getContainerId()\n-          + \" completed with event \" + event);\n-      return;\n-    }\n+  protected synchronized void completedContainerInternal(\n+      RMContainer rmContainer, ContainerStatus containerStatus,\n+      RMContainerEventType event) {\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainerInternal(\n      RMContainer rmContainer, ContainerStatus containerStatus,\n      RMContainerEventType event) {\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "completedContainer",
            "newValue": "completedContainerInternal"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
          "commitDate": "17/01/16 7:04 PM",
          "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "14/12/15 10:52 AM",
          "commitNameOld": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 34.34,
          "commitsBetweenForRepo": 200,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,33 @@\n-  protected synchronized void completedContainer(RMContainer rmContainer,\n-      ContainerStatus containerStatus, RMContainerEventType event) {\n-    if (rmContainer \u003d\u003d null) {\n-      LOG.info(\"Container \" + containerStatus.getContainerId()\n-          + \" completed with event \" + event);\n-      return;\n-    }\n+  protected synchronized void completedContainerInternal(\n+      RMContainer rmContainer, ContainerStatus containerStatus,\n+      RMContainerEventType event) {\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void completedContainerInternal(\n      RMContainer rmContainer, ContainerStatus containerStatus,\n      RMContainerEventType event) {\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "105afd54779852c518b978101f23526143e234a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3495. Confusing log generated by FairScheduler. Contributed by Brahma Reddy Battula.\n",
      "commitDate": "21/04/15 1:47 PM",
      "commitName": "105afd54779852c518b978101f23526143e234a5",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "02/04/15 1:56 PM",
      "commitNameOld": "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06",
      "commitAuthorOld": "Sandy Ryza",
      "daysBetweenCommits": 18.99,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n   protected synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n-      LOG.info(\"Null container completed...\");\n+      LOG.info(\"Container \" + containerStatus.getContainerId()\n+          + \" completed with event \" + event);\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n-          \" unknown application attempt \" + appId +\n+          \" finished application \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Container \" + containerStatus.getContainerId()\n          + \" completed with event \" + event);\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" finished application \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-2249. Avoided AM release requests being lost on work preserving RM restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618972 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/14 1:33 PM",
      "commitName": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "12/08/14 6:38 PM",
      "commitNameOld": "5197f8c3c53f18701f041dd2301b454930a5025b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 6.79,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n-  private synchronized void completedContainer(RMContainer rmContainer,\n+  protected synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Null container completed...\");\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" unknown application attempt \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application attempt \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "[private, synchronized]",
        "newValue": "[protected, synchronized]"
      }
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "08/08/14 7:17 AM",
      "commitNameOld": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.31,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,36 @@\n   private synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Null container completed...\");\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n-    FSSchedulerApp application \u003d\n+    FSAppAttempt application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" unknown application attempt \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n-      application.unreserve(node, rmContainer.getReservedPriority());\n-      node.unreserveResource(application);\n+      application.unreserve(rmContainer.getReservedPriority(), node);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSAppAttempt application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application attempt \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(rmContainer.getReservedPriority(), node);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   private synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Null container completed...\");\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     FSSchedulerApp application \u003d\n         getCurrentAttemptForContainer(container.getId());\n     ApplicationId appId \u003d\n         container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" unknown application attempt \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n-    FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n+    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(node, rmContainer.getReservedPriority());\n       node.unreserveResource(application);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n         + \" released container \" + container.getId() + \" on node: \" + node\n         + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSSchedulerApp application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application attempt \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d getFSSchedulerNode(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(node, rmContainer.getReservedPriority());\n      node.unreserveResource(application);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/01/14 12:19 PM",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n   private synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Null container completed...\");\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n-    ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n-    FSSchedulerApp application \u003d appAttempts.get(applicationAttemptId);\n+    FSSchedulerApp application \u003d\n+        getCurrentAttemptForContainer(container.getId());\n+    ApplicationId appId \u003d\n+        container.getId().getApplicationAttemptId().getApplicationId();\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n-          \" unknown application \" + applicationAttemptId +\n+          \" unknown application attempt \" + appId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(node, rmContainer.getReservedPriority());\n       node.unreserveResource(application);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n-    LOG.info(\"Application \" + applicationAttemptId +\n-        \" released container \" + container.getId() +\n-        \" on node: \" + node +\n-        \" with event: \" + event);\n+    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n+        + \" released container \" + container.getId() + \" on node: \" + node\n+        + \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    FSSchedulerApp application \u003d\n        getCurrentAttemptForContainer(container.getId());\n    ApplicationId appId \u003d\n        container.getId().getApplicationAttemptId().getApplicationId();\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application attempt \" + appId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(node, rmContainer.getReservedPriority());\n      node.unreserveResource(application);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application attempt \" + application.getApplicationAttemptId()\n        + \" released container \" + container.getId() + \" on node: \" + node\n        + \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 12:19 PM",
      "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/12/13 5:44 PM",
      "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 20.77,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Null container completed...\");\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n-    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n+    FSSchedulerApp application \u003d appAttempts.get(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" unknown application \" + applicationAttemptId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(node, rmContainer.getReservedPriority());\n       node.unreserveResource(application);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n       updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application \" + applicationAttemptId +\n         \" released container \" + container.getId() +\n         \" on node: \" + node +\n         \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n    FSSchedulerApp application \u003d appAttempts.get(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application \" + applicationAttemptId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(node, rmContainer.getReservedPriority());\n      node.unreserveResource(application);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application \" + applicationAttemptId +\n        \" released container \" + container.getId() +\n        \" on node: \" + node +\n        \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "51ccb87031eda6a2b75be098a88f1d89ea82c610": {
      "type": "Ybodychange",
      "commitMessage": "YARN-655. Fair scheduler metrics should subtract allocated memory from available memory. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480809 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 3:15 PM",
      "commitName": "51ccb87031eda6a2b75be098a88f1d89ea82c610",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/05/13 2:52 PM",
      "commitNameOld": "e0562e3d07f29afbf283857293db0699dcb232c9",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,36 @@\n   private synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Null container completed...\");\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n     FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" unknown application \" + applicationAttemptId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n     FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(node, rmContainer.getReservedPriority());\n       node.unreserveResource(application);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n+      updateRootQueueMetrics();\n     }\n \n     LOG.info(\"Application \" + applicationAttemptId +\n         \" released container \" + container.getId() +\n         \" on node: \" + node +\n         \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application \" + applicationAttemptId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(node, rmContainer.getReservedPriority());\n      node.unreserveResource(application);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n      updateRootQueueMetrics();\n    }\n\n    LOG.info(\"Application \" + applicationAttemptId +\n        \" released container \" + container.getId() +\n        \" on node: \" + node +\n        \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application \" + applicationAttemptId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(node, rmContainer.getReservedPriority());\n      node.unreserveResource(application);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n    }\n\n    LOG.info(\"Application \" + applicationAttemptId +\n        \" released container \" + container.getId() +\n        \" on node: \" + node +\n        \" with event: \" + event);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "12/07/12 5:43 PM",
      "commitNameOld": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private synchronized void completedContainer(RMContainer rmContainer,\n       ContainerStatus containerStatus, RMContainerEventType event) {\n     if (rmContainer \u003d\u003d null) {\n       LOG.info(\"Null container completed...\");\n       return;\n     }\n \n     Container container \u003d rmContainer.getContainer();\n \n     // Get the application for the finished container\n     ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n-    SchedulerApp application \u003d applications.get(applicationAttemptId);\n+    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Container \" + container + \" of\" +\n           \" unknown application \" + applicationAttemptId +\n           \" completed with event \" + event);\n       return;\n     }\n \n     // Get the node on which the container was allocated\n-    SchedulerNode node \u003d nodes.get(container.getNodeId());\n+    FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n \n     if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n       application.unreserve(node, rmContainer.getReservedPriority());\n       node.unreserveResource(application);\n     } else {\n       application.containerCompleted(rmContainer, containerStatus, event);\n       node.releaseContainer(container);\n     }\n \n     LOG.info(\"Application \" + applicationAttemptId +\n         \" released container \" + container.getId() +\n         \" on node: \" + node +\n         \" with event: \" + event);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n    FSSchedulerApp application \u003d applications.get(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application \" + applicationAttemptId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    FSSchedulerNode node \u003d nodes.get(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(node, rmContainer.getReservedPriority());\n      node.unreserveResource(application);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n    }\n\n    LOG.info(\"Application \" + applicationAttemptId +\n        \" released container \" + container.getId() +\n        \" on node: \" + node +\n        \" with event: \" + event);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,35 @@\n+  private synchronized void completedContainer(RMContainer rmContainer,\n+      ContainerStatus containerStatus, RMContainerEventType event) {\n+    if (rmContainer \u003d\u003d null) {\n+      LOG.info(\"Null container completed...\");\n+      return;\n+    }\n+\n+    Container container \u003d rmContainer.getContainer();\n+\n+    // Get the application for the finished container\n+    ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n+    SchedulerApp application \u003d applications.get(applicationAttemptId);\n+    if (application \u003d\u003d null) {\n+      LOG.info(\"Container \" + container + \" of\" +\n+          \" unknown application \" + applicationAttemptId +\n+          \" completed with event \" + event);\n+      return;\n+    }\n+\n+    // Get the node on which the container was allocated\n+    SchedulerNode node \u003d nodes.get(container.getNodeId());\n+\n+    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n+      application.unreserve(node, rmContainer.getReservedPriority());\n+      node.unreserveResource(application);\n+    } else {\n+      application.containerCompleted(rmContainer, containerStatus, event);\n+      node.releaseContainer(container);\n+    }\n+\n+    LOG.info(\"Application \" + applicationAttemptId +\n+        \" released container \" + container.getId() +\n+        \" on node: \" + node +\n+        \" with event: \" + event);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event) {\n    if (rmContainer \u003d\u003d null) {\n      LOG.info(\"Null container completed...\");\n      return;\n    }\n\n    Container container \u003d rmContainer.getContainer();\n\n    // Get the application for the finished container\n    ApplicationAttemptId applicationAttemptId \u003d container.getId().getApplicationAttemptId();\n    SchedulerApp application \u003d applications.get(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Container \" + container + \" of\" +\n          \" unknown application \" + applicationAttemptId +\n          \" completed with event \" + event);\n      return;\n    }\n\n    // Get the node on which the container was allocated\n    SchedulerNode node \u003d nodes.get(container.getNodeId());\n\n    if (rmContainer.getState() \u003d\u003d RMContainerState.RESERVED) {\n      application.unreserve(node, rmContainer.getReservedPriority());\n      node.unreserveResource(application);\n    } else {\n      application.containerCompleted(rmContainer, containerStatus, event);\n      node.releaseContainer(container);\n    }\n\n    LOG.info(\"Application \" + applicationAttemptId +\n        \" released container \" + container.getId() +\n        \" on node: \" + node +\n        \" with event: \" + event);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}