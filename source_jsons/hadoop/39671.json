{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeafQueue.java",
  "functionName": "canAssignToUser",
  "functionId": "canAssignToUser___clusterResource-Resource__userName-String__limit-Resource__application-FiCaSchedulerApp__nodePartition-String__currentResourceLimits-ResourceLimits",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
  "functionStartLine": 1527,
  "functionEndLine": 1579,
  "numCommitsSeen": 628,
  "timeTaken": 18288,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
    "468a53b22f4ac5bb079dff986ba849a687d709fe",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
    "189a63a719c63b67a1783a280bfc2f72dcb55277",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
    "586348e4cbf197188057d6b843a6701cfffdaff3",
    "86358221fc85a7743052a0b4c1647353508bf308",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "9c22065109a77681bc2534063eabe8692fbcb3cd",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "21c9116309d8482e7e28522cd7386e65415b15e9",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c": "Ybodychange",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": "Ymultichange(Ymodifierchange,Ybodychange)",
    "468a53b22f4ac5bb079dff986ba849a687d709fe": "Ymultichange(Yparameterchange,Ybodychange)",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": "Ybodychange",
    "189a63a719c63b67a1783a280bfc2f72dcb55277": "Ymultichange(Yparameterchange,Ybodychange)",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": "Ymultichange(Yparameterchange,Ybodychange)",
    "586348e4cbf197188057d6b843a6701cfffdaff3": "Ymultichange(Yrename,Ybodychange)",
    "86358221fc85a7743052a0b4c1647353508bf308": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ymultichange(Yparameterchange,Ybodychange)",
    "9c22065109a77681bc2534063eabe8692fbcb3cd": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ymultichange(Yparameterchange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "21c9116309d8482e7e28522cd7386e65415b15e9": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/01/20 7:54 PM",
      "commitNameOld": "e578e52aae01248507e089b406fe038ab8e84207",
      "commitAuthorOld": "Eric Badger",
      "daysBetweenCommits": 56.31,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   protected boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       String nodePartition, ResourceLimits currentResourceLimits) {\n \n     readLock.lock();\n     try {\n       User user \u003d getUser(userName);\n       if (user \u003d\u003d null) {\n         LOG.debug(\"User {} has been removed!\", userName);\n         return false;\n       }\n \n       currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n \n       // Note: We aren\u0027t considering the current request since there is a fixed\n       // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           user.getUsed(nodePartition), limit)) {\n         // if enabled, check to see if could we potentially use this node instead\n         // of a reserved node if the application has reserved containers\n         if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n             CommonNodeLabelsManager.NO_LABEL)) {\n           if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n               Resources.subtract(user.getUsed(),\n                   application.getCurrentReservation()), limit)) {\n \n             if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+              LOG.debug(\"User \" + userName + \" in queue \" + getQueuePath()\n                   + \" will exceed limit based on reservations - \"\n                   + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                   .getCurrentReservation() + \" limit: \" + limit);\n             }\n             Resource amountNeededToUnreserve \u003d Resources.subtract(\n                 user.getUsed(nodePartition), limit);\n             // we can only acquire a new container if we unreserve first to\n             // respect user-limit\n             currentResourceLimits.setAmountNeededUnreserve(\n                 amountNeededToUnreserve);\n             return true;\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+          LOG.debug(\"User \" + userName + \" in queue \" + getQueuePath()\n               + \" will exceed limit - \" + \" consumed: \" + user\n               .getUsed(nodePartition) + \" limit: \" + limit);\n         }\n         return false;\n       }\n       return true;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n\n    readLock.lock();\n    try {\n      User user \u003d getUser(userName);\n      if (user \u003d\u003d null) {\n        LOG.debug(\"User {} has been removed!\", userName);\n        return false;\n      }\n\n      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n      // Note: We aren\u0027t considering the current request since there is a fixed\n      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          user.getUsed(nodePartition), limit)) {\n        // if enabled, check to see if could we potentially use this node instead\n        // of a reserved node if the application has reserved containers\n        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n            CommonNodeLabelsManager.NO_LABEL)) {\n          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n              Resources.subtract(user.getUsed(),\n                  application.getCurrentReservation()), limit)) {\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"User \" + userName + \" in queue \" + getQueuePath()\n                  + \" will exceed limit based on reservations - \"\n                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                  .getCurrentReservation() + \" limit: \" + limit);\n            }\n            Resource amountNeededToUnreserve \u003d Resources.subtract(\n                user.getUsed(nodePartition), limit);\n            // we can only acquire a new container if we unreserve first to\n            // respect user-limit\n            currentResourceLimits.setAmountNeededUnreserve(\n                amountNeededToUnreserve);\n            return true;\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" in queue \" + getQueuePath()\n              + \" will exceed limit - \" + \" consumed: \" + user\n              .getUsed(nodePartition) + \" limit: \" + limit);\n        }\n        return false;\n      }\n      return true;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,53 @@\n   protected boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       String nodePartition, ResourceLimits currentResourceLimits) {\n \n     readLock.lock();\n     try {\n       User user \u003d getUser(userName);\n       if (user \u003d\u003d null) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"User \" + userName + \" has been removed!\");\n-        }\n+        LOG.debug(\"User {} has been removed!\", userName);\n         return false;\n       }\n \n       currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n \n       // Note: We aren\u0027t considering the current request since there is a fixed\n       // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           user.getUsed(nodePartition), limit)) {\n         // if enabled, check to see if could we potentially use this node instead\n         // of a reserved node if the application has reserved containers\n         if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n             CommonNodeLabelsManager.NO_LABEL)) {\n           if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n               Resources.subtract(user.getUsed(),\n                   application.getCurrentReservation()), limit)) {\n \n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                   + \" will exceed limit based on reservations - \"\n                   + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                   .getCurrentReservation() + \" limit: \" + limit);\n             }\n             Resource amountNeededToUnreserve \u003d Resources.subtract(\n                 user.getUsed(nodePartition), limit);\n             // we can only acquire a new container if we unreserve first to\n             // respect user-limit\n             currentResourceLimits.setAmountNeededUnreserve(\n                 amountNeededToUnreserve);\n             return true;\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n               + \" will exceed limit - \" + \" consumed: \" + user\n               .getUsed(nodePartition) + \" limit: \" + limit);\n         }\n         return false;\n       }\n       return true;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n\n    readLock.lock();\n    try {\n      User user \u003d getUser(userName);\n      if (user \u003d\u003d null) {\n        LOG.debug(\"User {} has been removed!\", userName);\n        return false;\n      }\n\n      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n      // Note: We aren\u0027t considering the current request since there is a fixed\n      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          user.getUsed(nodePartition), limit)) {\n        // if enabled, check to see if could we potentially use this node instead\n        // of a reserved node if the application has reserved containers\n        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n            CommonNodeLabelsManager.NO_LABEL)) {\n          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n              Resources.subtract(user.getUsed(),\n                  application.getCurrentReservation()), limit)) {\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                  + \" will exceed limit based on reservations - \"\n                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                  .getCurrentReservation() + \" limit: \" + limit);\n            }\n            Resource amountNeededToUnreserve \u003d Resources.subtract(\n                user.getUsed(nodePartition), limit);\n            // we can only acquire a new container if we unreserve first to\n            // respect user-limit\n            currentResourceLimits.setAmountNeededUnreserve(\n                amountNeededToUnreserve);\n            return true;\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n              + \" will exceed limit - \" + \" consumed: \" + user\n              .getUsed(nodePartition) + \" limit: \" + limit);\n        }\n        return false;\n      }\n      return true;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,55 @@\n   protected boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       String nodePartition, ResourceLimits currentResourceLimits) {\n+\n+    readLock.lock();\n     try {\n-      readLock.lock();\n       User user \u003d getUser(userName);\n       if (user \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"User \" + userName + \" has been removed!\");\n         }\n         return false;\n       }\n \n       currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n \n       // Note: We aren\u0027t considering the current request since there is a fixed\n       // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           user.getUsed(nodePartition), limit)) {\n         // if enabled, check to see if could we potentially use this node instead\n         // of a reserved node if the application has reserved containers\n         if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n             CommonNodeLabelsManager.NO_LABEL)) {\n           if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n               Resources.subtract(user.getUsed(),\n                   application.getCurrentReservation()), limit)) {\n \n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                   + \" will exceed limit based on reservations - \"\n                   + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                   .getCurrentReservation() + \" limit: \" + limit);\n             }\n             Resource amountNeededToUnreserve \u003d Resources.subtract(\n                 user.getUsed(nodePartition), limit);\n             // we can only acquire a new container if we unreserve first to\n             // respect user-limit\n             currentResourceLimits.setAmountNeededUnreserve(\n                 amountNeededToUnreserve);\n             return true;\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n               + \" will exceed limit - \" + \" consumed: \" + user\n               .getUsed(nodePartition) + \" limit: \" + limit);\n         }\n         return false;\n       }\n       return true;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n\n    readLock.lock();\n    try {\n      User user \u003d getUser(userName);\n      if (user \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" has been removed!\");\n        }\n        return false;\n      }\n\n      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n      // Note: We aren\u0027t considering the current request since there is a fixed\n      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          user.getUsed(nodePartition), limit)) {\n        // if enabled, check to see if could we potentially use this node instead\n        // of a reserved node if the application has reserved containers\n        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n            CommonNodeLabelsManager.NO_LABEL)) {\n          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n              Resources.subtract(user.getUsed(),\n                  application.getCurrentReservation()), limit)) {\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                  + \" will exceed limit based on reservations - \"\n                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                  .getCurrentReservation() + \" limit: \" + limit);\n            }\n            Resource amountNeededToUnreserve \u003d Resources.subtract(\n                user.getUsed(nodePartition), limit);\n            // we can only acquire a new container if we unreserve first to\n            // respect user-limit\n            currentResourceLimits.setAmountNeededUnreserve(\n                amountNeededToUnreserve);\n            return true;\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n              + \" will exceed limit - \" + \" consumed: \" + user\n              .getUsed(nodePartition) + \" limit: \" + limit);\n        }\n        return false;\n      }\n      return true;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7591. NPE in async-scheduling mode of CapacityScheduler. (Tao Yang via wangda)\n\nChange-Id: I46689e530550ee0a6ac7a29786aab2cc1bdf314f\n",
      "commitDate": "08/12/17 3:17 PM",
      "commitName": "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/12/17 3:10 PM",
      "commitNameOld": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,54 @@\n   protected boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       String nodePartition, ResourceLimits currentResourceLimits) {\n     try {\n       readLock.lock();\n       User user \u003d getUser(userName);\n+      if (user \u003d\u003d null) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"User \" + userName + \" has been removed!\");\n+        }\n+        return false;\n+      }\n \n       currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n \n       // Note: We aren\u0027t considering the current request since there is a fixed\n       // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n       if (Resources.greaterThan(resourceCalculator, clusterResource,\n           user.getUsed(nodePartition), limit)) {\n         // if enabled, check to see if could we potentially use this node instead\n         // of a reserved node if the application has reserved containers\n         if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n             CommonNodeLabelsManager.NO_LABEL)) {\n           if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n               Resources.subtract(user.getUsed(),\n                   application.getCurrentReservation()), limit)) {\n \n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                   + \" will exceed limit based on reservations - \"\n                   + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                   .getCurrentReservation() + \" limit: \" + limit);\n             }\n             Resource amountNeededToUnreserve \u003d Resources.subtract(\n                 user.getUsed(nodePartition), limit);\n             // we can only acquire a new container if we unreserve first to\n             // respect user-limit\n             currentResourceLimits.setAmountNeededUnreserve(\n                 amountNeededToUnreserve);\n             return true;\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n               + \" will exceed limit - \" + \" consumed: \" + user\n               .getUsed(nodePartition) + \" limit: \" + limit);\n         }\n         return false;\n       }\n       return true;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n    try {\n      readLock.lock();\n      User user \u003d getUser(userName);\n      if (user \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" has been removed!\");\n        }\n        return false;\n      }\n\n      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n      // Note: We aren\u0027t considering the current request since there is a fixed\n      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          user.getUsed(nodePartition), limit)) {\n        // if enabled, check to see if could we potentially use this node instead\n        // of a reserved node if the application has reserved containers\n        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n            CommonNodeLabelsManager.NO_LABEL)) {\n          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n              Resources.subtract(user.getUsed(),\n                  application.getCurrentReservation()), limit)) {\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                  + \" will exceed limit based on reservations - \"\n                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                  .getCurrentReservation() + \" limit: \" + limit);\n            }\n            Resource amountNeededToUnreserve \u003d Resources.subtract(\n                user.getUsed(nodePartition), limit);\n            // we can only acquire a new container if we unreserve first to\n            // respect user-limit\n            currentResourceLimits.setAmountNeededUnreserve(\n                amountNeededToUnreserve);\n            return true;\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n              + \" will exceed limit - \" + \" consumed: \" + user\n              .getUsed(nodePartition) + \" limit: \" + limit);\n        }\n        return false;\n      }\n      return true;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
      "commitDate": "20/09/16 12:03 AM",
      "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,48 @@\n-  protected synchronized boolean canAssignToUser(Resource clusterResource,\n+  protected boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       String nodePartition, ResourceLimits currentResourceLimits) {\n-    User user \u003d getUser(userName);\n+    try {\n+      readLock.lock();\n+      User user \u003d getUser(userName);\n \n-    currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n+      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n \n-    // Note: We aren\u0027t considering the current request since there is a fixed\n-    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n-    if (Resources\n-        .greaterThan(resourceCalculator, clusterResource,\n-            user.getUsed(nodePartition),\n-            limit)) {\n-      // if enabled, check to see if could we potentially use this node instead\n-      // of a reserved node if the application has reserved containers\n-      if (this.reservationsContinueLooking \u0026\u0026\n-          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n-        if (Resources.lessThanOrEqual(\n-            resourceCalculator,\n-            clusterResource,\n-            Resources.subtract(user.getUsed(),\n-                application.getCurrentReservation()), limit)) {\n+      // Note: We aren\u0027t considering the current request since there is a fixed\n+      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n+      if (Resources.greaterThan(resourceCalculator, clusterResource,\n+          user.getUsed(nodePartition), limit)) {\n+        // if enabled, check to see if could we potentially use this node instead\n+        // of a reserved node if the application has reserved containers\n+        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n+            CommonNodeLabelsManager.NO_LABEL)) {\n+          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n+              Resources.subtract(user.getUsed(),\n+                  application.getCurrentReservation()), limit)) {\n \n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n-                + \" will exceed limit based on reservations - \" + \" consumed: \"\n-                + user.getUsed() + \" reserved: \"\n-                + application.getCurrentReservation() + \" limit: \" + limit);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+                  + \" will exceed limit based on reservations - \"\n+                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n+                  .getCurrentReservation() + \" limit: \" + limit);\n+            }\n+            Resource amountNeededToUnreserve \u003d Resources.subtract(\n+                user.getUsed(nodePartition), limit);\n+            // we can only acquire a new container if we unreserve first to\n+            // respect user-limit\n+            currentResourceLimits.setAmountNeededUnreserve(\n+                amountNeededToUnreserve);\n+            return true;\n           }\n-          Resource amountNeededToUnreserve \u003d\n-              Resources.subtract(user.getUsed(nodePartition), limit);\n-          // we can only acquire a new container if we unreserve first to\n-          // respect user-limit\n-          currentResourceLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n-          return true;\n         }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+              + \" will exceed limit - \" + \" consumed: \" + user\n+              .getUsed(nodePartition) + \" limit: \" + limit);\n+        }\n+        return false;\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n-            + \" will exceed limit - \" + \" consumed: \"\n-            + user.getUsed(nodePartition) + \" limit: \" + limit);\n-      }\n-      return false;\n+      return true;\n+    } finally {\n+      readLock.unlock();\n     }\n-    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n    try {\n      readLock.lock();\n      User user \u003d getUser(userName);\n\n      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n      // Note: We aren\u0027t considering the current request since there is a fixed\n      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          user.getUsed(nodePartition), limit)) {\n        // if enabled, check to see if could we potentially use this node instead\n        // of a reserved node if the application has reserved containers\n        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n            CommonNodeLabelsManager.NO_LABEL)) {\n          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n              Resources.subtract(user.getUsed(),\n                  application.getCurrentReservation()), limit)) {\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                  + \" will exceed limit based on reservations - \"\n                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                  .getCurrentReservation() + \" limit: \" + limit);\n            }\n            Resource amountNeededToUnreserve \u003d Resources.subtract(\n                user.getUsed(nodePartition), limit);\n            // we can only acquire a new container if we unreserve first to\n            // respect user-limit\n            currentResourceLimits.setAmountNeededUnreserve(\n                amountNeededToUnreserve);\n            return true;\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n              + \" will exceed limit - \" + \" consumed: \" + user\n              .getUsed(nodePartition) + \" limit: \" + limit);\n        }\n        return false;\n      }\n      return true;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[protected, synchronized]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,48 @@\n-  protected synchronized boolean canAssignToUser(Resource clusterResource,\n+  protected boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       String nodePartition, ResourceLimits currentResourceLimits) {\n-    User user \u003d getUser(userName);\n+    try {\n+      readLock.lock();\n+      User user \u003d getUser(userName);\n \n-    currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n+      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n \n-    // Note: We aren\u0027t considering the current request since there is a fixed\n-    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n-    if (Resources\n-        .greaterThan(resourceCalculator, clusterResource,\n-            user.getUsed(nodePartition),\n-            limit)) {\n-      // if enabled, check to see if could we potentially use this node instead\n-      // of a reserved node if the application has reserved containers\n-      if (this.reservationsContinueLooking \u0026\u0026\n-          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n-        if (Resources.lessThanOrEqual(\n-            resourceCalculator,\n-            clusterResource,\n-            Resources.subtract(user.getUsed(),\n-                application.getCurrentReservation()), limit)) {\n+      // Note: We aren\u0027t considering the current request since there is a fixed\n+      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n+      if (Resources.greaterThan(resourceCalculator, clusterResource,\n+          user.getUsed(nodePartition), limit)) {\n+        // if enabled, check to see if could we potentially use this node instead\n+        // of a reserved node if the application has reserved containers\n+        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n+            CommonNodeLabelsManager.NO_LABEL)) {\n+          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n+              Resources.subtract(user.getUsed(),\n+                  application.getCurrentReservation()), limit)) {\n \n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n-                + \" will exceed limit based on reservations - \" + \" consumed: \"\n-                + user.getUsed() + \" reserved: \"\n-                + application.getCurrentReservation() + \" limit: \" + limit);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+                  + \" will exceed limit based on reservations - \"\n+                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n+                  .getCurrentReservation() + \" limit: \" + limit);\n+            }\n+            Resource amountNeededToUnreserve \u003d Resources.subtract(\n+                user.getUsed(nodePartition), limit);\n+            // we can only acquire a new container if we unreserve first to\n+            // respect user-limit\n+            currentResourceLimits.setAmountNeededUnreserve(\n+                amountNeededToUnreserve);\n+            return true;\n           }\n-          Resource amountNeededToUnreserve \u003d\n-              Resources.subtract(user.getUsed(nodePartition), limit);\n-          // we can only acquire a new container if we unreserve first to\n-          // respect user-limit\n-          currentResourceLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n-          return true;\n         }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+              + \" will exceed limit - \" + \" consumed: \" + user\n+              .getUsed(nodePartition) + \" limit: \" + limit);\n+        }\n+        return false;\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n-            + \" will exceed limit - \" + \" consumed: \"\n-            + user.getUsed(nodePartition) + \" limit: \" + limit);\n-      }\n-      return false;\n+      return true;\n+    } finally {\n+      readLock.unlock();\n     }\n-    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n    try {\n      readLock.lock();\n      User user \u003d getUser(userName);\n\n      currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n      // Note: We aren\u0027t considering the current request since there is a fixed\n      // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n      if (Resources.greaterThan(resourceCalculator, clusterResource,\n          user.getUsed(nodePartition), limit)) {\n        // if enabled, check to see if could we potentially use this node instead\n        // of a reserved node if the application has reserved containers\n        if (this.reservationsContinueLooking \u0026\u0026 nodePartition.equals(\n            CommonNodeLabelsManager.NO_LABEL)) {\n          if (Resources.lessThanOrEqual(resourceCalculator, clusterResource,\n              Resources.subtract(user.getUsed(),\n                  application.getCurrentReservation()), limit)) {\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                  + \" will exceed limit based on reservations - \"\n                  + \" consumed: \" + user.getUsed() + \" reserved: \" + application\n                  .getCurrentReservation() + \" limit: \" + limit);\n            }\n            Resource amountNeededToUnreserve \u003d Resources.subtract(\n                user.getUsed(nodePartition), limit);\n            // we can only acquire a new container if we unreserve first to\n            // respect user-limit\n            currentResourceLimits.setAmountNeededUnreserve(\n                amountNeededToUnreserve);\n            return true;\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n              + \" will exceed limit - \" + \" consumed: \" + user\n              .getUsed(nodePartition) + \" limit: \" + limit);\n        }\n        return false;\n      }\n      return true;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "468a53b22f4ac5bb079dff986ba849a687d709fe": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4610. Reservations continue looking for one app causes other apps to starve. Contributed by Jason Lowe\n",
      "commitDate": "21/01/16 10:31 AM",
      "commitName": "468a53b22f4ac5bb079dff986ba849a687d709fe",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4610. Reservations continue looking for one app causes other apps to starve. Contributed by Jason Lowe\n",
          "commitDate": "21/01/16 10:31 AM",
          "commitName": "468a53b22f4ac5bb079dff986ba849a687d709fe",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "17/01/16 7:11 PM",
          "commitNameOld": "b08ecf5c7589b055e93b2907413213f36097724d",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.64,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,46 @@\n   protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      String nodePartition, ResourceLimits currentResoureLimits) {\n+      String nodePartition, ResourceLimits currentResourceLimits) {\n     User user \u003d getUser(userName);\n \n+    currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n+\n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n             user.getUsed(nodePartition),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026\n           nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n             Resources.subtract(user.getUsed(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           Resource amountNeededToUnreserve \u003d\n               Resources.subtract(user.getUsed(nodePartition), limit);\n           // we can only acquire a new container if we unreserve first to\n           // respect user-limit\n-          currentResoureLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n+          currentResourceLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n             + user.getUsed(nodePartition) + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n    User user \u003d getUser(userName);\n\n    currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(nodePartition),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026\n          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          Resource amountNeededToUnreserve \u003d\n              Resources.subtract(user.getUsed(nodePartition), limit);\n          // we can only acquire a new container if we unreserve first to\n          // respect user-limit\n          currentResourceLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed(nodePartition) + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, nodePartition-String, currentResoureLimits-ResourceLimits]",
            "newValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, nodePartition-String, currentResourceLimits-ResourceLimits]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4610. Reservations continue looking for one app causes other apps to starve. Contributed by Jason Lowe\n",
          "commitDate": "21/01/16 10:31 AM",
          "commitName": "468a53b22f4ac5bb079dff986ba849a687d709fe",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "17/01/16 7:11 PM",
          "commitNameOld": "b08ecf5c7589b055e93b2907413213f36097724d",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.64,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,46 @@\n   protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      String nodePartition, ResourceLimits currentResoureLimits) {\n+      String nodePartition, ResourceLimits currentResourceLimits) {\n     User user \u003d getUser(userName);\n \n+    currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n+\n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n             user.getUsed(nodePartition),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026\n           nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n             Resources.subtract(user.getUsed(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           Resource amountNeededToUnreserve \u003d\n               Resources.subtract(user.getUsed(nodePartition), limit);\n           // we can only acquire a new container if we unreserve first to\n           // respect user-limit\n-          currentResoureLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n+          currentResourceLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n             + user.getUsed(nodePartition) + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResourceLimits) {\n    User user \u003d getUser(userName);\n\n    currentResourceLimits.setAmountNeededUnreserve(Resources.none());\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(nodePartition),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026\n          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          Resource amountNeededToUnreserve \u003d\n              Resources.subtract(user.getUsed(nodePartition), limit);\n          // we can only acquire a new container if we unreserve first to\n          // respect user-limit\n          currentResourceLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed(nodePartition) + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
      "commitDate": "24/07/15 2:00 PM",
      "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/07/15 11:54 AM",
      "commitNameOld": "76ec26de8099dc48ce3812c595b7ab857a600442",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,44 @@\n   protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       String nodePartition, ResourceLimits currentResoureLimits) {\n     User user \u003d getUser(userName);\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n             user.getUsed(nodePartition),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026\n           nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n-            Resources.subtract(user.getUsed(),application.getCurrentReservation()),\n-            limit)) {\n+            Resources.subtract(user.getUsed(),\n+                application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n-          Resource amountNeededToUnreserve \u003d Resources.subtract(user.getUsed(nodePartition), limit);\n-          // we can only acquire a new container if we unreserve first since we ignored the\n-          // user limit. Choose the max of user limit or what was previously set by max\n-          // capacity.\n-          currentResoureLimits.setAmountNeededUnreserve(\n-              Resources.max(resourceCalculator, clusterResource,\n-                  currentResoureLimits.getAmountNeededUnreserve(), amountNeededToUnreserve));\n+          Resource amountNeededToUnreserve \u003d\n+              Resources.subtract(user.getUsed(nodePartition), limit);\n+          // we can only acquire a new container if we unreserve first to\n+          // respect user-limit\n+          currentResoureLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n             + user.getUsed(nodePartition) + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResoureLimits) {\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(nodePartition),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026\n          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          Resource amountNeededToUnreserve \u003d\n              Resources.subtract(user.getUsed(nodePartition), limit);\n          // we can only acquire a new container if we unreserve first to\n          // respect user-limit\n          currentResoureLimits.setAmountNeededUnreserve(amountNeededToUnreserve);\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed(nodePartition) + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "189a63a719c63b67a1783a280bfc2f72dcb55277": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3434. Interaction between reservations and userlimit can result in significant ULF violation\n",
      "commitDate": "23/04/15 7:39 AM",
      "commitName": "189a63a719c63b67a1783a280bfc2f72dcb55277",
      "commitAuthor": "tgraves",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3434. Interaction between reservations and userlimit can result in significant ULF violation\n",
          "commitDate": "23/04/15 7:39 AM",
          "commitName": "189a63a719c63b67a1783a280bfc2f72dcb55277",
          "commitAuthor": "tgraves",
          "commitDateOld": "21/04/15 8:06 PM",
          "commitNameOld": "bdd90110e6904b59746812d9a093924a65e72280",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 1.48,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,46 @@\n   protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      boolean checkReservations, String nodePartition) {\n+      String nodePartition, ResourceLimits currentResoureLimits) {\n     User user \u003d getUser(userName);\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n             user.getUsed(nodePartition),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n-      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n-          \u0026\u0026 nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n+      if (this.reservationsContinueLooking \u0026\u0026\n+          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n-            Resources.subtract(user.getUsed(),\n-                application.getCurrentReservation()), limit)) {\n+            Resources.subtract(user.getUsed(),application.getCurrentReservation()),\n+            limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n+          Resource amountNeededToUnreserve \u003d Resources.subtract(user.getUsed(nodePartition), limit);\n+          // we can only acquire a new container if we unreserve first since we ignored the\n+          // user limit. Choose the max of user limit or what was previously set by max\n+          // capacity.\n+          currentResoureLimits.setAmountNeededUnreserve(\n+              Resources.max(resourceCalculator, clusterResource,\n+                  currentResoureLimits.getAmountNeededUnreserve(), amountNeededToUnreserve));\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n             + user.getUsed(nodePartition) + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResoureLimits) {\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(nodePartition),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026\n          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),application.getCurrentReservation()),\n            limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          Resource amountNeededToUnreserve \u003d Resources.subtract(user.getUsed(nodePartition), limit);\n          // we can only acquire a new container if we unreserve first since we ignored the\n          // user limit. Choose the max of user limit or what was previously set by max\n          // capacity.\n          currentResoureLimits.setAmountNeededUnreserve(\n              Resources.max(resourceCalculator, clusterResource,\n                  currentResoureLimits.getAmountNeededUnreserve(), amountNeededToUnreserve));\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed(nodePartition) + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, checkReservations-boolean, nodePartition-String]",
            "newValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, nodePartition-String, currentResoureLimits-ResourceLimits]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3434. Interaction between reservations and userlimit can result in significant ULF violation\n",
          "commitDate": "23/04/15 7:39 AM",
          "commitName": "189a63a719c63b67a1783a280bfc2f72dcb55277",
          "commitAuthor": "tgraves",
          "commitDateOld": "21/04/15 8:06 PM",
          "commitNameOld": "bdd90110e6904b59746812d9a093924a65e72280",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 1.48,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,46 @@\n   protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      boolean checkReservations, String nodePartition) {\n+      String nodePartition, ResourceLimits currentResoureLimits) {\n     User user \u003d getUser(userName);\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n             user.getUsed(nodePartition),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n-      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n-          \u0026\u0026 nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n+      if (this.reservationsContinueLooking \u0026\u0026\n+          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n-            Resources.subtract(user.getUsed(),\n-                application.getCurrentReservation()), limit)) {\n+            Resources.subtract(user.getUsed(),application.getCurrentReservation()),\n+            limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n+          Resource amountNeededToUnreserve \u003d Resources.subtract(user.getUsed(nodePartition), limit);\n+          // we can only acquire a new container if we unreserve first since we ignored the\n+          // user limit. Choose the max of user limit or what was previously set by max\n+          // capacity.\n+          currentResoureLimits.setAmountNeededUnreserve(\n+              Resources.max(resourceCalculator, clusterResource,\n+                  currentResoureLimits.getAmountNeededUnreserve(), amountNeededToUnreserve));\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n             + user.getUsed(nodePartition) + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      String nodePartition, ResourceLimits currentResoureLimits) {\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(nodePartition),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026\n          nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),application.getCurrentReservation()),\n            limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          Resource amountNeededToUnreserve \u003d Resources.subtract(user.getUsed(nodePartition), limit);\n          // we can only acquire a new container if we unreserve first since we ignored the\n          // user limit. Choose the max of user limit or what was previously set by max\n          // capacity.\n          currentResoureLimits.setAmountNeededUnreserve(\n              Resources.max(resourceCalculator, clusterResource,\n                  currentResoureLimits.getAmountNeededUnreserve(), amountNeededToUnreserve));\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed(nodePartition) + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
      "commitDate": "14/04/15 11:45 AM",
      "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,39 @@\n   protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n+      boolean checkReservations, String nodePartition) {\n     User user \u003d getUser(userName);\n-    \n-    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n-    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n-      label \u003d requestLabels.iterator().next();\n-    }\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n-            user.getUsed(label),\n+            user.getUsed(nodePartition),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n-          \u0026\u0026 label.equals(CommonNodeLabelsManager.NO_LABEL)) {\n+          \u0026\u0026 nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n             Resources.subtract(user.getUsed(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n-            + user.getUsed() + \" limit: \" + limit);\n+            + user.getUsed(nodePartition) + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations, String nodePartition) {\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(nodePartition),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n          \u0026\u0026 nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed(nodePartition) + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, checkReservations-boolean, requestLabels-Set\u003cString\u003e]",
            "newValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, checkReservations-boolean, nodePartition-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,39 @@\n   protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n+      boolean checkReservations, String nodePartition) {\n     User user \u003d getUser(userName);\n-    \n-    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n-    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n-      label \u003d requestLabels.iterator().next();\n-    }\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n-            user.getUsed(label),\n+            user.getUsed(nodePartition),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n-          \u0026\u0026 label.equals(CommonNodeLabelsManager.NO_LABEL)) {\n+          \u0026\u0026 nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n             Resources.subtract(user.getUsed(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n-            + user.getUsed() + \" limit: \" + limit);\n+            + user.getUsed(nodePartition) + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations, String nodePartition) {\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(nodePartition),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n          \u0026\u0026 nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed(nodePartition) + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "586348e4cbf197188057d6b843a6701cfffdaff3": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-3356. Capacity Scheduler FiCaSchedulerApp should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "20/03/15 1:54 PM",
      "commitName": "586348e4cbf197188057d6b843a6701cfffdaff3",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-3356. Capacity Scheduler FiCaSchedulerApp should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
          "commitDate": "20/03/15 1:54 PM",
          "commitName": "586348e4cbf197188057d6b843a6701cfffdaff3",
          "commitAuthor": "Jian He",
          "commitDateOld": "17/03/15 9:30 PM",
          "commitNameOld": "658097d6da1b1aac8e01db459f0c3b456e99652f",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 2.68,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n-  protected synchronized boolean assignToUser(Resource clusterResource,\n+  protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       boolean checkReservations, Set\u003cString\u003e requestLabels) {\n     User user \u003d getUser(userName);\n     \n     String label \u003d CommonNodeLabelsManager.NO_LABEL;\n     if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n       label \u003d requestLabels.iterator().next();\n     }\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n             user.getUsed(label),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n-      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n+      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n+          \u0026\u0026 label.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n             Resources.subtract(user.getUsed(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n             + user.getUsed() + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n    User user \u003d getUser(userName);\n    \n    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n      label \u003d requestLabels.iterator().next();\n    }\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(label),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n          \u0026\u0026 label.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "assignToUser",
            "newValue": "canAssignToUser"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3356. Capacity Scheduler FiCaSchedulerApp should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
          "commitDate": "20/03/15 1:54 PM",
          "commitName": "586348e4cbf197188057d6b843a6701cfffdaff3",
          "commitAuthor": "Jian He",
          "commitDateOld": "17/03/15 9:30 PM",
          "commitNameOld": "658097d6da1b1aac8e01db459f0c3b456e99652f",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 2.68,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n-  protected synchronized boolean assignToUser(Resource clusterResource,\n+  protected synchronized boolean canAssignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       boolean checkReservations, Set\u003cString\u003e requestLabels) {\n     User user \u003d getUser(userName);\n     \n     String label \u003d CommonNodeLabelsManager.NO_LABEL;\n     if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n       label \u003d requestLabels.iterator().next();\n     }\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n             user.getUsed(label),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n-      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n+      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n+          \u0026\u0026 label.equals(CommonNodeLabelsManager.NO_LABEL)) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n             Resources.subtract(user.getUsed(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n                 + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n             + user.getUsed() + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean canAssignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n    User user \u003d getUser(userName);\n    \n    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n      label \u003d requestLabels.iterator().next();\n    }\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(label),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations\n          \u0026\u0026 label.equals(CommonNodeLabelsManager.NO_LABEL)) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "86358221fc85a7743052a0b4c1647353508bf308": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3099. Capacity Scheduler LeafQueue/ParentQueue should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "30/01/15 3:15 PM",
      "commitName": "86358221fc85a7743052a0b4c1647353508bf308",
      "commitAuthor": "Jian He",
      "commitDateOld": "27/01/15 3:36 PM",
      "commitNameOld": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   protected synchronized boolean assignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n       boolean checkReservations, Set\u003cString\u003e requestLabels) {\n     User user \u003d getUser(userName);\n     \n     String label \u003d CommonNodeLabelsManager.NO_LABEL;\n     if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n       label \u003d requestLabels.iterator().next();\n     }\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n     if (Resources\n         .greaterThan(resourceCalculator, clusterResource,\n-            user.getConsumedResourceByLabel(label),\n+            user.getUsed(label),\n             limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n-            Resources.subtract(user.getTotalConsumedResources(),\n+            Resources.subtract(user.getUsed(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n-                + user.getTotalConsumedResources() + \" reserved: \"\n+                + user.getUsed() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n-            + user.getTotalConsumedResources() + \" limit: \" + limit);\n+            + user.getUsed() + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n    User user \u003d getUser(userName);\n    \n    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n      label \u003d requestLabels.iterator().next();\n    }\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getUsed(label),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getUsed(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getUsed() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getUsed() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,43 @@\n   protected synchronized boolean assignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      boolean checkReservations) {\n-\n+      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n     User user \u003d getUser(userName);\n+    \n+    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n+    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n+      label \u003d requestLabels.iterator().next();\n+    }\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n-    if (Resources.greaterThan(resourceCalculator, clusterResource,\n-        user.getConsumedResources(), limit)) {\n-\n+    if (Resources\n+        .greaterThan(resourceCalculator, clusterResource,\n+            user.getConsumedResourceByLabel(label),\n+            limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n-            Resources.subtract(user.getConsumedResources(),\n+            Resources.subtract(user.getTotalConsumedResources(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n-                + user.getConsumedResources() + \" reserved: \"\n+                + user.getTotalConsumedResources() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n-            + user.getConsumedResources() + \" limit: \" + limit);\n+            + user.getTotalConsumedResources() + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n    User user \u003d getUser(userName);\n    \n    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n      label \u003d requestLabels.iterator().next();\n    }\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getConsumedResourceByLabel(label),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getTotalConsumedResources(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getTotalConsumedResources() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getTotalConsumedResources() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, checkReservations-boolean]",
            "newValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, checkReservations-boolean, requestLabels-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,43 @@\n   protected synchronized boolean assignToUser(Resource clusterResource,\n       String userName, Resource limit, FiCaSchedulerApp application,\n-      boolean checkReservations) {\n-\n+      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n     User user \u003d getUser(userName);\n+    \n+    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n+    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n+      label \u003d requestLabels.iterator().next();\n+    }\n \n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n-    if (Resources.greaterThan(resourceCalculator, clusterResource,\n-        user.getConsumedResources(), limit)) {\n-\n+    if (Resources\n+        .greaterThan(resourceCalculator, clusterResource,\n+            user.getConsumedResourceByLabel(label),\n+            limit)) {\n       // if enabled, check to see if could we potentially use this node instead\n       // of a reserved node if the application has reserved containers\n       if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n         if (Resources.lessThanOrEqual(\n             resourceCalculator,\n             clusterResource,\n-            Resources.subtract(user.getConsumedResources(),\n+            Resources.subtract(user.getTotalConsumedResources(),\n                 application.getCurrentReservation()), limit)) {\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                 + \" will exceed limit based on reservations - \" + \" consumed: \"\n-                + user.getConsumedResources() + \" reserved: \"\n+                + user.getTotalConsumedResources() + \" reserved: \"\n                 + application.getCurrentReservation() + \" limit: \" + limit);\n           }\n           return true;\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n             + \" will exceed limit - \" + \" consumed: \"\n-            + user.getConsumedResources() + \" limit: \" + limit);\n+            + user.getTotalConsumedResources() + \" limit: \" + limit);\n       }\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations, Set\u003cString\u003e requestLabels) {\n    User user \u003d getUser(userName);\n    \n    String label \u003d CommonNodeLabelsManager.NO_LABEL;\n    if (requestLabels !\u003d null \u0026\u0026 !requestLabels.isEmpty()) {\n      label \u003d requestLabels.iterator().next();\n    }\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources\n        .greaterThan(resourceCalculator, clusterResource,\n            user.getConsumedResourceByLabel(label),\n            limit)) {\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getTotalConsumedResources(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getTotalConsumedResources() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getTotalConsumedResources() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "9c22065109a77681bc2534063eabe8692fbcb3cd": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
      "commitDate": "29/09/14 7:12 AM",
      "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
          "commitDate": "29/09/14 7:12 AM",
          "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "14/08/14 11:00 PM",
          "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 45.34,
          "commitsBetweenForRepo": 409,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,21 +1,38 @@\n-  private synchronized boolean assignToUser(Resource clusterResource,\n-      String userName, Resource limit) {\n+  protected synchronized boolean assignToUser(Resource clusterResource,\n+      String userName, Resource limit, FiCaSchedulerApp application,\n+      boolean checkReservations) {\n \n     User user \u003d getUser(userName);\n-    \n+\n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n-    if (Resources.greaterThan(resourceCalculator, clusterResource, \n-            user.getConsumedResources(), limit)) {\n+    if (Resources.greaterThan(resourceCalculator, clusterResource,\n+        user.getConsumedResources(), limit)) {\n+\n+      // if enabled, check to see if could we potentially use this node instead\n+      // of a reserved node if the application has reserved containers\n+      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n+        if (Resources.lessThanOrEqual(\n+            resourceCalculator,\n+            clusterResource,\n+            Resources.subtract(user.getConsumedResources(),\n+                application.getCurrentReservation()), limit)) {\n+\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+                + \" will exceed limit based on reservations - \" + \" consumed: \"\n+                + user.getConsumedResources() + \" reserved: \"\n+                + application.getCurrentReservation() + \" limit: \" + limit);\n+          }\n+          return true;\n+        }\n+      }\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n-            \" will exceed limit - \" +  \n-            \" consumed: \" + user.getConsumedResources() + \n-            \" limit: \" + limit\n-        );\n+        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+            + \" will exceed limit - \" + \" consumed: \"\n+            + user.getConsumedResources() + \" limit: \" + limit);\n       }\n       return false;\n     }\n-\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations) {\n\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources.greaterThan(resourceCalculator, clusterResource,\n        user.getConsumedResources(), limit)) {\n\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getConsumedResources(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getConsumedResources() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getConsumedResources() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, userName-String, limit-Resource]",
            "newValue": "[clusterResource-Resource, userName-String, limit-Resource, application-FiCaSchedulerApp, checkReservations-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
          "commitDate": "29/09/14 7:12 AM",
          "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "14/08/14 11:00 PM",
          "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 45.34,
          "commitsBetweenForRepo": 409,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,21 +1,38 @@\n-  private synchronized boolean assignToUser(Resource clusterResource,\n-      String userName, Resource limit) {\n+  protected synchronized boolean assignToUser(Resource clusterResource,\n+      String userName, Resource limit, FiCaSchedulerApp application,\n+      boolean checkReservations) {\n \n     User user \u003d getUser(userName);\n-    \n+\n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n-    if (Resources.greaterThan(resourceCalculator, clusterResource, \n-            user.getConsumedResources(), limit)) {\n+    if (Resources.greaterThan(resourceCalculator, clusterResource,\n+        user.getConsumedResources(), limit)) {\n+\n+      // if enabled, check to see if could we potentially use this node instead\n+      // of a reserved node if the application has reserved containers\n+      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n+        if (Resources.lessThanOrEqual(\n+            resourceCalculator,\n+            clusterResource,\n+            Resources.subtract(user.getConsumedResources(),\n+                application.getCurrentReservation()), limit)) {\n+\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+                + \" will exceed limit based on reservations - \" + \" consumed: \"\n+                + user.getConsumedResources() + \" reserved: \"\n+                + application.getCurrentReservation() + \" limit: \" + limit);\n+          }\n+          return true;\n+        }\n+      }\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n-            \" will exceed limit - \" +  \n-            \" consumed: \" + user.getConsumedResources() + \n-            \" limit: \" + limit\n-        );\n+        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+            + \" will exceed limit - \" + \" consumed: \"\n+            + user.getConsumedResources() + \" limit: \" + limit);\n       }\n       return false;\n     }\n-\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations) {\n\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources.greaterThan(resourceCalculator, clusterResource,\n        user.getConsumedResources(), limit)) {\n\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getConsumedResources(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getConsumedResources() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getConsumedResources() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[protected, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
          "commitDate": "29/09/14 7:12 AM",
          "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "14/08/14 11:00 PM",
          "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 45.34,
          "commitsBetweenForRepo": 409,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,21 +1,38 @@\n-  private synchronized boolean assignToUser(Resource clusterResource,\n-      String userName, Resource limit) {\n+  protected synchronized boolean assignToUser(Resource clusterResource,\n+      String userName, Resource limit, FiCaSchedulerApp application,\n+      boolean checkReservations) {\n \n     User user \u003d getUser(userName);\n-    \n+\n     // Note: We aren\u0027t considering the current request since there is a fixed\n     // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n-    if (Resources.greaterThan(resourceCalculator, clusterResource, \n-            user.getConsumedResources(), limit)) {\n+    if (Resources.greaterThan(resourceCalculator, clusterResource,\n+        user.getConsumedResources(), limit)) {\n+\n+      // if enabled, check to see if could we potentially use this node instead\n+      // of a reserved node if the application has reserved containers\n+      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n+        if (Resources.lessThanOrEqual(\n+            resourceCalculator,\n+            clusterResource,\n+            Resources.subtract(user.getConsumedResources(),\n+                application.getCurrentReservation()), limit)) {\n+\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+                + \" will exceed limit based on reservations - \" + \" consumed: \"\n+                + user.getConsumedResources() + \" reserved: \"\n+                + application.getCurrentReservation() + \" limit: \" + limit);\n+          }\n+          return true;\n+        }\n+      }\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n-            \" will exceed limit - \" +  \n-            \" consumed: \" + user.getConsumedResources() + \n-            \" limit: \" + limit\n-        );\n+        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n+            + \" will exceed limit - \" + \" consumed: \"\n+            + user.getConsumedResources() + \" limit: \" + limit);\n       }\n       return false;\n     }\n-\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit, FiCaSchedulerApp application,\n      boolean checkReservations) {\n\n    User user \u003d getUser(userName);\n\n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources.greaterThan(resourceCalculator, clusterResource,\n        user.getConsumedResources(), limit)) {\n\n      // if enabled, check to see if could we potentially use this node instead\n      // of a reserved node if the application has reserved containers\n      if (this.reservationsContinueLooking \u0026\u0026 checkReservations) {\n        if (Resources.lessThanOrEqual(\n            resourceCalculator,\n            clusterResource,\n            Resources.subtract(user.getConsumedResources(),\n                application.getCurrentReservation()), limit)) {\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n                + \" will exceed limit based on reservations - \" + \" consumed: \"\n                + user.getConsumedResources() + \" reserved: \"\n                + application.getCurrentReservation() + \" limit: \" + limit);\n          }\n          return true;\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName()\n            + \" will exceed limit - \" + \" consumed: \"\n            + user.getConsumedResources() + \" limit: \" + limit);\n      }\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/01/13 9:08 PM",
          "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "07/11/12 1:56 PM",
          "commitNameOld": "fb5b96dfc324f999e8b3698288c110a1c3b71c30",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 62.3,
          "commitsBetweenForRepo": 257,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,21 @@\n-  private synchronized boolean assignToUser(String userName, Resource limit) {\n+  private synchronized boolean assignToUser(Resource clusterResource,\n+      String userName, Resource limit) {\n \n     User user \u003d getUser(userName);\n     \n     // Note: We aren\u0027t considering the current request since there is a fixed\n-    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so... \n-    if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n+    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n+    if (Resources.greaterThan(resourceCalculator, clusterResource, \n+            user.getConsumedResources(), limit)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n             \" will exceed limit - \" +  \n             \" consumed: \" + user.getConsumedResources() + \n             \" limit: \" + limit\n         );\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit) {\n\n    User user \u003d getUser(userName);\n    \n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources.greaterThan(resourceCalculator, clusterResource, \n            user.getConsumedResources(), limit)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n            \" will exceed limit - \" +  \n            \" consumed: \" + user.getConsumedResources() + \n            \" limit: \" + limit\n        );\n      }\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[userName-String, limit-Resource]",
            "newValue": "[clusterResource-Resource, userName-String, limit-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/01/13 9:08 PM",
          "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "07/11/12 1:56 PM",
          "commitNameOld": "fb5b96dfc324f999e8b3698288c110a1c3b71c30",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 62.3,
          "commitsBetweenForRepo": 257,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,21 @@\n-  private synchronized boolean assignToUser(String userName, Resource limit) {\n+  private synchronized boolean assignToUser(Resource clusterResource,\n+      String userName, Resource limit) {\n \n     User user \u003d getUser(userName);\n     \n     // Note: We aren\u0027t considering the current request since there is a fixed\n-    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so... \n-    if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n+    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n+    if (Resources.greaterThan(resourceCalculator, clusterResource, \n+            user.getConsumedResources(), limit)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n             \" will exceed limit - \" +  \n             \" consumed: \" + user.getConsumedResources() + \n             \" limit: \" + limit\n         );\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized boolean assignToUser(Resource clusterResource,\n      String userName, Resource limit) {\n\n    User user \u003d getUser(userName);\n    \n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so...\n    if (Resources.greaterThan(resourceCalculator, clusterResource, \n            user.getConsumedResources(), limit)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n            \" will exceed limit - \" +  \n            \" consumed: \" + user.getConsumedResources() + \n            \" limit: \" + limit\n        );\n      }\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized boolean assignToUser(String userName, Resource limit) {\n\n    User user \u003d getUser(userName);\n    \n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so... \n    if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n            \" will exceed limit - \" +  \n            \" consumed: \" + user.getConsumedResources() + \n            \" limit: \" + limit\n        );\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "21c9116309d8482e7e28522cd7386e65415b15e9": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3713. Fixed the way head-room is allocated to applications by CapacityScheduler so that it deducts current-usage per user and not per-application. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235989 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 3:31 PM",
      "commitName": "21c9116309d8482e7e28522cd7386e65415b15e9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/01/12 10:17 AM",
      "commitNameOld": "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n   private synchronized boolean assignToUser(String userName, Resource limit) {\n \n     User user \u003d getUser(userName);\n     \n     // Note: We aren\u0027t considering the current request since there is a fixed\n-    // overhead of the AM, but it\u0027s a \u003e\u003d check, so... \n+    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so... \n     if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n             \" will exceed limit - \" +  \n             \" consumed: \" + user.getConsumedResources() + \n             \" limit: \" + limit\n         );\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized boolean assignToUser(String userName, Resource limit) {\n\n    User user \u003d getUser(userName);\n    \n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e check, not a \u003e\u003d check, so... \n    if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n            \" will exceed limit - \" +  \n            \" consumed: \" + user.getConsumedResources() + \n            \" limit: \" + limit\n        );\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized boolean assignToUser(String userName, Resource limit) {\n\n    User user \u003d getUser(userName);\n    \n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e\u003d check, so... \n    if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n            \" will exceed limit - \" +  \n            \" consumed: \" + user.getConsumedResources() + \n            \" limit: \" + limit\n        );\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,19 @@\n+  private synchronized boolean assignToUser(String userName, Resource limit) {\n+\n+    User user \u003d getUser(userName);\n+    \n+    // Note: We aren\u0027t considering the current request since there is a fixed\n+    // overhead of the AM, but it\u0027s a \u003e\u003d check, so... \n+    if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n+            \" will exceed limit - \" +  \n+            \" consumed: \" + user.getConsumedResources() + \n+            \" limit: \" + limit\n+        );\n+      }\n+      return false;\n+    }\n+\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized boolean assignToUser(String userName, Resource limit) {\n\n    User user \u003d getUser(userName);\n    \n    // Note: We aren\u0027t considering the current request since there is a fixed\n    // overhead of the AM, but it\u0027s a \u003e\u003d check, so... \n    if ((user.getConsumedResources().getMemory()) \u003e limit.getMemory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + userName + \" in queue \" + getQueueName() + \n            \" will exceed limit - \" +  \n            \" consumed: \" + user.getConsumedResources() + \n            \" limit: \" + limit\n        );\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
    }
  }
}