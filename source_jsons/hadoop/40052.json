{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacitySchedulerConfiguration.java",
  "functionName": "getAppOrderingPolicy",
  "functionId": "getAppOrderingPolicy___queue-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java",
  "functionStartLine": 577,
  "functionEndLine": 615,
  "numCommitsSeen": 141,
  "timeTaken": 4962,
  "changeHistory": [
    "d462308e0476053d1aae65eca2752eacce797e22",
    "c2731d4b6399f88f76341ed697e80652ed1b61ea",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "395205444e8a9ae6fc86f0a441e98486a775511a",
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5"
  ],
  "changeHistoryShort": {
    "d462308e0476053d1aae65eca2752eacce797e22": "Ybodychange",
    "c2731d4b6399f88f76341ed697e80652ed1b61ea": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ymultichange(Yrename,Ybodychange)",
    "395205444e8a9ae6fc86f0a441e98486a775511a": "Ybodychange",
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d462308e0476053d1aae65eca2752eacce797e22": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9949. Add missing queue configs for root queue in RMWebService#CapacitySchedulerInfo. Contributed by Prabhu Joseph.\n",
      "commitDate": "02/11/19 8:17 PM",
      "commitName": "d462308e0476053d1aae65eca2752eacce797e22",
      "commitAuthor": "Sunil G",
      "commitDateOld": "08/10/19 11:20 AM",
      "commitNameOld": "5462d2176f7a64b236f06700cd247f946798cb26",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 25.37,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,39 @@\n   public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n       String queue) {\n   \n     String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n         DEFAULT_APP_ORDERING_POLICY);\n     \n     OrderingPolicy\u003cS\u003e orderingPolicy;\n     \n     if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n        policyType \u003d FifoOrderingPolicy.class.getName();\n     }\n     if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n        policyType \u003d FairOrderingPolicy.class.getName();\n     }\n     if (policyType.trim().equals(FIFO_WITH_PARTITIONS_APP_ORDERING_POLICY)) {\n       policyType \u003d FifoOrderingPolicyWithExclusivePartitions.class.getName();\n     }\n+    if (policyType.trim().equals(FIFO_FOR_PENDING_APPS)) {\n+      policyType \u003d FifoOrderingPolicyForPendingApps.class.getName();\n+    }\n+\n     try {\n       orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n         Class.forName(policyType).newInstance();\n     } catch (Exception e) {\n       String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n       throw new RuntimeException(message, e);\n     }\n \n     Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n     String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n     for (Map.Entry\u003cString, String\u003e kv : this) {\n       if (kv.getKey().startsWith(confPrefix)) {\n          config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n       }\n     }\n     orderingPolicy.configure(config);\n     return orderingPolicy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n      String queue) {\n  \n    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n        DEFAULT_APP_ORDERING_POLICY);\n    \n    OrderingPolicy\u003cS\u003e orderingPolicy;\n    \n    if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n       policyType \u003d FifoOrderingPolicy.class.getName();\n    }\n    if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n       policyType \u003d FairOrderingPolicy.class.getName();\n    }\n    if (policyType.trim().equals(FIFO_WITH_PARTITIONS_APP_ORDERING_POLICY)) {\n      policyType \u003d FifoOrderingPolicyWithExclusivePartitions.class.getName();\n    }\n    if (policyType.trim().equals(FIFO_FOR_PENDING_APPS)) {\n      policyType \u003d FifoOrderingPolicyForPendingApps.class.getName();\n    }\n\n    try {\n      orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n        Class.forName(policyType).newInstance();\n    } catch (Exception e) {\n      String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n      throw new RuntimeException(message, e);\n    }\n\n    Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n    String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n    for (Map.Entry\u003cString, String\u003e kv : this) {\n      if (kv.getKey().startsWith(confPrefix)) {\n         config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n      }\n    }\n    orderingPolicy.configure(config);\n    return orderingPolicy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java",
      "extendedDetails": {}
    },
    "c2731d4b6399f88f76341ed697e80652ed1b61ea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9730. Support forcing configured partitions to be exclusive based on app node label\n",
      "commitDate": "24/09/19 1:51 PM",
      "commitName": "c2731d4b6399f88f76341ed697e80652ed1b61ea",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "10/09/19 3:19 PM",
      "commitNameOld": "f8f8598ea5e86330fa5b553963f5632da286409d",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 13.94,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,35 @@\n   public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n       String queue) {\n   \n     String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n         DEFAULT_APP_ORDERING_POLICY);\n     \n     OrderingPolicy\u003cS\u003e orderingPolicy;\n     \n     if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n        policyType \u003d FifoOrderingPolicy.class.getName();\n     }\n     if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n        policyType \u003d FairOrderingPolicy.class.getName();\n     }\n+    if (policyType.trim().equals(FIFO_WITH_PARTITIONS_APP_ORDERING_POLICY)) {\n+      policyType \u003d FifoOrderingPolicyWithExclusivePartitions.class.getName();\n+    }\n     try {\n       orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n         Class.forName(policyType).newInstance();\n     } catch (Exception e) {\n       String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n       throw new RuntimeException(message, e);\n     }\n \n     Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n     String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n     for (Map.Entry\u003cString, String\u003e kv : this) {\n       if (kv.getKey().startsWith(confPrefix)) {\n          config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n       }\n     }\n     orderingPolicy.configure(config);\n     return orderingPolicy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n      String queue) {\n  \n    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n        DEFAULT_APP_ORDERING_POLICY);\n    \n    OrderingPolicy\u003cS\u003e orderingPolicy;\n    \n    if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n       policyType \u003d FifoOrderingPolicy.class.getName();\n    }\n    if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n       policyType \u003d FairOrderingPolicy.class.getName();\n    }\n    if (policyType.trim().equals(FIFO_WITH_PARTITIONS_APP_ORDERING_POLICY)) {\n      policyType \u003d FifoOrderingPolicyWithExclusivePartitions.class.getName();\n    }\n    try {\n      orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n        Class.forName(policyType).newInstance();\n    } catch (Exception e) {\n      String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n      throw new RuntimeException(message, e);\n    }\n\n    Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n    String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n    for (Map.Entry\u003cString, String\u003e kv : this) {\n      if (kv.getKey().startsWith(confPrefix)) {\n         config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n      }\n    }\n    orderingPolicy.configure(config);\n    return orderingPolicy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
          "commitDate": "23/01/17 10:52 AM",
          "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/01/17 8:40 AM",
          "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 14.09,
          "commitsBetweenForRepo": 81,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,32 @@\n-  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getOrderingPolicy(\n+  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n       String queue) {\n   \n-    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY, \n-      DEFAULT_ORDERING_POLICY);\n+    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n+        DEFAULT_APP_ORDERING_POLICY);\n     \n     OrderingPolicy\u003cS\u003e orderingPolicy;\n     \n-    if (policyType.trim().equals(FIFO_ORDERING_POLICY)) {\n+    if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n        policyType \u003d FifoOrderingPolicy.class.getName();\n     }\n-    if (policyType.trim().equals(FAIR_ORDERING_POLICY)) {\n+    if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n        policyType \u003d FairOrderingPolicy.class.getName();\n     }\n     try {\n       orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n         Class.forName(policyType).newInstance();\n     } catch (Exception e) {\n       String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n       throw new RuntimeException(message, e);\n     }\n \n     Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n     String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n     for (Map.Entry\u003cString, String\u003e kv : this) {\n       if (kv.getKey().startsWith(confPrefix)) {\n          config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n       }\n     }\n     orderingPolicy.configure(config);\n     return orderingPolicy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n      String queue) {\n  \n    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n        DEFAULT_APP_ORDERING_POLICY);\n    \n    OrderingPolicy\u003cS\u003e orderingPolicy;\n    \n    if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n       policyType \u003d FifoOrderingPolicy.class.getName();\n    }\n    if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n       policyType \u003d FairOrderingPolicy.class.getName();\n    }\n    try {\n      orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n        Class.forName(policyType).newInstance();\n    } catch (Exception e) {\n      String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n      throw new RuntimeException(message, e);\n    }\n\n    Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n    String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n    for (Map.Entry\u003cString, String\u003e kv : this) {\n      if (kv.getKey().startsWith(confPrefix)) {\n         config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n      }\n    }\n    orderingPolicy.configure(config);\n    return orderingPolicy;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java",
          "extendedDetails": {
            "oldValue": "getOrderingPolicy",
            "newValue": "getAppOrderingPolicy"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
          "commitDate": "23/01/17 10:52 AM",
          "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/01/17 8:40 AM",
          "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 14.09,
          "commitsBetweenForRepo": 81,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,32 @@\n-  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getOrderingPolicy(\n+  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n       String queue) {\n   \n-    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY, \n-      DEFAULT_ORDERING_POLICY);\n+    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n+        DEFAULT_APP_ORDERING_POLICY);\n     \n     OrderingPolicy\u003cS\u003e orderingPolicy;\n     \n-    if (policyType.trim().equals(FIFO_ORDERING_POLICY)) {\n+    if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n        policyType \u003d FifoOrderingPolicy.class.getName();\n     }\n-    if (policyType.trim().equals(FAIR_ORDERING_POLICY)) {\n+    if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n        policyType \u003d FairOrderingPolicy.class.getName();\n     }\n     try {\n       orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n         Class.forName(policyType).newInstance();\n     } catch (Exception e) {\n       String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n       throw new RuntimeException(message, e);\n     }\n \n     Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n     String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n     for (Map.Entry\u003cString, String\u003e kv : this) {\n       if (kv.getKey().startsWith(confPrefix)) {\n          config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n       }\n     }\n     orderingPolicy.configure(config);\n     return orderingPolicy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getAppOrderingPolicy(\n      String queue) {\n  \n    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY,\n        DEFAULT_APP_ORDERING_POLICY);\n    \n    OrderingPolicy\u003cS\u003e orderingPolicy;\n    \n    if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {\n       policyType \u003d FifoOrderingPolicy.class.getName();\n    }\n    if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {\n       policyType \u003d FairOrderingPolicy.class.getName();\n    }\n    try {\n      orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n        Class.forName(policyType).newInstance();\n    } catch (Exception e) {\n      String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n      throw new RuntimeException(message, e);\n    }\n\n    Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n    String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n    for (Map.Entry\u003cString, String\u003e kv : this) {\n      if (kv.getKey().startsWith(confPrefix)) {\n         config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n      }\n    }\n    orderingPolicy.configure(config);\n    return orderingPolicy;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java",
          "extendedDetails": {}
        }
      ]
    },
    "395205444e8a9ae6fc86f0a441e98486a775511a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3319. Implement a FairOrderingPolicy. (Craig Welch via wangda)\n",
      "commitDate": "23/04/15 10:47 AM",
      "commitName": "395205444e8a9ae6fc86f0a441e98486a775511a",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "20/04/15 5:12 PM",
      "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.73,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,32 @@\n   public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getOrderingPolicy(\n       String queue) {\n   \n     String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY, \n       DEFAULT_ORDERING_POLICY);\n     \n     OrderingPolicy\u003cS\u003e orderingPolicy;\n     \n-    if (policyType.trim().equals(\"fifo\")) {\n+    if (policyType.trim().equals(FIFO_ORDERING_POLICY)) {\n        policyType \u003d FifoOrderingPolicy.class.getName();\n     }\n+    if (policyType.trim().equals(FAIR_ORDERING_POLICY)) {\n+       policyType \u003d FairOrderingPolicy.class.getName();\n+    }\n     try {\n       orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n         Class.forName(policyType).newInstance();\n     } catch (Exception e) {\n       String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n       throw new RuntimeException(message, e);\n     }\n+\n+    Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n+    String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n+    for (Map.Entry\u003cString, String\u003e kv : this) {\n+      if (kv.getKey().startsWith(confPrefix)) {\n+         config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n+      }\n+    }\n+    orderingPolicy.configure(config);\n     return orderingPolicy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getOrderingPolicy(\n      String queue) {\n  \n    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY, \n      DEFAULT_ORDERING_POLICY);\n    \n    OrderingPolicy\u003cS\u003e orderingPolicy;\n    \n    if (policyType.trim().equals(FIFO_ORDERING_POLICY)) {\n       policyType \u003d FifoOrderingPolicy.class.getName();\n    }\n    if (policyType.trim().equals(FAIR_ORDERING_POLICY)) {\n       policyType \u003d FairOrderingPolicy.class.getName();\n    }\n    try {\n      orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n        Class.forName(policyType).newInstance();\n    } catch (Exception e) {\n      String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n      throw new RuntimeException(message, e);\n    }\n\n    Map\u003cString, String\u003e config \u003d new HashMap\u003cString, String\u003e();\n    String confPrefix \u003d getQueuePrefix(queue) + ORDERING_POLICY + \".\";\n    for (Map.Entry\u003cString, String\u003e kv : this) {\n      if (kv.getKey().startsWith(confPrefix)) {\n         config.put(kv.getKey().substring(confPrefix.length()), kv.getValue());\n      }\n    }\n    orderingPolicy.configure(config);\n    return orderingPolicy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java",
      "extendedDetails": {}
    },
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3463. Integrate OrderingPolicy Framework with CapacityScheduler. (Craig Welch via wangda)\n",
      "commitDate": "20/04/15 5:12 PM",
      "commitName": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,20 @@\n+  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getOrderingPolicy(\n+      String queue) {\n+  \n+    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY, \n+      DEFAULT_ORDERING_POLICY);\n+    \n+    OrderingPolicy\u003cS\u003e orderingPolicy;\n+    \n+    if (policyType.trim().equals(\"fifo\")) {\n+       policyType \u003d FifoOrderingPolicy.class.getName();\n+    }\n+    try {\n+      orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n+        Class.forName(policyType).newInstance();\n+    } catch (Exception e) {\n+      String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n+      throw new RuntimeException(message, e);\n+    }\n+    return orderingPolicy;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cS extends SchedulableEntity\u003e OrderingPolicy\u003cS\u003e getOrderingPolicy(\n      String queue) {\n  \n    String policyType \u003d get(getQueuePrefix(queue) + ORDERING_POLICY, \n      DEFAULT_ORDERING_POLICY);\n    \n    OrderingPolicy\u003cS\u003e orderingPolicy;\n    \n    if (policyType.trim().equals(\"fifo\")) {\n       policyType \u003d FifoOrderingPolicy.class.getName();\n    }\n    try {\n      orderingPolicy \u003d (OrderingPolicy\u003cS\u003e)\n        Class.forName(policyType).newInstance();\n    } catch (Exception e) {\n      String message \u003d \"Unable to construct ordering policy for: \" + policyType + \", \" + e.getMessage();\n      throw new RuntimeException(message, e);\n    }\n    return orderingPolicy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java"
    }
  }
}