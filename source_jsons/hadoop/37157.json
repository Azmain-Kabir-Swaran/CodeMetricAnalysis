{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StageExecutionIntervalByDemand.java",
  "functionName": "computeExecutionInterval",
  "functionId": "computeExecutionInterval___plan-Plan__reservation-ReservationDefinition__currentReservationStage-ReservationRequest__allocateLeft-boolean__allocations-RLESparseResourceAllocation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageExecutionIntervalByDemand.java",
  "functionStartLine": 45,
  "functionEndLine": 125,
  "numCommitsSeen": 1,
  "timeTaken": 904,
  "changeHistory": [
    "a3a615eeab8c14ccdc548311097e62a916963dc5"
  ],
  "changeHistoryShort": {
    "a3a615eeab8c14ccdc548311097e62a916963dc5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a3a615eeab8c14ccdc548311097e62a916963dc5": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
      "commitDate": "01/05/17 4:01 PM",
      "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,81 @@\n+  public ReservationInterval computeExecutionInterval(Plan plan,\n+      ReservationDefinition reservation,\n+      ReservationRequest currentReservationStage, boolean allocateLeft,\n+      RLESparseResourceAllocation allocations) {\n+\n+    // Use StageExecutionIntervalUnconstrained to get the maximal interval\n+    ReservationInterval maxInterval \u003d\n+        (new StageExecutionIntervalUnconstrained()).computeExecutionInterval(\n+            plan, reservation, currentReservationStage, allocateLeft,\n+            allocations);\n+\n+    ReservationRequestInterpreter jobType \u003d\n+        reservation.getReservationRequests().getInterpreter();\n+\n+    // For unconstrained jobs, such as ALL \u0026 ANY, we can use the unconstrained\n+    // version\n+    if ((jobType !\u003d ReservationRequestInterpreter.R_ORDER)\n+        \u0026\u0026 (jobType !\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP)) {\n+      return maxInterval;\n+    }\n+\n+    // For ORDER and ORDER_NO_GAP, take a sub-interval of maxInterval\n+    step \u003d plan.getStep();\n+\n+    double totalWeight \u003d 0.0;\n+    long totalDuration \u003d 0;\n+\n+    // Iterate over the stages that haven\u0027t been allocated.\n+    // For allocateLeft \u003d\u003d True, we iterate in reverse order, starting from the\n+    // last\n+    // stage, until we reach the current stage.\n+    // For allocateLeft \u003d\u003d False, we do the opposite.\n+    StageProvider stageProvider \u003d new StageProvider(!allocateLeft, reservation);\n+\n+    while (stageProvider.hasNext()) {\n+      ReservationRequest rr \u003d stageProvider.next();\n+      totalWeight +\u003d calcWeight(rr);\n+      totalDuration +\u003d getRoundedDuration(rr, step);\n+\n+      // Stop once we reach current\n+      if (rr \u003d\u003d currentReservationStage) {\n+        break;\n+      }\n+    }\n+\n+    // Compute the weight of the current stage as compared to remaining ones\n+    double ratio \u003d calcWeight(currentReservationStage) / totalWeight;\n+\n+    // Estimate an early start time, such that:\n+    // 1. Every stage is guaranteed to receive at least its duration\n+    // 2. The remainder of the window is divided between stages\n+    // proportionally to its workload (total memory consumption)\n+    long maxIntervalArrival \u003d maxInterval.getStartTime();\n+    long maxIntervalDeadline \u003d maxInterval.getEndTime();\n+    long window \u003d maxIntervalDeadline - maxIntervalArrival;\n+    long windowRemainder \u003d window - totalDuration;\n+\n+    if (allocateLeft) {\n+      long latestEnd \u003d\n+          (long) (maxIntervalArrival\n+              + getRoundedDuration(currentReservationStage, step)\n+              + (windowRemainder * ratio));\n+\n+      // Realign if necessary (since we did some arithmetic)\n+      latestEnd \u003d stepRoundDown(latestEnd, step);\n+\n+      // Return new interval\n+      return new ReservationInterval(maxIntervalArrival, latestEnd);\n+    } else {\n+      long earlyStart \u003d\n+          (long) (maxIntervalDeadline\n+              - getRoundedDuration(currentReservationStage, step)\n+              - (windowRemainder * ratio));\n+\n+      // Realign if necessary (since we did some arithmetic)\n+      earlyStart \u003d stepRoundUp(earlyStart, step);\n+\n+      // Return new interval\n+      return new ReservationInterval(earlyStart, maxIntervalDeadline);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ReservationInterval computeExecutionInterval(Plan plan,\n      ReservationDefinition reservation,\n      ReservationRequest currentReservationStage, boolean allocateLeft,\n      RLESparseResourceAllocation allocations) {\n\n    // Use StageExecutionIntervalUnconstrained to get the maximal interval\n    ReservationInterval maxInterval \u003d\n        (new StageExecutionIntervalUnconstrained()).computeExecutionInterval(\n            plan, reservation, currentReservationStage, allocateLeft,\n            allocations);\n\n    ReservationRequestInterpreter jobType \u003d\n        reservation.getReservationRequests().getInterpreter();\n\n    // For unconstrained jobs, such as ALL \u0026 ANY, we can use the unconstrained\n    // version\n    if ((jobType !\u003d ReservationRequestInterpreter.R_ORDER)\n        \u0026\u0026 (jobType !\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP)) {\n      return maxInterval;\n    }\n\n    // For ORDER and ORDER_NO_GAP, take a sub-interval of maxInterval\n    step \u003d plan.getStep();\n\n    double totalWeight \u003d 0.0;\n    long totalDuration \u003d 0;\n\n    // Iterate over the stages that haven\u0027t been allocated.\n    // For allocateLeft \u003d\u003d True, we iterate in reverse order, starting from the\n    // last\n    // stage, until we reach the current stage.\n    // For allocateLeft \u003d\u003d False, we do the opposite.\n    StageProvider stageProvider \u003d new StageProvider(!allocateLeft, reservation);\n\n    while (stageProvider.hasNext()) {\n      ReservationRequest rr \u003d stageProvider.next();\n      totalWeight +\u003d calcWeight(rr);\n      totalDuration +\u003d getRoundedDuration(rr, step);\n\n      // Stop once we reach current\n      if (rr \u003d\u003d currentReservationStage) {\n        break;\n      }\n    }\n\n    // Compute the weight of the current stage as compared to remaining ones\n    double ratio \u003d calcWeight(currentReservationStage) / totalWeight;\n\n    // Estimate an early start time, such that:\n    // 1. Every stage is guaranteed to receive at least its duration\n    // 2. The remainder of the window is divided between stages\n    // proportionally to its workload (total memory consumption)\n    long maxIntervalArrival \u003d maxInterval.getStartTime();\n    long maxIntervalDeadline \u003d maxInterval.getEndTime();\n    long window \u003d maxIntervalDeadline - maxIntervalArrival;\n    long windowRemainder \u003d window - totalDuration;\n\n    if (allocateLeft) {\n      long latestEnd \u003d\n          (long) (maxIntervalArrival\n              + getRoundedDuration(currentReservationStage, step)\n              + (windowRemainder * ratio));\n\n      // Realign if necessary (since we did some arithmetic)\n      latestEnd \u003d stepRoundDown(latestEnd, step);\n\n      // Return new interval\n      return new ReservationInterval(maxIntervalArrival, latestEnd);\n    } else {\n      long earlyStart \u003d\n          (long) (maxIntervalDeadline\n              - getRoundedDuration(currentReservationStage, step)\n              - (windowRemainder * ratio));\n\n      // Realign if necessary (since we did some arithmetic)\n      earlyStart \u003d stepRoundUp(earlyStart, step);\n\n      // Return new interval\n      return new ReservationInterval(earlyStart, maxIntervalDeadline);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageExecutionIntervalByDemand.java"
    }
  }
}