{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DiffListBySkipList.java",
  "functionName": "addLast",
  "functionId": "addLast___diff-DirectoryDiff",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DiffListBySkipList.java",
  "functionStartLine": 351,
  "functionEndLine": 381,
  "numCommitsSeen": 6,
  "timeTaken": 2654,
  "changeHistory": [
    "871d0d39faa2c4c992d61ed20497dcf6c3faa376",
    "ba82e5c488ca0081534c1e40810b3f9e7da9eaad",
    "60080fbfcf3919fc155af45975fa24bdeb6c8ffe",
    "81d9446a92e3968234702b2981468a991c7cf8a0"
  ],
  "changeHistoryShort": {
    "871d0d39faa2c4c992d61ed20497dcf6c3faa376": "Ybodychange",
    "ba82e5c488ca0081534c1e40810b3f9e7da9eaad": "Yfilerename",
    "60080fbfcf3919fc155af45975fa24bdeb6c8ffe": "Ybodychange",
    "81d9446a92e3968234702b2981468a991c7cf8a0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "871d0d39faa2c4c992d61ed20497dcf6c3faa376": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13223. Reduce DiffListBySkipList memory usage.  Contributed by Shashikant Banerjee\n",
      "commitDate": "06/03/18 12:23 PM",
      "commitName": "871d0d39faa2c4c992d61ed20497dcf6c3faa376",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "02/03/18 5:47 PM",
      "commitNameOld": "ba82e5c488ca0081534c1e40810b3f9e7da9eaad",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,31 @@\n   public boolean addLast(DirectoryDiff diff) {\n-    final int nodeLevel \u003d randomLevel(skipInterval, maxSkipLevels);\n-    final int headLevel \u003d head.level();\n+    final int nodeLevel \u003d DirectoryDiffListFactory.randomLevel();\n     final SkipListNode[] nodePath \u003d findPreviousNodes(null, nodeLevel);\n-    for (int level \u003d headLevel + 1; level \u003c\u003d nodeLevel; level++) {\n-      head.skipDiffList.add(new SkipDiff(null));\n-      nodePath[level] \u003d head;\n-    }\n \n-    final SkipListNode current \u003d new SkipListNode(diff, nodeLevel);\n+    final SkipListNode newNode \u003d new SkipListNode(diff, nodeLevel);\n     for (int level \u003d 0; level \u003c\u003d nodeLevel; level++) {\n       if (level \u003e 0 \u0026\u0026 nodePath[level] !\u003d head) {\n         //  suppose the list is like:\n         //  level 2: head -\u003e  s1-----------------------------\u003eNULL\n         //  level 1: head -\u003e  s1----\u003es3\u0027------\u003es5-------------\u003eNULL\n         //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9\n \n         // case : s10 is added at the end the let the level for this node \u003d 4\n         //  in this case,\n         //  level 2: head -\u003e  s1\u0027\u0027------------------------------------\u003es10\n         //  level 1: head -\u003e  s1\u0027----\u003es3\u0027------\u003es5\u0027--------------------\u003es10\n         //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9----\u003es10\n         //  At level 1, we combine s5, s6, s7, s8, s9 and store as s5\u0027\n         //  At level 2, we combine s1\u0027, s3\u0027, s5\u0027 and form s1\u0027\u0027 and store at s1.\n-        // Note : the last element(elemnt being added) diff is not added while\n+        // Note : the last element(element being added) diff is not added while\n         // combining the diffs.\n-        ChildrenDiff combined \u003d combineDiff(nodePath[level], current, level);\n+        ChildrenDiff combined \u003d combineDiff(nodePath[level], newNode, level);\n         if (combined !\u003d null) {\n           nodePath[level].setSkipDiff(combined, level);\n         }\n       }\n-      nodePath[level].setSkipTo(current, level);\n-      current.setSkipTo(null, level);\n+      nodePath[level].setSkipTo(newNode, level);\n+      newNode.setSkipTo(null, level);\n     }\n-    return skipNodeList.add(current);\n+    return skipNodeList.add(newNode);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addLast(DirectoryDiff diff) {\n    final int nodeLevel \u003d DirectoryDiffListFactory.randomLevel();\n    final SkipListNode[] nodePath \u003d findPreviousNodes(null, nodeLevel);\n\n    final SkipListNode newNode \u003d new SkipListNode(diff, nodeLevel);\n    for (int level \u003d 0; level \u003c\u003d nodeLevel; level++) {\n      if (level \u003e 0 \u0026\u0026 nodePath[level] !\u003d head) {\n        //  suppose the list is like:\n        //  level 2: head -\u003e  s1-----------------------------\u003eNULL\n        //  level 1: head -\u003e  s1----\u003es3\u0027------\u003es5-------------\u003eNULL\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9\n\n        // case : s10 is added at the end the let the level for this node \u003d 4\n        //  in this case,\n        //  level 2: head -\u003e  s1\u0027\u0027------------------------------------\u003es10\n        //  level 1: head -\u003e  s1\u0027----\u003es3\u0027------\u003es5\u0027--------------------\u003es10\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9----\u003es10\n        //  At level 1, we combine s5, s6, s7, s8, s9 and store as s5\u0027\n        //  At level 2, we combine s1\u0027, s3\u0027, s5\u0027 and form s1\u0027\u0027 and store at s1.\n        // Note : the last element(element being added) diff is not added while\n        // combining the diffs.\n        ChildrenDiff combined \u003d combineDiff(nodePath[level], newNode, level);\n        if (combined !\u003d null) {\n          nodePath[level].setSkipDiff(combined, level);\n        }\n      }\n      nodePath[level].setSkipTo(newNode, level);\n      newNode.setSkipTo(null, level);\n    }\n    return skipNodeList.add(newNode);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DiffListBySkipList.java",
      "extendedDetails": {}
    },
    "ba82e5c488ca0081534c1e40810b3f9e7da9eaad": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13173.  Replace ArrayList with DirectoryDiffList(SnapshotSkipList) to store DirectoryDiffs.  Contributed by Shashikant Banerjee\n",
      "commitDate": "02/03/18 5:47 PM",
      "commitName": "ba82e5c488ca0081534c1e40810b3f9e7da9eaad",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "02/03/18 5:08 PM",
      "commitNameOld": "90d2bdcb752f5f32ef65765af6fd5596dd5d373b",
      "commitAuthorOld": "Andras Bokor",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean addLast(DirectoryDiff diff) {\n    final int nodeLevel \u003d randomLevel(skipInterval, maxSkipLevels);\n    final int headLevel \u003d head.level();\n    final SkipListNode[] nodePath \u003d findPreviousNodes(null, nodeLevel);\n    for (int level \u003d headLevel + 1; level \u003c\u003d nodeLevel; level++) {\n      head.skipDiffList.add(new SkipDiff(null));\n      nodePath[level] \u003d head;\n    }\n\n    final SkipListNode current \u003d new SkipListNode(diff, nodeLevel);\n    for (int level \u003d 0; level \u003c\u003d nodeLevel; level++) {\n      if (level \u003e 0 \u0026\u0026 nodePath[level] !\u003d head) {\n        //  suppose the list is like:\n        //  level 2: head -\u003e  s1-----------------------------\u003eNULL\n        //  level 1: head -\u003e  s1----\u003es3\u0027------\u003es5-------------\u003eNULL\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9\n\n        // case : s10 is added at the end the let the level for this node \u003d 4\n        //  in this case,\n        //  level 2: head -\u003e  s1\u0027\u0027------------------------------------\u003es10\n        //  level 1: head -\u003e  s1\u0027----\u003es3\u0027------\u003es5\u0027--------------------\u003es10\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9----\u003es10\n        //  At level 1, we combine s5, s6, s7, s8, s9 and store as s5\u0027\n        //  At level 2, we combine s1\u0027, s3\u0027, s5\u0027 and form s1\u0027\u0027 and store at s1.\n        // Note : the last element(elemnt being added) diff is not added while\n        // combining the diffs.\n        ChildrenDiff combined \u003d combineDiff(nodePath[level], current, level);\n        if (combined !\u003d null) {\n          nodePath[level].setSkipDiff(combined, level);\n        }\n      }\n      nodePath[level].setSkipTo(current, level);\n      current.setSkipTo(null, level);\n    }\n    return skipNodeList.add(current);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DiffListBySkipList.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryDiffList.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DiffListBySkipList.java"
      }
    },
    "60080fbfcf3919fc155af45975fa24bdeb6c8ffe": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13171. Handle Deletion of nodes in SnasphotSkipList.  Contributed by Shashikant Banerjee\n",
      "commitDate": "02/03/18 10:51 AM",
      "commitName": "60080fbfcf3919fc155af45975fa24bdeb6c8ffe",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "01/03/18 2:12 PM",
      "commitNameOld": "96e8f260ab90cc7b5a5aa2a59c182ef20a028238",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.86,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,36 @@\n   public boolean addLast(DirectoryDiff diff) {\n     final int nodeLevel \u003d randomLevel(skipInterval, maxSkipLevels);\n-    final SkipListNode[] nodePath \u003d new SkipListNode[nodeLevel + 1];\n-    SkipListNode cur \u003d head;\n     final int headLevel \u003d head.level();\n-    for (int level \u003d headLevel \u003c nodeLevel ? headLevel : nodeLevel;\n-         level \u003e\u003d 0; level--) {\n-      while (cur.getSkipNode(level) !\u003d null) {\n-        cur \u003d cur.getSkipNode(level);\n-      }\n-      nodePath[level] \u003d cur;\n-    }\n+    final SkipListNode[] nodePath \u003d findPreviousNodes(null, nodeLevel);\n     for (int level \u003d headLevel + 1; level \u003c\u003d nodeLevel; level++) {\n       head.skipDiffList.add(new SkipDiff(null));\n       nodePath[level] \u003d head;\n     }\n \n     final SkipListNode current \u003d new SkipListNode(diff, nodeLevel);\n     for (int level \u003d 0; level \u003c\u003d nodeLevel; level++) {\n       if (level \u003e 0 \u0026\u0026 nodePath[level] !\u003d head) {\n         //  suppose the list is like:\n         //  level 2: head -\u003e  s1-----------------------------\u003eNULL\n         //  level 1: head -\u003e  s1----\u003es3\u0027------\u003es5-------------\u003eNULL\n         //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9\n \n         // case : s10 is added at the end the let the level for this node \u003d 4\n         //  in this case,\n         //  level 2: head -\u003e  s1\u0027\u0027------------------------------------\u003es10\n         //  level 1: head -\u003e  s1\u0027----\u003es3\u0027------\u003es5\u0027--------------------\u003es10\n         //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9----\u003es10\n         //  At level 1, we combine s5, s6, s7, s8, s9 and store as s5\u0027\n         //  At level 2, we combine s1\u0027, s3\u0027, s5\u0027 and form s1\u0027\u0027 and store at s1.\n         // Note : the last element(elemnt being added) diff is not added while\n         // combining the diffs.\n         ChildrenDiff combined \u003d combineDiff(nodePath[level], current, level);\n         if (combined !\u003d null) {\n           nodePath[level].setSkipDiff(combined, level);\n         }\n       }\n       nodePath[level].setSkipTo(current, level);\n+      current.setSkipTo(null, level);\n     }\n     return skipNodeList.add(current);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addLast(DirectoryDiff diff) {\n    final int nodeLevel \u003d randomLevel(skipInterval, maxSkipLevels);\n    final int headLevel \u003d head.level();\n    final SkipListNode[] nodePath \u003d findPreviousNodes(null, nodeLevel);\n    for (int level \u003d headLevel + 1; level \u003c\u003d nodeLevel; level++) {\n      head.skipDiffList.add(new SkipDiff(null));\n      nodePath[level] \u003d head;\n    }\n\n    final SkipListNode current \u003d new SkipListNode(diff, nodeLevel);\n    for (int level \u003d 0; level \u003c\u003d nodeLevel; level++) {\n      if (level \u003e 0 \u0026\u0026 nodePath[level] !\u003d head) {\n        //  suppose the list is like:\n        //  level 2: head -\u003e  s1-----------------------------\u003eNULL\n        //  level 1: head -\u003e  s1----\u003es3\u0027------\u003es5-------------\u003eNULL\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9\n\n        // case : s10 is added at the end the let the level for this node \u003d 4\n        //  in this case,\n        //  level 2: head -\u003e  s1\u0027\u0027------------------------------------\u003es10\n        //  level 1: head -\u003e  s1\u0027----\u003es3\u0027------\u003es5\u0027--------------------\u003es10\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9----\u003es10\n        //  At level 1, we combine s5, s6, s7, s8, s9 and store as s5\u0027\n        //  At level 2, we combine s1\u0027, s3\u0027, s5\u0027 and form s1\u0027\u0027 and store at s1.\n        // Note : the last element(elemnt being added) diff is not added while\n        // combining the diffs.\n        ChildrenDiff combined \u003d combineDiff(nodePath[level], current, level);\n        if (combined !\u003d null) {\n          nodePath[level].setSkipDiff(combined, level);\n        }\n      }\n      nodePath[level].setSkipTo(current, level);\n      current.setSkipTo(null, level);\n    }\n    return skipNodeList.add(current);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryDiffList.java",
      "extendedDetails": {}
    },
    "81d9446a92e3968234702b2981468a991c7cf8a0": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13102. Implement SnapshotSkipList class to store Multi level DirectoryDiffs.  Contributed by Shashikant Banerjee\n",
      "commitDate": "28/02/18 1:42 PM",
      "commitName": "81d9446a92e3968234702b2981468a991c7cf8a0",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "diff": "@@ -0,0 +1,43 @@\n+  public boolean addLast(DirectoryDiff diff) {\n+    final int nodeLevel \u003d randomLevel(skipInterval, maxSkipLevels);\n+    final SkipListNode[] nodePath \u003d new SkipListNode[nodeLevel + 1];\n+    SkipListNode cur \u003d head;\n+    final int headLevel \u003d head.level();\n+    for (int level \u003d headLevel \u003c nodeLevel ? headLevel : nodeLevel;\n+         level \u003e\u003d 0; level--) {\n+      while (cur.getSkipNode(level) !\u003d null) {\n+        cur \u003d cur.getSkipNode(level);\n+      }\n+      nodePath[level] \u003d cur;\n+    }\n+    for (int level \u003d headLevel + 1; level \u003c\u003d nodeLevel; level++) {\n+      head.skipDiffList.add(new SkipDiff(null));\n+      nodePath[level] \u003d head;\n+    }\n+\n+    final SkipListNode current \u003d new SkipListNode(diff, nodeLevel);\n+    for (int level \u003d 0; level \u003c\u003d nodeLevel; level++) {\n+      if (level \u003e 0 \u0026\u0026 nodePath[level] !\u003d head) {\n+        //  suppose the list is like:\n+        //  level 2: head -\u003e  s1-----------------------------\u003eNULL\n+        //  level 1: head -\u003e  s1----\u003es3\u0027------\u003es5-------------\u003eNULL\n+        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9\n+\n+        // case : s10 is added at the end the let the level for this node \u003d 4\n+        //  in this case,\n+        //  level 2: head -\u003e  s1\u0027\u0027------------------------------------\u003es10\n+        //  level 1: head -\u003e  s1\u0027----\u003es3\u0027------\u003es5\u0027--------------------\u003es10\n+        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9----\u003es10\n+        //  At level 1, we combine s5, s6, s7, s8, s9 and store as s5\u0027\n+        //  At level 2, we combine s1\u0027, s3\u0027, s5\u0027 and form s1\u0027\u0027 and store at s1.\n+        // Note : the last element(elemnt being added) diff is not added while\n+        // combining the diffs.\n+        ChildrenDiff combined \u003d combineDiff(nodePath[level], current, level);\n+        if (combined !\u003d null) {\n+          nodePath[level].setSkipDiff(combined, level);\n+        }\n+      }\n+      nodePath[level].setSkipTo(current, level);\n+    }\n+    return skipNodeList.add(current);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addLast(DirectoryDiff diff) {\n    final int nodeLevel \u003d randomLevel(skipInterval, maxSkipLevels);\n    final SkipListNode[] nodePath \u003d new SkipListNode[nodeLevel + 1];\n    SkipListNode cur \u003d head;\n    final int headLevel \u003d head.level();\n    for (int level \u003d headLevel \u003c nodeLevel ? headLevel : nodeLevel;\n         level \u003e\u003d 0; level--) {\n      while (cur.getSkipNode(level) !\u003d null) {\n        cur \u003d cur.getSkipNode(level);\n      }\n      nodePath[level] \u003d cur;\n    }\n    for (int level \u003d headLevel + 1; level \u003c\u003d nodeLevel; level++) {\n      head.skipDiffList.add(new SkipDiff(null));\n      nodePath[level] \u003d head;\n    }\n\n    final SkipListNode current \u003d new SkipListNode(diff, nodeLevel);\n    for (int level \u003d 0; level \u003c\u003d nodeLevel; level++) {\n      if (level \u003e 0 \u0026\u0026 nodePath[level] !\u003d head) {\n        //  suppose the list is like:\n        //  level 2: head -\u003e  s1-----------------------------\u003eNULL\n        //  level 1: head -\u003e  s1----\u003es3\u0027------\u003es5-------------\u003eNULL\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9\n\n        // case : s10 is added at the end the let the level for this node \u003d 4\n        //  in this case,\n        //  level 2: head -\u003e  s1\u0027\u0027------------------------------------\u003es10\n        //  level 1: head -\u003e  s1\u0027----\u003es3\u0027------\u003es5\u0027--------------------\u003es10\n        //  level 0:head-\u003e    s1-\u003es2-\u003es3-\u003es4-\u003es5-\u003es6-\u003es7-\u003es8-\u003es9----\u003es10\n        //  At level 1, we combine s5, s6, s7, s8, s9 and store as s5\u0027\n        //  At level 2, we combine s1\u0027, s3\u0027, s5\u0027 and form s1\u0027\u0027 and store at s1.\n        // Note : the last element(elemnt being added) diff is not added while\n        // combining the diffs.\n        ChildrenDiff combined \u003d combineDiff(nodePath[level], current, level);\n        if (combined !\u003d null) {\n          nodePath[level].setSkipDiff(combined, level);\n        }\n      }\n      nodePath[level].setSkipTo(current, level);\n    }\n    return skipNodeList.add(current);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryDiffList.java"
    }
  }
}