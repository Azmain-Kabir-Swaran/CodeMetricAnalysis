{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueuePriorityContainerCandidateSelector.java",
  "functionName": "selectCandidates",
  "functionId": "selectCandidates___selectedCandidates-Map__ApplicationAttemptId,Set__RMContainer______clusterResource-Resource__totalPreemptedResourceAllowed-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
  "functionStartLine": 373,
  "functionEndLine": 495,
  "numCommitsSeen": 8,
  "timeTaken": 3554,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
    "4aae2d40a3e2e732e09b4b8a82623cacc0dc8861",
    "ce832059db077fa95922198b066a737ed4f609fe"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ybodychange",
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": "Ybodychange",
    "4aae2d40a3e2e732e09b4b8a82623cacc0dc8861": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,123 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource,\n       Resource totalPreemptedResourceAllowed) {\n     Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // Initialize digraph from queues\n     // TODO (wangda): only do this when queue refreshed.\n     priorityDigraph.clear();\n     initializePriorityDigraph();\n \n     // When all queues are set to same priority, or priority is not respected,\n     // direct return.\n     if (priorityDigraph.isEmpty()) {\n       return curCandidates;\n     }\n \n     // Save parameters to be shared by other methods\n     this.selectedCandidates \u003d selectedCandidates;\n     this.clusterResource \u003d clusterResource;\n     this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n \n     toPreemptedFromOtherQueues.clear();\n \n     reservedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Clear temp-scheduler-node-map every time when doing selection of\n     // containers.\n     tempSchedulerNodeMap.clear();\n     touchedNodes \u003d new HashSet\u003c\u003e();\n \n     // Add all reserved containers for analysis\n     List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n         preemptionContext.getScheduler().getAllNodes();\n     for (FiCaSchedulerNode node : allSchedulerNodes) {\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (null !\u003d reservedContainer) {\n         // Add to reservedContainers list if the queue that the reserved\n         // container belongs to has high priority than at least one queue\n         if (priorityDigraph.containsRow(\n             reservedContainer.getQueueName())) {\n           reservedContainers.add(reservedContainer);\n         }\n       }\n     }\n \n     // Sort reserved container by creation time\n     Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n \n     long currentTime \u003d System.currentTimeMillis();\n \n     // From the beginning of the list\n     for (RMContainer reservedContainer : reservedContainers) {\n       // Only try to preempt reserved container after reserved container created\n       // and cannot be allocated after minTimeout\n       if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n         continue;\n       }\n \n       FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n           reservedContainer.getReservedNode());\n       if (null \u003d\u003d node) {\n         // Something is wrong, ignore\n         continue;\n       }\n \n       List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n \n       // Check if we can preempt for this queue\n       // We will skip if the demanding queue is already satisfied.\n       String demandingQueueName \u003d reservedContainer.getQueueName();\n       boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n           node.getPartition());\n \n       // We will continue check if it is possible to preempt reserved container\n       // from the node.\n       boolean canPreempt \u003d false;\n       if (!demandingQueueSatisfied) {\n         canPreempt \u003d canPreemptEnoughResourceForAsked(\n             reservedContainer.getReservedResource(), demandingQueueName, node,\n             false, newlySelectedToBePreemptContainers);\n       }\n \n       // Add selected container if we can allocate reserved container by\n       // preemption others\n       if (canPreempt) {\n         touchedNodes.add(node.getNodeID());\n \n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Trying to preempt following containers to make reserved \"\n-              + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n-              + node.getNodeID() + \" can be allocated:\");\n-        }\n+        LOG.debug(\"Trying to preempt following containers to make reserved \"\n+            + \"container\u003d{} on node\u003d{} can be allocated:\",\n+            reservedContainer.getContainerId(), node.getNodeID());\n \n         // Update to-be-preempt\n         incToPreempt(demandingQueueName, node.getPartition(),\n             reservedContainer.getReservedResource());\n \n         for (RMContainer c : newlySelectedToBePreemptContainers) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n-                .getReservedResource());\n-          }\n+          LOG.debug(\" --container\u003d{} resource\u003d{}\", c.getContainerId(),\n+              c.getReservedResource());\n \n           // Add to preemptMap\n           CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n               curCandidates, c.getApplicationAttemptId(), c);\n \n           // Update totalPreemptionResourceAllowed\n           Resources.subtractFrom(totalPreemptedResourceAllowed,\n               c.getAllocatedResource());\n         }\n       } else if (!demandingQueueSatisfied) {\n         // We failed to get enough resource to allocate the container\n         // This typically happens when the reserved node is proper, will\n         // try to see if we can reserve the container on a better host.\n         // Only do this if the demanding queue is not satisfied.\n         //\n         // TODO (wangda): do more tests before making it usable\n         //\n         if (allowMoveReservation) {\n           tryToMakeBetterReservationPlacement(reservedContainer,\n               allSchedulerNodes);\n         }\n       }\n     }\n     return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // Initialize digraph from queues\n    // TODO (wangda): only do this when queue refreshed.\n    priorityDigraph.clear();\n    initializePriorityDigraph();\n\n    // When all queues are set to same priority, or priority is not respected,\n    // direct return.\n    if (priorityDigraph.isEmpty()) {\n      return curCandidates;\n    }\n\n    // Save parameters to be shared by other methods\n    this.selectedCandidates \u003d selectedCandidates;\n    this.clusterResource \u003d clusterResource;\n    this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n\n    toPreemptedFromOtherQueues.clear();\n\n    reservedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Clear temp-scheduler-node-map every time when doing selection of\n    // containers.\n    tempSchedulerNodeMap.clear();\n    touchedNodes \u003d new HashSet\u003c\u003e();\n\n    // Add all reserved containers for analysis\n    List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n        preemptionContext.getScheduler().getAllNodes();\n    for (FiCaSchedulerNode node : allSchedulerNodes) {\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (null !\u003d reservedContainer) {\n        // Add to reservedContainers list if the queue that the reserved\n        // container belongs to has high priority than at least one queue\n        if (priorityDigraph.containsRow(\n            reservedContainer.getQueueName())) {\n          reservedContainers.add(reservedContainer);\n        }\n      }\n    }\n\n    // Sort reserved container by creation time\n    Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n\n    long currentTime \u003d System.currentTimeMillis();\n\n    // From the beginning of the list\n    for (RMContainer reservedContainer : reservedContainers) {\n      // Only try to preempt reserved container after reserved container created\n      // and cannot be allocated after minTimeout\n      if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n        continue;\n      }\n\n      FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n          reservedContainer.getReservedNode());\n      if (null \u003d\u003d node) {\n        // Something is wrong, ignore\n        continue;\n      }\n\n      List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n\n      // Check if we can preempt for this queue\n      // We will skip if the demanding queue is already satisfied.\n      String demandingQueueName \u003d reservedContainer.getQueueName();\n      boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n          node.getPartition());\n\n      // We will continue check if it is possible to preempt reserved container\n      // from the node.\n      boolean canPreempt \u003d false;\n      if (!demandingQueueSatisfied) {\n        canPreempt \u003d canPreemptEnoughResourceForAsked(\n            reservedContainer.getReservedResource(), demandingQueueName, node,\n            false, newlySelectedToBePreemptContainers);\n      }\n\n      // Add selected container if we can allocate reserved container by\n      // preemption others\n      if (canPreempt) {\n        touchedNodes.add(node.getNodeID());\n\n        LOG.debug(\"Trying to preempt following containers to make reserved \"\n            + \"container\u003d{} on node\u003d{} can be allocated:\",\n            reservedContainer.getContainerId(), node.getNodeID());\n\n        // Update to-be-preempt\n        incToPreempt(demandingQueueName, node.getPartition(),\n            reservedContainer.getReservedResource());\n\n        for (RMContainer c : newlySelectedToBePreemptContainers) {\n          LOG.debug(\" --container\u003d{} resource\u003d{}\", c.getContainerId(),\n              c.getReservedResource());\n\n          // Add to preemptMap\n          CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n              curCandidates, c.getApplicationAttemptId(), c);\n\n          // Update totalPreemptionResourceAllowed\n          Resources.subtractFrom(totalPreemptedResourceAllowed,\n              c.getAllocatedResource());\n        }\n      } else if (!demandingQueueSatisfied) {\n        // We failed to get enough resource to allocate the container\n        // This typically happens when the reserved node is proper, will\n        // try to see if we can reserve the container on a better host.\n        // Only do this if the demanding queue is not satisfied.\n        //\n        // TODO (wangda): do more tests before making it usable\n        //\n        if (allowMoveReservation) {\n          tryToMakeBetterReservationPlacement(reservedContainer,\n              allSchedulerNodes);\n        }\n      }\n    }\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
      "extendedDetails": {}
    },
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "commitDateOld": "24/02/18 2:41 PM",
      "commitNameOld": "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 123.78,
      "commitsBetweenForRepo": 1508,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,127 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource,\n       Resource totalPreemptedResourceAllowed) {\n+    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // Initialize digraph from queues\n     // TODO (wangda): only do this when queue refreshed.\n     priorityDigraph.clear();\n     initializePriorityDigraph();\n \n     // When all queues are set to same priority, or priority is not respected,\n     // direct return.\n     if (priorityDigraph.isEmpty()) {\n-      return selectedCandidates;\n+      return curCandidates;\n     }\n \n     // Save parameters to be shared by other methods\n     this.selectedCandidates \u003d selectedCandidates;\n     this.clusterResource \u003d clusterResource;\n     this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n \n     toPreemptedFromOtherQueues.clear();\n \n     reservedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Clear temp-scheduler-node-map every time when doing selection of\n     // containers.\n     tempSchedulerNodeMap.clear();\n     touchedNodes \u003d new HashSet\u003c\u003e();\n \n     // Add all reserved containers for analysis\n     List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n         preemptionContext.getScheduler().getAllNodes();\n     for (FiCaSchedulerNode node : allSchedulerNodes) {\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (null !\u003d reservedContainer) {\n         // Add to reservedContainers list if the queue that the reserved\n         // container belongs to has high priority than at least one queue\n         if (priorityDigraph.containsRow(\n             reservedContainer.getQueueName())) {\n           reservedContainers.add(reservedContainer);\n         }\n       }\n     }\n \n     // Sort reserved container by creation time\n     Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n \n     long currentTime \u003d System.currentTimeMillis();\n \n     // From the beginning of the list\n     for (RMContainer reservedContainer : reservedContainers) {\n       // Only try to preempt reserved container after reserved container created\n       // and cannot be allocated after minTimeout\n       if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n         continue;\n       }\n \n       FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n           reservedContainer.getReservedNode());\n       if (null \u003d\u003d node) {\n         // Something is wrong, ignore\n         continue;\n       }\n \n       List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n \n       // Check if we can preempt for this queue\n       // We will skip if the demanding queue is already satisfied.\n       String demandingQueueName \u003d reservedContainer.getQueueName();\n       boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n           node.getPartition());\n \n       // We will continue check if it is possible to preempt reserved container\n       // from the node.\n       boolean canPreempt \u003d false;\n       if (!demandingQueueSatisfied) {\n         canPreempt \u003d canPreemptEnoughResourceForAsked(\n             reservedContainer.getReservedResource(), demandingQueueName, node,\n             false, newlySelectedToBePreemptContainers);\n       }\n \n       // Add selected container if we can allocate reserved container by\n       // preemption others\n       if (canPreempt) {\n         touchedNodes.add(node.getNodeID());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Trying to preempt following containers to make reserved \"\n               + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n               + node.getNodeID() + \" can be allocated:\");\n         }\n \n         // Update to-be-preempt\n         incToPreempt(demandingQueueName, node.getPartition(),\n             reservedContainer.getReservedResource());\n \n         for (RMContainer c : newlySelectedToBePreemptContainers) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n                 .getReservedResource());\n           }\n \n-          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(\n-              c.getApplicationAttemptId());\n-          if (null \u003d\u003d containers) {\n-            containers \u003d new HashSet\u003c\u003e();\n-            selectedCandidates.put(c.getApplicationAttemptId(), containers);\n-          }\n-          containers.add(c);\n+          // Add to preemptMap\n+          CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n+              curCandidates, c.getApplicationAttemptId(), c);\n \n           // Update totalPreemptionResourceAllowed\n           Resources.subtractFrom(totalPreemptedResourceAllowed,\n               c.getAllocatedResource());\n         }\n       } else if (!demandingQueueSatisfied) {\n         // We failed to get enough resource to allocate the container\n         // This typically happens when the reserved node is proper, will\n         // try to see if we can reserve the container on a better host.\n         // Only do this if the demanding queue is not satisfied.\n         //\n         // TODO (wangda): do more tests before making it usable\n         //\n         if (allowMoveReservation) {\n           tryToMakeBetterReservationPlacement(reservedContainer,\n               allSchedulerNodes);\n         }\n       }\n     }\n-\n-    return selectedCandidates;\n+    return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // Initialize digraph from queues\n    // TODO (wangda): only do this when queue refreshed.\n    priorityDigraph.clear();\n    initializePriorityDigraph();\n\n    // When all queues are set to same priority, or priority is not respected,\n    // direct return.\n    if (priorityDigraph.isEmpty()) {\n      return curCandidates;\n    }\n\n    // Save parameters to be shared by other methods\n    this.selectedCandidates \u003d selectedCandidates;\n    this.clusterResource \u003d clusterResource;\n    this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n\n    toPreemptedFromOtherQueues.clear();\n\n    reservedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Clear temp-scheduler-node-map every time when doing selection of\n    // containers.\n    tempSchedulerNodeMap.clear();\n    touchedNodes \u003d new HashSet\u003c\u003e();\n\n    // Add all reserved containers for analysis\n    List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n        preemptionContext.getScheduler().getAllNodes();\n    for (FiCaSchedulerNode node : allSchedulerNodes) {\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (null !\u003d reservedContainer) {\n        // Add to reservedContainers list if the queue that the reserved\n        // container belongs to has high priority than at least one queue\n        if (priorityDigraph.containsRow(\n            reservedContainer.getQueueName())) {\n          reservedContainers.add(reservedContainer);\n        }\n      }\n    }\n\n    // Sort reserved container by creation time\n    Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n\n    long currentTime \u003d System.currentTimeMillis();\n\n    // From the beginning of the list\n    for (RMContainer reservedContainer : reservedContainers) {\n      // Only try to preempt reserved container after reserved container created\n      // and cannot be allocated after minTimeout\n      if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n        continue;\n      }\n\n      FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n          reservedContainer.getReservedNode());\n      if (null \u003d\u003d node) {\n        // Something is wrong, ignore\n        continue;\n      }\n\n      List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n\n      // Check if we can preempt for this queue\n      // We will skip if the demanding queue is already satisfied.\n      String demandingQueueName \u003d reservedContainer.getQueueName();\n      boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n          node.getPartition());\n\n      // We will continue check if it is possible to preempt reserved container\n      // from the node.\n      boolean canPreempt \u003d false;\n      if (!demandingQueueSatisfied) {\n        canPreempt \u003d canPreemptEnoughResourceForAsked(\n            reservedContainer.getReservedResource(), demandingQueueName, node,\n            false, newlySelectedToBePreemptContainers);\n      }\n\n      // Add selected container if we can allocate reserved container by\n      // preemption others\n      if (canPreempt) {\n        touchedNodes.add(node.getNodeID());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Trying to preempt following containers to make reserved \"\n              + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n              + node.getNodeID() + \" can be allocated:\");\n        }\n\n        // Update to-be-preempt\n        incToPreempt(demandingQueueName, node.getPartition(),\n            reservedContainer.getReservedResource());\n\n        for (RMContainer c : newlySelectedToBePreemptContainers) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n                .getReservedResource());\n          }\n\n          // Add to preemptMap\n          CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n              curCandidates, c.getApplicationAttemptId(), c);\n\n          // Update totalPreemptionResourceAllowed\n          Resources.subtractFrom(totalPreemptedResourceAllowed,\n              c.getAllocatedResource());\n        }\n      } else if (!demandingQueueSatisfied) {\n        // We failed to get enough resource to allocate the container\n        // This typically happens when the reserved node is proper, will\n        // try to see if we can reserve the container on a better host.\n        // Only do this if the demanding queue is not satisfied.\n        //\n        // TODO (wangda): do more tests before making it usable\n        //\n        if (allowMoveReservation) {\n          tryToMakeBetterReservationPlacement(reservedContainer,\n              allSchedulerNodes);\n        }\n      }\n    }\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
      "extendedDetails": {}
    },
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15254. Correct the wrong word spelling \u0027intialize\u0027. Contributed by fang zhenyi.\n",
      "commitDate": "24/02/18 2:41 PM",
      "commitName": "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "12/01/18 2:11 AM",
      "commitNameOld": "128d773a2315fa6baaa3a52b13c53c77e741b69c",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 43.52,
      "commitsBetweenForRepo": 272,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,131 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource,\n       Resource totalPreemptedResourceAllowed) {\n     // Initialize digraph from queues\n     // TODO (wangda): only do this when queue refreshed.\n     priorityDigraph.clear();\n-    intializePriorityDigraph();\n+    initializePriorityDigraph();\n \n     // When all queues are set to same priority, or priority is not respected,\n     // direct return.\n     if (priorityDigraph.isEmpty()) {\n       return selectedCandidates;\n     }\n \n     // Save parameters to be shared by other methods\n     this.selectedCandidates \u003d selectedCandidates;\n     this.clusterResource \u003d clusterResource;\n     this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n \n     toPreemptedFromOtherQueues.clear();\n \n     reservedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Clear temp-scheduler-node-map every time when doing selection of\n     // containers.\n     tempSchedulerNodeMap.clear();\n     touchedNodes \u003d new HashSet\u003c\u003e();\n \n     // Add all reserved containers for analysis\n     List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n         preemptionContext.getScheduler().getAllNodes();\n     for (FiCaSchedulerNode node : allSchedulerNodes) {\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (null !\u003d reservedContainer) {\n         // Add to reservedContainers list if the queue that the reserved\n         // container belongs to has high priority than at least one queue\n         if (priorityDigraph.containsRow(\n             reservedContainer.getQueueName())) {\n           reservedContainers.add(reservedContainer);\n         }\n       }\n     }\n \n     // Sort reserved container by creation time\n     Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n \n     long currentTime \u003d System.currentTimeMillis();\n \n     // From the beginning of the list\n     for (RMContainer reservedContainer : reservedContainers) {\n       // Only try to preempt reserved container after reserved container created\n       // and cannot be allocated after minTimeout\n       if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n         continue;\n       }\n \n       FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n           reservedContainer.getReservedNode());\n       if (null \u003d\u003d node) {\n         // Something is wrong, ignore\n         continue;\n       }\n \n       List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n \n       // Check if we can preempt for this queue\n       // We will skip if the demanding queue is already satisfied.\n       String demandingQueueName \u003d reservedContainer.getQueueName();\n       boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n           node.getPartition());\n \n       // We will continue check if it is possible to preempt reserved container\n       // from the node.\n       boolean canPreempt \u003d false;\n       if (!demandingQueueSatisfied) {\n         canPreempt \u003d canPreemptEnoughResourceForAsked(\n             reservedContainer.getReservedResource(), demandingQueueName, node,\n             false, newlySelectedToBePreemptContainers);\n       }\n \n       // Add selected container if we can allocate reserved container by\n       // preemption others\n       if (canPreempt) {\n         touchedNodes.add(node.getNodeID());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Trying to preempt following containers to make reserved \"\n               + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n               + node.getNodeID() + \" can be allocated:\");\n         }\n \n         // Update to-be-preempt\n         incToPreempt(demandingQueueName, node.getPartition(),\n             reservedContainer.getReservedResource());\n \n         for (RMContainer c : newlySelectedToBePreemptContainers) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n                 .getReservedResource());\n           }\n \n           Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(\n               c.getApplicationAttemptId());\n           if (null \u003d\u003d containers) {\n             containers \u003d new HashSet\u003c\u003e();\n             selectedCandidates.put(c.getApplicationAttemptId(), containers);\n           }\n           containers.add(c);\n \n           // Update totalPreemptionResourceAllowed\n           Resources.subtractFrom(totalPreemptedResourceAllowed,\n               c.getAllocatedResource());\n         }\n       } else if (!demandingQueueSatisfied) {\n         // We failed to get enough resource to allocate the container\n         // This typically happens when the reserved node is proper, will\n         // try to see if we can reserve the container on a better host.\n         // Only do this if the demanding queue is not satisfied.\n         //\n         // TODO (wangda): do more tests before making it usable\n         //\n         if (allowMoveReservation) {\n           tryToMakeBetterReservationPlacement(reservedContainer,\n               allSchedulerNodes);\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    // Initialize digraph from queues\n    // TODO (wangda): only do this when queue refreshed.\n    priorityDigraph.clear();\n    initializePriorityDigraph();\n\n    // When all queues are set to same priority, or priority is not respected,\n    // direct return.\n    if (priorityDigraph.isEmpty()) {\n      return selectedCandidates;\n    }\n\n    // Save parameters to be shared by other methods\n    this.selectedCandidates \u003d selectedCandidates;\n    this.clusterResource \u003d clusterResource;\n    this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n\n    toPreemptedFromOtherQueues.clear();\n\n    reservedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Clear temp-scheduler-node-map every time when doing selection of\n    // containers.\n    tempSchedulerNodeMap.clear();\n    touchedNodes \u003d new HashSet\u003c\u003e();\n\n    // Add all reserved containers for analysis\n    List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n        preemptionContext.getScheduler().getAllNodes();\n    for (FiCaSchedulerNode node : allSchedulerNodes) {\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (null !\u003d reservedContainer) {\n        // Add to reservedContainers list if the queue that the reserved\n        // container belongs to has high priority than at least one queue\n        if (priorityDigraph.containsRow(\n            reservedContainer.getQueueName())) {\n          reservedContainers.add(reservedContainer);\n        }\n      }\n    }\n\n    // Sort reserved container by creation time\n    Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n\n    long currentTime \u003d System.currentTimeMillis();\n\n    // From the beginning of the list\n    for (RMContainer reservedContainer : reservedContainers) {\n      // Only try to preempt reserved container after reserved container created\n      // and cannot be allocated after minTimeout\n      if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n        continue;\n      }\n\n      FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n          reservedContainer.getReservedNode());\n      if (null \u003d\u003d node) {\n        // Something is wrong, ignore\n        continue;\n      }\n\n      List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n\n      // Check if we can preempt for this queue\n      // We will skip if the demanding queue is already satisfied.\n      String demandingQueueName \u003d reservedContainer.getQueueName();\n      boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n          node.getPartition());\n\n      // We will continue check if it is possible to preempt reserved container\n      // from the node.\n      boolean canPreempt \u003d false;\n      if (!demandingQueueSatisfied) {\n        canPreempt \u003d canPreemptEnoughResourceForAsked(\n            reservedContainer.getReservedResource(), demandingQueueName, node,\n            false, newlySelectedToBePreemptContainers);\n      }\n\n      // Add selected container if we can allocate reserved container by\n      // preemption others\n      if (canPreempt) {\n        touchedNodes.add(node.getNodeID());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Trying to preempt following containers to make reserved \"\n              + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n              + node.getNodeID() + \" can be allocated:\");\n        }\n\n        // Update to-be-preempt\n        incToPreempt(demandingQueueName, node.getPartition(),\n            reservedContainer.getReservedResource());\n\n        for (RMContainer c : newlySelectedToBePreemptContainers) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n                .getReservedResource());\n          }\n\n          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(\n              c.getApplicationAttemptId());\n          if (null \u003d\u003d containers) {\n            containers \u003d new HashSet\u003c\u003e();\n            selectedCandidates.put(c.getApplicationAttemptId(), containers);\n          }\n          containers.add(c);\n\n          // Update totalPreemptionResourceAllowed\n          Resources.subtractFrom(totalPreemptedResourceAllowed,\n              c.getAllocatedResource());\n        }\n      } else if (!demandingQueueSatisfied) {\n        // We failed to get enough resource to allocate the container\n        // This typically happens when the reserved node is proper, will\n        // try to see if we can reserve the container on a better host.\n        // Only do this if the demanding queue is not satisfied.\n        //\n        // TODO (wangda): do more tests before making it usable\n        //\n        if (allowMoveReservation) {\n          tryToMakeBetterReservationPlacement(reservedContainer,\n              allSchedulerNodes);\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
      "extendedDetails": {}
    },
    "4aae2d40a3e2e732e09b4b8a82623cacc0dc8861": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14410. Correct spelling of  \u0027beginning\u0027 and variants. Contributed By Dongtao Zhang\n",
      "commitDate": "11/05/17 11:03 AM",
      "commitName": "4aae2d40a3e2e732e09b4b8a82623cacc0dc8861",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "23/01/17 10:52 AM",
      "commitNameOld": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 107.97,
      "commitsBetweenForRepo": 605,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,131 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource,\n       Resource totalPreemptedResourceAllowed) {\n     // Initialize digraph from queues\n     // TODO (wangda): only do this when queue refreshed.\n     priorityDigraph.clear();\n     intializePriorityDigraph();\n \n     // When all queues are set to same priority, or priority is not respected,\n     // direct return.\n     if (priorityDigraph.isEmpty()) {\n       return selectedCandidates;\n     }\n \n     // Save parameters to be shared by other methods\n     this.selectedCandidates \u003d selectedCandidates;\n     this.clusterResource \u003d clusterResource;\n     this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n \n     toPreemptedFromOtherQueues.clear();\n \n     reservedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Clear temp-scheduler-node-map every time when doing selection of\n     // containers.\n     tempSchedulerNodeMap.clear();\n     touchedNodes \u003d new HashSet\u003c\u003e();\n \n     // Add all reserved containers for analysis\n     List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n         preemptionContext.getScheduler().getAllNodes();\n     for (FiCaSchedulerNode node : allSchedulerNodes) {\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (null !\u003d reservedContainer) {\n         // Add to reservedContainers list if the queue that the reserved\n         // container belongs to has high priority than at least one queue\n         if (priorityDigraph.containsRow(\n             reservedContainer.getQueueName())) {\n           reservedContainers.add(reservedContainer);\n         }\n       }\n     }\n \n     // Sort reserved container by creation time\n     Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n \n     long currentTime \u003d System.currentTimeMillis();\n \n-    // From the begining of the list\n+    // From the beginning of the list\n     for (RMContainer reservedContainer : reservedContainers) {\n       // Only try to preempt reserved container after reserved container created\n       // and cannot be allocated after minTimeout\n       if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n         continue;\n       }\n \n       FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n           reservedContainer.getReservedNode());\n       if (null \u003d\u003d node) {\n         // Something is wrong, ignore\n         continue;\n       }\n \n       List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n \n       // Check if we can preempt for this queue\n       // We will skip if the demanding queue is already satisfied.\n       String demandingQueueName \u003d reservedContainer.getQueueName();\n       boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n           node.getPartition());\n \n       // We will continue check if it is possible to preempt reserved container\n       // from the node.\n       boolean canPreempt \u003d false;\n       if (!demandingQueueSatisfied) {\n         canPreempt \u003d canPreemptEnoughResourceForAsked(\n             reservedContainer.getReservedResource(), demandingQueueName, node,\n             false, newlySelectedToBePreemptContainers);\n       }\n \n       // Add selected container if we can allocate reserved container by\n       // preemption others\n       if (canPreempt) {\n         touchedNodes.add(node.getNodeID());\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Trying to preempt following containers to make reserved \"\n               + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n               + node.getNodeID() + \" can be allocated:\");\n         }\n \n         // Update to-be-preempt\n         incToPreempt(demandingQueueName, node.getPartition(),\n             reservedContainer.getReservedResource());\n \n         for (RMContainer c : newlySelectedToBePreemptContainers) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n                 .getReservedResource());\n           }\n \n           Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(\n               c.getApplicationAttemptId());\n           if (null \u003d\u003d containers) {\n             containers \u003d new HashSet\u003c\u003e();\n             selectedCandidates.put(c.getApplicationAttemptId(), containers);\n           }\n           containers.add(c);\n \n           // Update totalPreemptionResourceAllowed\n           Resources.subtractFrom(totalPreemptedResourceAllowed,\n               c.getAllocatedResource());\n         }\n       } else if (!demandingQueueSatisfied) {\n         // We failed to get enough resource to allocate the container\n         // This typically happens when the reserved node is proper, will\n         // try to see if we can reserve the container on a better host.\n         // Only do this if the demanding queue is not satisfied.\n         //\n         // TODO (wangda): do more tests before making it usable\n         //\n         if (allowMoveReservation) {\n           tryToMakeBetterReservationPlacement(reservedContainer,\n               allSchedulerNodes);\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    // Initialize digraph from queues\n    // TODO (wangda): only do this when queue refreshed.\n    priorityDigraph.clear();\n    intializePriorityDigraph();\n\n    // When all queues are set to same priority, or priority is not respected,\n    // direct return.\n    if (priorityDigraph.isEmpty()) {\n      return selectedCandidates;\n    }\n\n    // Save parameters to be shared by other methods\n    this.selectedCandidates \u003d selectedCandidates;\n    this.clusterResource \u003d clusterResource;\n    this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n\n    toPreemptedFromOtherQueues.clear();\n\n    reservedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Clear temp-scheduler-node-map every time when doing selection of\n    // containers.\n    tempSchedulerNodeMap.clear();\n    touchedNodes \u003d new HashSet\u003c\u003e();\n\n    // Add all reserved containers for analysis\n    List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n        preemptionContext.getScheduler().getAllNodes();\n    for (FiCaSchedulerNode node : allSchedulerNodes) {\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (null !\u003d reservedContainer) {\n        // Add to reservedContainers list if the queue that the reserved\n        // container belongs to has high priority than at least one queue\n        if (priorityDigraph.containsRow(\n            reservedContainer.getQueueName())) {\n          reservedContainers.add(reservedContainer);\n        }\n      }\n    }\n\n    // Sort reserved container by creation time\n    Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n\n    long currentTime \u003d System.currentTimeMillis();\n\n    // From the beginning of the list\n    for (RMContainer reservedContainer : reservedContainers) {\n      // Only try to preempt reserved container after reserved container created\n      // and cannot be allocated after minTimeout\n      if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n        continue;\n      }\n\n      FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n          reservedContainer.getReservedNode());\n      if (null \u003d\u003d node) {\n        // Something is wrong, ignore\n        continue;\n      }\n\n      List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n\n      // Check if we can preempt for this queue\n      // We will skip if the demanding queue is already satisfied.\n      String demandingQueueName \u003d reservedContainer.getQueueName();\n      boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n          node.getPartition());\n\n      // We will continue check if it is possible to preempt reserved container\n      // from the node.\n      boolean canPreempt \u003d false;\n      if (!demandingQueueSatisfied) {\n        canPreempt \u003d canPreemptEnoughResourceForAsked(\n            reservedContainer.getReservedResource(), demandingQueueName, node,\n            false, newlySelectedToBePreemptContainers);\n      }\n\n      // Add selected container if we can allocate reserved container by\n      // preemption others\n      if (canPreempt) {\n        touchedNodes.add(node.getNodeID());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Trying to preempt following containers to make reserved \"\n              + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n              + node.getNodeID() + \" can be allocated:\");\n        }\n\n        // Update to-be-preempt\n        incToPreempt(demandingQueueName, node.getPartition(),\n            reservedContainer.getReservedResource());\n\n        for (RMContainer c : newlySelectedToBePreemptContainers) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n                .getReservedResource());\n          }\n\n          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(\n              c.getApplicationAttemptId());\n          if (null \u003d\u003d containers) {\n            containers \u003d new HashSet\u003c\u003e();\n            selectedCandidates.put(c.getApplicationAttemptId(), containers);\n          }\n          containers.add(c);\n\n          // Update totalPreemptionResourceAllowed\n          Resources.subtractFrom(totalPreemptedResourceAllowed,\n              c.getAllocatedResource());\n        }\n      } else if (!demandingQueueSatisfied) {\n        // We failed to get enough resource to allocate the container\n        // This typically happens when the reserved node is proper, will\n        // try to see if we can reserve the container on a better host.\n        // Only do this if the demanding queue is not satisfied.\n        //\n        // TODO (wangda): do more tests before making it usable\n        //\n        if (allowMoveReservation) {\n          tryToMakeBetterReservationPlacement(reservedContainer,\n              allSchedulerNodes);\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,131 @@\n+  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Resource clusterResource,\n+      Resource totalPreemptedResourceAllowed) {\n+    // Initialize digraph from queues\n+    // TODO (wangda): only do this when queue refreshed.\n+    priorityDigraph.clear();\n+    intializePriorityDigraph();\n+\n+    // When all queues are set to same priority, or priority is not respected,\n+    // direct return.\n+    if (priorityDigraph.isEmpty()) {\n+      return selectedCandidates;\n+    }\n+\n+    // Save parameters to be shared by other methods\n+    this.selectedCandidates \u003d selectedCandidates;\n+    this.clusterResource \u003d clusterResource;\n+    this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n+\n+    toPreemptedFromOtherQueues.clear();\n+\n+    reservedContainers \u003d new ArrayList\u003c\u003e();\n+\n+    // Clear temp-scheduler-node-map every time when doing selection of\n+    // containers.\n+    tempSchedulerNodeMap.clear();\n+    touchedNodes \u003d new HashSet\u003c\u003e();\n+\n+    // Add all reserved containers for analysis\n+    List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n+        preemptionContext.getScheduler().getAllNodes();\n+    for (FiCaSchedulerNode node : allSchedulerNodes) {\n+      RMContainer reservedContainer \u003d node.getReservedContainer();\n+      if (null !\u003d reservedContainer) {\n+        // Add to reservedContainers list if the queue that the reserved\n+        // container belongs to has high priority than at least one queue\n+        if (priorityDigraph.containsRow(\n+            reservedContainer.getQueueName())) {\n+          reservedContainers.add(reservedContainer);\n+        }\n+      }\n+    }\n+\n+    // Sort reserved container by creation time\n+    Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n+\n+    long currentTime \u003d System.currentTimeMillis();\n+\n+    // From the begining of the list\n+    for (RMContainer reservedContainer : reservedContainers) {\n+      // Only try to preempt reserved container after reserved container created\n+      // and cannot be allocated after minTimeout\n+      if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n+        continue;\n+      }\n+\n+      FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n+          reservedContainer.getReservedNode());\n+      if (null \u003d\u003d node) {\n+        // Something is wrong, ignore\n+        continue;\n+      }\n+\n+      List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n+\n+      // Check if we can preempt for this queue\n+      // We will skip if the demanding queue is already satisfied.\n+      String demandingQueueName \u003d reservedContainer.getQueueName();\n+      boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n+          node.getPartition());\n+\n+      // We will continue check if it is possible to preempt reserved container\n+      // from the node.\n+      boolean canPreempt \u003d false;\n+      if (!demandingQueueSatisfied) {\n+        canPreempt \u003d canPreemptEnoughResourceForAsked(\n+            reservedContainer.getReservedResource(), demandingQueueName, node,\n+            false, newlySelectedToBePreemptContainers);\n+      }\n+\n+      // Add selected container if we can allocate reserved container by\n+      // preemption others\n+      if (canPreempt) {\n+        touchedNodes.add(node.getNodeID());\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Trying to preempt following containers to make reserved \"\n+              + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n+              + node.getNodeID() + \" can be allocated:\");\n+        }\n+\n+        // Update to-be-preempt\n+        incToPreempt(demandingQueueName, node.getPartition(),\n+            reservedContainer.getReservedResource());\n+\n+        for (RMContainer c : newlySelectedToBePreemptContainers) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n+                .getReservedResource());\n+          }\n+\n+          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(\n+              c.getApplicationAttemptId());\n+          if (null \u003d\u003d containers) {\n+            containers \u003d new HashSet\u003c\u003e();\n+            selectedCandidates.put(c.getApplicationAttemptId(), containers);\n+          }\n+          containers.add(c);\n+\n+          // Update totalPreemptionResourceAllowed\n+          Resources.subtractFrom(totalPreemptedResourceAllowed,\n+              c.getAllocatedResource());\n+        }\n+      } else if (!demandingQueueSatisfied) {\n+        // We failed to get enough resource to allocate the container\n+        // This typically happens when the reserved node is proper, will\n+        // try to see if we can reserve the container on a better host.\n+        // Only do this if the demanding queue is not satisfied.\n+        //\n+        // TODO (wangda): do more tests before making it usable\n+        //\n+        if (allowMoveReservation) {\n+          tryToMakeBetterReservationPlacement(reservedContainer,\n+              allSchedulerNodes);\n+        }\n+      }\n+    }\n+\n+    return selectedCandidates;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    // Initialize digraph from queues\n    // TODO (wangda): only do this when queue refreshed.\n    priorityDigraph.clear();\n    intializePriorityDigraph();\n\n    // When all queues are set to same priority, or priority is not respected,\n    // direct return.\n    if (priorityDigraph.isEmpty()) {\n      return selectedCandidates;\n    }\n\n    // Save parameters to be shared by other methods\n    this.selectedCandidates \u003d selectedCandidates;\n    this.clusterResource \u003d clusterResource;\n    this.totalPreemptionAllowed \u003d totalPreemptedResourceAllowed;\n\n    toPreemptedFromOtherQueues.clear();\n\n    reservedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Clear temp-scheduler-node-map every time when doing selection of\n    // containers.\n    tempSchedulerNodeMap.clear();\n    touchedNodes \u003d new HashSet\u003c\u003e();\n\n    // Add all reserved containers for analysis\n    List\u003cFiCaSchedulerNode\u003e allSchedulerNodes \u003d\n        preemptionContext.getScheduler().getAllNodes();\n    for (FiCaSchedulerNode node : allSchedulerNodes) {\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (null !\u003d reservedContainer) {\n        // Add to reservedContainers list if the queue that the reserved\n        // container belongs to has high priority than at least one queue\n        if (priorityDigraph.containsRow(\n            reservedContainer.getQueueName())) {\n          reservedContainers.add(reservedContainer);\n        }\n      }\n    }\n\n    // Sort reserved container by creation time\n    Collections.sort(reservedContainers, CONTAINER_CREATION_TIME_COMPARATOR);\n\n    long currentTime \u003d System.currentTimeMillis();\n\n    // From the begining of the list\n    for (RMContainer reservedContainer : reservedContainers) {\n      // Only try to preempt reserved container after reserved container created\n      // and cannot be allocated after minTimeout\n      if (currentTime - reservedContainer.getCreationTime() \u003c minTimeout) {\n        continue;\n      }\n\n      FiCaSchedulerNode node \u003d preemptionContext.getScheduler().getNode(\n          reservedContainer.getReservedNode());\n      if (null \u003d\u003d node) {\n        // Something is wrong, ignore\n        continue;\n      }\n\n      List\u003cRMContainer\u003e newlySelectedToBePreemptContainers \u003d new ArrayList\u003c\u003e();\n\n      // Check if we can preempt for this queue\n      // We will skip if the demanding queue is already satisfied.\n      String demandingQueueName \u003d reservedContainer.getQueueName();\n      boolean demandingQueueSatisfied \u003d isQueueSatisfied(demandingQueueName,\n          node.getPartition());\n\n      // We will continue check if it is possible to preempt reserved container\n      // from the node.\n      boolean canPreempt \u003d false;\n      if (!demandingQueueSatisfied) {\n        canPreempt \u003d canPreemptEnoughResourceForAsked(\n            reservedContainer.getReservedResource(), demandingQueueName, node,\n            false, newlySelectedToBePreemptContainers);\n      }\n\n      // Add selected container if we can allocate reserved container by\n      // preemption others\n      if (canPreempt) {\n        touchedNodes.add(node.getNodeID());\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Trying to preempt following containers to make reserved \"\n              + \"container\u003d\" + reservedContainer.getContainerId() + \" on node\u003d\"\n              + node.getNodeID() + \" can be allocated:\");\n        }\n\n        // Update to-be-preempt\n        incToPreempt(demandingQueueName, node.getPartition(),\n            reservedContainer.getReservedResource());\n\n        for (RMContainer c : newlySelectedToBePreemptContainers) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\" --container\u003d\" + c.getContainerId() + \" resource\u003d\" + c\n                .getReservedResource());\n          }\n\n          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(\n              c.getApplicationAttemptId());\n          if (null \u003d\u003d containers) {\n            containers \u003d new HashSet\u003c\u003e();\n            selectedCandidates.put(c.getApplicationAttemptId(), containers);\n          }\n          containers.add(c);\n\n          // Update totalPreemptionResourceAllowed\n          Resources.subtractFrom(totalPreemptedResourceAllowed,\n              c.getAllocatedResource());\n        }\n      } else if (!demandingQueueSatisfied) {\n        // We failed to get enough resource to allocate the container\n        // This typically happens when the reserved node is proper, will\n        // try to see if we can reserve the container on a better host.\n        // Only do this if the demanding queue is not satisfied.\n        //\n        // TODO (wangda): do more tests before making it usable\n        //\n        if (allowMoveReservation) {\n          tryToMakeBetterReservationPlacement(reservedContainer,\n              allSchedulerNodes);\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java"
    }
  }
}