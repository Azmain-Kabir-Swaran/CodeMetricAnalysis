{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerLaunch.java",
  "functionName": "sanitizeWindowsEnv",
  "functionId": "sanitizeWindowsEnv___environment-Map__String,String____pwd-Path__resources-Map__Path,List__String______nmPrivateClasspathJarDir-Path",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
  "functionStartLine": 1652,
  "functionEndLine": 1747,
  "numCommitsSeen": 95,
  "timeTaken": 1900,
  "changeHistory": [
    "74a61438ca01e2191b54000af73b654a2d0b8253"
  ],
  "changeHistoryShort": {
    "74a61438ca01e2191b54000af73b654a2d0b8253": "Yintroduced"
  },
  "changeHistoryDetails": {
    "74a61438ca01e2191b54000af73b654a2d0b8253": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6475. Fix some long function checkstyle issues\n(Contributed by Soumabrata Chakraborty via Daniel Templeton)\n",
      "commitDate": "10/05/17 10:46 AM",
      "commitName": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthor": "Daniel Templeton",
      "diff": "@@ -0,0 +1,96 @@\n+  private void sanitizeWindowsEnv(Map\u003cString, String\u003e environment, Path pwd,\n+      Map\u003cPath, List\u003cString\u003e\u003e resources, Path nmPrivateClasspathJarDir)\n+      throws IOException {\n+\n+    String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n+\n+    if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n+\n+      //On non-windows, localized resources\n+      //from distcache are available via the classpath as they were placed\n+      //there but on windows they are not available when the classpath\n+      //jar is created and so they \"are lost\" and have to be explicitly\n+      //added to the classpath instead.  This also means that their position\n+      //is lost relative to other non-distcache classpath entries which will\n+      //break things like mapreduce.job.user.classpath.first.  An environment\n+      //variable can be set to indicate that distcache entries should come\n+      //first\n+\n+      boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n+              environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n+      );\n+\n+      boolean needsSeparator \u003d false;\n+      StringBuilder newClassPath \u003d new StringBuilder();\n+      if (!preferLocalizedJars) {\n+        newClassPath.append(inputClassPath);\n+        needsSeparator \u003d true;\n+      }\n+\n+      // Localized resources do not exist at the desired paths yet, because the\n+      // container launch script has not run to create symlinks yet.  This\n+      // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n+      // wildcards to separate classpath entries for each file in the manifest.\n+      // To resolve this, append classpath entries explicitly for each\n+      // resource.\n+      for (Map.Entry\u003cPath, List\u003cString\u003e\u003e entry : resources.entrySet()) {\n+        boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n+                .isDirectory();\n+\n+        for (String linkName : entry.getValue()) {\n+          // Append resource.\n+          if (needsSeparator) {\n+            newClassPath.append(File.pathSeparator);\n+          } else {\n+            needsSeparator \u003d true;\n+          }\n+          newClassPath.append(pwd.toString())\n+                  .append(Path.SEPARATOR).append(linkName);\n+\n+          // FileUtil.createJarWithClassPath must use File.toURI to convert\n+          // each file to a URI to write into the manifest\u0027s classpath.  For\n+          // directories, the classpath must have a trailing \u0027/\u0027, but\n+          // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n+          // already exists.  To resolve this, add the classpath entries with\n+          // explicit trailing \u0027/\u0027 here for any localized resource that targets\n+          // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n+          // that the resulting entry in the manifest\u0027s classpath will have a\n+          // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n+          if (targetIsDirectory) {\n+            newClassPath.append(Path.SEPARATOR);\n+          }\n+        }\n+      }\n+      if (preferLocalizedJars) {\n+        if (needsSeparator) {\n+          newClassPath.append(File.pathSeparator);\n+        }\n+        newClassPath.append(inputClassPath);\n+      }\n+\n+      // When the container launches, it takes the parent process\u0027s environment\n+      // and then adds/overwrites with the entries from the container launch\n+      // context.  Do the same thing here for correct substitution of\n+      // environment variables in the classpath jar manifest.\n+      Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n+              System.getenv());\n+      mergedEnv.putAll(environment);\n+\n+      // this is hacky and temporary - it\u0027s to preserve the windows secure\n+      // behavior but enable non-secure windows to properly build the class\n+      // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n+      Path jarDir;\n+      if (exec instanceof WindowsSecureContainerExecutor) {\n+        jarDir \u003d nmPrivateClasspathJarDir;\n+      } else {\n+        jarDir \u003d pwd;\n+      }\n+      String[] jarCp \u003d FileUtil.createJarWithClassPath(\n+              newClassPath.toString(), jarDir, pwd, mergedEnv);\n+      // In a secure cluster the classpath jar must be localized to grant access\n+      Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n+              new Path(jarCp[0]), pwd, container.getUser());\n+      String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n+      environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void sanitizeWindowsEnv(Map\u003cString, String\u003e environment, Path pwd,\n      Map\u003cPath, List\u003cString\u003e\u003e resources, Path nmPrivateClasspathJarDir)\n      throws IOException {\n\n    String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n\n    if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n\n      //On non-windows, localized resources\n      //from distcache are available via the classpath as they were placed\n      //there but on windows they are not available when the classpath\n      //jar is created and so they \"are lost\" and have to be explicitly\n      //added to the classpath instead.  This also means that their position\n      //is lost relative to other non-distcache classpath entries which will\n      //break things like mapreduce.job.user.classpath.first.  An environment\n      //variable can be set to indicate that distcache entries should come\n      //first\n\n      boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n              environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n      );\n\n      boolean needsSeparator \u003d false;\n      StringBuilder newClassPath \u003d new StringBuilder();\n      if (!preferLocalizedJars) {\n        newClassPath.append(inputClassPath);\n        needsSeparator \u003d true;\n      }\n\n      // Localized resources do not exist at the desired paths yet, because the\n      // container launch script has not run to create symlinks yet.  This\n      // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n      // wildcards to separate classpath entries for each file in the manifest.\n      // To resolve this, append classpath entries explicitly for each\n      // resource.\n      for (Map.Entry\u003cPath, List\u003cString\u003e\u003e entry : resources.entrySet()) {\n        boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n                .isDirectory();\n\n        for (String linkName : entry.getValue()) {\n          // Append resource.\n          if (needsSeparator) {\n            newClassPath.append(File.pathSeparator);\n          } else {\n            needsSeparator \u003d true;\n          }\n          newClassPath.append(pwd.toString())\n                  .append(Path.SEPARATOR).append(linkName);\n\n          // FileUtil.createJarWithClassPath must use File.toURI to convert\n          // each file to a URI to write into the manifest\u0027s classpath.  For\n          // directories, the classpath must have a trailing \u0027/\u0027, but\n          // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n          // already exists.  To resolve this, add the classpath entries with\n          // explicit trailing \u0027/\u0027 here for any localized resource that targets\n          // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n          // that the resulting entry in the manifest\u0027s classpath will have a\n          // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n          if (targetIsDirectory) {\n            newClassPath.append(Path.SEPARATOR);\n          }\n        }\n      }\n      if (preferLocalizedJars) {\n        if (needsSeparator) {\n          newClassPath.append(File.pathSeparator);\n        }\n        newClassPath.append(inputClassPath);\n      }\n\n      // When the container launches, it takes the parent process\u0027s environment\n      // and then adds/overwrites with the entries from the container launch\n      // context.  Do the same thing here for correct substitution of\n      // environment variables in the classpath jar manifest.\n      Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n              System.getenv());\n      mergedEnv.putAll(environment);\n\n      // this is hacky and temporary - it\u0027s to preserve the windows secure\n      // behavior but enable non-secure windows to properly build the class\n      // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n      Path jarDir;\n      if (exec instanceof WindowsSecureContainerExecutor) {\n        jarDir \u003d nmPrivateClasspathJarDir;\n      } else {\n        jarDir \u003d pwd;\n      }\n      String[] jarCp \u003d FileUtil.createJarWithClassPath(\n              newClassPath.toString(), jarDir, pwd, mergedEnv);\n      // In a secure cluster the classpath jar must be localized to grant access\n      Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n              new Path(jarCp[0]), pwd, container.getUser());\n      String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n      environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java"
    }
  }
}