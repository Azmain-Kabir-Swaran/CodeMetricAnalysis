{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReadBufferManager.java",
  "functionName": "waitForProcess",
  "functionId": "waitForProcess___stream-AbfsInputStream(modifiers-final)__position-long(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/ReadBufferManager.java",
  "functionStartLine": 180,
  "functionEndLine": 207,
  "numCommitsSeen": 3,
  "timeTaken": 863,
  "changeHistory": [
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
    "f044deedbbfee0812316d587139cb828f27172e9"
  ],
  "changeHistoryShort": {
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be": "Ybodychange",
    "f044deedbbfee0812316d587139cb828f27172e9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15446. ABFS: tune imports \u0026 javadocs; stabilise tests.\nContributed by Steve Loughran and Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   private void waitForProcess(final AbfsInputStream stream, final long position) {\n     ReadBuffer readBuf;\n     synchronized (this) {\n       clearFromReadAheadQueue(stream, position);\n       readBuf \u003d getFromList(inProgressList, stream, position);\n     }\n     if (readBuf !\u003d null) {         // if in in-progress queue, then block for it\n       try {\n         if (LOGGER.isTraceEnabled()) {\n-          LOGGER.trace(\"got a relevant read buffer for file \" + stream.getPath() + \" offset \" + readBuf.getOffset()\n-                  + \" buffer idx \" + readBuf.getBufferindex());\n+          LOGGER.trace(\"got a relevant read buffer for file {} offset {} buffer idx {}\",\n+              stream.getPath(), readBuf.getOffset(), readBuf.getBufferindex());\n         }\n         readBuf.getLatch().await();  // blocking wait on the caller stream\u0027s thread\n         // Note on correctness: readBuf gets out of inProgressList only in 1 place: after worker thread\n         // is done processing it (in doneReading). There, the latch is set after removing the buffer from\n         // inProgressList. So this latch is safe to be outside the synchronized block.\n         // Putting it in synchronized would result in a deadlock, since this thread would be holding the lock\n         // while waiting, so no one will be able to  change any state. If this becomes more complex in the future,\n         // then the latch cane be removed and replaced with wait/notify whenever inProgressList is touched.\n       } catch (InterruptedException ex) {\n         Thread.currentThread().interrupt();\n       }\n       if (LOGGER.isTraceEnabled()) {\n-        LOGGER.trace(\"latch done for file \" + stream.getPath() + \" buffer idx \" + readBuf.getBufferindex()\n-                + \" length \" + readBuf.getLength());\n+        LOGGER.trace(\"latch done for file {} buffer idx {} length {}\",\n+            stream.getPath(), readBuf.getBufferindex(), readBuf.getLength());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void waitForProcess(final AbfsInputStream stream, final long position) {\n    ReadBuffer readBuf;\n    synchronized (this) {\n      clearFromReadAheadQueue(stream, position);\n      readBuf \u003d getFromList(inProgressList, stream, position);\n    }\n    if (readBuf !\u003d null) {         // if in in-progress queue, then block for it\n      try {\n        if (LOGGER.isTraceEnabled()) {\n          LOGGER.trace(\"got a relevant read buffer for file {} offset {} buffer idx {}\",\n              stream.getPath(), readBuf.getOffset(), readBuf.getBufferindex());\n        }\n        readBuf.getLatch().await();  // blocking wait on the caller stream\u0027s thread\n        // Note on correctness: readBuf gets out of inProgressList only in 1 place: after worker thread\n        // is done processing it (in doneReading). There, the latch is set after removing the buffer from\n        // inProgressList. So this latch is safe to be outside the synchronized block.\n        // Putting it in synchronized would result in a deadlock, since this thread would be holding the lock\n        // while waiting, so no one will be able to  change any state. If this becomes more complex in the future,\n        // then the latch cane be removed and replaced with wait/notify whenever inProgressList is touched.\n      } catch (InterruptedException ex) {\n        Thread.currentThread().interrupt();\n      }\n      if (LOGGER.isTraceEnabled()) {\n        LOGGER.trace(\"latch done for file {} buffer idx {} length {}\",\n            stream.getPath(), readBuf.getBufferindex(), readBuf.getLength());\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/ReadBufferManager.java",
      "extendedDetails": {}
    },
    "f044deedbbfee0812316d587139cb828f27172e9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15407. HADOOP-15540. Support Windows Azure Storage - Blob file system \"ABFS\" in Hadoop: Core Commit.\n\nContributed by Shane Mainali, Thomas Marquardt, Zichen Sun, Georgi Chalakov, Esfandiar Manii, Amit Singh, Dana Kaban, Da Zhou, Junhua Gu, Saher Ahwal, Saurabh Pant, James Baker, Shaoyu Zhang, Lawrence Chen, Kevin Chen and Steve Loughran\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "f044deedbbfee0812316d587139cb828f27172e9",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,28 @@\n+  private void waitForProcess(final AbfsInputStream stream, final long position) {\n+    ReadBuffer readBuf;\n+    synchronized (this) {\n+      clearFromReadAheadQueue(stream, position);\n+      readBuf \u003d getFromList(inProgressList, stream, position);\n+    }\n+    if (readBuf !\u003d null) {         // if in in-progress queue, then block for it\n+      try {\n+        if (LOGGER.isTraceEnabled()) {\n+          LOGGER.trace(\"got a relevant read buffer for file \" + stream.getPath() + \" offset \" + readBuf.getOffset()\n+                  + \" buffer idx \" + readBuf.getBufferindex());\n+        }\n+        readBuf.getLatch().await();  // blocking wait on the caller stream\u0027s thread\n+        // Note on correctness: readBuf gets out of inProgressList only in 1 place: after worker thread\n+        // is done processing it (in doneReading). There, the latch is set after removing the buffer from\n+        // inProgressList. So this latch is safe to be outside the synchronized block.\n+        // Putting it in synchronized would result in a deadlock, since this thread would be holding the lock\n+        // while waiting, so no one will be able to  change any state. If this becomes more complex in the future,\n+        // then the latch cane be removed and replaced with wait/notify whenever inProgressList is touched.\n+      } catch (InterruptedException ex) {\n+        Thread.currentThread().interrupt();\n+      }\n+      if (LOGGER.isTraceEnabled()) {\n+        LOGGER.trace(\"latch done for file \" + stream.getPath() + \" buffer idx \" + readBuf.getBufferindex()\n+                + \" length \" + readBuf.getLength());\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void waitForProcess(final AbfsInputStream stream, final long position) {\n    ReadBuffer readBuf;\n    synchronized (this) {\n      clearFromReadAheadQueue(stream, position);\n      readBuf \u003d getFromList(inProgressList, stream, position);\n    }\n    if (readBuf !\u003d null) {         // if in in-progress queue, then block for it\n      try {\n        if (LOGGER.isTraceEnabled()) {\n          LOGGER.trace(\"got a relevant read buffer for file \" + stream.getPath() + \" offset \" + readBuf.getOffset()\n                  + \" buffer idx \" + readBuf.getBufferindex());\n        }\n        readBuf.getLatch().await();  // blocking wait on the caller stream\u0027s thread\n        // Note on correctness: readBuf gets out of inProgressList only in 1 place: after worker thread\n        // is done processing it (in doneReading). There, the latch is set after removing the buffer from\n        // inProgressList. So this latch is safe to be outside the synchronized block.\n        // Putting it in synchronized would result in a deadlock, since this thread would be holding the lock\n        // while waiting, so no one will be able to  change any state. If this becomes more complex in the future,\n        // then the latch cane be removed and replaced with wait/notify whenever inProgressList is touched.\n      } catch (InterruptedException ex) {\n        Thread.currentThread().interrupt();\n      }\n      if (LOGGER.isTraceEnabled()) {\n        LOGGER.trace(\"latch done for file \" + stream.getPath() + \" buffer idx \" + readBuf.getBufferindex()\n                + \" length \" + readBuf.getLength());\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/ReadBufferManager.java"
    }
  }
}