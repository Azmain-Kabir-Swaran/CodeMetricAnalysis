{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CheckpointAMPreemptionPolicy.java",
  "functionName": "preempt",
  "functionId": "preempt___ctxt-Context__preemptionRequests-PreemptionMessage",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/preemption/CheckpointAMPreemptionPolicy.java",
  "functionStartLine": 104,
  "functionEndLine": 223,
  "numCommitsSeen": 4,
  "timeTaken": 1348,
  "changeHistory": [
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "3122daa80261b466e309e88d88d1e2c030525e3f",
    "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f"
  ],
  "changeHistoryShort": {
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "3122daa80261b466e309e88d88d1e2c030525e3f": "Ybodychange",
    "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "12/09/14 10:33 AM",
      "commitNameOld": "3122daa80261b466e309e88d88d1e2c030525e3f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 624.93,
      "commitsBetweenForRepo": 4860,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n   public void preempt(Context ctxt, PreemptionMessage preemptionRequests) {\n \n     if (preemptionRequests !\u003d null) {\n \n       // handling non-negotiable preemption\n \n       StrictPreemptionContract cStrict \u003d preemptionRequests.getStrictContract();\n       if (cStrict !\u003d null\n           \u0026\u0026 cStrict.getContainers() !\u003d null\n           \u0026\u0026 cStrict.getContainers().size() \u003e 0) {\n         LOG.info(\"strict preemption :\" +\n             preemptionRequests.getStrictContract().getContainers().size() +\n             \" containers to kill\");\n \n         // handle strict preemptions. These containers are non-negotiable\n         for (PreemptionContainer c :\n             preemptionRequests.getStrictContract().getContainers()) {\n           ContainerId reqCont \u003d c.getId();\n           TaskAttemptId reqTask \u003d ctxt.getTaskAttempt(reqCont);\n           if (reqTask !\u003d null) {\n             // ignore requests for preempting containers running maps\n             if (org.apache.hadoop.mapreduce.v2.api.records.TaskType.REDUCE\n                 .equals(reqTask.getTaskId().getTaskType())) {\n               toBePreempted.add(reqTask);\n               LOG.info(\"preempting \" + reqCont + \" running task:\" + reqTask);\n             } else {\n               LOG.info(\"NOT preempting \" + reqCont + \" running task:\" + reqTask);\n             }\n           }\n         }\n       }\n \n       // handling negotiable preemption\n       PreemptionContract cNegot \u003d preemptionRequests.getContract();\n       if (cNegot !\u003d null\n           \u0026\u0026 cNegot.getResourceRequest() !\u003d null\n           \u0026\u0026 cNegot.getResourceRequest().size() \u003e 0\n           \u0026\u0026 cNegot.getContainers() !\u003d null\n           \u0026\u0026 cNegot.getContainers().size() \u003e 0) {\n \n         LOG.info(\"negotiable preemption :\" +\n             preemptionRequests.getContract().getResourceRequest().size() +\n             \" resourceReq, \" +\n             preemptionRequests.getContract().getContainers().size() +\n             \" containers\");\n         // handle fungible preemption. Here we only look at the total amount of\n         // resources to be preempted and pick enough of our containers to\n         // satisfy that. We only support checkpointing for reducers for now.\n         List\u003cPreemptionResourceRequest\u003e reqResources \u003d\n           preemptionRequests.getContract().getResourceRequest();\n \n         // compute the total amount of pending preemptions (to be discounted\n         // from current request)\n         int pendingPreemptionRam \u003d 0;\n         int pendingPreemptionCores \u003d 0;\n         for (Resource r : pendingFlexiblePreemptions.values()) {\n-          pendingPreemptionRam +\u003d r.getMemory();\n+          pendingPreemptionRam +\u003d r.getMemorySize();\n           pendingPreemptionCores +\u003d r.getVirtualCores();\n         }\n \n         // discount preemption request based on currently pending preemption\n         for (PreemptionResourceRequest rr : reqResources) {\n           ResourceRequest reqRsrc \u003d rr.getResourceRequest();\n           if (!ResourceRequest.ANY.equals(reqRsrc.getResourceName())) {\n             // For now, only respond to aggregate requests and ignore locality\n             continue;\n           }\n \n           LOG.info(\"ResourceRequest:\" + reqRsrc);\n           int reqCont \u003d reqRsrc.getNumContainers();\n-          int reqMem \u003d reqRsrc.getCapability().getMemory();\n-          int totalMemoryToRelease \u003d reqCont * reqMem;\n+          long reqMem \u003d reqRsrc.getCapability().getMemorySize();\n+          long totalMemoryToRelease \u003d reqCont * reqMem;\n           int reqCores \u003d reqRsrc.getCapability().getVirtualCores();\n           int totalCoresToRelease \u003d reqCont * reqCores;\n \n           // remove\n           if (pendingPreemptionRam \u003e 0) {\n             // if goes negative we simply exit\n             totalMemoryToRelease -\u003d pendingPreemptionRam;\n             // decrement pending resources if zero or negatve we will\n             // ignore it while processing next PreemptionResourceRequest\n             pendingPreemptionRam -\u003d totalMemoryToRelease;\n           }\n           if (pendingPreemptionCores \u003e 0) {\n             totalCoresToRelease -\u003d pendingPreemptionCores;\n             pendingPreemptionCores -\u003d totalCoresToRelease;\n           }\n \n           // reverse order of allocation (for now)\n           List\u003cContainer\u003e listOfCont \u003d ctxt.getContainers(TaskType.REDUCE);\n           Collections.sort(listOfCont, new Comparator\u003cContainer\u003e() {\n             @Override\n             public int compare(final Container o1, final Container o2) {\n               return o2.getId().compareTo(o1.getId());\n             }\n           });\n \n           // preempt reducers first\n           for (Container cont : listOfCont) {\n             if (totalMemoryToRelease \u003c\u003d 0 \u0026\u0026 totalCoresToRelease\u003c\u003d0) {\n               break;\n             }\n             TaskAttemptId reduceId \u003d ctxt.getTaskAttempt(cont.getId());\n-            int cMem \u003d cont.getResource().getMemory();\n+            int cMem \u003d (int) cont.getResource().getMemorySize();\n             int cCores \u003d cont.getResource().getVirtualCores();\n \n             if (!toBePreempted.contains(reduceId)) {\n               totalMemoryToRelease -\u003d cMem;\n               totalCoresToRelease -\u003d cCores;\n                 toBePreempted.add(reduceId);\n                 pendingFlexiblePreemptions.put(reduceId, cont.getResource());\n             }\n             LOG.info(\"ResourceRequest:\" + reqRsrc + \" satisfied preempting \"\n                 + reduceId);\n           }\n           // if map was preemptable we would do add them to toBePreempted here\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void preempt(Context ctxt, PreemptionMessage preemptionRequests) {\n\n    if (preemptionRequests !\u003d null) {\n\n      // handling non-negotiable preemption\n\n      StrictPreemptionContract cStrict \u003d preemptionRequests.getStrictContract();\n      if (cStrict !\u003d null\n          \u0026\u0026 cStrict.getContainers() !\u003d null\n          \u0026\u0026 cStrict.getContainers().size() \u003e 0) {\n        LOG.info(\"strict preemption :\" +\n            preemptionRequests.getStrictContract().getContainers().size() +\n            \" containers to kill\");\n\n        // handle strict preemptions. These containers are non-negotiable\n        for (PreemptionContainer c :\n            preemptionRequests.getStrictContract().getContainers()) {\n          ContainerId reqCont \u003d c.getId();\n          TaskAttemptId reqTask \u003d ctxt.getTaskAttempt(reqCont);\n          if (reqTask !\u003d null) {\n            // ignore requests for preempting containers running maps\n            if (org.apache.hadoop.mapreduce.v2.api.records.TaskType.REDUCE\n                .equals(reqTask.getTaskId().getTaskType())) {\n              toBePreempted.add(reqTask);\n              LOG.info(\"preempting \" + reqCont + \" running task:\" + reqTask);\n            } else {\n              LOG.info(\"NOT preempting \" + reqCont + \" running task:\" + reqTask);\n            }\n          }\n        }\n      }\n\n      // handling negotiable preemption\n      PreemptionContract cNegot \u003d preemptionRequests.getContract();\n      if (cNegot !\u003d null\n          \u0026\u0026 cNegot.getResourceRequest() !\u003d null\n          \u0026\u0026 cNegot.getResourceRequest().size() \u003e 0\n          \u0026\u0026 cNegot.getContainers() !\u003d null\n          \u0026\u0026 cNegot.getContainers().size() \u003e 0) {\n\n        LOG.info(\"negotiable preemption :\" +\n            preemptionRequests.getContract().getResourceRequest().size() +\n            \" resourceReq, \" +\n            preemptionRequests.getContract().getContainers().size() +\n            \" containers\");\n        // handle fungible preemption. Here we only look at the total amount of\n        // resources to be preempted and pick enough of our containers to\n        // satisfy that. We only support checkpointing for reducers for now.\n        List\u003cPreemptionResourceRequest\u003e reqResources \u003d\n          preemptionRequests.getContract().getResourceRequest();\n\n        // compute the total amount of pending preemptions (to be discounted\n        // from current request)\n        int pendingPreemptionRam \u003d 0;\n        int pendingPreemptionCores \u003d 0;\n        for (Resource r : pendingFlexiblePreemptions.values()) {\n          pendingPreemptionRam +\u003d r.getMemorySize();\n          pendingPreemptionCores +\u003d r.getVirtualCores();\n        }\n\n        // discount preemption request based on currently pending preemption\n        for (PreemptionResourceRequest rr : reqResources) {\n          ResourceRequest reqRsrc \u003d rr.getResourceRequest();\n          if (!ResourceRequest.ANY.equals(reqRsrc.getResourceName())) {\n            // For now, only respond to aggregate requests and ignore locality\n            continue;\n          }\n\n          LOG.info(\"ResourceRequest:\" + reqRsrc);\n          int reqCont \u003d reqRsrc.getNumContainers();\n          long reqMem \u003d reqRsrc.getCapability().getMemorySize();\n          long totalMemoryToRelease \u003d reqCont * reqMem;\n          int reqCores \u003d reqRsrc.getCapability().getVirtualCores();\n          int totalCoresToRelease \u003d reqCont * reqCores;\n\n          // remove\n          if (pendingPreemptionRam \u003e 0) {\n            // if goes negative we simply exit\n            totalMemoryToRelease -\u003d pendingPreemptionRam;\n            // decrement pending resources if zero or negatve we will\n            // ignore it while processing next PreemptionResourceRequest\n            pendingPreemptionRam -\u003d totalMemoryToRelease;\n          }\n          if (pendingPreemptionCores \u003e 0) {\n            totalCoresToRelease -\u003d pendingPreemptionCores;\n            pendingPreemptionCores -\u003d totalCoresToRelease;\n          }\n\n          // reverse order of allocation (for now)\n          List\u003cContainer\u003e listOfCont \u003d ctxt.getContainers(TaskType.REDUCE);\n          Collections.sort(listOfCont, new Comparator\u003cContainer\u003e() {\n            @Override\n            public int compare(final Container o1, final Container o2) {\n              return o2.getId().compareTo(o1.getId());\n            }\n          });\n\n          // preempt reducers first\n          for (Container cont : listOfCont) {\n            if (totalMemoryToRelease \u003c\u003d 0 \u0026\u0026 totalCoresToRelease\u003c\u003d0) {\n              break;\n            }\n            TaskAttemptId reduceId \u003d ctxt.getTaskAttempt(cont.getId());\n            int cMem \u003d (int) cont.getResource().getMemorySize();\n            int cCores \u003d cont.getResource().getVirtualCores();\n\n            if (!toBePreempted.contains(reduceId)) {\n              totalMemoryToRelease -\u003d cMem;\n              totalCoresToRelease -\u003d cCores;\n                toBePreempted.add(reduceId);\n                pendingFlexiblePreemptions.put(reduceId, cont.getResource());\n            }\n            LOG.info(\"ResourceRequest:\" + reqRsrc + \" satisfied preempting \"\n                + reduceId);\n          }\n          // if map was preemptable we would do add them to toBePreempted here\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/preemption/CheckpointAMPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "3122daa80261b466e309e88d88d1e2c030525e3f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2229. Changed the integer field of ContainerId to be long type. Contributed by Tsuyoshi OZAWA\n",
      "commitDate": "12/09/14 10:33 AM",
      "commitName": "3122daa80261b466e309e88d88d1e2c030525e3f",
      "commitAuthor": "Jian He",
      "commitDateOld": "28/12/13 1:58 PM",
      "commitNameOld": "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 257.82,
      "commitsBetweenForRepo": 1885,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n   public void preempt(Context ctxt, PreemptionMessage preemptionRequests) {\n \n     if (preemptionRequests !\u003d null) {\n \n       // handling non-negotiable preemption\n \n       StrictPreemptionContract cStrict \u003d preemptionRequests.getStrictContract();\n       if (cStrict !\u003d null\n           \u0026\u0026 cStrict.getContainers() !\u003d null\n           \u0026\u0026 cStrict.getContainers().size() \u003e 0) {\n         LOG.info(\"strict preemption :\" +\n             preemptionRequests.getStrictContract().getContainers().size() +\n             \" containers to kill\");\n \n         // handle strict preemptions. These containers are non-negotiable\n         for (PreemptionContainer c :\n             preemptionRequests.getStrictContract().getContainers()) {\n           ContainerId reqCont \u003d c.getId();\n           TaskAttemptId reqTask \u003d ctxt.getTaskAttempt(reqCont);\n           if (reqTask !\u003d null) {\n             // ignore requests for preempting containers running maps\n             if (org.apache.hadoop.mapreduce.v2.api.records.TaskType.REDUCE\n                 .equals(reqTask.getTaskId().getTaskType())) {\n               toBePreempted.add(reqTask);\n               LOG.info(\"preempting \" + reqCont + \" running task:\" + reqTask);\n             } else {\n               LOG.info(\"NOT preempting \" + reqCont + \" running task:\" + reqTask);\n             }\n           }\n         }\n       }\n \n       // handling negotiable preemption\n       PreemptionContract cNegot \u003d preemptionRequests.getContract();\n       if (cNegot !\u003d null\n           \u0026\u0026 cNegot.getResourceRequest() !\u003d null\n           \u0026\u0026 cNegot.getResourceRequest().size() \u003e 0\n           \u0026\u0026 cNegot.getContainers() !\u003d null\n           \u0026\u0026 cNegot.getContainers().size() \u003e 0) {\n \n         LOG.info(\"negotiable preemption :\" +\n             preemptionRequests.getContract().getResourceRequest().size() +\n             \" resourceReq, \" +\n             preemptionRequests.getContract().getContainers().size() +\n             \" containers\");\n         // handle fungible preemption. Here we only look at the total amount of\n         // resources to be preempted and pick enough of our containers to\n         // satisfy that. We only support checkpointing for reducers for now.\n         List\u003cPreemptionResourceRequest\u003e reqResources \u003d\n           preemptionRequests.getContract().getResourceRequest();\n \n         // compute the total amount of pending preemptions (to be discounted\n         // from current request)\n         int pendingPreemptionRam \u003d 0;\n         int pendingPreemptionCores \u003d 0;\n         for (Resource r : pendingFlexiblePreemptions.values()) {\n           pendingPreemptionRam +\u003d r.getMemory();\n           pendingPreemptionCores +\u003d r.getVirtualCores();\n         }\n \n         // discount preemption request based on currently pending preemption\n         for (PreemptionResourceRequest rr : reqResources) {\n           ResourceRequest reqRsrc \u003d rr.getResourceRequest();\n           if (!ResourceRequest.ANY.equals(reqRsrc.getResourceName())) {\n             // For now, only respond to aggregate requests and ignore locality\n             continue;\n           }\n \n           LOG.info(\"ResourceRequest:\" + reqRsrc);\n           int reqCont \u003d reqRsrc.getNumContainers();\n           int reqMem \u003d reqRsrc.getCapability().getMemory();\n           int totalMemoryToRelease \u003d reqCont * reqMem;\n           int reqCores \u003d reqRsrc.getCapability().getVirtualCores();\n           int totalCoresToRelease \u003d reqCont * reqCores;\n \n           // remove\n           if (pendingPreemptionRam \u003e 0) {\n             // if goes negative we simply exit\n             totalMemoryToRelease -\u003d pendingPreemptionRam;\n             // decrement pending resources if zero or negatve we will\n             // ignore it while processing next PreemptionResourceRequest\n             pendingPreemptionRam -\u003d totalMemoryToRelease;\n           }\n           if (pendingPreemptionCores \u003e 0) {\n             totalCoresToRelease -\u003d pendingPreemptionCores;\n             pendingPreemptionCores -\u003d totalCoresToRelease;\n           }\n \n           // reverse order of allocation (for now)\n           List\u003cContainer\u003e listOfCont \u003d ctxt.getContainers(TaskType.REDUCE);\n           Collections.sort(listOfCont, new Comparator\u003cContainer\u003e() {\n             @Override\n             public int compare(final Container o1, final Container o2) {\n-              return o2.getId().getId() - o1.getId().getId();\n+              return o2.getId().compareTo(o1.getId());\n             }\n           });\n \n           // preempt reducers first\n           for (Container cont : listOfCont) {\n             if (totalMemoryToRelease \u003c\u003d 0 \u0026\u0026 totalCoresToRelease\u003c\u003d0) {\n               break;\n             }\n             TaskAttemptId reduceId \u003d ctxt.getTaskAttempt(cont.getId());\n             int cMem \u003d cont.getResource().getMemory();\n             int cCores \u003d cont.getResource().getVirtualCores();\n \n             if (!toBePreempted.contains(reduceId)) {\n               totalMemoryToRelease -\u003d cMem;\n               totalCoresToRelease -\u003d cCores;\n                 toBePreempted.add(reduceId);\n                 pendingFlexiblePreemptions.put(reduceId, cont.getResource());\n             }\n             LOG.info(\"ResourceRequest:\" + reqRsrc + \" satisfied preempting \"\n                 + reduceId);\n           }\n           // if map was preemptable we would do add them to toBePreempted here\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void preempt(Context ctxt, PreemptionMessage preemptionRequests) {\n\n    if (preemptionRequests !\u003d null) {\n\n      // handling non-negotiable preemption\n\n      StrictPreemptionContract cStrict \u003d preemptionRequests.getStrictContract();\n      if (cStrict !\u003d null\n          \u0026\u0026 cStrict.getContainers() !\u003d null\n          \u0026\u0026 cStrict.getContainers().size() \u003e 0) {\n        LOG.info(\"strict preemption :\" +\n            preemptionRequests.getStrictContract().getContainers().size() +\n            \" containers to kill\");\n\n        // handle strict preemptions. These containers are non-negotiable\n        for (PreemptionContainer c :\n            preemptionRequests.getStrictContract().getContainers()) {\n          ContainerId reqCont \u003d c.getId();\n          TaskAttemptId reqTask \u003d ctxt.getTaskAttempt(reqCont);\n          if (reqTask !\u003d null) {\n            // ignore requests for preempting containers running maps\n            if (org.apache.hadoop.mapreduce.v2.api.records.TaskType.REDUCE\n                .equals(reqTask.getTaskId().getTaskType())) {\n              toBePreempted.add(reqTask);\n              LOG.info(\"preempting \" + reqCont + \" running task:\" + reqTask);\n            } else {\n              LOG.info(\"NOT preempting \" + reqCont + \" running task:\" + reqTask);\n            }\n          }\n        }\n      }\n\n      // handling negotiable preemption\n      PreemptionContract cNegot \u003d preemptionRequests.getContract();\n      if (cNegot !\u003d null\n          \u0026\u0026 cNegot.getResourceRequest() !\u003d null\n          \u0026\u0026 cNegot.getResourceRequest().size() \u003e 0\n          \u0026\u0026 cNegot.getContainers() !\u003d null\n          \u0026\u0026 cNegot.getContainers().size() \u003e 0) {\n\n        LOG.info(\"negotiable preemption :\" +\n            preemptionRequests.getContract().getResourceRequest().size() +\n            \" resourceReq, \" +\n            preemptionRequests.getContract().getContainers().size() +\n            \" containers\");\n        // handle fungible preemption. Here we only look at the total amount of\n        // resources to be preempted and pick enough of our containers to\n        // satisfy that. We only support checkpointing for reducers for now.\n        List\u003cPreemptionResourceRequest\u003e reqResources \u003d\n          preemptionRequests.getContract().getResourceRequest();\n\n        // compute the total amount of pending preemptions (to be discounted\n        // from current request)\n        int pendingPreemptionRam \u003d 0;\n        int pendingPreemptionCores \u003d 0;\n        for (Resource r : pendingFlexiblePreemptions.values()) {\n          pendingPreemptionRam +\u003d r.getMemory();\n          pendingPreemptionCores +\u003d r.getVirtualCores();\n        }\n\n        // discount preemption request based on currently pending preemption\n        for (PreemptionResourceRequest rr : reqResources) {\n          ResourceRequest reqRsrc \u003d rr.getResourceRequest();\n          if (!ResourceRequest.ANY.equals(reqRsrc.getResourceName())) {\n            // For now, only respond to aggregate requests and ignore locality\n            continue;\n          }\n\n          LOG.info(\"ResourceRequest:\" + reqRsrc);\n          int reqCont \u003d reqRsrc.getNumContainers();\n          int reqMem \u003d reqRsrc.getCapability().getMemory();\n          int totalMemoryToRelease \u003d reqCont * reqMem;\n          int reqCores \u003d reqRsrc.getCapability().getVirtualCores();\n          int totalCoresToRelease \u003d reqCont * reqCores;\n\n          // remove\n          if (pendingPreemptionRam \u003e 0) {\n            // if goes negative we simply exit\n            totalMemoryToRelease -\u003d pendingPreemptionRam;\n            // decrement pending resources if zero or negatve we will\n            // ignore it while processing next PreemptionResourceRequest\n            pendingPreemptionRam -\u003d totalMemoryToRelease;\n          }\n          if (pendingPreemptionCores \u003e 0) {\n            totalCoresToRelease -\u003d pendingPreemptionCores;\n            pendingPreemptionCores -\u003d totalCoresToRelease;\n          }\n\n          // reverse order of allocation (for now)\n          List\u003cContainer\u003e listOfCont \u003d ctxt.getContainers(TaskType.REDUCE);\n          Collections.sort(listOfCont, new Comparator\u003cContainer\u003e() {\n            @Override\n            public int compare(final Container o1, final Container o2) {\n              return o2.getId().compareTo(o1.getId());\n            }\n          });\n\n          // preempt reducers first\n          for (Container cont : listOfCont) {\n            if (totalMemoryToRelease \u003c\u003d 0 \u0026\u0026 totalCoresToRelease\u003c\u003d0) {\n              break;\n            }\n            TaskAttemptId reduceId \u003d ctxt.getTaskAttempt(cont.getId());\n            int cMem \u003d cont.getResource().getMemory();\n            int cCores \u003d cont.getResource().getVirtualCores();\n\n            if (!toBePreempted.contains(reduceId)) {\n              totalMemoryToRelease -\u003d cMem;\n              totalCoresToRelease -\u003d cCores;\n                toBePreempted.add(reduceId);\n                pendingFlexiblePreemptions.put(reduceId, cont.getResource());\n            }\n            LOG.info(\"ResourceRequest:\" + reqRsrc + \" satisfied preempting \"\n                + reduceId);\n          }\n          // if map was preemptable we would do add them to toBePreempted here\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/preemption/CheckpointAMPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5196. Add bookkeeping for managing checkpoints of task state.\nContributed by Carlo Curino\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1553939 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/12/13 1:58 PM",
      "commitName": "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,120 @@\n+  public void preempt(Context ctxt, PreemptionMessage preemptionRequests) {\n+\n+    if (preemptionRequests !\u003d null) {\n+\n+      // handling non-negotiable preemption\n+\n+      StrictPreemptionContract cStrict \u003d preemptionRequests.getStrictContract();\n+      if (cStrict !\u003d null\n+          \u0026\u0026 cStrict.getContainers() !\u003d null\n+          \u0026\u0026 cStrict.getContainers().size() \u003e 0) {\n+        LOG.info(\"strict preemption :\" +\n+            preemptionRequests.getStrictContract().getContainers().size() +\n+            \" containers to kill\");\n+\n+        // handle strict preemptions. These containers are non-negotiable\n+        for (PreemptionContainer c :\n+            preemptionRequests.getStrictContract().getContainers()) {\n+          ContainerId reqCont \u003d c.getId();\n+          TaskAttemptId reqTask \u003d ctxt.getTaskAttempt(reqCont);\n+          if (reqTask !\u003d null) {\n+            // ignore requests for preempting containers running maps\n+            if (org.apache.hadoop.mapreduce.v2.api.records.TaskType.REDUCE\n+                .equals(reqTask.getTaskId().getTaskType())) {\n+              toBePreempted.add(reqTask);\n+              LOG.info(\"preempting \" + reqCont + \" running task:\" + reqTask);\n+            } else {\n+              LOG.info(\"NOT preempting \" + reqCont + \" running task:\" + reqTask);\n+            }\n+          }\n+        }\n+      }\n+\n+      // handling negotiable preemption\n+      PreemptionContract cNegot \u003d preemptionRequests.getContract();\n+      if (cNegot !\u003d null\n+          \u0026\u0026 cNegot.getResourceRequest() !\u003d null\n+          \u0026\u0026 cNegot.getResourceRequest().size() \u003e 0\n+          \u0026\u0026 cNegot.getContainers() !\u003d null\n+          \u0026\u0026 cNegot.getContainers().size() \u003e 0) {\n+\n+        LOG.info(\"negotiable preemption :\" +\n+            preemptionRequests.getContract().getResourceRequest().size() +\n+            \" resourceReq, \" +\n+            preemptionRequests.getContract().getContainers().size() +\n+            \" containers\");\n+        // handle fungible preemption. Here we only look at the total amount of\n+        // resources to be preempted and pick enough of our containers to\n+        // satisfy that. We only support checkpointing for reducers for now.\n+        List\u003cPreemptionResourceRequest\u003e reqResources \u003d\n+          preemptionRequests.getContract().getResourceRequest();\n+\n+        // compute the total amount of pending preemptions (to be discounted\n+        // from current request)\n+        int pendingPreemptionRam \u003d 0;\n+        int pendingPreemptionCores \u003d 0;\n+        for (Resource r : pendingFlexiblePreemptions.values()) {\n+          pendingPreemptionRam +\u003d r.getMemory();\n+          pendingPreemptionCores +\u003d r.getVirtualCores();\n+        }\n+\n+        // discount preemption request based on currently pending preemption\n+        for (PreemptionResourceRequest rr : reqResources) {\n+          ResourceRequest reqRsrc \u003d rr.getResourceRequest();\n+          if (!ResourceRequest.ANY.equals(reqRsrc.getResourceName())) {\n+            // For now, only respond to aggregate requests and ignore locality\n+            continue;\n+          }\n+\n+          LOG.info(\"ResourceRequest:\" + reqRsrc);\n+          int reqCont \u003d reqRsrc.getNumContainers();\n+          int reqMem \u003d reqRsrc.getCapability().getMemory();\n+          int totalMemoryToRelease \u003d reqCont * reqMem;\n+          int reqCores \u003d reqRsrc.getCapability().getVirtualCores();\n+          int totalCoresToRelease \u003d reqCont * reqCores;\n+\n+          // remove\n+          if (pendingPreemptionRam \u003e 0) {\n+            // if goes negative we simply exit\n+            totalMemoryToRelease -\u003d pendingPreemptionRam;\n+            // decrement pending resources if zero or negatve we will\n+            // ignore it while processing next PreemptionResourceRequest\n+            pendingPreemptionRam -\u003d totalMemoryToRelease;\n+          }\n+          if (pendingPreemptionCores \u003e 0) {\n+            totalCoresToRelease -\u003d pendingPreemptionCores;\n+            pendingPreemptionCores -\u003d totalCoresToRelease;\n+          }\n+\n+          // reverse order of allocation (for now)\n+          List\u003cContainer\u003e listOfCont \u003d ctxt.getContainers(TaskType.REDUCE);\n+          Collections.sort(listOfCont, new Comparator\u003cContainer\u003e() {\n+            @Override\n+            public int compare(final Container o1, final Container o2) {\n+              return o2.getId().getId() - o1.getId().getId();\n+            }\n+          });\n+\n+          // preempt reducers first\n+          for (Container cont : listOfCont) {\n+            if (totalMemoryToRelease \u003c\u003d 0 \u0026\u0026 totalCoresToRelease\u003c\u003d0) {\n+              break;\n+            }\n+            TaskAttemptId reduceId \u003d ctxt.getTaskAttempt(cont.getId());\n+            int cMem \u003d cont.getResource().getMemory();\n+            int cCores \u003d cont.getResource().getVirtualCores();\n+\n+            if (!toBePreempted.contains(reduceId)) {\n+              totalMemoryToRelease -\u003d cMem;\n+              totalCoresToRelease -\u003d cCores;\n+                toBePreempted.add(reduceId);\n+                pendingFlexiblePreemptions.put(reduceId, cont.getResource());\n+            }\n+            LOG.info(\"ResourceRequest:\" + reqRsrc + \" satisfied preempting \"\n+                + reduceId);\n+          }\n+          // if map was preemptable we would do add them to toBePreempted here\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void preempt(Context ctxt, PreemptionMessage preemptionRequests) {\n\n    if (preemptionRequests !\u003d null) {\n\n      // handling non-negotiable preemption\n\n      StrictPreemptionContract cStrict \u003d preemptionRequests.getStrictContract();\n      if (cStrict !\u003d null\n          \u0026\u0026 cStrict.getContainers() !\u003d null\n          \u0026\u0026 cStrict.getContainers().size() \u003e 0) {\n        LOG.info(\"strict preemption :\" +\n            preemptionRequests.getStrictContract().getContainers().size() +\n            \" containers to kill\");\n\n        // handle strict preemptions. These containers are non-negotiable\n        for (PreemptionContainer c :\n            preemptionRequests.getStrictContract().getContainers()) {\n          ContainerId reqCont \u003d c.getId();\n          TaskAttemptId reqTask \u003d ctxt.getTaskAttempt(reqCont);\n          if (reqTask !\u003d null) {\n            // ignore requests for preempting containers running maps\n            if (org.apache.hadoop.mapreduce.v2.api.records.TaskType.REDUCE\n                .equals(reqTask.getTaskId().getTaskType())) {\n              toBePreempted.add(reqTask);\n              LOG.info(\"preempting \" + reqCont + \" running task:\" + reqTask);\n            } else {\n              LOG.info(\"NOT preempting \" + reqCont + \" running task:\" + reqTask);\n            }\n          }\n        }\n      }\n\n      // handling negotiable preemption\n      PreemptionContract cNegot \u003d preemptionRequests.getContract();\n      if (cNegot !\u003d null\n          \u0026\u0026 cNegot.getResourceRequest() !\u003d null\n          \u0026\u0026 cNegot.getResourceRequest().size() \u003e 0\n          \u0026\u0026 cNegot.getContainers() !\u003d null\n          \u0026\u0026 cNegot.getContainers().size() \u003e 0) {\n\n        LOG.info(\"negotiable preemption :\" +\n            preemptionRequests.getContract().getResourceRequest().size() +\n            \" resourceReq, \" +\n            preemptionRequests.getContract().getContainers().size() +\n            \" containers\");\n        // handle fungible preemption. Here we only look at the total amount of\n        // resources to be preempted and pick enough of our containers to\n        // satisfy that. We only support checkpointing for reducers for now.\n        List\u003cPreemptionResourceRequest\u003e reqResources \u003d\n          preemptionRequests.getContract().getResourceRequest();\n\n        // compute the total amount of pending preemptions (to be discounted\n        // from current request)\n        int pendingPreemptionRam \u003d 0;\n        int pendingPreemptionCores \u003d 0;\n        for (Resource r : pendingFlexiblePreemptions.values()) {\n          pendingPreemptionRam +\u003d r.getMemory();\n          pendingPreemptionCores +\u003d r.getVirtualCores();\n        }\n\n        // discount preemption request based on currently pending preemption\n        for (PreemptionResourceRequest rr : reqResources) {\n          ResourceRequest reqRsrc \u003d rr.getResourceRequest();\n          if (!ResourceRequest.ANY.equals(reqRsrc.getResourceName())) {\n            // For now, only respond to aggregate requests and ignore locality\n            continue;\n          }\n\n          LOG.info(\"ResourceRequest:\" + reqRsrc);\n          int reqCont \u003d reqRsrc.getNumContainers();\n          int reqMem \u003d reqRsrc.getCapability().getMemory();\n          int totalMemoryToRelease \u003d reqCont * reqMem;\n          int reqCores \u003d reqRsrc.getCapability().getVirtualCores();\n          int totalCoresToRelease \u003d reqCont * reqCores;\n\n          // remove\n          if (pendingPreemptionRam \u003e 0) {\n            // if goes negative we simply exit\n            totalMemoryToRelease -\u003d pendingPreemptionRam;\n            // decrement pending resources if zero or negatve we will\n            // ignore it while processing next PreemptionResourceRequest\n            pendingPreemptionRam -\u003d totalMemoryToRelease;\n          }\n          if (pendingPreemptionCores \u003e 0) {\n            totalCoresToRelease -\u003d pendingPreemptionCores;\n            pendingPreemptionCores -\u003d totalCoresToRelease;\n          }\n\n          // reverse order of allocation (for now)\n          List\u003cContainer\u003e listOfCont \u003d ctxt.getContainers(TaskType.REDUCE);\n          Collections.sort(listOfCont, new Comparator\u003cContainer\u003e() {\n            @Override\n            public int compare(final Container o1, final Container o2) {\n              return o2.getId().getId() - o1.getId().getId();\n            }\n          });\n\n          // preempt reducers first\n          for (Container cont : listOfCont) {\n            if (totalMemoryToRelease \u003c\u003d 0 \u0026\u0026 totalCoresToRelease\u003c\u003d0) {\n              break;\n            }\n            TaskAttemptId reduceId \u003d ctxt.getTaskAttempt(cont.getId());\n            int cMem \u003d cont.getResource().getMemory();\n            int cCores \u003d cont.getResource().getVirtualCores();\n\n            if (!toBePreempted.contains(reduceId)) {\n              totalMemoryToRelease -\u003d cMem;\n              totalCoresToRelease -\u003d cCores;\n                toBePreempted.add(reduceId);\n                pendingFlexiblePreemptions.put(reduceId, cont.getResource());\n            }\n            LOG.info(\"ResourceRequest:\" + reqRsrc + \" satisfied preempting \"\n                + reduceId);\n          }\n          // if map was preemptable we would do add them to toBePreempted here\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/preemption/CheckpointAMPreemptionPolicy.java"
    }
  }
}