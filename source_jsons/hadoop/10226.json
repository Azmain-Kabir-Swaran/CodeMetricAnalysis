{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPoolManager.java",
  "functionName": "doRefreshNamenodes",
  "functionId": "doRefreshNamenodes___addrMap-Map__String,Map__String,InetSocketAddress______lifelineAddrMap-Map__String,Map__String,InetSocketAddress____",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java",
  "functionStartLine": 174,
  "functionEndLine": 291,
  "numCommitsSeen": 27,
  "timeTaken": 4155,
  "changeHistory": [
    "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa",
    "35c17351cab645dcc72e0d2ae1608507aa787ffb",
    "3a91376707d451777b8269f81bcd48315edd9fc7",
    "2759689d7d23001f007cb0dbe2521de90734dd5c",
    "d9593621b5739a6c2a4f2ea7817d7783326a3886",
    "f4fa76719e622a4ef883c51ec0abc6e6e6ddf09e"
  ],
  "changeHistoryShort": {
    "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa": "Ybodychange",
    "35c17351cab645dcc72e0d2ae1608507aa787ffb": "Ybodychange",
    "3a91376707d451777b8269f81bcd48315edd9fc7": "Ybodychange",
    "2759689d7d23001f007cb0dbe2521de90734dd5c": "Ymultichange(Yparameterchange,Ybodychange)",
    "d9593621b5739a6c2a4f2ea7817d7783326a3886": "Ybodychange",
    "f4fa76719e622a4ef883c51ec0abc6e6e6ddf09e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14045. Use different metrics in DataNode to better measure latency of heartbeat/blockReports/incrementalBlockReports of Active/Standby NN. Contributed by Jiandan Yang.\n",
      "commitDate": "15/11/18 10:58 AM",
      "commitName": "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "14/03/18 10:38 AM",
      "commitNameOld": "0be0f1ce1da984ff3a8fd4b079297ead2dc6722d",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 246.06,
      "commitsBetweenForRepo": 2563,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,118 @@\n   private void doRefreshNamenodes(\n       Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n       Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n       throws IOException {\n     assert Thread.holdsLock(refreshNamenodesLock);\n \n     Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toRemove;\n     \n     synchronized (this) {\n       // Step 1. For each of the new nameservices, figure out whether\n       // it\u0027s an update of the set of NNs for an existing NS,\n       // or an entirely new nameservice.\n       for (String nameserviceId : addrMap.keySet()) {\n         if (bpByNameserviceId.containsKey(nameserviceId)) {\n           toRefresh.add(nameserviceId);\n         } else {\n           toAdd.add(nameserviceId);\n         }\n       }\n       \n       // Step 2. Any nameservices we currently have but are no longer present\n       // need to be removed.\n       toRemove \u003d Sets.newHashSet(Sets.difference(\n           bpByNameserviceId.keySet(), addrMap.keySet()));\n       \n       assert toRefresh.size() + toAdd.size() \u003d\u003d\n         addrMap.size() :\n           \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n           \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n           \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n \n       \n       // Step 3. Start new nameservices\n       if (!toAdd.isEmpty()) {\n         LOG.info(\"Starting BPOfferServices for nameservices: \" +\n             Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n       \n         for (String nsToAdd : toAdd) {\n           Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n           Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n               lifelineAddrMap.get(nsToAdd);\n           ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n               Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+          ArrayList\u003cString\u003e nnIds \u003d\n+              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n           ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n               Lists.newArrayListWithCapacity(nnIdToAddr.size());\n           for (String nnId : nnIdToAddr.keySet()) {\n             addrs.add(nnIdToAddr.get(nnId));\n+            nnIds.add(nnId);\n             lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                 nnIdToLifelineAddr.get(nnId) : null);\n           }\n-          BPOfferService bpos \u003d createBPOS(nsToAdd, addrs, lifelineAddrs);\n+          BPOfferService bpos \u003d createBPOS(nsToAdd, nnIds, addrs,\n+              lifelineAddrs);\n           bpByNameserviceId.put(nsToAdd, bpos);\n           offerServices.add(bpos);\n         }\n       }\n       startAll();\n     }\n \n     // Step 4. Shut down old nameservices. This happens outside\n     // of the synchronized(this) lock since they need to call\n     // back to .remove() from another thread\n     if (!toRemove.isEmpty()) {\n       LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n       \n       for (String nsToRemove : toRemove) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n         bpos.stop();\n         bpos.join();\n         // they will call remove on their own\n       }\n     }\n     \n     // Step 5. Update nameservices whose NN list has changed\n     if (!toRefresh.isEmpty()) {\n       LOG.info(\"Refreshing list of NNs for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n       \n       for (String nsToRefresh : toRefresh) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n         Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n         Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n             lifelineAddrMap.get(nsToRefresh);\n         ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n             Lists.newArrayListWithCapacity(nnIdToAddr.size());\n         ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n             Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+        ArrayList\u003cString\u003e nnIds \u003d Lists.newArrayListWithCapacity(\n+            nnIdToAddr.size());\n         for (String nnId : nnIdToAddr.keySet()) {\n           addrs.add(nnIdToAddr.get(nnId));\n           lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n               nnIdToLifelineAddr.get(nnId) : null);\n+          nnIds.add(nnId);\n         }\n         try {\n           UserGroupInformation.getLoginUser()\n               .doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                 @Override\n                 public Object run() throws Exception {\n-                  bpos.refreshNNList(addrs, lifelineAddrs);\n+                  bpos.refreshNNList(nsToRefresh, nnIds, addrs, lifelineAddrs);\n                   return null;\n                 }\n               });\n         } catch (InterruptedException ex) {\n           IOException ioe \u003d new IOException();\n           ioe.initCause(ex.getCause());\n           throw ioe;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRefreshNamenodes(\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n      throws IOException {\n    assert Thread.holdsLock(refreshNamenodesLock);\n\n    Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toRemove;\n    \n    synchronized (this) {\n      // Step 1. For each of the new nameservices, figure out whether\n      // it\u0027s an update of the set of NNs for an existing NS,\n      // or an entirely new nameservice.\n      for (String nameserviceId : addrMap.keySet()) {\n        if (bpByNameserviceId.containsKey(nameserviceId)) {\n          toRefresh.add(nameserviceId);\n        } else {\n          toAdd.add(nameserviceId);\n        }\n      }\n      \n      // Step 2. Any nameservices we currently have but are no longer present\n      // need to be removed.\n      toRemove \u003d Sets.newHashSet(Sets.difference(\n          bpByNameserviceId.keySet(), addrMap.keySet()));\n      \n      assert toRefresh.size() + toAdd.size() \u003d\u003d\n        addrMap.size() :\n          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n\n      \n      // Step 3. Start new nameservices\n      if (!toAdd.isEmpty()) {\n        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n      \n        for (String nsToAdd : toAdd) {\n          Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n          Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n              lifelineAddrMap.get(nsToAdd);\n          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          ArrayList\u003cString\u003e nnIds \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          for (String nnId : nnIdToAddr.keySet()) {\n            addrs.add(nnIdToAddr.get(nnId));\n            nnIds.add(nnId);\n            lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                nnIdToLifelineAddr.get(nnId) : null);\n          }\n          BPOfferService bpos \u003d createBPOS(nsToAdd, nnIds, addrs,\n              lifelineAddrs);\n          bpByNameserviceId.put(nsToAdd, bpos);\n          offerServices.add(bpos);\n        }\n      }\n      startAll();\n    }\n\n    // Step 4. Shut down old nameservices. This happens outside\n    // of the synchronized(this) lock since they need to call\n    // back to .remove() from another thread\n    if (!toRemove.isEmpty()) {\n      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n      \n      for (String nsToRemove : toRemove) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n        bpos.stop();\n        bpos.join();\n        // they will call remove on their own\n      }\n    }\n    \n    // Step 5. Update nameservices whose NN list has changed\n    if (!toRefresh.isEmpty()) {\n      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n      \n      for (String nsToRefresh : toRefresh) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n            lifelineAddrMap.get(nsToRefresh);\n        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        ArrayList\u003cString\u003e nnIds \u003d Lists.newArrayListWithCapacity(\n            nnIdToAddr.size());\n        for (String nnId : nnIdToAddr.keySet()) {\n          addrs.add(nnIdToAddr.get(nnId));\n          lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n              nnIdToLifelineAddr.get(nnId) : null);\n          nnIds.add(nnId);\n        }\n        try {\n          UserGroupInformation.getLoginUser()\n              .doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws Exception {\n                  bpos.refreshNNList(nsToRefresh, nnIds, addrs, lifelineAddrs);\n                  return null;\n                }\n              });\n        } catch (InterruptedException ex) {\n          IOException ioe \u003d new IOException();\n          ioe.initCause(ex.getCause());\n          throw ioe;\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java",
      "extendedDetails": {}
    },
    "35c17351cab645dcc72e0d2ae1608507aa787ffb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8693. Addendum patch to execute the command using UGI. Contributed by Brahma Reddy Battula.\n",
      "commitDate": "12/02/18 8:44 AM",
      "commitName": "35c17351cab645dcc72e0d2ae1608507aa787ffb",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "14/09/17 11:17 AM",
      "commitNameOld": "65a941008d4bbf906772399d3f035f2a0da5abfa",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 150.94,
      "commitsBetweenForRepo": 1041,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,111 @@\n   private void doRefreshNamenodes(\n       Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n       Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n       throws IOException {\n     assert Thread.holdsLock(refreshNamenodesLock);\n \n     Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toRemove;\n     \n     synchronized (this) {\n       // Step 1. For each of the new nameservices, figure out whether\n       // it\u0027s an update of the set of NNs for an existing NS,\n       // or an entirely new nameservice.\n       for (String nameserviceId : addrMap.keySet()) {\n         if (bpByNameserviceId.containsKey(nameserviceId)) {\n           toRefresh.add(nameserviceId);\n         } else {\n           toAdd.add(nameserviceId);\n         }\n       }\n       \n       // Step 2. Any nameservices we currently have but are no longer present\n       // need to be removed.\n       toRemove \u003d Sets.newHashSet(Sets.difference(\n           bpByNameserviceId.keySet(), addrMap.keySet()));\n       \n       assert toRefresh.size() + toAdd.size() \u003d\u003d\n         addrMap.size() :\n           \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n           \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n           \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n \n       \n       // Step 3. Start new nameservices\n       if (!toAdd.isEmpty()) {\n         LOG.info(\"Starting BPOfferServices for nameservices: \" +\n             Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n       \n         for (String nsToAdd : toAdd) {\n           Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n           Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n               lifelineAddrMap.get(nsToAdd);\n           ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n               Lists.newArrayListWithCapacity(nnIdToAddr.size());\n           ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n               Lists.newArrayListWithCapacity(nnIdToAddr.size());\n           for (String nnId : nnIdToAddr.keySet()) {\n             addrs.add(nnIdToAddr.get(nnId));\n             lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                 nnIdToLifelineAddr.get(nnId) : null);\n           }\n           BPOfferService bpos \u003d createBPOS(nsToAdd, addrs, lifelineAddrs);\n           bpByNameserviceId.put(nsToAdd, bpos);\n           offerServices.add(bpos);\n         }\n       }\n       startAll();\n     }\n \n     // Step 4. Shut down old nameservices. This happens outside\n     // of the synchronized(this) lock since they need to call\n     // back to .remove() from another thread\n     if (!toRemove.isEmpty()) {\n       LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n       \n       for (String nsToRemove : toRemove) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n         bpos.stop();\n         bpos.join();\n         // they will call remove on their own\n       }\n     }\n     \n     // Step 5. Update nameservices whose NN list has changed\n     if (!toRefresh.isEmpty()) {\n       LOG.info(\"Refreshing list of NNs for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n       \n       for (String nsToRefresh : toRefresh) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n         Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n         Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n             lifelineAddrMap.get(nsToRefresh);\n         ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n             Lists.newArrayListWithCapacity(nnIdToAddr.size());\n         ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n             Lists.newArrayListWithCapacity(nnIdToAddr.size());\n         for (String nnId : nnIdToAddr.keySet()) {\n           addrs.add(nnIdToAddr.get(nnId));\n           lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n               nnIdToLifelineAddr.get(nnId) : null);\n         }\n-        bpos.refreshNNList(addrs, lifelineAddrs);\n+        try {\n+          UserGroupInformation.getLoginUser()\n+              .doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+                @Override\n+                public Object run() throws Exception {\n+                  bpos.refreshNNList(addrs, lifelineAddrs);\n+                  return null;\n+                }\n+              });\n+        } catch (InterruptedException ex) {\n+          IOException ioe \u003d new IOException();\n+          ioe.initCause(ex.getCause());\n+          throw ioe;\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRefreshNamenodes(\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n      throws IOException {\n    assert Thread.holdsLock(refreshNamenodesLock);\n\n    Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toRemove;\n    \n    synchronized (this) {\n      // Step 1. For each of the new nameservices, figure out whether\n      // it\u0027s an update of the set of NNs for an existing NS,\n      // or an entirely new nameservice.\n      for (String nameserviceId : addrMap.keySet()) {\n        if (bpByNameserviceId.containsKey(nameserviceId)) {\n          toRefresh.add(nameserviceId);\n        } else {\n          toAdd.add(nameserviceId);\n        }\n      }\n      \n      // Step 2. Any nameservices we currently have but are no longer present\n      // need to be removed.\n      toRemove \u003d Sets.newHashSet(Sets.difference(\n          bpByNameserviceId.keySet(), addrMap.keySet()));\n      \n      assert toRefresh.size() + toAdd.size() \u003d\u003d\n        addrMap.size() :\n          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n\n      \n      // Step 3. Start new nameservices\n      if (!toAdd.isEmpty()) {\n        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n      \n        for (String nsToAdd : toAdd) {\n          Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n          Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n              lifelineAddrMap.get(nsToAdd);\n          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          for (String nnId : nnIdToAddr.keySet()) {\n            addrs.add(nnIdToAddr.get(nnId));\n            lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                nnIdToLifelineAddr.get(nnId) : null);\n          }\n          BPOfferService bpos \u003d createBPOS(nsToAdd, addrs, lifelineAddrs);\n          bpByNameserviceId.put(nsToAdd, bpos);\n          offerServices.add(bpos);\n        }\n      }\n      startAll();\n    }\n\n    // Step 4. Shut down old nameservices. This happens outside\n    // of the synchronized(this) lock since they need to call\n    // back to .remove() from another thread\n    if (!toRemove.isEmpty()) {\n      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n      \n      for (String nsToRemove : toRemove) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n        bpos.stop();\n        bpos.join();\n        // they will call remove on their own\n      }\n    }\n    \n    // Step 5. Update nameservices whose NN list has changed\n    if (!toRefresh.isEmpty()) {\n      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n      \n      for (String nsToRefresh : toRefresh) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n            lifelineAddrMap.get(nsToRefresh);\n        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        for (String nnId : nnIdToAddr.keySet()) {\n          addrs.add(nnIdToAddr.get(nnId));\n          lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n              nnIdToLifelineAddr.get(nnId) : null);\n        }\n        try {\n          UserGroupInformation.getLoginUser()\n              .doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws Exception {\n                  bpos.refreshNNList(addrs, lifelineAddrs);\n                  return null;\n                }\n              });\n        } catch (InterruptedException ex) {\n          IOException ioe \u003d new IOException();\n          ioe.initCause(ex.getCause());\n          throw ioe;\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java",
      "extendedDetails": {}
    },
    "3a91376707d451777b8269f81bcd48315edd9fc7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11558. BPServiceActor thread name is too long. Contributed by Xiaobing Zhou\n",
      "commitDate": "11/04/17 3:29 PM",
      "commitName": "3a91376707d451777b8269f81bcd48315edd9fc7",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "04/03/16 3:29 PM",
      "commitNameOld": "2759689d7d23001f007cb0dbe2521de90734dd5c",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 402.96,
      "commitsBetweenForRepo": 2671,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   private void doRefreshNamenodes(\n       Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n       Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n       throws IOException {\n     assert Thread.holdsLock(refreshNamenodesLock);\n \n     Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toRemove;\n     \n     synchronized (this) {\n       // Step 1. For each of the new nameservices, figure out whether\n       // it\u0027s an update of the set of NNs for an existing NS,\n       // or an entirely new nameservice.\n       for (String nameserviceId : addrMap.keySet()) {\n         if (bpByNameserviceId.containsKey(nameserviceId)) {\n           toRefresh.add(nameserviceId);\n         } else {\n           toAdd.add(nameserviceId);\n         }\n       }\n       \n       // Step 2. Any nameservices we currently have but are no longer present\n       // need to be removed.\n       toRemove \u003d Sets.newHashSet(Sets.difference(\n           bpByNameserviceId.keySet(), addrMap.keySet()));\n       \n       assert toRefresh.size() + toAdd.size() \u003d\u003d\n         addrMap.size() :\n           \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n           \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n           \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n \n       \n       // Step 3. Start new nameservices\n       if (!toAdd.isEmpty()) {\n         LOG.info(\"Starting BPOfferServices for nameservices: \" +\n             Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n       \n         for (String nsToAdd : toAdd) {\n           Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n           Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n               lifelineAddrMap.get(nsToAdd);\n           ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n               Lists.newArrayListWithCapacity(nnIdToAddr.size());\n           ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n               Lists.newArrayListWithCapacity(nnIdToAddr.size());\n           for (String nnId : nnIdToAddr.keySet()) {\n             addrs.add(nnIdToAddr.get(nnId));\n             lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                 nnIdToLifelineAddr.get(nnId) : null);\n           }\n-          BPOfferService bpos \u003d createBPOS(addrs, lifelineAddrs);\n+          BPOfferService bpos \u003d createBPOS(nsToAdd, addrs, lifelineAddrs);\n           bpByNameserviceId.put(nsToAdd, bpos);\n           offerServices.add(bpos);\n         }\n       }\n       startAll();\n     }\n \n     // Step 4. Shut down old nameservices. This happens outside\n     // of the synchronized(this) lock since they need to call\n     // back to .remove() from another thread\n     if (!toRemove.isEmpty()) {\n       LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n       \n       for (String nsToRemove : toRemove) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n         bpos.stop();\n         bpos.join();\n         // they will call remove on their own\n       }\n     }\n     \n     // Step 5. Update nameservices whose NN list has changed\n     if (!toRefresh.isEmpty()) {\n       LOG.info(\"Refreshing list of NNs for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n       \n       for (String nsToRefresh : toRefresh) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n         Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n         Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n             lifelineAddrMap.get(nsToRefresh);\n         ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n             Lists.newArrayListWithCapacity(nnIdToAddr.size());\n         ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n             Lists.newArrayListWithCapacity(nnIdToAddr.size());\n         for (String nnId : nnIdToAddr.keySet()) {\n           addrs.add(nnIdToAddr.get(nnId));\n           lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n               nnIdToLifelineAddr.get(nnId) : null);\n         }\n         bpos.refreshNNList(addrs, lifelineAddrs);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRefreshNamenodes(\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n      throws IOException {\n    assert Thread.holdsLock(refreshNamenodesLock);\n\n    Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toRemove;\n    \n    synchronized (this) {\n      // Step 1. For each of the new nameservices, figure out whether\n      // it\u0027s an update of the set of NNs for an existing NS,\n      // or an entirely new nameservice.\n      for (String nameserviceId : addrMap.keySet()) {\n        if (bpByNameserviceId.containsKey(nameserviceId)) {\n          toRefresh.add(nameserviceId);\n        } else {\n          toAdd.add(nameserviceId);\n        }\n      }\n      \n      // Step 2. Any nameservices we currently have but are no longer present\n      // need to be removed.\n      toRemove \u003d Sets.newHashSet(Sets.difference(\n          bpByNameserviceId.keySet(), addrMap.keySet()));\n      \n      assert toRefresh.size() + toAdd.size() \u003d\u003d\n        addrMap.size() :\n          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n\n      \n      // Step 3. Start new nameservices\n      if (!toAdd.isEmpty()) {\n        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n      \n        for (String nsToAdd : toAdd) {\n          Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n          Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n              lifelineAddrMap.get(nsToAdd);\n          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          for (String nnId : nnIdToAddr.keySet()) {\n            addrs.add(nnIdToAddr.get(nnId));\n            lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                nnIdToLifelineAddr.get(nnId) : null);\n          }\n          BPOfferService bpos \u003d createBPOS(nsToAdd, addrs, lifelineAddrs);\n          bpByNameserviceId.put(nsToAdd, bpos);\n          offerServices.add(bpos);\n        }\n      }\n      startAll();\n    }\n\n    // Step 4. Shut down old nameservices. This happens outside\n    // of the synchronized(this) lock since they need to call\n    // back to .remove() from another thread\n    if (!toRemove.isEmpty()) {\n      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n      \n      for (String nsToRemove : toRemove) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n        bpos.stop();\n        bpos.join();\n        // they will call remove on their own\n      }\n    }\n    \n    // Step 5. Update nameservices whose NN list has changed\n    if (!toRefresh.isEmpty()) {\n      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n      \n      for (String nsToRefresh : toRefresh) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n            lifelineAddrMap.get(nsToRefresh);\n        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        for (String nnId : nnIdToAddr.keySet()) {\n          addrs.add(nnIdToAddr.get(nnId));\n          lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n              nnIdToLifelineAddr.get(nnId) : null);\n        }\n        bpos.refreshNNList(addrs, lifelineAddrs);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java",
      "extendedDetails": {}
    },
    "2759689d7d23001f007cb0dbe2521de90734dd5c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9239. DataNode Lifeline Protocol: an alternative protocol for reporting DataNode liveness. Contributed by Chris Nauroth.\n",
      "commitDate": "04/03/16 3:29 PM",
      "commitName": "2759689d7d23001f007cb0dbe2521de90734dd5c",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9239. DataNode Lifeline Protocol: an alternative protocol for reporting DataNode liveness. Contributed by Chris Nauroth.\n",
          "commitDate": "04/03/16 3:29 PM",
          "commitName": "2759689d7d23001f007cb0dbe2521de90734dd5c",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "22/11/15 3:54 PM",
          "commitNameOld": "176ff5ce90f2cbcd8342016d0f5570337d2ff79f",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 102.98,
          "commitsBetweenForRepo": 682,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,98 @@\n   private void doRefreshNamenodes(\n-      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap) throws IOException {\n+      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n+      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n+      throws IOException {\n     assert Thread.holdsLock(refreshNamenodesLock);\n \n     Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toRemove;\n     \n     synchronized (this) {\n       // Step 1. For each of the new nameservices, figure out whether\n       // it\u0027s an update of the set of NNs for an existing NS,\n       // or an entirely new nameservice.\n       for (String nameserviceId : addrMap.keySet()) {\n         if (bpByNameserviceId.containsKey(nameserviceId)) {\n           toRefresh.add(nameserviceId);\n         } else {\n           toAdd.add(nameserviceId);\n         }\n       }\n       \n       // Step 2. Any nameservices we currently have but are no longer present\n       // need to be removed.\n       toRemove \u003d Sets.newHashSet(Sets.difference(\n           bpByNameserviceId.keySet(), addrMap.keySet()));\n       \n       assert toRefresh.size() + toAdd.size() \u003d\u003d\n         addrMap.size() :\n           \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n           \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n           \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n \n       \n       // Step 3. Start new nameservices\n       if (!toAdd.isEmpty()) {\n         LOG.info(\"Starting BPOfferServices for nameservices: \" +\n             Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n       \n         for (String nsToAdd : toAdd) {\n+          Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n+          Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n+              lifelineAddrMap.get(nsToAdd);\n           ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n-            Lists.newArrayList(addrMap.get(nsToAdd).values());\n-          BPOfferService bpos \u003d createBPOS(addrs);\n+              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+          ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n+              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+          for (String nnId : nnIdToAddr.keySet()) {\n+            addrs.add(nnIdToAddr.get(nnId));\n+            lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n+                nnIdToLifelineAddr.get(nnId) : null);\n+          }\n+          BPOfferService bpos \u003d createBPOS(addrs, lifelineAddrs);\n           bpByNameserviceId.put(nsToAdd, bpos);\n           offerServices.add(bpos);\n         }\n       }\n       startAll();\n     }\n \n     // Step 4. Shut down old nameservices. This happens outside\n     // of the synchronized(this) lock since they need to call\n     // back to .remove() from another thread\n     if (!toRemove.isEmpty()) {\n       LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n       \n       for (String nsToRemove : toRemove) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n         bpos.stop();\n         bpos.join();\n         // they will call remove on their own\n       }\n     }\n     \n     // Step 5. Update nameservices whose NN list has changed\n     if (!toRefresh.isEmpty()) {\n       LOG.info(\"Refreshing list of NNs for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n       \n       for (String nsToRefresh : toRefresh) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n+        Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n+        Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n+            lifelineAddrMap.get(nsToRefresh);\n         ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n-          Lists.newArrayList(addrMap.get(nsToRefresh).values());\n-        bpos.refreshNNList(addrs);\n+            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+        ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n+            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+        for (String nnId : nnIdToAddr.keySet()) {\n+          addrs.add(nnIdToAddr.get(nnId));\n+          lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n+              nnIdToLifelineAddr.get(nnId) : null);\n+        }\n+        bpos.refreshNNList(addrs, lifelineAddrs);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doRefreshNamenodes(\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n      throws IOException {\n    assert Thread.holdsLock(refreshNamenodesLock);\n\n    Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toRemove;\n    \n    synchronized (this) {\n      // Step 1. For each of the new nameservices, figure out whether\n      // it\u0027s an update of the set of NNs for an existing NS,\n      // or an entirely new nameservice.\n      for (String nameserviceId : addrMap.keySet()) {\n        if (bpByNameserviceId.containsKey(nameserviceId)) {\n          toRefresh.add(nameserviceId);\n        } else {\n          toAdd.add(nameserviceId);\n        }\n      }\n      \n      // Step 2. Any nameservices we currently have but are no longer present\n      // need to be removed.\n      toRemove \u003d Sets.newHashSet(Sets.difference(\n          bpByNameserviceId.keySet(), addrMap.keySet()));\n      \n      assert toRefresh.size() + toAdd.size() \u003d\u003d\n        addrMap.size() :\n          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n\n      \n      // Step 3. Start new nameservices\n      if (!toAdd.isEmpty()) {\n        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n      \n        for (String nsToAdd : toAdd) {\n          Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n          Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n              lifelineAddrMap.get(nsToAdd);\n          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          for (String nnId : nnIdToAddr.keySet()) {\n            addrs.add(nnIdToAddr.get(nnId));\n            lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                nnIdToLifelineAddr.get(nnId) : null);\n          }\n          BPOfferService bpos \u003d createBPOS(addrs, lifelineAddrs);\n          bpByNameserviceId.put(nsToAdd, bpos);\n          offerServices.add(bpos);\n        }\n      }\n      startAll();\n    }\n\n    // Step 4. Shut down old nameservices. This happens outside\n    // of the synchronized(this) lock since they need to call\n    // back to .remove() from another thread\n    if (!toRemove.isEmpty()) {\n      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n      \n      for (String nsToRemove : toRemove) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n        bpos.stop();\n        bpos.join();\n        // they will call remove on their own\n      }\n    }\n    \n    // Step 5. Update nameservices whose NN list has changed\n    if (!toRefresh.isEmpty()) {\n      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n      \n      for (String nsToRefresh : toRefresh) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n            lifelineAddrMap.get(nsToRefresh);\n        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        for (String nnId : nnIdToAddr.keySet()) {\n          addrs.add(nnIdToAddr.get(nnId));\n          lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n              nnIdToLifelineAddr.get(nnId) : null);\n        }\n        bpos.refreshNNList(addrs, lifelineAddrs);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java",
          "extendedDetails": {
            "oldValue": "[addrMap-Map\u003cString,Map\u003cString,InetSocketAddress\u003e\u003e]",
            "newValue": "[addrMap-Map\u003cString,Map\u003cString,InetSocketAddress\u003e\u003e, lifelineAddrMap-Map\u003cString,Map\u003cString,InetSocketAddress\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9239. DataNode Lifeline Protocol: an alternative protocol for reporting DataNode liveness. Contributed by Chris Nauroth.\n",
          "commitDate": "04/03/16 3:29 PM",
          "commitName": "2759689d7d23001f007cb0dbe2521de90734dd5c",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "22/11/15 3:54 PM",
          "commitNameOld": "176ff5ce90f2cbcd8342016d0f5570337d2ff79f",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 102.98,
          "commitsBetweenForRepo": 682,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,98 @@\n   private void doRefreshNamenodes(\n-      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap) throws IOException {\n+      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n+      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n+      throws IOException {\n     assert Thread.holdsLock(refreshNamenodesLock);\n \n     Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toRemove;\n     \n     synchronized (this) {\n       // Step 1. For each of the new nameservices, figure out whether\n       // it\u0027s an update of the set of NNs for an existing NS,\n       // or an entirely new nameservice.\n       for (String nameserviceId : addrMap.keySet()) {\n         if (bpByNameserviceId.containsKey(nameserviceId)) {\n           toRefresh.add(nameserviceId);\n         } else {\n           toAdd.add(nameserviceId);\n         }\n       }\n       \n       // Step 2. Any nameservices we currently have but are no longer present\n       // need to be removed.\n       toRemove \u003d Sets.newHashSet(Sets.difference(\n           bpByNameserviceId.keySet(), addrMap.keySet()));\n       \n       assert toRefresh.size() + toAdd.size() \u003d\u003d\n         addrMap.size() :\n           \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n           \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n           \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n \n       \n       // Step 3. Start new nameservices\n       if (!toAdd.isEmpty()) {\n         LOG.info(\"Starting BPOfferServices for nameservices: \" +\n             Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n       \n         for (String nsToAdd : toAdd) {\n+          Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n+          Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n+              lifelineAddrMap.get(nsToAdd);\n           ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n-            Lists.newArrayList(addrMap.get(nsToAdd).values());\n-          BPOfferService bpos \u003d createBPOS(addrs);\n+              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+          ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n+              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+          for (String nnId : nnIdToAddr.keySet()) {\n+            addrs.add(nnIdToAddr.get(nnId));\n+            lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n+                nnIdToLifelineAddr.get(nnId) : null);\n+          }\n+          BPOfferService bpos \u003d createBPOS(addrs, lifelineAddrs);\n           bpByNameserviceId.put(nsToAdd, bpos);\n           offerServices.add(bpos);\n         }\n       }\n       startAll();\n     }\n \n     // Step 4. Shut down old nameservices. This happens outside\n     // of the synchronized(this) lock since they need to call\n     // back to .remove() from another thread\n     if (!toRemove.isEmpty()) {\n       LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n       \n       for (String nsToRemove : toRemove) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n         bpos.stop();\n         bpos.join();\n         // they will call remove on their own\n       }\n     }\n     \n     // Step 5. Update nameservices whose NN list has changed\n     if (!toRefresh.isEmpty()) {\n       LOG.info(\"Refreshing list of NNs for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n       \n       for (String nsToRefresh : toRefresh) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n+        Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n+        Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n+            lifelineAddrMap.get(nsToRefresh);\n         ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n-          Lists.newArrayList(addrMap.get(nsToRefresh).values());\n-        bpos.refreshNNList(addrs);\n+            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+        ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n+            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n+        for (String nnId : nnIdToAddr.keySet()) {\n+          addrs.add(nnIdToAddr.get(nnId));\n+          lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n+              nnIdToLifelineAddr.get(nnId) : null);\n+        }\n+        bpos.refreshNNList(addrs, lifelineAddrs);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doRefreshNamenodes(\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap,\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e lifelineAddrMap)\n      throws IOException {\n    assert Thread.holdsLock(refreshNamenodesLock);\n\n    Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toRemove;\n    \n    synchronized (this) {\n      // Step 1. For each of the new nameservices, figure out whether\n      // it\u0027s an update of the set of NNs for an existing NS,\n      // or an entirely new nameservice.\n      for (String nameserviceId : addrMap.keySet()) {\n        if (bpByNameserviceId.containsKey(nameserviceId)) {\n          toRefresh.add(nameserviceId);\n        } else {\n          toAdd.add(nameserviceId);\n        }\n      }\n      \n      // Step 2. Any nameservices we currently have but are no longer present\n      // need to be removed.\n      toRemove \u003d Sets.newHashSet(Sets.difference(\n          bpByNameserviceId.keySet(), addrMap.keySet()));\n      \n      assert toRefresh.size() + toAdd.size() \u003d\u003d\n        addrMap.size() :\n          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n\n      \n      // Step 3. Start new nameservices\n      if (!toAdd.isEmpty()) {\n        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n      \n        for (String nsToAdd : toAdd) {\n          Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToAdd);\n          Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n              lifelineAddrMap.get(nsToAdd);\n          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n              Lists.newArrayListWithCapacity(nnIdToAddr.size());\n          for (String nnId : nnIdToAddr.keySet()) {\n            addrs.add(nnIdToAddr.get(nnId));\n            lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n                nnIdToLifelineAddr.get(nnId) : null);\n          }\n          BPOfferService bpos \u003d createBPOS(addrs, lifelineAddrs);\n          bpByNameserviceId.put(nsToAdd, bpos);\n          offerServices.add(bpos);\n        }\n      }\n      startAll();\n    }\n\n    // Step 4. Shut down old nameservices. This happens outside\n    // of the synchronized(this) lock since they need to call\n    // back to .remove() from another thread\n    if (!toRemove.isEmpty()) {\n      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n      \n      for (String nsToRemove : toRemove) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n        bpos.stop();\n        bpos.join();\n        // they will call remove on their own\n      }\n    }\n    \n    // Step 5. Update nameservices whose NN list has changed\n    if (!toRefresh.isEmpty()) {\n      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n      \n      for (String nsToRefresh : toRefresh) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToAddr \u003d addrMap.get(nsToRefresh);\n        Map\u003cString, InetSocketAddress\u003e nnIdToLifelineAddr \u003d\n            lifelineAddrMap.get(nsToRefresh);\n        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        ArrayList\u003cInetSocketAddress\u003e lifelineAddrs \u003d\n            Lists.newArrayListWithCapacity(nnIdToAddr.size());\n        for (String nnId : nnIdToAddr.keySet()) {\n          addrs.add(nnIdToAddr.get(nnId));\n          lifelineAddrs.add(nnIdToLifelineAddr !\u003d null ?\n              nnIdToLifelineAddr.get(nnId) : null);\n        }\n        bpos.refreshNNList(addrs, lifelineAddrs);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "d9593621b5739a6c2a4f2ea7817d7783326a3886": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4669. TestBlockPoolManager fails using IBM java. Contributed by Tian Hong Wang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466176 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/13 12:04 PM",
      "commitName": "d9593621b5739a6c2a4f2ea7817d7783326a3886",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "26/10/12 11:22 AM",
      "commitNameOld": "3335e502446b1542fc99c0c831e0542e53eac6f1",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 165.03,
      "commitsBetweenForRepo": 756,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   private void doRefreshNamenodes(\n       Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap) throws IOException {\n     assert Thread.holdsLock(refreshNamenodesLock);\n \n-    Set\u003cString\u003e toRefresh \u003d Sets.newHashSet();\n-    Set\u003cString\u003e toAdd \u003d Sets.newHashSet();\n+    Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n+    Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n     Set\u003cString\u003e toRemove;\n     \n     synchronized (this) {\n       // Step 1. For each of the new nameservices, figure out whether\n       // it\u0027s an update of the set of NNs for an existing NS,\n       // or an entirely new nameservice.\n       for (String nameserviceId : addrMap.keySet()) {\n         if (bpByNameserviceId.containsKey(nameserviceId)) {\n           toRefresh.add(nameserviceId);\n         } else {\n           toAdd.add(nameserviceId);\n         }\n       }\n       \n       // Step 2. Any nameservices we currently have but are no longer present\n       // need to be removed.\n       toRemove \u003d Sets.newHashSet(Sets.difference(\n           bpByNameserviceId.keySet(), addrMap.keySet()));\n       \n       assert toRefresh.size() + toAdd.size() \u003d\u003d\n         addrMap.size() :\n           \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n           \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n           \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n \n       \n       // Step 3. Start new nameservices\n       if (!toAdd.isEmpty()) {\n         LOG.info(\"Starting BPOfferServices for nameservices: \" +\n             Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n       \n         for (String nsToAdd : toAdd) {\n           ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n             Lists.newArrayList(addrMap.get(nsToAdd).values());\n           BPOfferService bpos \u003d createBPOS(addrs);\n           bpByNameserviceId.put(nsToAdd, bpos);\n           offerServices.add(bpos);\n         }\n       }\n       startAll();\n     }\n \n     // Step 4. Shut down old nameservices. This happens outside\n     // of the synchronized(this) lock since they need to call\n     // back to .remove() from another thread\n     if (!toRemove.isEmpty()) {\n       LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n       \n       for (String nsToRemove : toRemove) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n         bpos.stop();\n         bpos.join();\n         // they will call remove on their own\n       }\n     }\n     \n     // Step 5. Update nameservices whose NN list has changed\n     if (!toRefresh.isEmpty()) {\n       LOG.info(\"Refreshing list of NNs for nameservices: \" +\n           Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n       \n       for (String nsToRefresh : toRefresh) {\n         BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n         ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n           Lists.newArrayList(addrMap.get(nsToRefresh).values());\n         bpos.refreshNNList(addrs);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRefreshNamenodes(\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap) throws IOException {\n    assert Thread.holdsLock(refreshNamenodesLock);\n\n    Set\u003cString\u003e toRefresh \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toAdd \u003d Sets.newLinkedHashSet();\n    Set\u003cString\u003e toRemove;\n    \n    synchronized (this) {\n      // Step 1. For each of the new nameservices, figure out whether\n      // it\u0027s an update of the set of NNs for an existing NS,\n      // or an entirely new nameservice.\n      for (String nameserviceId : addrMap.keySet()) {\n        if (bpByNameserviceId.containsKey(nameserviceId)) {\n          toRefresh.add(nameserviceId);\n        } else {\n          toAdd.add(nameserviceId);\n        }\n      }\n      \n      // Step 2. Any nameservices we currently have but are no longer present\n      // need to be removed.\n      toRemove \u003d Sets.newHashSet(Sets.difference(\n          bpByNameserviceId.keySet(), addrMap.keySet()));\n      \n      assert toRefresh.size() + toAdd.size() \u003d\u003d\n        addrMap.size() :\n          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n\n      \n      // Step 3. Start new nameservices\n      if (!toAdd.isEmpty()) {\n        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n      \n        for (String nsToAdd : toAdd) {\n          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n            Lists.newArrayList(addrMap.get(nsToAdd).values());\n          BPOfferService bpos \u003d createBPOS(addrs);\n          bpByNameserviceId.put(nsToAdd, bpos);\n          offerServices.add(bpos);\n        }\n      }\n      startAll();\n    }\n\n    // Step 4. Shut down old nameservices. This happens outside\n    // of the synchronized(this) lock since they need to call\n    // back to .remove() from another thread\n    if (!toRemove.isEmpty()) {\n      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n      \n      for (String nsToRemove : toRemove) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n        bpos.stop();\n        bpos.join();\n        // they will call remove on their own\n      }\n    }\n    \n    // Step 5. Update nameservices whose NN list has changed\n    if (!toRefresh.isEmpty()) {\n      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n      \n      for (String nsToRefresh : toRefresh) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n          Lists.newArrayList(addrMap.get(nsToRefresh).values());\n        bpos.refreshNNList(addrs);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java",
      "extendedDetails": {}
    },
    "f4fa76719e622a4ef883c51ec0abc6e6e6ddf09e": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2612. Handle refreshNameNodes in federated HA clusters. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1209249 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/12/11 1:26 PM",
      "commitName": "f4fa76719e622a4ef883c51ec0abc6e6e6ddf09e",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,76 @@\n+  private void doRefreshNamenodes(\n+      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap) throws IOException {\n+    assert Thread.holdsLock(refreshNamenodesLock);\n+\n+    Set\u003cString\u003e toRefresh \u003d Sets.newHashSet();\n+    Set\u003cString\u003e toAdd \u003d Sets.newHashSet();\n+    Set\u003cString\u003e toRemove;\n+    \n+    synchronized (this) {\n+      // Step 1. For each of the new nameservices, figure out whether\n+      // it\u0027s an update of the set of NNs for an existing NS,\n+      // or an entirely new nameservice.\n+      for (String nameserviceId : addrMap.keySet()) {\n+        if (bpByNameserviceId.containsKey(nameserviceId)) {\n+          toRefresh.add(nameserviceId);\n+        } else {\n+          toAdd.add(nameserviceId);\n+        }\n+      }\n+      \n+      // Step 2. Any nameservices we currently have but are no longer present\n+      // need to be removed.\n+      toRemove \u003d Sets.newHashSet(Sets.difference(\n+          bpByNameserviceId.keySet(), addrMap.keySet()));\n+      \n+      assert toRefresh.size() + toAdd.size() \u003d\u003d\n+        addrMap.size() :\n+          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n+          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n+          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n+\n+      \n+      // Step 3. Start new nameservices\n+      if (!toAdd.isEmpty()) {\n+        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n+            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n+      \n+        for (String nsToAdd : toAdd) {\n+          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n+            Lists.newArrayList(addrMap.get(nsToAdd).values());\n+          BPOfferService bpos \u003d createBPOS(addrs);\n+          bpByNameserviceId.put(nsToAdd, bpos);\n+          offerServices.add(bpos);\n+        }\n+      }\n+      startAll();\n+    }\n+\n+    // Step 4. Shut down old nameservices. This happens outside\n+    // of the synchronized(this) lock since they need to call\n+    // back to .remove() from another thread\n+    if (!toRemove.isEmpty()) {\n+      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n+          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n+      \n+      for (String nsToRemove : toRemove) {\n+        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n+        bpos.stop();\n+        bpos.join();\n+        // they will call remove on their own\n+      }\n+    }\n+    \n+    // Step 5. Update nameservices whose NN list has changed\n+    if (!toRefresh.isEmpty()) {\n+      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n+          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n+      \n+      for (String nsToRefresh : toRefresh) {\n+        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n+        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n+          Lists.newArrayList(addrMap.get(nsToRefresh).values());\n+        bpos.refreshNNList(addrs);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRefreshNamenodes(\n      Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e addrMap) throws IOException {\n    assert Thread.holdsLock(refreshNamenodesLock);\n\n    Set\u003cString\u003e toRefresh \u003d Sets.newHashSet();\n    Set\u003cString\u003e toAdd \u003d Sets.newHashSet();\n    Set\u003cString\u003e toRemove;\n    \n    synchronized (this) {\n      // Step 1. For each of the new nameservices, figure out whether\n      // it\u0027s an update of the set of NNs for an existing NS,\n      // or an entirely new nameservice.\n      for (String nameserviceId : addrMap.keySet()) {\n        if (bpByNameserviceId.containsKey(nameserviceId)) {\n          toRefresh.add(nameserviceId);\n        } else {\n          toAdd.add(nameserviceId);\n        }\n      }\n      \n      // Step 2. Any nameservices we currently have but are no longer present\n      // need to be removed.\n      toRemove \u003d Sets.newHashSet(Sets.difference(\n          bpByNameserviceId.keySet(), addrMap.keySet()));\n      \n      assert toRefresh.size() + toAdd.size() \u003d\u003d\n        addrMap.size() :\n          \"toAdd: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd) +\n          \"  toRemove: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove) +\n          \"  toRefresh: \" + Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh);\n\n      \n      // Step 3. Start new nameservices\n      if (!toAdd.isEmpty()) {\n        LOG.info(\"Starting BPOfferServices for nameservices: \" +\n            Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toAdd));\n      \n        for (String nsToAdd : toAdd) {\n          ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n            Lists.newArrayList(addrMap.get(nsToAdd).values());\n          BPOfferService bpos \u003d createBPOS(addrs);\n          bpByNameserviceId.put(nsToAdd, bpos);\n          offerServices.add(bpos);\n        }\n      }\n      startAll();\n    }\n\n    // Step 4. Shut down old nameservices. This happens outside\n    // of the synchronized(this) lock since they need to call\n    // back to .remove() from another thread\n    if (!toRemove.isEmpty()) {\n      LOG.info(\"Stopping BPOfferServices for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRemove));\n      \n      for (String nsToRemove : toRemove) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRemove);\n        bpos.stop();\n        bpos.join();\n        // they will call remove on their own\n      }\n    }\n    \n    // Step 5. Update nameservices whose NN list has changed\n    if (!toRefresh.isEmpty()) {\n      LOG.info(\"Refreshing list of NNs for nameservices: \" +\n          Joiner.on(\",\").useForNull(\"\u003cdefault\u003e\").join(toRefresh));\n      \n      for (String nsToRefresh : toRefresh) {\n        BPOfferService bpos \u003d bpByNameserviceId.get(nsToRefresh);\n        ArrayList\u003cInetSocketAddress\u003e addrs \u003d\n          Lists.newArrayList(addrMap.get(nsToRefresh).values());\n        bpos.refreshNNList(addrs);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockPoolManager.java"
    }
  }
}