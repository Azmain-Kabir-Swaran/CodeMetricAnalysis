{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractYarnScheduler.java",
  "functionName": "updateNewContainerInfo",
  "functionId": "updateNewContainerInfo___nm-RMNode__schedulerNode-SchedulerNode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
  "functionStartLine": 1025,
  "functionEndLine": 1087,
  "numCommitsSeen": 207,
  "timeTaken": 4782,
  "changeHistory": [
    "614af50625a8495812dce8da59db0e1aef40b1c0",
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
    "e9c72d04beddfe0252d2e81123a9fe66bdf04078",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335"
  ],
  "changeHistoryShort": {
    "614af50625a8495812dce8da59db0e1aef40b1c0": "Ybodychange",
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": "Ybodychange",
    "e9c72d04beddfe0252d2e81123a9fe66bdf04078": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": "Yintroduced"
  },
  "changeHistoryDetails": {
    "614af50625a8495812dce8da59db0e1aef40b1c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9179. Fix NPE in AbstractYarnScheduler#updateNewContainerInfo.\n",
      "commitDate": "14/01/19 7:59 PM",
      "commitName": "614af50625a8495812dce8da59db0e1aef40b1c0",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "03/01/19 7:56 AM",
      "commitNameOld": "cfe89e6f963ba25b5fff1ce48cad36d74b3c789c",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 11.5,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,63 @@\n   private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n       SchedulerNode schedulerNode) {\n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003c\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003c\u003e();\n     List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e updateExistContainers \u003d\n         new ArrayList\u003c\u003e();\n \n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers\n           .addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n       updateExistContainers.addAll(containerInfo.getUpdateContainers());\n     }\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(),\n           schedulerNode);\n     }\n \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), schedulerNode, container);\n     }\n \n     // Processing the update exist containers\n     for (Map.Entry\u003cApplicationId, ContainerStatus\u003e c : updateExistContainers) {\n       SchedulerApplication\u003cT\u003e app \u003d applications.get(c.getKey());\n       ContainerId containerId \u003d c.getValue().getContainerId();\n-      String strExposedPorts \u003d c.getValue().getExposedPorts();\n-      Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n-      if (null !\u003d strExposedPorts \u0026\u0026 !strExposedPorts.isEmpty()) {\n-        Gson gson \u003d new Gson();\n-        exposedPorts \u003d gson.fromJson(strExposedPorts,\n-            new TypeToken\u003cMap\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e\u003e()\n-            {}.getType());\n+      if (app \u003d\u003d null || app.getCurrentAppAttempt() \u003d\u003d null) {\n+        continue;\n       }\n-\n       RMContainer rmContainer\n           \u003d app.getCurrentAppAttempt().getRMContainer(containerId);\n-      if (null !\u003d rmContainer \u0026\u0026\n-          (null \u003d\u003d rmContainer.getExposedPorts()\n-              || rmContainer.getExposedPorts().size() \u003d\u003d 0)) {\n+      if (rmContainer \u003d\u003d null) {\n+        continue;\n+      }\n+      // exposed ports are already set for the container, skip\n+      if (rmContainer.getExposedPorts() !\u003d null \u0026\u0026\n+          rmContainer.getExposedPorts().size() \u003e 0) {\n+        continue;\n+      }\n+\n+      String strExposedPorts \u003d c.getValue().getExposedPorts();\n+      if (null !\u003d strExposedPorts \u0026\u0026 !strExposedPorts.isEmpty()) {\n+        Gson gson \u003d new Gson();\n+        Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d\n+            gson.fromJson(strExposedPorts,\n+            new TypeToken\u003cMap\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e\u003e()\n+                {}.getType());\n         LOG.info(\"update exist container \" + containerId.getContainerId()\n             + \", strExposedPorts \u003d \" + strExposedPorts);\n         rmContainer.setExposedPorts(exposedPorts);\n       }\n     }\n \n     return completedContainers;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n      SchedulerNode schedulerNode) {\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e updateExistContainers \u003d\n        new ArrayList\u003c\u003e();\n\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers\n          .addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n      updateExistContainers.addAll(containerInfo.getUpdateContainers());\n    }\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(),\n          schedulerNode);\n    }\n\n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n    }\n\n    // Processing the update exist containers\n    for (Map.Entry\u003cApplicationId, ContainerStatus\u003e c : updateExistContainers) {\n      SchedulerApplication\u003cT\u003e app \u003d applications.get(c.getKey());\n      ContainerId containerId \u003d c.getValue().getContainerId();\n      if (app \u003d\u003d null || app.getCurrentAppAttempt() \u003d\u003d null) {\n        continue;\n      }\n      RMContainer rmContainer\n          \u003d app.getCurrentAppAttempt().getRMContainer(containerId);\n      if (rmContainer \u003d\u003d null) {\n        continue;\n      }\n      // exposed ports are already set for the container, skip\n      if (rmContainer.getExposedPorts() !\u003d null \u0026\u0026\n          rmContainer.getExposedPorts().size() \u003e 0) {\n        continue;\n      }\n\n      String strExposedPorts \u003d c.getValue().getExposedPorts();\n      if (null !\u003d strExposedPorts \u0026\u0026 !strExposedPorts.isEmpty()) {\n        Gson gson \u003d new Gson();\n        Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d\n            gson.fromJson(strExposedPorts,\n            new TypeToken\u003cMap\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e\u003e()\n                {}.getType());\n        LOG.info(\"update exist container \" + containerId.getContainerId()\n            + \", strExposedPorts \u003d \" + strExposedPorts);\n        rmContainer.setExposedPorts(exposedPorts);\n      }\n    }\n\n    return completedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5168. Added exposed port information for Docker container.\n           Contributed by Xun Liu\n",
      "commitDate": "21/12/18 4:44 PM",
      "commitName": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "05/11/18 9:14 PM",
      "commitNameOld": "c7fcca0d7ec9e31d43ef3040ecd576ec808f1f8b",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 45.81,
      "commitsBetweenForRepo": 303,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,56 @@\n   private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n       SchedulerNode schedulerNode) {\n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003c\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003c\u003e();\n+    List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e updateExistContainers \u003d\n+        new ArrayList\u003c\u003e();\n \n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers\n           .addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n+      updateExistContainers.addAll(containerInfo.getUpdateContainers());\n     }\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(),\n           schedulerNode);\n     }\n \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), schedulerNode, container);\n     }\n \n+    // Processing the update exist containers\n+    for (Map.Entry\u003cApplicationId, ContainerStatus\u003e c : updateExistContainers) {\n+      SchedulerApplication\u003cT\u003e app \u003d applications.get(c.getKey());\n+      ContainerId containerId \u003d c.getValue().getContainerId();\n+      String strExposedPorts \u003d c.getValue().getExposedPorts();\n+      Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n+      if (null !\u003d strExposedPorts \u0026\u0026 !strExposedPorts.isEmpty()) {\n+        Gson gson \u003d new Gson();\n+        exposedPorts \u003d gson.fromJson(strExposedPorts,\n+            new TypeToken\u003cMap\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e\u003e()\n+            {}.getType());\n+      }\n+\n+      RMContainer rmContainer\n+          \u003d app.getCurrentAppAttempt().getRMContainer(containerId);\n+      if (null !\u003d rmContainer \u0026\u0026\n+          (null \u003d\u003d rmContainer.getExposedPorts()\n+              || rmContainer.getExposedPorts().size() \u003d\u003d 0)) {\n+        LOG.info(\"update exist container \" + containerId.getContainerId()\n+            + \", strExposedPorts \u003d \" + strExposedPorts);\n+        rmContainer.setExposedPorts(exposedPorts);\n+      }\n+    }\n+\n     return completedContainers;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n      SchedulerNode schedulerNode) {\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e updateExistContainers \u003d\n        new ArrayList\u003c\u003e();\n\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers\n          .addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n      updateExistContainers.addAll(containerInfo.getUpdateContainers());\n    }\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(),\n          schedulerNode);\n    }\n\n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n    }\n\n    // Processing the update exist containers\n    for (Map.Entry\u003cApplicationId, ContainerStatus\u003e c : updateExistContainers) {\n      SchedulerApplication\u003cT\u003e app \u003d applications.get(c.getKey());\n      ContainerId containerId \u003d c.getValue().getContainerId();\n      String strExposedPorts \u003d c.getValue().getExposedPorts();\n      Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n      if (null !\u003d strExposedPorts \u0026\u0026 !strExposedPorts.isEmpty()) {\n        Gson gson \u003d new Gson();\n        exposedPorts \u003d gson.fromJson(strExposedPorts,\n            new TypeToken\u003cMap\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e\u003e()\n            {}.getType());\n      }\n\n      RMContainer rmContainer\n          \u003d app.getCurrentAppAttempt().getRMContainer(containerId);\n      if (null !\u003d rmContainer \u0026\u0026\n          (null \u003d\u003d rmContainer.getExposedPorts()\n              || rmContainer.getExposedPorts().size() \u003d\u003d 0)) {\n        LOG.info(\"update exist container \" + containerId.getContainerId()\n            + \", strExposedPorts \u003d \" + strExposedPorts);\n        rmContainer.setExposedPorts(exposedPorts);\n      }\n    }\n\n    return completedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "e9c72d04beddfe0252d2e81123a9fe66bdf04078": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-7790. Improve Capacity Scheduler Async Scheduling to better handle node failures. Contributed by Wangda Tan.\n",
      "commitDate": "29/01/18 7:14 AM",
      "commitName": "e9c72d04beddfe0252d2e81123a9fe66bdf04078",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7790. Improve Capacity Scheduler Async Scheduling to better handle node failures. Contributed by Wangda Tan.\n",
          "commitDate": "29/01/18 7:14 AM",
          "commitName": "e9c72d04beddfe0252d2e81123a9fe66bdf04078",
          "commitAuthor": "Sunil G",
          "commitDateOld": "09/01/18 4:59 PM",
          "commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
          "commitAuthorOld": "Miklos Szegedi",
          "daysBetweenCommits": 19.59,
          "commitsBetweenForRepo": 102,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n-  protected List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm) {\n-    SchedulerNode node \u003d getNode(nm.getNodeID());\n-\n+  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n+      SchedulerNode schedulerNode) {\n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003c\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003c\u003e();\n \n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers\n           .addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n-      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+      containerLaunchedOnNode(launchedContainer.getContainerId(),\n+          schedulerNode);\n     }\n \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n-      containerIncreasedOnNode(container.getId(), node, container);\n+      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n     }\n \n     return completedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n      SchedulerNode schedulerNode) {\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003c\u003e();\n\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers\n          .addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(),\n          schedulerNode);\n    }\n\n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n    }\n\n    return completedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {
            "oldValue": "[nm-RMNode]",
            "newValue": "[nm-RMNode, schedulerNode-SchedulerNode]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-7790. Improve Capacity Scheduler Async Scheduling to better handle node failures. Contributed by Wangda Tan.\n",
          "commitDate": "29/01/18 7:14 AM",
          "commitName": "e9c72d04beddfe0252d2e81123a9fe66bdf04078",
          "commitAuthor": "Sunil G",
          "commitDateOld": "09/01/18 4:59 PM",
          "commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
          "commitAuthorOld": "Miklos Szegedi",
          "daysBetweenCommits": 19.59,
          "commitsBetweenForRepo": 102,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n-  protected List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm) {\n-    SchedulerNode node \u003d getNode(nm.getNodeID());\n-\n+  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n+      SchedulerNode schedulerNode) {\n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003c\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003c\u003e();\n \n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers\n           .addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n-      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+      containerLaunchedOnNode(launchedContainer.getContainerId(),\n+          schedulerNode);\n     }\n \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n-      containerIncreasedOnNode(container.getId(), node, container);\n+      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n     }\n \n     return completedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n      SchedulerNode schedulerNode) {\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003c\u003e();\n\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers\n          .addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(),\n          schedulerNode);\n    }\n\n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n    }\n\n    return completedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7790. Improve Capacity Scheduler Async Scheduling to better handle node failures. Contributed by Wangda Tan.\n",
          "commitDate": "29/01/18 7:14 AM",
          "commitName": "e9c72d04beddfe0252d2e81123a9fe66bdf04078",
          "commitAuthor": "Sunil G",
          "commitDateOld": "09/01/18 4:59 PM",
          "commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
          "commitAuthorOld": "Miklos Szegedi",
          "daysBetweenCommits": 19.59,
          "commitsBetweenForRepo": 102,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n-  protected List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm) {\n-    SchedulerNode node \u003d getNode(nm.getNodeID());\n-\n+  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n+      SchedulerNode schedulerNode) {\n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003c\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003c\u003e();\n \n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers\n           .addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n-      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+      containerLaunchedOnNode(launchedContainer.getContainerId(),\n+          schedulerNode);\n     }\n \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n-      containerIncreasedOnNode(container.getId(), node, container);\n+      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n     }\n \n     return completedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm,\n      SchedulerNode schedulerNode) {\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003c\u003e();\n\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers\n          .addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(),\n          schedulerNode);\n    }\n\n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), schedulerNode, container);\n    }\n\n    return completedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5047. Refactor nodeUpdate across schedulers. (Ray Chiang via kasha)\n",
      "commitDate": "20/10/16 9:17 PM",
      "commitName": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,29 @@\n+  protected List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm) {\n+    SchedulerNode node \u003d getNode(nm.getNodeID());\n+\n+    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n+    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n+        new ArrayList\u003c\u003e();\n+    List\u003cContainerStatus\u003e completedContainers \u003d\n+        new ArrayList\u003c\u003e();\n+\n+    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n+      newlyLaunchedContainers\n+          .addAll(containerInfo.getNewlyLaunchedContainers());\n+      completedContainers.addAll(containerInfo.getCompletedContainers());\n+    }\n+\n+    // Processing the newly launched containers\n+    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n+      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+    }\n+\n+    // Processing the newly increased containers\n+    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n+        nm.pullNewlyIncreasedContainers();\n+    for (Container container : newlyIncreasedContainers) {\n+      containerIncreasedOnNode(container.getId(), node, container);\n+    }\n+\n+    return completedContainers;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e updateNewContainerInfo(RMNode nm) {\n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003c\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003c\u003e();\n\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers\n          .addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    return completedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java"
    }
  }
}