{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Portmap.java",
  "functionName": "start",
  "functionId": "start___idleTimeMilliSeconds-int(modifiers-final)__tcpAddress-SocketAddress(modifiers-final)__udpAddress-SocketAddress(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/portmap/Portmap.java",
  "functionStartLine": 95,
  "functionEndLine": 129,
  "numCommitsSeen": 7,
  "timeTaken": 1215,
  "changeHistory": [
    "09ad8effb825eddbf0ee2ef591a0d16a58468f56",
    "1f9848dfe1fc9148cbbcfcc3dfed948b9e0f3c3c",
    "a379a7bbb9d9da669ccdc0dd5e6f6514af43ae78"
  ],
  "changeHistoryShort": {
    "09ad8effb825eddbf0ee2ef591a0d16a58468f56": "Ybodychange",
    "1f9848dfe1fc9148cbbcfcc3dfed948b9e0f3c3c": "Ybodychange",
    "a379a7bbb9d9da669ccdc0dd5e6f6514af43ae78": "Yintroduced"
  },
  "changeHistoryDetails": {
    "09ad8effb825eddbf0ee2ef591a0d16a58468f56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11533. reuseAddress option should be used for child channels in Portmap and SimpleTcpServer. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "16/03/17 12:20 PM",
      "commitName": "09ad8effb825eddbf0ee2ef591a0d16a58468f56",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "07/03/17 11:41 AM",
      "commitNameOld": "1f9848dfe1fc9148cbbcfcc3dfed948b9e0f3c3c",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 8.99,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n   void start(final int idleTimeMilliSeconds, final SocketAddress tcpAddress,\n       final SocketAddress udpAddress) {\n \n     tcpServer \u003d new ServerBootstrap(new NioServerSocketChannelFactory(\n         Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n     tcpServer.setPipelineFactory(new ChannelPipelineFactory() {\n       private final HashedWheelTimer timer \u003d new HashedWheelTimer();\n       private final IdleStateHandler idleStateHandler \u003d new IdleStateHandler(\n           timer, 0, 0, idleTimeMilliSeconds, TimeUnit.MILLISECONDS);\n \n       @Override\n       public ChannelPipeline getPipeline() throws Exception {\n         return Channels.pipeline(RpcUtil.constructRpcFrameDecoder(),\n             RpcUtil.STAGE_RPC_MESSAGE_PARSER, idleStateHandler, handler,\n             RpcUtil.STAGE_RPC_TCP_RESPONSE);\n       }\n     });\n     tcpServer.setOption(\"reuseAddress\", true);\n+    tcpServer.setOption(\"child.reuseAddress\", true);\n \n     udpServer \u003d new ConnectionlessBootstrap(new NioDatagramChannelFactory(\n         Executors.newCachedThreadPool()));\n \n     udpServer.setPipeline(Channels.pipeline(RpcUtil.STAGE_RPC_MESSAGE_PARSER,\n         handler, RpcUtil.STAGE_RPC_UDP_RESPONSE));\n     udpServer.setOption(\"reuseAddress\", true);\n \n     tcpChannel \u003d tcpServer.bind(tcpAddress);\n     udpChannel \u003d udpServer.bind(udpAddress);\n     allChannels.add(tcpChannel);\n     allChannels.add(udpChannel);\n \n     LOG.info(\"Portmap server started at tcp://\" + tcpChannel.getLocalAddress()\n         + \", udp://\" + udpChannel.getLocalAddress());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start(final int idleTimeMilliSeconds, final SocketAddress tcpAddress,\n      final SocketAddress udpAddress) {\n\n    tcpServer \u003d new ServerBootstrap(new NioServerSocketChannelFactory(\n        Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n    tcpServer.setPipelineFactory(new ChannelPipelineFactory() {\n      private final HashedWheelTimer timer \u003d new HashedWheelTimer();\n      private final IdleStateHandler idleStateHandler \u003d new IdleStateHandler(\n          timer, 0, 0, idleTimeMilliSeconds, TimeUnit.MILLISECONDS);\n\n      @Override\n      public ChannelPipeline getPipeline() throws Exception {\n        return Channels.pipeline(RpcUtil.constructRpcFrameDecoder(),\n            RpcUtil.STAGE_RPC_MESSAGE_PARSER, idleStateHandler, handler,\n            RpcUtil.STAGE_RPC_TCP_RESPONSE);\n      }\n    });\n    tcpServer.setOption(\"reuseAddress\", true);\n    tcpServer.setOption(\"child.reuseAddress\", true);\n\n    udpServer \u003d new ConnectionlessBootstrap(new NioDatagramChannelFactory(\n        Executors.newCachedThreadPool()));\n\n    udpServer.setPipeline(Channels.pipeline(RpcUtil.STAGE_RPC_MESSAGE_PARSER,\n        handler, RpcUtil.STAGE_RPC_UDP_RESPONSE));\n    udpServer.setOption(\"reuseAddress\", true);\n\n    tcpChannel \u003d tcpServer.bind(tcpAddress);\n    udpChannel \u003d udpServer.bind(udpAddress);\n    allChannels.add(tcpChannel);\n    allChannels.add(udpChannel);\n\n    LOG.info(\"Portmap server started at tcp://\" + tcpChannel.getLocalAddress()\n        + \", udp://\" + udpChannel.getLocalAddress());\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/portmap/Portmap.java",
      "extendedDetails": {}
    },
    "1f9848dfe1fc9148cbbcfcc3dfed948b9e0f3c3c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11508. Fix bind failure in SimpleTCPServer \u0026 Portmap where bind fails because socket is in TIME_WAIT state. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "07/03/17 11:41 AM",
      "commitName": "1f9848dfe1fc9148cbbcfcc3dfed948b9e0f3c3c",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "24/03/14 1:49 PM",
      "commitNameOld": "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 1078.95,
      "commitsBetweenForRepo": 8076,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,34 @@\n   void start(final int idleTimeMilliSeconds, final SocketAddress tcpAddress,\n       final SocketAddress udpAddress) {\n \n     tcpServer \u003d new ServerBootstrap(new NioServerSocketChannelFactory(\n         Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n     tcpServer.setPipelineFactory(new ChannelPipelineFactory() {\n       private final HashedWheelTimer timer \u003d new HashedWheelTimer();\n       private final IdleStateHandler idleStateHandler \u003d new IdleStateHandler(\n           timer, 0, 0, idleTimeMilliSeconds, TimeUnit.MILLISECONDS);\n \n       @Override\n       public ChannelPipeline getPipeline() throws Exception {\n         return Channels.pipeline(RpcUtil.constructRpcFrameDecoder(),\n             RpcUtil.STAGE_RPC_MESSAGE_PARSER, idleStateHandler, handler,\n             RpcUtil.STAGE_RPC_TCP_RESPONSE);\n       }\n     });\n+    tcpServer.setOption(\"reuseAddress\", true);\n \n     udpServer \u003d new ConnectionlessBootstrap(new NioDatagramChannelFactory(\n         Executors.newCachedThreadPool()));\n \n     udpServer.setPipeline(Channels.pipeline(RpcUtil.STAGE_RPC_MESSAGE_PARSER,\n         handler, RpcUtil.STAGE_RPC_UDP_RESPONSE));\n+    udpServer.setOption(\"reuseAddress\", true);\n \n     tcpChannel \u003d tcpServer.bind(tcpAddress);\n     udpChannel \u003d udpServer.bind(udpAddress);\n     allChannels.add(tcpChannel);\n     allChannels.add(udpChannel);\n \n     LOG.info(\"Portmap server started at tcp://\" + tcpChannel.getLocalAddress()\n         + \", udp://\" + udpChannel.getLocalAddress());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start(final int idleTimeMilliSeconds, final SocketAddress tcpAddress,\n      final SocketAddress udpAddress) {\n\n    tcpServer \u003d new ServerBootstrap(new NioServerSocketChannelFactory(\n        Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n    tcpServer.setPipelineFactory(new ChannelPipelineFactory() {\n      private final HashedWheelTimer timer \u003d new HashedWheelTimer();\n      private final IdleStateHandler idleStateHandler \u003d new IdleStateHandler(\n          timer, 0, 0, idleTimeMilliSeconds, TimeUnit.MILLISECONDS);\n\n      @Override\n      public ChannelPipeline getPipeline() throws Exception {\n        return Channels.pipeline(RpcUtil.constructRpcFrameDecoder(),\n            RpcUtil.STAGE_RPC_MESSAGE_PARSER, idleStateHandler, handler,\n            RpcUtil.STAGE_RPC_TCP_RESPONSE);\n      }\n    });\n    tcpServer.setOption(\"reuseAddress\", true);\n\n    udpServer \u003d new ConnectionlessBootstrap(new NioDatagramChannelFactory(\n        Executors.newCachedThreadPool()));\n\n    udpServer.setPipeline(Channels.pipeline(RpcUtil.STAGE_RPC_MESSAGE_PARSER,\n        handler, RpcUtil.STAGE_RPC_UDP_RESPONSE));\n    udpServer.setOption(\"reuseAddress\", true);\n\n    tcpChannel \u003d tcpServer.bind(tcpAddress);\n    udpChannel \u003d udpServer.bind(udpAddress);\n    allChannels.add(tcpChannel);\n    allChannels.add(udpChannel);\n\n    LOG.info(\"Portmap server started at tcp://\" + tcpChannel.getLocalAddress()\n        + \", udp://\" + udpChannel.getLocalAddress());\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/portmap/Portmap.java",
      "extendedDetails": {}
    },
    "a379a7bbb9d9da669ccdc0dd5e6f6514af43ae78": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5288. Close idle connections in portmap. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544352 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/13 2:43 PM",
      "commitName": "a379a7bbb9d9da669ccdc0dd5e6f6514af43ae78",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,32 @@\n+  void start(final int idleTimeMilliSeconds, final SocketAddress tcpAddress,\n+      final SocketAddress udpAddress) {\n+\n+    tcpServer \u003d new ServerBootstrap(new NioServerSocketChannelFactory(\n+        Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n+    tcpServer.setPipelineFactory(new ChannelPipelineFactory() {\n+      private final HashedWheelTimer timer \u003d new HashedWheelTimer();\n+      private final IdleStateHandler idleStateHandler \u003d new IdleStateHandler(\n+          timer, 0, 0, idleTimeMilliSeconds, TimeUnit.MILLISECONDS);\n+\n+      @Override\n+      public ChannelPipeline getPipeline() throws Exception {\n+        return Channels.pipeline(RpcUtil.constructRpcFrameDecoder(),\n+            RpcUtil.STAGE_RPC_MESSAGE_PARSER, idleStateHandler, handler,\n+            RpcUtil.STAGE_RPC_TCP_RESPONSE);\n+      }\n+    });\n+\n+    udpServer \u003d new ConnectionlessBootstrap(new NioDatagramChannelFactory(\n+        Executors.newCachedThreadPool()));\n+\n+    udpServer.setPipeline(Channels.pipeline(RpcUtil.STAGE_RPC_MESSAGE_PARSER,\n+        handler, RpcUtil.STAGE_RPC_UDP_RESPONSE));\n+\n+    tcpChannel \u003d tcpServer.bind(tcpAddress);\n+    udpChannel \u003d udpServer.bind(udpAddress);\n+    allChannels.add(tcpChannel);\n+    allChannels.add(udpChannel);\n+\n+    LOG.info(\"Portmap server started at tcp://\" + tcpChannel.getLocalAddress()\n+        + \", udp://\" + udpChannel.getLocalAddress());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void start(final int idleTimeMilliSeconds, final SocketAddress tcpAddress,\n      final SocketAddress udpAddress) {\n\n    tcpServer \u003d new ServerBootstrap(new NioServerSocketChannelFactory(\n        Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n    tcpServer.setPipelineFactory(new ChannelPipelineFactory() {\n      private final HashedWheelTimer timer \u003d new HashedWheelTimer();\n      private final IdleStateHandler idleStateHandler \u003d new IdleStateHandler(\n          timer, 0, 0, idleTimeMilliSeconds, TimeUnit.MILLISECONDS);\n\n      @Override\n      public ChannelPipeline getPipeline() throws Exception {\n        return Channels.pipeline(RpcUtil.constructRpcFrameDecoder(),\n            RpcUtil.STAGE_RPC_MESSAGE_PARSER, idleStateHandler, handler,\n            RpcUtil.STAGE_RPC_TCP_RESPONSE);\n      }\n    });\n\n    udpServer \u003d new ConnectionlessBootstrap(new NioDatagramChannelFactory(\n        Executors.newCachedThreadPool()));\n\n    udpServer.setPipeline(Channels.pipeline(RpcUtil.STAGE_RPC_MESSAGE_PARSER,\n        handler, RpcUtil.STAGE_RPC_UDP_RESPONSE));\n\n    tcpChannel \u003d tcpServer.bind(tcpAddress);\n    udpChannel \u003d udpServer.bind(udpAddress);\n    allChannels.add(tcpChannel);\n    allChannels.add(udpChannel);\n\n    LOG.info(\"Portmap server started at tcp://\" + tcpChannel.getLocalAddress()\n        + \", udp://\" + udpChannel.getLocalAddress());\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/portmap/Portmap.java"
    }
  }
}