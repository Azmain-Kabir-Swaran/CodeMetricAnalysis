{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacitySchedulerConfigValidator.java",
  "functionName": "validateQueueHierarchy",
  "functionId": "validateQueueHierarchy___queues-CSQueueStore__newQueues-CSQueueStore__newConf-CapacitySchedulerConfiguration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
  "functionStartLine": 118,
  "functionEndLine": 195,
  "numCommitsSeen": 205,
  "timeTaken": 19508,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "28f730b317b23038bf9bd0775dd2cdb96518b13b",
    "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
    "4627dd670800b2191ebdd41c6971ccd53e718e18",
    "c7ef4fb74acacdb184d12bafadd8fb040b5c04b6",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
    "d8f74c3964fa429a4a53c3651d175792cf00ac81",
    "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9",
    "72054a817dfb43e93916d7036eba19cf2f49cea2",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
    "6ad4e59cfc111a92747fdb1fb99cc6378044832a",
    "eb3e40b833b9d82c1556843f960194dc42e482f3",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1f46b991da9b91585608a0babd3eda39485dce09",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ymultichange(Yparameterchange,Ybodychange)",
    "28f730b317b23038bf9bd0775dd2cdb96518b13b": "Ybodychange",
    "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "4627dd670800b2191ebdd41c6971ccd53e718e18": "Ymultichange(Yparameterchange,Ybodychange)",
    "c7ef4fb74acacdb184d12bafadd8fb040b5c04b6": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ybodychange",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Ybodychange",
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9": "Ybodychange",
    "d8f74c3964fa429a4a53c3651d175792cf00ac81": "Ybodychange",
    "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9": "Ybodychange",
    "72054a817dfb43e93916d7036eba19cf2f49cea2": "Ymultichange(Yrename,Ybodychange)",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": "Ymovefromfile",
    "6ad4e59cfc111a92747fdb1fb99cc6378044832a": "Ybodychange",
    "eb3e40b833b9d82c1556843f960194dc42e482f3": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1f46b991da9b91585608a0babd3eda39485dce09": "Yparameterchange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
          "commitDate": "25/03/20 4:20 AM",
          "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
          "commitAuthor": "Sunil G",
          "commitDateOld": "09/02/20 7:44 AM",
          "commitNameOld": "28f730b317b23038bf9bd0775dd2cdb96518b13b",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 44.82,
          "commitsBetweenForRepo": 154,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,78 +1,78 @@\n-  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n-         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n-         throws IOException {\n+  public static void validateQueueHierarchy(\n+      CSQueueStore queues,\n+      CSQueueStore newQueues,\n+      CapacitySchedulerConfiguration newConf) throws IOException {\n     // check that all static queues are included in the newQueues list\n-    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n-      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n-              .getClass()))) {\n-        String queueName \u003d e.getKey();\n-        CSQueue oldQueue \u003d e.getValue();\n-        CSQueue newQueue \u003d newQueues.get(queueName);\n+    for (CSQueue oldQueue : queues.getQueues()) {\n+      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n+          oldQueue.getClass()))) {\n+        String queuePath \u003d oldQueue.getQueuePath();\n+        CSQueue newQueue \u003d newQueues.get(queuePath);\n         String configPrefix \u003d newConf.getQueuePrefix(\n             oldQueue.getQueuePath());\n         String state \u003d newConf.get(configPrefix + \"state\");\n         QueueState newQueueState \u003d null;\n         if (state !\u003d null) {\n           try {\n             newQueueState \u003d QueueState.valueOf(state);\n           } catch (Exception ex) {\n             LOG.warn(\"Not a valid queue state for queue \"\n                 + oldQueue.getQueuePath());\n           }\n         }\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n-                  newQueueState \u003d\u003d QueueState.STOPPED) {\n-            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n-                    + \" present in the modified capacity configuration xml\");\n-          } else{\n+              newQueueState \u003d\u003d QueueState.STOPPED) {\n+            LOG.info(\"Deleting Queue \" + queuePath + \", as it is not\"\n+                + \" present in the modified capacity configuration xml\");\n+          } else {\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n-                    + \" deleted from the capacity scheduler configuration, \"\n-                    + \"as the queue is not yet in stopped state. \"\n-                    + \"Current State : \" + oldQueue.getState());\n+              + \" deleted from the capacity scheduler configuration, as the\"\n+              + \" queue is not yet in stopped state. Current State : \"\n+              + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n-                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n-                          + \" to:\" + newQueue.getQueuePath()\n-                          + \" after refresh, which is not allowed.\");\n+            queuePath + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n+              + newQueue.getQueuePath()\n+              + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n-                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n-                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n+            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n+            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n-                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n-                          + \" to auto create enabled parent queue since \"\n-                          + \"it could have other pre-configured queues which is\"\n-                          + \" not supported\");\n+            \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n+                + \" to auto create enabled parent queue since \"\n+                + \"it could have other pre-configured queues which is not \"\n+                + \"supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n-                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n+            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n-                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n-                          .getQueuePath() + \" to leaf queue. Please check \"\n-                          + \" parent queue\u0027s configuration \"\n-                          + CapacitySchedulerConfiguration\n-                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n-                          + \" is set to true\");\n+            \"Cannot convert auto create enabled parent queue: \"\n+              + oldQueue.getQueuePath() + \" to leaf queue. Please check \"\n+              + \" parent queue\u0027s configuration \"\n+              + CapacitySchedulerConfiguration\n+              .AUTO_CREATE_CHILD_QUEUE_ENABLED\n+              + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n                 \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n               newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n-                    + \" to parent queue.\");\n+                + \" to parent queue.\");\n           } else{\n             throw new IOException(\n-                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n-                            + \" to parent queue since \"\n-                            + \"it is not yet in stopped state. Current State : \"\n-                            + oldQueue.getState());\n+              \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n+                + \" to parent queue since \"\n+                + \"it is not yet in stopped state. Current State : \"\n+                + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n-                \u0026\u0026 newQueue instanceof LeafQueue) {\n+            \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n-                  + \" to leaf queue.\");\n+              + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateQueueHierarchy(\n      CSQueueStore queues,\n      CSQueueStore newQueues,\n      CapacitySchedulerConfiguration newConf) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (CSQueue oldQueue : queues.getQueues()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n          oldQueue.getClass()))) {\n        String queuePath \u003d oldQueue.getQueuePath();\n        CSQueue newQueue \u003d newQueues.get(queuePath);\n        String configPrefix \u003d newConf.getQueuePrefix(\n            oldQueue.getQueuePath());\n        String state \u003d newConf.get(configPrefix + \"state\");\n        QueueState newQueueState \u003d null;\n        if (state !\u003d null) {\n          try {\n            newQueueState \u003d QueueState.valueOf(state);\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                + oldQueue.getQueuePath());\n          }\n        }\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n              newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queuePath + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else {\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n              + \" deleted from the capacity scheduler configuration, as the\"\n              + \" queue is not yet in stopped state. Current State : \"\n              + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n            queuePath + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n              + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n            \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                + \" to auto create enabled parent queue since \"\n                + \"it could have other pre-configured queues which is not \"\n                + \"supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n            \"Cannot convert auto create enabled parent queue: \"\n              + oldQueue.getQueuePath() + \" to leaf queue. Please check \"\n              + \" parent queue\u0027s configuration \"\n              + CapacitySchedulerConfiguration\n              .AUTO_CREATE_CHILD_QUEUE_ENABLED\n              + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n                \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n              newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else{\n            throw new IOException(\n              \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue since \"\n                + \"it is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
          "extendedDetails": {
            "oldValue": "[queues-Map\u003cString,CSQueue\u003e, newQueues-Map\u003cString,CSQueue\u003e, newConf-CapacitySchedulerConfiguration]",
            "newValue": "[queues-CSQueueStore, newQueues-CSQueueStore, newConf-CapacitySchedulerConfiguration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
          "commitDate": "25/03/20 4:20 AM",
          "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
          "commitAuthor": "Sunil G",
          "commitDateOld": "09/02/20 7:44 AM",
          "commitNameOld": "28f730b317b23038bf9bd0775dd2cdb96518b13b",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 44.82,
          "commitsBetweenForRepo": 154,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,78 +1,78 @@\n-  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n-         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n-         throws IOException {\n+  public static void validateQueueHierarchy(\n+      CSQueueStore queues,\n+      CSQueueStore newQueues,\n+      CapacitySchedulerConfiguration newConf) throws IOException {\n     // check that all static queues are included in the newQueues list\n-    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n-      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n-              .getClass()))) {\n-        String queueName \u003d e.getKey();\n-        CSQueue oldQueue \u003d e.getValue();\n-        CSQueue newQueue \u003d newQueues.get(queueName);\n+    for (CSQueue oldQueue : queues.getQueues()) {\n+      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n+          oldQueue.getClass()))) {\n+        String queuePath \u003d oldQueue.getQueuePath();\n+        CSQueue newQueue \u003d newQueues.get(queuePath);\n         String configPrefix \u003d newConf.getQueuePrefix(\n             oldQueue.getQueuePath());\n         String state \u003d newConf.get(configPrefix + \"state\");\n         QueueState newQueueState \u003d null;\n         if (state !\u003d null) {\n           try {\n             newQueueState \u003d QueueState.valueOf(state);\n           } catch (Exception ex) {\n             LOG.warn(\"Not a valid queue state for queue \"\n                 + oldQueue.getQueuePath());\n           }\n         }\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n-                  newQueueState \u003d\u003d QueueState.STOPPED) {\n-            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n-                    + \" present in the modified capacity configuration xml\");\n-          } else{\n+              newQueueState \u003d\u003d QueueState.STOPPED) {\n+            LOG.info(\"Deleting Queue \" + queuePath + \", as it is not\"\n+                + \" present in the modified capacity configuration xml\");\n+          } else {\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n-                    + \" deleted from the capacity scheduler configuration, \"\n-                    + \"as the queue is not yet in stopped state. \"\n-                    + \"Current State : \" + oldQueue.getState());\n+              + \" deleted from the capacity scheduler configuration, as the\"\n+              + \" queue is not yet in stopped state. Current State : \"\n+              + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n-                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n-                          + \" to:\" + newQueue.getQueuePath()\n-                          + \" after refresh, which is not allowed.\");\n+            queuePath + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n+              + newQueue.getQueuePath()\n+              + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n-                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n-                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n+            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n+            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n-                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n-                          + \" to auto create enabled parent queue since \"\n-                          + \"it could have other pre-configured queues which is\"\n-                          + \" not supported\");\n+            \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n+                + \" to auto create enabled parent queue since \"\n+                + \"it could have other pre-configured queues which is not \"\n+                + \"supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n-                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n+            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n-                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n-                          .getQueuePath() + \" to leaf queue. Please check \"\n-                          + \" parent queue\u0027s configuration \"\n-                          + CapacitySchedulerConfiguration\n-                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n-                          + \" is set to true\");\n+            \"Cannot convert auto create enabled parent queue: \"\n+              + oldQueue.getQueuePath() + \" to leaf queue. Please check \"\n+              + \" parent queue\u0027s configuration \"\n+              + CapacitySchedulerConfiguration\n+              .AUTO_CREATE_CHILD_QUEUE_ENABLED\n+              + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n                 \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n               newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n-                    + \" to parent queue.\");\n+                + \" to parent queue.\");\n           } else{\n             throw new IOException(\n-                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n-                            + \" to parent queue since \"\n-                            + \"it is not yet in stopped state. Current State : \"\n-                            + oldQueue.getState());\n+              \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n+                + \" to parent queue since \"\n+                + \"it is not yet in stopped state. Current State : \"\n+                + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n-                \u0026\u0026 newQueue instanceof LeafQueue) {\n+            \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n-                  + \" to leaf queue.\");\n+              + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateQueueHierarchy(\n      CSQueueStore queues,\n      CSQueueStore newQueues,\n      CapacitySchedulerConfiguration newConf) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (CSQueue oldQueue : queues.getQueues()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n          oldQueue.getClass()))) {\n        String queuePath \u003d oldQueue.getQueuePath();\n        CSQueue newQueue \u003d newQueues.get(queuePath);\n        String configPrefix \u003d newConf.getQueuePrefix(\n            oldQueue.getQueuePath());\n        String state \u003d newConf.get(configPrefix + \"state\");\n        QueueState newQueueState \u003d null;\n        if (state !\u003d null) {\n          try {\n            newQueueState \u003d QueueState.valueOf(state);\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                + oldQueue.getQueuePath());\n          }\n        }\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n              newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queuePath + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else {\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n              + \" deleted from the capacity scheduler configuration, as the\"\n              + \" queue is not yet in stopped state. Current State : \"\n              + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n            queuePath + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n              + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n            \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                + \" to auto create enabled parent queue since \"\n                + \"it could have other pre-configured queues which is not \"\n                + \"supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n            \"Cannot convert auto create enabled parent queue: \"\n              + oldQueue.getQueuePath() + \" to leaf queue. Please check \"\n              + \" parent queue\u0027s configuration \"\n              + CapacitySchedulerConfiguration\n              .AUTO_CREATE_CHILD_QUEUE_ENABLED\n              + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n                \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n              newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else{\n            throw new IOException(\n              \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue since \"\n                + \"it is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
          "extendedDetails": {}
        }
      ]
    },
    "28f730b317b23038bf9bd0775dd2cdb96518b13b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10109. Allow stop and convert from leaf to parent queue in a single Mutation API call. Contributed by Prabhu Joseph\n",
      "commitDate": "09/02/20 7:44 AM",
      "commitName": "28f730b317b23038bf9bd0775dd2cdb96518b13b",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/01/20 9:46 AM",
      "commitNameOld": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 11.92,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,78 @@\n   public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n          Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n          throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n               .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n-        if (null \u003d\u003d newQueue) {\n-          // old queue doesn\u0027t exist in the new XML\n-          String configPrefix \u003d newConf.getQueuePrefix(\n-                  oldQueue.getQueuePath());\n-          QueueState newQueueState \u003d null;\n+        String configPrefix \u003d newConf.getQueuePrefix(\n+            oldQueue.getQueuePath());\n+        String state \u003d newConf.get(configPrefix + \"state\");\n+        QueueState newQueueState \u003d null;\n+        if (state !\u003d null) {\n           try {\n-            newQueueState \u003d QueueState.valueOf(\n-                    newConf.get(configPrefix + \"state\"));\n+            newQueueState \u003d QueueState.valueOf(state);\n           } catch (Exception ex) {\n             LOG.warn(\"Not a valid queue state for queue \"\n-                    + oldQueue.getQueuePath());\n+                + oldQueue.getQueuePath());\n           }\n+        }\n+        if (null \u003d\u003d newQueue) {\n+          // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n                   newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                     + \" present in the modified capacity configuration xml\");\n           } else{\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                     + \" deleted from the capacity scheduler configuration, \"\n                     + \"as the queue is not yet in stopped state. \"\n                     + \"Current State : \" + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n                   queueName + \" is moved from:\" + oldQueue.getQueuePath()\n                           + \" to:\" + newQueue.getQueuePath()\n                           + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n                 \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n                 \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n                   \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                           + \" to auto create enabled parent queue since \"\n                           + \"it could have other pre-configured queues which is\"\n                           + \" not supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n                 \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n                   \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                           .getQueuePath() + \" to leaf queue. Please check \"\n                           + \" parent queue\u0027s configuration \"\n                           + CapacitySchedulerConfiguration\n                           .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                           + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n                 \u0026\u0026 newQueue instanceof ParentQueue) {\n-          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n+          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n+              newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                     + \" to parent queue.\");\n           } else{\n             throw new IOException(\n                     \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                             + \" to parent queue since \"\n                             + \"it is not yet in stopped state. Current State : \"\n                             + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n                 \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n                   + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n         throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n              .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        String configPrefix \u003d newConf.getQueuePrefix(\n            oldQueue.getQueuePath());\n        String state \u003d newConf.get(configPrefix + \"state\");\n        QueueState newQueueState \u003d null;\n        if (state !\u003d null) {\n          try {\n            newQueueState \u003d QueueState.valueOf(state);\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                + oldQueue.getQueuePath());\n          }\n        }\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n                  newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                    + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                    + \" deleted from the capacity scheduler configuration, \"\n                    + \"as the queue is not yet in stopped state. \"\n                    + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n                          + \" to:\" + newQueue.getQueuePath()\n                          + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                          + \" to auto create enabled parent queue since \"\n                          + \"it could have other pre-configured queues which is\"\n                          + \" not supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                          .getQueuePath() + \" to leaf queue. Please check \"\n                          + \" parent queue\u0027s configuration \"\n                          + CapacitySchedulerConfiguration\n                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                          + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n                \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n              newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                            + \" to parent queue since \"\n                            + \"it is not yet in stopped state. Current State : \"\n                            + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n                  + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
      "extendedDetails": {}
    },
    "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-10022. RM Rest API to validate the CapacityScheduler Configuration change\n\nContributed by Kinga Marton.\n",
      "commitDate": "28/01/20 9:46 AM",
      "commitName": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
      "commitAuthor": "Prabhu Joseph",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-10022. RM Rest API to validate the CapacityScheduler Configuration change\n\nContributed by Kinga Marton.\n",
          "commitDate": "28/01/20 9:46 AM",
          "commitName": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
          "commitAuthor": "Prabhu Joseph",
          "commitDateOld": "28/01/20 9:39 AM",
          "commitNameOld": "87c198468bb6a6312bbb27b174c18822b6b9ccf8",
          "commitAuthorOld": "Ayush Saxena",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,75 @@\n-  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n-      Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n-      throws IOException {\n+  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n+         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n+         throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n-          .getClass()))) {\n+              .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           String configPrefix \u003d newConf.getQueuePrefix(\n-              oldQueue.getQueuePath());\n+                  oldQueue.getQueuePath());\n           QueueState newQueueState \u003d null;\n           try {\n             newQueueState \u003d QueueState.valueOf(\n-                newConf.get(configPrefix + \"state\"));\n+                    newConf.get(configPrefix + \"state\"));\n           } catch (Exception ex) {\n             LOG.warn(\"Not a valid queue state for queue \"\n-                + oldQueue.getQueuePath());\n+                    + oldQueue.getQueuePath());\n           }\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n-              newQueueState \u003d\u003d QueueState.STOPPED) {\n+                  newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n-                + \" present in the modified capacity configuration xml\");\n+                    + \" present in the modified capacity configuration xml\");\n           } else{\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n-                + \" deleted from the capacity scheduler configuration, as the\"\n-                + \" queue is not yet in stopped state. Current State : \"\n-                + oldQueue.getState());\n+                    + \" deleted from the capacity scheduler configuration, \"\n+                    + \"as the queue is not yet in stopped state. \"\n+                    + \"Current State : \" + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n-              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n-                  + newQueue.getQueuePath()\n-                  + \" after refresh, which is not allowed.\");\n+                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n+                          + \" to:\" + newQueue.getQueuePath()\n+                          + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n-            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n-            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n+                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n+                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n-              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n-                  + \" to auto create enabled parent queue since \"\n-                  + \"it could have other pre-configured queues which is not \"\n-                  + \"supported\");\n+                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n+                          + \" to auto create enabled parent queue since \"\n+                          + \"it could have other pre-configured queues which is\"\n+                          + \" not supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n-            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n+                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n-              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n-                  .getQueuePath() + \" to leaf queue. Please check \"\n-                  + \" parent queue\u0027s configuration \"\n-                  + CapacitySchedulerConfiguration\n-                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n-                  + \" is set to true\");\n+                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n+                          .getQueuePath() + \" to leaf queue. Please check \"\n+                          + \" parent queue\u0027s configuration \"\n+                          + CapacitySchedulerConfiguration\n+                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n+                          + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n-            \u0026\u0026 newQueue instanceof ParentQueue) {\n+                \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n-                + \" to parent queue.\");\n+                    + \" to parent queue.\");\n           } else{\n             throw new IOException(\n-                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n-                    + \" to parent queue since \"\n-                    + \"it is not yet in stopped state. Current State : \"\n-                    + oldQueue.getState());\n+                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n+                            + \" to parent queue since \"\n+                            + \"it is not yet in stopped state. Current State : \"\n+                            + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n-            \u0026\u0026 newQueue instanceof LeafQueue) {\n+                \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n-              + \" to leaf queue.\");\n+                  + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n         throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n              .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          String configPrefix \u003d newConf.getQueuePrefix(\n                  oldQueue.getQueuePath());\n          QueueState newQueueState \u003d null;\n          try {\n            newQueueState \u003d QueueState.valueOf(\n                    newConf.get(configPrefix + \"state\"));\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                    + oldQueue.getQueuePath());\n          }\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n                  newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                    + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                    + \" deleted from the capacity scheduler configuration, \"\n                    + \"as the queue is not yet in stopped state. \"\n                    + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n                          + \" to:\" + newQueue.getQueuePath()\n                          + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                          + \" to auto create enabled parent queue since \"\n                          + \"it could have other pre-configured queues which is\"\n                          + \" not supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                          .getQueuePath() + \" to leaf queue. Please check \"\n                          + \" parent queue\u0027s configuration \"\n                          + CapacitySchedulerConfiguration\n                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                          + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n                \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                            + \" to parent queue since \"\n                            + \"it is not yet in stopped state. Current State : \"\n                            + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n                  + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
            "oldMethodName": "validateQueueHierarchy",
            "newMethodName": "validateQueueHierarchy"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-10022. RM Rest API to validate the CapacityScheduler Configuration change\n\nContributed by Kinga Marton.\n",
          "commitDate": "28/01/20 9:46 AM",
          "commitName": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
          "commitAuthor": "Prabhu Joseph",
          "commitDateOld": "28/01/20 9:39 AM",
          "commitNameOld": "87c198468bb6a6312bbb27b174c18822b6b9ccf8",
          "commitAuthorOld": "Ayush Saxena",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,75 @@\n-  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n-      Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n-      throws IOException {\n+  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n+         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n+         throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n-          .getClass()))) {\n+              .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           String configPrefix \u003d newConf.getQueuePrefix(\n-              oldQueue.getQueuePath());\n+                  oldQueue.getQueuePath());\n           QueueState newQueueState \u003d null;\n           try {\n             newQueueState \u003d QueueState.valueOf(\n-                newConf.get(configPrefix + \"state\"));\n+                    newConf.get(configPrefix + \"state\"));\n           } catch (Exception ex) {\n             LOG.warn(\"Not a valid queue state for queue \"\n-                + oldQueue.getQueuePath());\n+                    + oldQueue.getQueuePath());\n           }\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n-              newQueueState \u003d\u003d QueueState.STOPPED) {\n+                  newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n-                + \" present in the modified capacity configuration xml\");\n+                    + \" present in the modified capacity configuration xml\");\n           } else{\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n-                + \" deleted from the capacity scheduler configuration, as the\"\n-                + \" queue is not yet in stopped state. Current State : \"\n-                + oldQueue.getState());\n+                    + \" deleted from the capacity scheduler configuration, \"\n+                    + \"as the queue is not yet in stopped state. \"\n+                    + \"Current State : \" + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n-              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n-                  + newQueue.getQueuePath()\n-                  + \" after refresh, which is not allowed.\");\n+                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n+                          + \" to:\" + newQueue.getQueuePath()\n+                          + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n-            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n-            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n+                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n+                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n-              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n-                  + \" to auto create enabled parent queue since \"\n-                  + \"it could have other pre-configured queues which is not \"\n-                  + \"supported\");\n+                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n+                          + \" to auto create enabled parent queue since \"\n+                          + \"it could have other pre-configured queues which is\"\n+                          + \" not supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n-            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n+                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n-              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n-                  .getQueuePath() + \" to leaf queue. Please check \"\n-                  + \" parent queue\u0027s configuration \"\n-                  + CapacitySchedulerConfiguration\n-                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n-                  + \" is set to true\");\n+                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n+                          .getQueuePath() + \" to leaf queue. Please check \"\n+                          + \" parent queue\u0027s configuration \"\n+                          + CapacitySchedulerConfiguration\n+                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n+                          + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n-            \u0026\u0026 newQueue instanceof ParentQueue) {\n+                \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n-                + \" to parent queue.\");\n+                    + \" to parent queue.\");\n           } else{\n             throw new IOException(\n-                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n-                    + \" to parent queue since \"\n-                    + \"it is not yet in stopped state. Current State : \"\n-                    + oldQueue.getState());\n+                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n+                            + \" to parent queue since \"\n+                            + \"it is not yet in stopped state. Current State : \"\n+                            + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n-            \u0026\u0026 newQueue instanceof LeafQueue) {\n+                \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n-              + \" to leaf queue.\");\n+                  + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n         throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n              .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          String configPrefix \u003d newConf.getQueuePrefix(\n                  oldQueue.getQueuePath());\n          QueueState newQueueState \u003d null;\n          try {\n            newQueueState \u003d QueueState.valueOf(\n                    newConf.get(configPrefix + \"state\"));\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                    + oldQueue.getQueuePath());\n          }\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n                  newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                    + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                    + \" deleted from the capacity scheduler configuration, \"\n                    + \"as the queue is not yet in stopped state. \"\n                    + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n                          + \" to:\" + newQueue.getQueuePath()\n                          + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                          + \" to auto create enabled parent queue since \"\n                          + \"it could have other pre-configured queues which is\"\n                          + \" not supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                          .getQueuePath() + \" to leaf queue. Please check \"\n                          + \" parent queue\u0027s configuration \"\n                          + CapacitySchedulerConfiguration\n                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                          + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n                \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                            + \" to parent queue since \"\n                            + \"it is not yet in stopped state. Current State : \"\n                            + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n                  + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-10022. RM Rest API to validate the CapacityScheduler Configuration change\n\nContributed by Kinga Marton.\n",
          "commitDate": "28/01/20 9:46 AM",
          "commitName": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
          "commitAuthor": "Prabhu Joseph",
          "commitDateOld": "28/01/20 9:39 AM",
          "commitNameOld": "87c198468bb6a6312bbb27b174c18822b6b9ccf8",
          "commitAuthorOld": "Ayush Saxena",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,75 @@\n-  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n-      Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n-      throws IOException {\n+  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n+         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n+         throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n-          .getClass()))) {\n+              .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           String configPrefix \u003d newConf.getQueuePrefix(\n-              oldQueue.getQueuePath());\n+                  oldQueue.getQueuePath());\n           QueueState newQueueState \u003d null;\n           try {\n             newQueueState \u003d QueueState.valueOf(\n-                newConf.get(configPrefix + \"state\"));\n+                    newConf.get(configPrefix + \"state\"));\n           } catch (Exception ex) {\n             LOG.warn(\"Not a valid queue state for queue \"\n-                + oldQueue.getQueuePath());\n+                    + oldQueue.getQueuePath());\n           }\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n-              newQueueState \u003d\u003d QueueState.STOPPED) {\n+                  newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n-                + \" present in the modified capacity configuration xml\");\n+                    + \" present in the modified capacity configuration xml\");\n           } else{\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n-                + \" deleted from the capacity scheduler configuration, as the\"\n-                + \" queue is not yet in stopped state. Current State : \"\n-                + oldQueue.getState());\n+                    + \" deleted from the capacity scheduler configuration, \"\n+                    + \"as the queue is not yet in stopped state. \"\n+                    + \"Current State : \" + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n-              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n-                  + newQueue.getQueuePath()\n-                  + \" after refresh, which is not allowed.\");\n+                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n+                          + \" to:\" + newQueue.getQueuePath()\n+                          + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n-            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n-            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n+                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n+                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n-              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n-                  + \" to auto create enabled parent queue since \"\n-                  + \"it could have other pre-configured queues which is not \"\n-                  + \"supported\");\n+                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n+                          + \" to auto create enabled parent queue since \"\n+                          + \"it could have other pre-configured queues which is\"\n+                          + \" not supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n-            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n+                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n-              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n-                  .getQueuePath() + \" to leaf queue. Please check \"\n-                  + \" parent queue\u0027s configuration \"\n-                  + CapacitySchedulerConfiguration\n-                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n-                  + \" is set to true\");\n+                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n+                          .getQueuePath() + \" to leaf queue. Please check \"\n+                          + \" parent queue\u0027s configuration \"\n+                          + CapacitySchedulerConfiguration\n+                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n+                          + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n-            \u0026\u0026 newQueue instanceof ParentQueue) {\n+                \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n-                + \" to parent queue.\");\n+                    + \" to parent queue.\");\n           } else{\n             throw new IOException(\n-                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n-                    + \" to parent queue since \"\n-                    + \"it is not yet in stopped state. Current State : \"\n-                    + oldQueue.getState());\n+                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n+                            + \" to parent queue since \"\n+                            + \"it is not yet in stopped state. Current State : \"\n+                            + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n-            \u0026\u0026 newQueue instanceof LeafQueue) {\n+                \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n-              + \" to leaf queue.\");\n+                  + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n         Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n         throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n              .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          String configPrefix \u003d newConf.getQueuePrefix(\n                  oldQueue.getQueuePath());\n          QueueState newQueueState \u003d null;\n          try {\n            newQueueState \u003d QueueState.valueOf(\n                    newConf.get(configPrefix + \"state\"));\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                    + oldQueue.getQueuePath());\n          }\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n                  newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                    + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                    + \" deleted from the capacity scheduler configuration, \"\n                    + \"as the queue is not yet in stopped state. \"\n                    + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n                  queueName + \" is moved from:\" + oldQueue.getQueuePath()\n                          + \" to:\" + newQueue.getQueuePath()\n                          + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n                \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n                  \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                          + \" to auto create enabled parent queue since \"\n                          + \"it could have other pre-configured queues which is\"\n                          + \" not supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n                \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n                  \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                          .getQueuePath() + \" to leaf queue. Please check \"\n                          + \" parent queue\u0027s configuration \"\n                          + CapacitySchedulerConfiguration\n                          .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                          + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n                \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                    \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                            + \" to parent queue since \"\n                            + \"it is not yet in stopped state. Current State : \"\n                            + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n                \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n                  + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfigValidator.java",
          "extendedDetails": {}
        }
      ]
    },
    "4627dd670800b2191ebdd41c6971ccd53e718e18": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9780. SchedulerConf Mutation API does not Allow Stop and Remove Queue in a single call. Contributed by Prabhu Joseph\n",
      "commitDate": "05/12/19 11:38 AM",
      "commitName": "4627dd670800b2191ebdd41c6971ccd53e718e18",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9780. SchedulerConf Mutation API does not Allow Stop and Remove Queue in a single call. Contributed by Prabhu Joseph\n",
          "commitDate": "05/12/19 11:38 AM",
          "commitName": "4627dd670800b2191ebdd41c6971ccd53e718e18",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "31/08/19 9:30 PM",
          "commitNameOld": "c7ef4fb74acacdb184d12bafadd8fb040b5c04b6",
          "commitAuthorOld": "Abhishek Modi",
          "daysBetweenCommits": 95.63,
          "commitsBetweenForRepo": 540,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,75 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n-      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n+      Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n+      throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n           .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n-          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n+          String configPrefix \u003d newConf.getQueuePrefix(\n+              oldQueue.getQueuePath());\n+          QueueState newQueueState \u003d null;\n+          try {\n+            newQueueState \u003d QueueState.valueOf(\n+                newConf.get(configPrefix + \"state\"));\n+          } catch (Exception ex) {\n+            LOG.warn(\"Not a valid queue state for queue \"\n+                + oldQueue.getQueuePath());\n+          }\n+          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n+              newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n           } else{\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                 + \" deleted from the capacity scheduler configuration, as the\"\n                 + \" queue is not yet in stopped state. Current State : \"\n                 + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n               queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                   + newQueue.getQueuePath()\n                   + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n             \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n               \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                   + \" to auto create enabled parent queue since \"\n                   + \"it could have other pre-configured queues which is not \"\n                   + \"supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n             \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n               \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                   .getQueuePath() + \" to leaf queue. Please check \"\n                   + \" parent queue\u0027s configuration \"\n                   + CapacitySchedulerConfiguration\n                   .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                   + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n             \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                 + \" to parent queue.\");\n           } else{\n             throw new IOException(\n                 \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                     + \" to parent queue since \"\n                     + \"it is not yet in stopped state. Current State : \"\n                     + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n               + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n      throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n          .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          String configPrefix \u003d newConf.getQueuePrefix(\n              oldQueue.getQueuePath());\n          QueueState newQueueState \u003d null;\n          try {\n            newQueueState \u003d QueueState.valueOf(\n                newConf.get(configPrefix + \"state\"));\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                + oldQueue.getQueuePath());\n          }\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n              newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                + \" deleted from the capacity scheduler configuration, as the\"\n                + \" queue is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                  + newQueue.getQueuePath()\n                  + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                  + \" to auto create enabled parent queue since \"\n                  + \"it could have other pre-configured queues which is not \"\n                  + \"supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                  .getQueuePath() + \" to leaf queue. Please check \"\n                  + \" parent queue\u0027s configuration \"\n                  + CapacitySchedulerConfiguration\n                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                  + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue since \"\n                    + \"it is not yet in stopped state. Current State : \"\n                    + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {
            "oldValue": "[queues-Map\u003cString,CSQueue\u003e, newQueues-Map\u003cString,CSQueue\u003e]",
            "newValue": "[queues-Map\u003cString,CSQueue\u003e, newQueues-Map\u003cString,CSQueue\u003e, newConf-CapacitySchedulerConfiguration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9780. SchedulerConf Mutation API does not Allow Stop and Remove Queue in a single call. Contributed by Prabhu Joseph\n",
          "commitDate": "05/12/19 11:38 AM",
          "commitName": "4627dd670800b2191ebdd41c6971ccd53e718e18",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "31/08/19 9:30 PM",
          "commitNameOld": "c7ef4fb74acacdb184d12bafadd8fb040b5c04b6",
          "commitAuthorOld": "Abhishek Modi",
          "daysBetweenCommits": 95.63,
          "commitsBetweenForRepo": 540,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,75 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n-      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n+      Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n+      throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n           .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n-          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n+          String configPrefix \u003d newConf.getQueuePrefix(\n+              oldQueue.getQueuePath());\n+          QueueState newQueueState \u003d null;\n+          try {\n+            newQueueState \u003d QueueState.valueOf(\n+                newConf.get(configPrefix + \"state\"));\n+          } catch (Exception ex) {\n+            LOG.warn(\"Not a valid queue state for queue \"\n+                + oldQueue.getQueuePath());\n+          }\n+          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n+              newQueueState \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n           } else{\n             throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                 + \" deleted from the capacity scheduler configuration, as the\"\n                 + \" queue is not yet in stopped state. Current State : \"\n                 + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n               queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                   + newQueue.getQueuePath()\n                   + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n             \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n               \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                   + \" to auto create enabled parent queue since \"\n                   + \"it could have other pre-configured queues which is not \"\n                   + \"supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n             \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n               \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                   .getQueuePath() + \" to leaf queue. Please check \"\n                   + \" parent queue\u0027s configuration \"\n                   + CapacitySchedulerConfiguration\n                   .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                   + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n             \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                 + \" to parent queue.\");\n           } else{\n             throw new IOException(\n                 \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                     + \" to parent queue since \"\n                     + \"it is not yet in stopped state. Current State : \"\n                     + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n               + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues, CapacitySchedulerConfiguration newConf)\n      throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n          .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          String configPrefix \u003d newConf.getQueuePrefix(\n              oldQueue.getQueuePath());\n          QueueState newQueueState \u003d null;\n          try {\n            newQueueState \u003d QueueState.valueOf(\n                newConf.get(configPrefix + \"state\"));\n          } catch (Exception ex) {\n            LOG.warn(\"Not a valid queue state for queue \"\n                + oldQueue.getQueuePath());\n          }\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED ||\n              newQueueState \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                + \" deleted from the capacity scheduler configuration, as the\"\n                + \" queue is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                  + newQueue.getQueuePath()\n                  + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                  + \" to auto create enabled parent queue since \"\n                  + \"it could have other pre-configured queues which is not \"\n                  + \"supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                  .getQueuePath() + \" to leaf queue. Please check \"\n                  + \" parent queue\u0027s configuration \"\n                  + CapacitySchedulerConfiguration\n                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                  + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue since \"\n                    + \"it is not yet in stopped state. Current State : \"\n                    + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "c7ef4fb74acacdb184d12bafadd8fb040b5c04b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8678. Queue Management API - rephrase error messages. Contributed by Prabhu Joseph.\n",
      "commitDate": "31/08/19 9:30 PM",
      "commitName": "c7ef4fb74acacdb184d12bafadd8fb040b5c04b6",
      "commitAuthor": "Abhishek Modi",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 179.97,
      "commitsBetweenForRepo": 1390,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n           .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n           } else{\n-            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n-                + \" the new capacity scheduler configuration, but the\"\n-                + \" queue is not yet in stopped state. \" + \"Current State : \"\n+            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n+                + \" deleted from the capacity scheduler configuration, as the\"\n+                + \" queue is not yet in stopped state. Current State : \"\n                 + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n               queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                   + newQueue.getQueuePath()\n                   + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n             \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n               \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                   + \" to auto create enabled parent queue since \"\n                   + \"it could have other pre-configured queues which is not \"\n                   + \"supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n             \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n               \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                   .getQueuePath() + \" to leaf queue. Please check \"\n                   + \" parent queue\u0027s configuration \"\n                   + CapacitySchedulerConfiguration\n                   .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                   + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n             \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                 + \" to parent queue.\");\n           } else{\n             throw new IOException(\n                 \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                     + \" to parent queue since \"\n                     + \"it is not yet in stopped state. Current State : \"\n                     + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n               + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n          .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" cannot be\"\n                + \" deleted from the capacity scheduler configuration, as the\"\n                + \" queue is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                  + newQueue.getQueuePath()\n                  + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                  + \" to auto create enabled parent queue since \"\n                  + \"it could have other pre-configured queues which is not \"\n                  + \"supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                  .getQueuePath() + \" to leaf queue. Please check \"\n                  + \" parent queue\u0027s configuration \"\n                  + CapacitySchedulerConfiguration\n                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                  + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue since \"\n                    + \"it is not yet in stopped state. Current State : \"\n                    + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/11/17 11:25 AM",
      "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 22.16,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n-      if (!(e.getValue() instanceof AutoCreatedLeafQueue)) {\n+      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n+          .getClass()))) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n           } else{\n             throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                 + \" the new capacity scheduler configuration, but the\"\n                 + \" queue is not yet in stopped state. \" + \"Current State : \"\n                 + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(\n               queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                   + newQueue.getQueuePath()\n                   + \" after refresh, which is not allowed.\");\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n             \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n           throw new IOException(\n               \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                   + \" to auto create enabled parent queue since \"\n                   + \"it could have other pre-configured queues which is not \"\n                   + \"supported\");\n         } else if (oldQueue instanceof ManagedParentQueue\n             \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n           throw new IOException(\n               \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                   .getQueuePath() + \" to leaf queue. Please check \"\n                   + \" parent queue\u0027s configuration \"\n                   + CapacitySchedulerConfiguration\n                   .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                   + \" is set to true\");\n         } else if (oldQueue instanceof LeafQueue\n             \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                 + \" to parent queue.\");\n           } else{\n             throw new IOException(\n                 \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                     + \" to parent queue since \"\n                     + \"it is not yet in stopped state. Current State : \"\n                     + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n               + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(e.getValue()\n          .getClass()))) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                + \" the new capacity scheduler configuration, but the\"\n                + \" queue is not yet in stopped state. \" + \"Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                  + newQueue.getQueuePath()\n                  + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                  + \" to auto create enabled parent queue since \"\n                  + \"it could have other pre-configured queues which is not \"\n                  + \"supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                  .getQueuePath() + \" to leaf queue. Please check \"\n                  + \" parent queue\u0027s configuration \"\n                  + CapacitySchedulerConfiguration\n                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                  + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue since \"\n                    + \"it is not yet in stopped state. Current State : \"\n                    + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "06/11/17 9:38 PM",
      "commitNameOld": "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.57,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,62 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(e.getValue() instanceof AutoCreatedLeafQueue)) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n-          } else {\n+          } else{\n             throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                 + \" the new capacity scheduler configuration, but the\"\n-                + \" queue is not yet in stopped state. \"\n-                + \"Current State : \" + oldQueue.getState());\n+                + \" queue is not yet in stopped state. \" + \"Current State : \"\n+                + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n-          throw new IOException(queueName + \" is moved from:\"\n-              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n-              + \" after refresh, which is not allowed.\");\n-        } else  if (oldQueue instanceof LeafQueue\n+          throw new IOException(\n+              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n+                  + newQueue.getQueuePath()\n+                  + \" after refresh, which is not allowed.\");\n+        } else if (oldQueue instanceof ParentQueue\n+            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n+            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n+          throw new IOException(\n+              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n+                  + \" to auto create enabled parent queue since \"\n+                  + \"it could have other pre-configured queues which is not \"\n+                  + \"supported\");\n+        } else if (oldQueue instanceof ManagedParentQueue\n+            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n+          throw new IOException(\n+              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n+                  .getQueuePath() + \" to leaf queue. Please check \"\n+                  + \" parent queue\u0027s configuration \"\n+                  + CapacitySchedulerConfiguration\n+                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n+                  + \" is set to true\");\n+        } else if (oldQueue instanceof LeafQueue\n             \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                 + \" to parent queue.\");\n-          } else {\n-            throw new IOException(\"Can not convert the leaf queue: \"\n-                + oldQueue.getQueuePath() + \" to parent queue since \"\n-                + \"it is not yet in stopped state. Current State : \"\n-                + oldQueue.getState());\n+          } else{\n+            throw new IOException(\n+                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n+                    + \" to parent queue since \"\n+                    + \"it is not yet in stopped state. Current State : \"\n+                    + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n               + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof AutoCreatedLeafQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else{\n            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                + \" the new capacity scheduler configuration, but the\"\n                + \" queue is not yet in stopped state. \" + \"Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(\n              queueName + \" is moved from:\" + oldQueue.getQueuePath() + \" to:\"\n                  + newQueue.getQueuePath()\n                  + \" after refresh, which is not allowed.\");\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 !(oldQueue instanceof ManagedParentQueue)\n            \u0026\u0026 newQueue instanceof ManagedParentQueue) {\n          throw new IOException(\n              \"Can not convert parent queue: \" + oldQueue.getQueuePath()\n                  + \" to auto create enabled parent queue since \"\n                  + \"it could have other pre-configured queues which is not \"\n                  + \"supported\");\n        } else if (oldQueue instanceof ManagedParentQueue\n            \u0026\u0026 !(newQueue instanceof ManagedParentQueue)) {\n          throw new IOException(\n              \"Cannot convert auto create enabled parent queue: \" + oldQueue\n                  .getQueuePath() + \" to leaf queue. Please check \"\n                  + \" parent queue\u0027s configuration \"\n                  + CapacitySchedulerConfiguration\n                  .AUTO_CREATE_CHILD_QUEUE_ENABLED\n                  + \" is set to true\");\n        } else if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else{\n            throw new IOException(\n                \"Can not convert the leaf queue: \" + oldQueue.getQueuePath()\n                    + \" to parent queue since \"\n                    + \"it is not yet in stopped state. Current State : \"\n                    + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7394. Merge code paths for Reservation/Plan queues and Auto Created queues. (Suma Shivaprasad via wangda)\n",
      "commitDate": "06/11/17 9:38 PM",
      "commitName": "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "1d36b53ab6d9bb1d9144101e424c24371343c5bf",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 28.48,
      "commitsBetweenForRepo": 280,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n-      if (!(e.getValue() instanceof ReservationQueue)) {\n+      if (!(e.getValue() instanceof AutoCreatedLeafQueue)) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n           } else {\n             throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                 + \" the new capacity scheduler configuration, but the\"\n                 + \" queue is not yet in stopped state. \"\n                 + \"Current State : \" + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(queueName + \" is moved from:\"\n               + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n               + \" after refresh, which is not allowed.\");\n         } else  if (oldQueue instanceof LeafQueue\n             \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                 + \" to parent queue.\");\n           } else {\n             throw new IOException(\"Can not convert the leaf queue: \"\n                 + oldQueue.getQueuePath() + \" to parent queue since \"\n                 + \"it is not yet in stopped state. Current State : \"\n                 + oldQueue.getState());\n           }\n         } else if (oldQueue instanceof ParentQueue\n             \u0026\u0026 newQueue instanceof LeafQueue) {\n           LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n               + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof AutoCreatedLeafQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else {\n            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                + \" the new capacity scheduler configuration, but the\"\n                + \" queue is not yet in stopped state. \"\n                + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(queueName + \" is moved from:\"\n              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        } else  if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else {\n            throw new IOException(\"Can not convert the leaf queue: \"\n                + oldQueue.getQueuePath() + \" to parent queue since \"\n                + \"it is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "d8f74c3964fa429a4a53c3651d175792cf00ac81": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6741. Deleting all children of a Parent Queue on refresh throws exception. Contributed by Naganarasimha G R.\n",
      "commitDate": "13/08/17 9:09 PM",
      "commitName": "d8f74c3964fa429a4a53c3651d175792cf00ac81",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "01/05/17 7:45 AM",
      "commitNameOld": "30fc5801966feb7f9bdd7d79db75acc595102913",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 104.56,
      "commitsBetweenForRepo": 598,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,43 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(e.getValue() instanceof ReservationQueue)) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n           } else {\n             throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                 + \" the new capacity scheduler configuration, but the\"\n                 + \" queue is not yet in stopped state. \"\n                 + \"Current State : \" + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(queueName + \" is moved from:\"\n               + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n               + \" after refresh, which is not allowed.\");\n         } else  if (oldQueue instanceof LeafQueue\n             \u0026\u0026 newQueue instanceof ParentQueue) {\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                 + \" to parent queue.\");\n           } else {\n             throw new IOException(\"Can not convert the leaf queue: \"\n                 + oldQueue.getQueuePath() + \" to parent queue since \"\n                 + \"it is not yet in stopped state. Current State : \"\n                 + oldQueue.getState());\n           }\n+        } else if (oldQueue instanceof ParentQueue\n+            \u0026\u0026 newQueue instanceof LeafQueue) {\n+          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n+              + \" to leaf queue.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof ReservationQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else {\n            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                + \" the new capacity scheduler configuration, but the\"\n                + \" queue is not yet in stopped state. \"\n                + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(queueName + \" is moved from:\"\n              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        } else  if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else {\n            throw new IOException(\"Can not convert the leaf queue: \"\n                + oldQueue.getQueuePath() + \" to parent queue since \"\n                + \"it is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        } else if (oldQueue instanceof ParentQueue\n            \u0026\u0026 newQueue instanceof LeafQueue) {\n          LOG.info(\"Converting the parent queue: \" + oldQueue.getQueuePath()\n              + \" to leaf queue.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6109. Add an ability to convert ChildQueue to ParentQueue. (Xuan Gong via wangda)\n",
      "commitDate": "04/04/17 2:39 PM",
      "commitName": "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/03/17 12:52 PM",
      "commitNameOld": "0a3aa40fe7878c939dbf4e6b43466595159ff930",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 21.07,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,39 @@\n   private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(e.getValue() instanceof ReservationQueue)) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           // old queue doesn\u0027t exist in the new XML\n           if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n             LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                 + \" present in the modified capacity configuration xml\");\n           } else {\n             throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                 + \" the new capacity scheduler configuration, but the\"\n                 + \" queue is not yet in stopped state. \"\n                 + \"Current State : \" + oldQueue.getState());\n           }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(queueName + \" is moved from:\"\n               + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n               + \" after refresh, which is not allowed.\");\n+        } else  if (oldQueue instanceof LeafQueue\n+            \u0026\u0026 newQueue instanceof ParentQueue) {\n+          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n+            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n+                + \" to parent queue.\");\n+          } else {\n+            throw new IOException(\"Can not convert the leaf queue: \"\n+                + oldQueue.getQueuePath() + \" to parent queue since \"\n+                + \"it is not yet in stopped state. Current State : \"\n+                + oldQueue.getState());\n+          }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof ReservationQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else {\n            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                + \" the new capacity scheduler configuration, but the\"\n                + \" queue is not yet in stopped state. \"\n                + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(queueName + \" is moved from:\"\n              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        } else  if (oldQueue instanceof LeafQueue\n            \u0026\u0026 newQueue instanceof ParentQueue) {\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Converting the leaf queue: \" + oldQueue.getQueuePath()\n                + \" to parent queue.\");\n          } else {\n            throw new IOException(\"Can not convert the leaf queue: \"\n                + oldQueue.getQueuePath() + \" to parent queue since \"\n                + \"it is not yet in stopped state. Current State : \"\n                + oldQueue.getState());\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "72054a817dfb43e93916d7036eba19cf2f49cea2": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-5556. CapacityScheduler: Support deleting queues without requiring a RM restart. (Naganarasimha G R via wangda)\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "72054a817dfb43e93916d7036eba19cf2f49cea2",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-5556. CapacityScheduler: Support deleting queues without requiring a RM restart. (Naganarasimha G R via wangda)\n",
          "commitDate": "18/01/17 1:31 PM",
          "commitName": "72054a817dfb43e93916d7036eba19cf2f49cea2",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/01/17 8:40 AM",
          "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 9.2,
          "commitsBetweenForRepo": 52,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,28 @@\n-  private void validateExistingQueues(\n-      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues)\n-      throws IOException {\n+  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n+      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(e.getValue() instanceof ReservationQueue)) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n-          throw new IOException(queueName + \" cannot be found during refresh!\");\n+          // old queue doesn\u0027t exist in the new XML\n+          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n+            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n+                + \" present in the modified capacity configuration xml\");\n+          } else {\n+            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n+                + \" the new capacity scheduler configuration, but the\"\n+                + \" queue is not yet in stopped state. \"\n+                + \"Current State : \" + oldQueue.getState());\n+          }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n+          //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(queueName + \" is moved from:\"\n               + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n               + \" after refresh, which is not allowed.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof ReservationQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else {\n            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                + \" the new capacity scheduler configuration, but the\"\n                + \" queue is not yet in stopped state. \"\n                + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(queueName + \" is moved from:\"\n              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {
            "oldValue": "validateExistingQueues",
            "newValue": "validateQueueHierarchy"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5556. CapacityScheduler: Support deleting queues without requiring a RM restart. (Naganarasimha G R via wangda)\n",
          "commitDate": "18/01/17 1:31 PM",
          "commitName": "72054a817dfb43e93916d7036eba19cf2f49cea2",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/01/17 8:40 AM",
          "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 9.2,
          "commitsBetweenForRepo": 52,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,28 @@\n-  private void validateExistingQueues(\n-      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues)\n-      throws IOException {\n+  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n+      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(e.getValue() instanceof ReservationQueue)) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n-          throw new IOException(queueName + \" cannot be found during refresh!\");\n+          // old queue doesn\u0027t exist in the new XML\n+          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n+            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n+                + \" present in the modified capacity configuration xml\");\n+          } else {\n+            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n+                + \" the new capacity scheduler configuration, but the\"\n+                + \" queue is not yet in stopped state. \"\n+                + \"Current State : \" + oldQueue.getState());\n+          }\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n+          //Queue\u0027s cannot be moved from one hierarchy to other\n           throw new IOException(queueName + \" is moved from:\"\n               + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n               + \" after refresh, which is not allowed.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void validateQueueHierarchy(Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e newQueues) throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof ReservationQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          // old queue doesn\u0027t exist in the new XML\n          if (oldQueue.getState() \u003d\u003d QueueState.STOPPED) {\n            LOG.info(\"Deleting Queue \" + queueName + \", as it is not\"\n                + \" present in the modified capacity configuration xml\");\n          } else {\n            throw new IOException(oldQueue.getQueuePath() + \" is deleted from\"\n                + \" the new capacity scheduler configuration, but the\"\n                + \" queue is not yet in stopped state. \"\n                + \"Current State : \" + oldQueue.getState());\n          }\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          //Queue\u0027s cannot be moved from one hierarchy to other\n          throw new IOException(queueName + \" is moved from:\"\n              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": {
      "type": "Ymovefromfile",
      "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
      "commitDate": "30/11/16 1:38 PM",
      "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
      "commitAuthor": "Li Lu",
      "commitDateOld": "30/11/16 1:01 PM",
      "commitNameOld": "3fd844b99fdfae6be6e5e261f371d175aad14229",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n   private void validateExistingQueues(\n       Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues)\n-  throws IOException {\n+      throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(e.getValue() instanceof ReservationQueue)) {\n         String queueName \u003d e.getKey();\n         CSQueue oldQueue \u003d e.getValue();\n         CSQueue newQueue \u003d newQueues.get(queueName);\n         if (null \u003d\u003d newQueue) {\n           throw new IOException(queueName + \" cannot be found during refresh!\");\n         } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n           throw new IOException(queueName + \" is moved from:\"\n               + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n               + \" after refresh, which is not allowed.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateExistingQueues(\n      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues)\n      throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof ReservationQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName);\n        if (null \u003d\u003d newQueue) {\n          throw new IOException(queueName + \" cannot be found during refresh!\");\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          throw new IOException(queueName + \" is moved from:\"\n              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
        "oldMethodName": "validateExistingQueues",
        "newMethodName": "validateExistingQueues"
      }
    },
    "6ad4e59cfc111a92747fdb1fb99cc6378044832a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3764. CapacityScheduler should forbid moving LeafQueue from one parent to another. Contributed by Wangda Tan\n",
      "commitDate": "04/06/15 10:52 AM",
      "commitName": "6ad4e59cfc111a92747fdb1fb99cc6378044832a",
      "commitAuthor": "Jian He",
      "commitDateOld": "26/05/15 12:00 PM",
      "commitNameOld": "10732d515f62258309f98e4d7d23249f80b1847d",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 8.95,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,19 @@\n   private void validateExistingQueues(\n       Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues) \n   throws IOException {\n     // check that all static queues are included in the newQueues list\n     for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n       if (!(e.getValue() instanceof ReservationQueue)) {\n-        if (!newQueues.containsKey(e.getKey())) {\n-          throw new IOException(e.getKey() + \" cannot be found during refresh!\");\n+        String queueName \u003d e.getKey();\n+        CSQueue oldQueue \u003d e.getValue();\n+        CSQueue newQueue \u003d newQueues.get(queueName); \n+        if (null \u003d\u003d newQueue) {\n+          throw new IOException(queueName + \" cannot be found during refresh!\");\n+        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n+          throw new IOException(queueName + \" is moved from:\"\n+              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n+              + \" after refresh, which is not allowed.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateExistingQueues(\n      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues) \n  throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof ReservationQueue)) {\n        String queueName \u003d e.getKey();\n        CSQueue oldQueue \u003d e.getValue();\n        CSQueue newQueue \u003d newQueues.get(queueName); \n        if (null \u003d\u003d newQueue) {\n          throw new IOException(queueName + \" cannot be found during refresh!\");\n        } else if (!oldQueue.getQueuePath().equals(newQueue.getQueuePath())) {\n          throw new IOException(queueName + \" is moved from:\"\n              + oldQueue.getQueuePath() + \" to:\" + newQueue.getQueuePath()\n              + \" after refresh, which is not allowed.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "eb3e40b833b9d82c1556843f960194dc42e482f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1707. Introduce APIs to add/remove/resize queues in the CapacityScheduler. Contributed by Carlo Curino and Subru Krishnan\n(cherry picked from commit aac47fda7fecda9fc18ade34d633eca895865a70)\n\nConflicts:\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthor": "carlo curino",
      "commitDateOld": "02/10/14 3:13 PM",
      "commitNameOld": "054f28552687e9b9859c0126e16a2066e20ead3f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,9 +1,12 @@\n   private void validateExistingQueues(\n       Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues) \n   throws IOException {\n-    for (String queue : queues.keySet()) {\n-      if (!newQueues.containsKey(queue)) {\n-        throw new IOException(queue + \" cannot be found during refresh!\");\n+    // check that all static queues are included in the newQueues list\n+    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n+      if (!(e.getValue() instanceof ReservationQueue)) {\n+        if (!newQueues.containsKey(e.getKey())) {\n+          throw new IOException(e.getKey() + \" cannot be found during refresh!\");\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateExistingQueues(\n      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues) \n  throws IOException {\n    // check that all static queues are included in the newQueues list\n    for (Map.Entry\u003cString, CSQueue\u003e e : queues.entrySet()) {\n      if (!(e.getValue() instanceof ReservationQueue)) {\n        if (!newQueues.containsKey(e.getKey())) {\n          throw new IOException(e.getKey() + \" cannot be found during refresh!\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void validateExistingQueues(\n      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues) \n  throws IOException {\n    for (String queue : queues.keySet()) {\n      if (!newQueues.containsKey(queue)) {\n        throw new IOException(queue + \" cannot be found during refresh!\");\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "1f46b991da9b91585608a0babd3eda39485dce09": {
      "type": "Yparameterchange",
      "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 11:26 AM",
      "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "06/09/11 10:54 PM",
      "commitNameOld": "0ecba04727b5c31182d29511646c8d3e6441300f",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.52,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,9 +1,9 @@\n   private void validateExistingQueues(\n-      Map\u003cString, Queue\u003e queues, Map\u003cString, Queue\u003e newQueues) \n+      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues) \n   throws IOException {\n     for (String queue : queues.keySet()) {\n       if (!newQueues.containsKey(queue)) {\n         throw new IOException(queue + \" cannot be found during refresh!\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateExistingQueues(\n      Map\u003cString, CSQueue\u003e queues, Map\u003cString, CSQueue\u003e newQueues) \n  throws IOException {\n    for (String queue : queues.keySet()) {\n      if (!newQueues.containsKey(queue)) {\n        throw new IOException(queue + \" cannot be found during refresh!\");\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldValue": "[queues-Map\u003cString,Queue\u003e, newQueues-Map\u003cString,Queue\u003e]",
        "newValue": "[queues-Map\u003cString,CSQueue\u003e, newQueues-Map\u003cString,CSQueue\u003e]"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void validateExistingQueues(\n      Map\u003cString, Queue\u003e queues, Map\u003cString, Queue\u003e newQueues) \n  throws IOException {\n    for (String queue : queues.keySet()) {\n      if (!newQueues.containsKey(queue)) {\n        throw new IOException(queue + \" cannot be found during refresh!\");\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,9 @@\n+  private void validateExistingQueues(\n+      Map\u003cString, Queue\u003e queues, Map\u003cString, Queue\u003e newQueues) \n+  throws IOException {\n+    for (String queue : queues.keySet()) {\n+      if (!newQueues.containsKey(queue)) {\n+        throw new IOException(queue + \" cannot be found during refresh!\");\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateExistingQueues(\n      Map\u003cString, Queue\u003e queues, Map\u003cString, Queue\u003e newQueues) \n  throws IOException {\n    for (String queue : queues.keySet()) {\n      if (!newQueues.containsKey(queue)) {\n        throw new IOException(queue + \" cannot be found during refresh!\");\n      }\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}