{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RPCUtil.java",
  "functionName": "unwrapAndThrowException",
  "functionId": "unwrapAndThrowException___se-ServiceException",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
  "functionStartLine": 96,
  "functionEndLine": 141,
  "numCommitsSeen": 14,
  "timeTaken": 3283,
  "changeHistory": [
    "87130bf6b22f538c5c26ad5cef984558a8117798",
    "6d4d87008ca27f434a062e27c9794e3fd2ee2e0d",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "065747efabd1cbea9b14e93e905e304b9973d355",
    "2638bc67a48f923404d57ed2026c4997df6bd06e",
    "92b7165a71656468f17ce8b760ce11e648932f0e",
    "fc275fed66469daf07a62db174b1df0916c72143",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "db3e592df0cd022d15a6acdeac3517c54d510ad2"
  ],
  "changeHistoryShort": {
    "87130bf6b22f538c5c26ad5cef984558a8117798": "Ybodychange",
    "6d4d87008ca27f434a062e27c9794e3fd2ee2e0d": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ymultichange(Yexceptionschange,Ybodychange)",
    "065747efabd1cbea9b14e93e905e304b9973d355": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
    "2638bc67a48f923404d57ed2026c4997df6bd06e": "Ybodychange",
    "92b7165a71656468f17ce8b760ce11e648932f0e": "Ybodychange",
    "fc275fed66469daf07a62db174b1df0916c72143": "Ymovefromfile",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "db3e592df0cd022d15a6acdeac3517c54d510ad2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "87130bf6b22f538c5c26ad5cef984558a8117798": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3400. [JDK 8] Build Failure due to unreported exceptions in RPCUtil (rkanter)\n",
      "commitDate": "26/03/15 11:00 AM",
      "commitName": "87130bf6b22f538c5c26ad5cef984558a8117798",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "16/06/13 8:32 PM",
      "commitNameOld": "f5f8f3bca4eeaedeff8181812452ec363c4db744",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 647.6,
      "commitsBetweenForRepo": 4838,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   public static Void unwrapAndThrowException(ServiceException se)\n       throws IOException, YarnException {\n     Throwable cause \u003d se.getCause();\n     if (cause \u003d\u003d null) {\n       // SE generated by the RPC layer itself.\n       throw new IOException(se);\n     } else {\n       if (cause instanceof RemoteException) {\n         RemoteException re \u003d (RemoteException) cause;\n         Class\u003c?\u003e realClass \u003d null;\n         try {\n           realClass \u003d Class.forName(re.getClassName());\n         } catch (ClassNotFoundException cnf) {\n           // Assume this to be a new exception type added to YARN. This isn\u0027t\n           // absolutely correct since the RPC layer could add an exception as\n           // well.\n-          throw instantiateException(YarnException.class, re);\n+          throw instantiateYarnException(YarnException.class, re);\n         }\n \n         if (YarnException.class.isAssignableFrom(realClass)) {\n-          throw instantiateException(\n+          throw instantiateYarnException(\n               realClass.asSubclass(YarnException.class), re);\n         } else if (IOException.class.isAssignableFrom(realClass)) {\n-          throw instantiateException(realClass.asSubclass(IOException.class),\n+          throw instantiateIOException(realClass.asSubclass(IOException.class),\n               re);\n         } else if (RuntimeException.class.isAssignableFrom(realClass)) {\n-          throw instantiateException(\n+          throw instantiateRuntimeException(\n               realClass.asSubclass(RuntimeException.class), re);\n         } else {\n           throw re;\n         }\n         // RemoteException contains useful information as against the\n         // java.lang.reflect exceptions.\n \n       } else if (cause instanceof IOException) {\n         // RPC Client exception.\n         throw (IOException) cause;\n       } else if (cause instanceof RuntimeException) {\n         // RPC RuntimeException\n         throw (RuntimeException) cause;\n       } else {\n         // Should not be generated.\n         throw new IOException(se);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Void unwrapAndThrowException(ServiceException se)\n      throws IOException, YarnException {\n    Throwable cause \u003d se.getCause();\n    if (cause \u003d\u003d null) {\n      // SE generated by the RPC layer itself.\n      throw new IOException(se);\n    } else {\n      if (cause instanceof RemoteException) {\n        RemoteException re \u003d (RemoteException) cause;\n        Class\u003c?\u003e realClass \u003d null;\n        try {\n          realClass \u003d Class.forName(re.getClassName());\n        } catch (ClassNotFoundException cnf) {\n          // Assume this to be a new exception type added to YARN. This isn\u0027t\n          // absolutely correct since the RPC layer could add an exception as\n          // well.\n          throw instantiateYarnException(YarnException.class, re);\n        }\n\n        if (YarnException.class.isAssignableFrom(realClass)) {\n          throw instantiateYarnException(\n              realClass.asSubclass(YarnException.class), re);\n        } else if (IOException.class.isAssignableFrom(realClass)) {\n          throw instantiateIOException(realClass.asSubclass(IOException.class),\n              re);\n        } else if (RuntimeException.class.isAssignableFrom(realClass)) {\n          throw instantiateRuntimeException(\n              realClass.asSubclass(RuntimeException.class), re);\n        } else {\n          throw re;\n        }\n        // RemoteException contains useful information as against the\n        // java.lang.reflect exceptions.\n\n      } else if (cause instanceof IOException) {\n        // RPC Client exception.\n        throw (IOException) cause;\n      } else if (cause instanceof RuntimeException) {\n        // RPC RuntimeException\n        throw (RuntimeException) cause;\n      } else {\n        // Should not be generated.\n        throw new IOException(se);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
      "extendedDetails": {}
    },
    "6d4d87008ca27f434a062e27c9794e3fd2ee2e0d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-731. RPCUtil.unwrapAndThrowException should unwrap remote RuntimeExceptions. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492000 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/13 3:34 PM",
      "commitName": "6d4d87008ca27f434a062e27c9794e3fd2ee2e0d",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "03/06/13 9:05 PM",
      "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.77,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,46 @@\n   public static Void unwrapAndThrowException(ServiceException se)\n       throws IOException, YarnException {\n     Throwable cause \u003d se.getCause();\n     if (cause \u003d\u003d null) {\n       // SE generated by the RPC layer itself.\n       throw new IOException(se);\n     } else {\n       if (cause instanceof RemoteException) {\n         RemoteException re \u003d (RemoteException) cause;\n         Class\u003c?\u003e realClass \u003d null;\n         try {\n           realClass \u003d Class.forName(re.getClassName());\n         } catch (ClassNotFoundException cnf) {\n           // Assume this to be a new exception type added to YARN. This isn\u0027t\n           // absolutely correct since the RPC layer could add an exception as\n           // well.\n           throw instantiateException(YarnException.class, re);\n         }\n \n         if (YarnException.class.isAssignableFrom(realClass)) {\n           throw instantiateException(\n               realClass.asSubclass(YarnException.class), re);\n         } else if (IOException.class.isAssignableFrom(realClass)) {\n           throw instantiateException(realClass.asSubclass(IOException.class),\n               re);\n+        } else if (RuntimeException.class.isAssignableFrom(realClass)) {\n+          throw instantiateException(\n+              realClass.asSubclass(RuntimeException.class), re);\n         } else {\n           throw re;\n         }\n         // RemoteException contains useful information as against the\n         // java.lang.reflect exceptions.\n \n       } else if (cause instanceof IOException) {\n         // RPC Client exception.\n         throw (IOException) cause;\n+      } else if (cause instanceof RuntimeException) {\n+        // RPC RuntimeException\n+        throw (RuntimeException) cause;\n       } else {\n         // Should not be generated.\n         throw new IOException(se);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Void unwrapAndThrowException(ServiceException se)\n      throws IOException, YarnException {\n    Throwable cause \u003d se.getCause();\n    if (cause \u003d\u003d null) {\n      // SE generated by the RPC layer itself.\n      throw new IOException(se);\n    } else {\n      if (cause instanceof RemoteException) {\n        RemoteException re \u003d (RemoteException) cause;\n        Class\u003c?\u003e realClass \u003d null;\n        try {\n          realClass \u003d Class.forName(re.getClassName());\n        } catch (ClassNotFoundException cnf) {\n          // Assume this to be a new exception type added to YARN. This isn\u0027t\n          // absolutely correct since the RPC layer could add an exception as\n          // well.\n          throw instantiateException(YarnException.class, re);\n        }\n\n        if (YarnException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(\n              realClass.asSubclass(YarnException.class), re);\n        } else if (IOException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(realClass.asSubclass(IOException.class),\n              re);\n        } else if (RuntimeException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(\n              realClass.asSubclass(RuntimeException.class), re);\n        } else {\n          throw re;\n        }\n        // RemoteException contains useful information as against the\n        // java.lang.reflect exceptions.\n\n      } else if (cause instanceof IOException) {\n        // RPC Client exception.\n        throw (IOException) cause;\n      } else if (cause instanceof RuntimeException) {\n        // RPC RuntimeException\n        throw (RuntimeException) cause;\n      } else {\n        // Should not be generated.\n        throw new IOException(se);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/06/13 9:05 PM",
          "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "15/05/13 11:58 PM",
          "commitNameOld": "065747efabd1cbea9b14e93e905e304b9973d355",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 18.88,
          "commitsBetweenForRepo": 107,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n   public static Void unwrapAndThrowException(ServiceException se)\n-      throws IOException, YarnRemoteException {\n+      throws IOException, YarnException {\n     Throwable cause \u003d se.getCause();\n     if (cause \u003d\u003d null) {\n       // SE generated by the RPC layer itself.\n       throw new IOException(se);\n     } else {\n       if (cause instanceof RemoteException) {\n         RemoteException re \u003d (RemoteException) cause;\n         Class\u003c?\u003e realClass \u003d null;\n         try {\n           realClass \u003d Class.forName(re.getClassName());\n         } catch (ClassNotFoundException cnf) {\n           // Assume this to be a new exception type added to YARN. This isn\u0027t\n           // absolutely correct since the RPC layer could add an exception as\n           // well.\n-          throw instantiateException(YarnRemoteException.class, re);\n+          throw instantiateException(YarnException.class, re);\n         }\n \n-        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n+        if (YarnException.class.isAssignableFrom(realClass)) {\n           throw instantiateException(\n-              realClass.asSubclass(YarnRemoteException.class), re);\n+              realClass.asSubclass(YarnException.class), re);\n         } else if (IOException.class.isAssignableFrom(realClass)) {\n           throw instantiateException(realClass.asSubclass(IOException.class),\n               re);\n         } else {\n           throw re;\n         }\n         // RemoteException contains useful information as against the\n         // java.lang.reflect exceptions.\n \n       } else if (cause instanceof IOException) {\n         // RPC Client exception.\n         throw (IOException) cause;\n       } else {\n         // Should not be generated.\n         throw new IOException(se);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static Void unwrapAndThrowException(ServiceException se)\n      throws IOException, YarnException {\n    Throwable cause \u003d se.getCause();\n    if (cause \u003d\u003d null) {\n      // SE generated by the RPC layer itself.\n      throw new IOException(se);\n    } else {\n      if (cause instanceof RemoteException) {\n        RemoteException re \u003d (RemoteException) cause;\n        Class\u003c?\u003e realClass \u003d null;\n        try {\n          realClass \u003d Class.forName(re.getClassName());\n        } catch (ClassNotFoundException cnf) {\n          // Assume this to be a new exception type added to YARN. This isn\u0027t\n          // absolutely correct since the RPC layer could add an exception as\n          // well.\n          throw instantiateException(YarnException.class, re);\n        }\n\n        if (YarnException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(\n              realClass.asSubclass(YarnException.class), re);\n        } else if (IOException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(realClass.asSubclass(IOException.class),\n              re);\n        } else {\n          throw re;\n        }\n        // RemoteException contains useful information as against the\n        // java.lang.reflect exceptions.\n\n      } else if (cause instanceof IOException) {\n        // RPC Client exception.\n        throw (IOException) cause;\n      } else {\n        // Should not be generated.\n        throw new IOException(se);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
          "extendedDetails": {
            "oldValue": "[IOException, YarnRemoteException]",
            "newValue": "[IOException, YarnException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/06/13 9:05 PM",
          "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "15/05/13 11:58 PM",
          "commitNameOld": "065747efabd1cbea9b14e93e905e304b9973d355",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 18.88,
          "commitsBetweenForRepo": 107,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n   public static Void unwrapAndThrowException(ServiceException se)\n-      throws IOException, YarnRemoteException {\n+      throws IOException, YarnException {\n     Throwable cause \u003d se.getCause();\n     if (cause \u003d\u003d null) {\n       // SE generated by the RPC layer itself.\n       throw new IOException(se);\n     } else {\n       if (cause instanceof RemoteException) {\n         RemoteException re \u003d (RemoteException) cause;\n         Class\u003c?\u003e realClass \u003d null;\n         try {\n           realClass \u003d Class.forName(re.getClassName());\n         } catch (ClassNotFoundException cnf) {\n           // Assume this to be a new exception type added to YARN. This isn\u0027t\n           // absolutely correct since the RPC layer could add an exception as\n           // well.\n-          throw instantiateException(YarnRemoteException.class, re);\n+          throw instantiateException(YarnException.class, re);\n         }\n \n-        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n+        if (YarnException.class.isAssignableFrom(realClass)) {\n           throw instantiateException(\n-              realClass.asSubclass(YarnRemoteException.class), re);\n+              realClass.asSubclass(YarnException.class), re);\n         } else if (IOException.class.isAssignableFrom(realClass)) {\n           throw instantiateException(realClass.asSubclass(IOException.class),\n               re);\n         } else {\n           throw re;\n         }\n         // RemoteException contains useful information as against the\n         // java.lang.reflect exceptions.\n \n       } else if (cause instanceof IOException) {\n         // RPC Client exception.\n         throw (IOException) cause;\n       } else {\n         // Should not be generated.\n         throw new IOException(se);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static Void unwrapAndThrowException(ServiceException se)\n      throws IOException, YarnException {\n    Throwable cause \u003d se.getCause();\n    if (cause \u003d\u003d null) {\n      // SE generated by the RPC layer itself.\n      throw new IOException(se);\n    } else {\n      if (cause instanceof RemoteException) {\n        RemoteException re \u003d (RemoteException) cause;\n        Class\u003c?\u003e realClass \u003d null;\n        try {\n          realClass \u003d Class.forName(re.getClassName());\n        } catch (ClassNotFoundException cnf) {\n          // Assume this to be a new exception type added to YARN. This isn\u0027t\n          // absolutely correct since the RPC layer could add an exception as\n          // well.\n          throw instantiateException(YarnException.class, re);\n        }\n\n        if (YarnException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(\n              realClass.asSubclass(YarnException.class), re);\n        } else if (IOException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(realClass.asSubclass(IOException.class),\n              re);\n        } else {\n          throw re;\n        }\n        // RemoteException contains useful information as against the\n        // java.lang.reflect exceptions.\n\n      } else if (cause instanceof IOException) {\n        // RPC Client exception.\n        throw (IOException) cause;\n      } else {\n        // Should not be generated.\n        throw new IOException(se);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "065747efabd1cbea9b14e93e905e304b9973d355": {
      "type": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-628. Fix the way YarnRemoteException is being unrolled to extract out the underlying exception. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483207 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/05/13 11:58 PM",
      "commitName": "065747efabd1cbea9b14e93e905e304b9973d355",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-628. Fix the way YarnRemoteException is being unrolled to extract out the underlying exception. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483207 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/05/13 11:58 PM",
          "commitName": "065747efabd1cbea9b14e93e905e304b9973d355",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "10/05/13 2:49 PM",
          "commitNameOld": "2638bc67a48f923404d57ed2026c4997df6bd06e",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 5.38,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,40 @@\n-  public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n-      throws UndeclaredThrowableException {\n-    if (se.getCause() instanceof RemoteException) {\n-      try {\n-        RemoteException re \u003d (RemoteException) se.getCause();\n-        Class\u003c?\u003e realClass \u003d Class.forName(re.getClassName());\n-        //YarnRemoteException is not rooted as IOException.\n-        //Do the explicitly check if it is YarnRemoteException\n-        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n-          Constructor\u003c? extends YarnRemoteException\u003e cn \u003d\n-              realClass.asSubclass(YarnRemoteException.class).getConstructor(\n-                  String.class);\n-          cn.setAccessible(true);\n-          YarnRemoteException ex \u003d cn.newInstance(re.getMessage());\n-          ex.initCause(re);\n-          return ex;\n-        } else {\n-          // TODO Fix in YARN-628.\n-          throw new IOException((RemoteException) se.getCause());\n-        }\n-      } catch (IOException e1) {\n-        throw new UndeclaredThrowableException(e1);\n-      } catch (Exception ex) {\n-        throw new UndeclaredThrowableException(\n-            (RemoteException) se.getCause());\n-      }\n-    } else if (se.getCause() instanceof YarnRemoteException) {\n-      return (YarnRemoteException) se.getCause();\n-    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n-      throw (UndeclaredThrowableException) se.getCause();\n+  public static Void unwrapAndThrowException(ServiceException se)\n+      throws IOException, YarnRemoteException {\n+    Throwable cause \u003d se.getCause();\n+    if (cause \u003d\u003d null) {\n+      // SE generated by the RPC layer itself.\n+      throw new IOException(se);\n     } else {\n-      throw new UndeclaredThrowableException(se);\n+      if (cause instanceof RemoteException) {\n+        RemoteException re \u003d (RemoteException) cause;\n+        Class\u003c?\u003e realClass \u003d null;\n+        try {\n+          realClass \u003d Class.forName(re.getClassName());\n+        } catch (ClassNotFoundException cnf) {\n+          // Assume this to be a new exception type added to YARN. This isn\u0027t\n+          // absolutely correct since the RPC layer could add an exception as\n+          // well.\n+          throw instantiateException(YarnRemoteException.class, re);\n+        }\n+\n+        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n+          throw instantiateException(\n+              realClass.asSubclass(YarnRemoteException.class), re);\n+        } else if (IOException.class.isAssignableFrom(realClass)) {\n+          throw instantiateException(realClass.asSubclass(IOException.class),\n+              re);\n+        } else {\n+          throw re;\n+        }\n+        // RemoteException contains useful information as against the\n+        // java.lang.reflect exceptions.\n+\n+      } else if (cause instanceof IOException) {\n+        // RPC Client exception.\n+        throw (IOException) cause;\n+      } else {\n+        // Should not be generated.\n+        throw new IOException(se);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static Void unwrapAndThrowException(ServiceException se)\n      throws IOException, YarnRemoteException {\n    Throwable cause \u003d se.getCause();\n    if (cause \u003d\u003d null) {\n      // SE generated by the RPC layer itself.\n      throw new IOException(se);\n    } else {\n      if (cause instanceof RemoteException) {\n        RemoteException re \u003d (RemoteException) cause;\n        Class\u003c?\u003e realClass \u003d null;\n        try {\n          realClass \u003d Class.forName(re.getClassName());\n        } catch (ClassNotFoundException cnf) {\n          // Assume this to be a new exception type added to YARN. This isn\u0027t\n          // absolutely correct since the RPC layer could add an exception as\n          // well.\n          throw instantiateException(YarnRemoteException.class, re);\n        }\n\n        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(\n              realClass.asSubclass(YarnRemoteException.class), re);\n        } else if (IOException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(realClass.asSubclass(IOException.class),\n              re);\n        } else {\n          throw re;\n        }\n        // RemoteException contains useful information as against the\n        // java.lang.reflect exceptions.\n\n      } else if (cause instanceof IOException) {\n        // RPC Client exception.\n        throw (IOException) cause;\n      } else {\n        // Should not be generated.\n        throw new IOException(se);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
          "extendedDetails": {
            "oldValue": "YarnRemoteException",
            "newValue": "Void"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-628. Fix the way YarnRemoteException is being unrolled to extract out the underlying exception. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483207 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/05/13 11:58 PM",
          "commitName": "065747efabd1cbea9b14e93e905e304b9973d355",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "10/05/13 2:49 PM",
          "commitNameOld": "2638bc67a48f923404d57ed2026c4997df6bd06e",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 5.38,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,40 @@\n-  public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n-      throws UndeclaredThrowableException {\n-    if (se.getCause() instanceof RemoteException) {\n-      try {\n-        RemoteException re \u003d (RemoteException) se.getCause();\n-        Class\u003c?\u003e realClass \u003d Class.forName(re.getClassName());\n-        //YarnRemoteException is not rooted as IOException.\n-        //Do the explicitly check if it is YarnRemoteException\n-        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n-          Constructor\u003c? extends YarnRemoteException\u003e cn \u003d\n-              realClass.asSubclass(YarnRemoteException.class).getConstructor(\n-                  String.class);\n-          cn.setAccessible(true);\n-          YarnRemoteException ex \u003d cn.newInstance(re.getMessage());\n-          ex.initCause(re);\n-          return ex;\n-        } else {\n-          // TODO Fix in YARN-628.\n-          throw new IOException((RemoteException) se.getCause());\n-        }\n-      } catch (IOException e1) {\n-        throw new UndeclaredThrowableException(e1);\n-      } catch (Exception ex) {\n-        throw new UndeclaredThrowableException(\n-            (RemoteException) se.getCause());\n-      }\n-    } else if (se.getCause() instanceof YarnRemoteException) {\n-      return (YarnRemoteException) se.getCause();\n-    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n-      throw (UndeclaredThrowableException) se.getCause();\n+  public static Void unwrapAndThrowException(ServiceException se)\n+      throws IOException, YarnRemoteException {\n+    Throwable cause \u003d se.getCause();\n+    if (cause \u003d\u003d null) {\n+      // SE generated by the RPC layer itself.\n+      throw new IOException(se);\n     } else {\n-      throw new UndeclaredThrowableException(se);\n+      if (cause instanceof RemoteException) {\n+        RemoteException re \u003d (RemoteException) cause;\n+        Class\u003c?\u003e realClass \u003d null;\n+        try {\n+          realClass \u003d Class.forName(re.getClassName());\n+        } catch (ClassNotFoundException cnf) {\n+          // Assume this to be a new exception type added to YARN. This isn\u0027t\n+          // absolutely correct since the RPC layer could add an exception as\n+          // well.\n+          throw instantiateException(YarnRemoteException.class, re);\n+        }\n+\n+        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n+          throw instantiateException(\n+              realClass.asSubclass(YarnRemoteException.class), re);\n+        } else if (IOException.class.isAssignableFrom(realClass)) {\n+          throw instantiateException(realClass.asSubclass(IOException.class),\n+              re);\n+        } else {\n+          throw re;\n+        }\n+        // RemoteException contains useful information as against the\n+        // java.lang.reflect exceptions.\n+\n+      } else if (cause instanceof IOException) {\n+        // RPC Client exception.\n+        throw (IOException) cause;\n+      } else {\n+        // Should not be generated.\n+        throw new IOException(se);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static Void unwrapAndThrowException(ServiceException se)\n      throws IOException, YarnRemoteException {\n    Throwable cause \u003d se.getCause();\n    if (cause \u003d\u003d null) {\n      // SE generated by the RPC layer itself.\n      throw new IOException(se);\n    } else {\n      if (cause instanceof RemoteException) {\n        RemoteException re \u003d (RemoteException) cause;\n        Class\u003c?\u003e realClass \u003d null;\n        try {\n          realClass \u003d Class.forName(re.getClassName());\n        } catch (ClassNotFoundException cnf) {\n          // Assume this to be a new exception type added to YARN. This isn\u0027t\n          // absolutely correct since the RPC layer could add an exception as\n          // well.\n          throw instantiateException(YarnRemoteException.class, re);\n        }\n\n        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(\n              realClass.asSubclass(YarnRemoteException.class), re);\n        } else if (IOException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(realClass.asSubclass(IOException.class),\n              re);\n        } else {\n          throw re;\n        }\n        // RemoteException contains useful information as against the\n        // java.lang.reflect exceptions.\n\n      } else if (cause instanceof IOException) {\n        // RPC Client exception.\n        throw (IOException) cause;\n      } else {\n        // Should not be generated.\n        throw new IOException(se);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
          "extendedDetails": {
            "oldValue": "[UndeclaredThrowableException]",
            "newValue": "[IOException, YarnRemoteException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-628. Fix the way YarnRemoteException is being unrolled to extract out the underlying exception. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483207 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/05/13 11:58 PM",
          "commitName": "065747efabd1cbea9b14e93e905e304b9973d355",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "10/05/13 2:49 PM",
          "commitNameOld": "2638bc67a48f923404d57ed2026c4997df6bd06e",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 5.38,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,40 @@\n-  public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n-      throws UndeclaredThrowableException {\n-    if (se.getCause() instanceof RemoteException) {\n-      try {\n-        RemoteException re \u003d (RemoteException) se.getCause();\n-        Class\u003c?\u003e realClass \u003d Class.forName(re.getClassName());\n-        //YarnRemoteException is not rooted as IOException.\n-        //Do the explicitly check if it is YarnRemoteException\n-        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n-          Constructor\u003c? extends YarnRemoteException\u003e cn \u003d\n-              realClass.asSubclass(YarnRemoteException.class).getConstructor(\n-                  String.class);\n-          cn.setAccessible(true);\n-          YarnRemoteException ex \u003d cn.newInstance(re.getMessage());\n-          ex.initCause(re);\n-          return ex;\n-        } else {\n-          // TODO Fix in YARN-628.\n-          throw new IOException((RemoteException) se.getCause());\n-        }\n-      } catch (IOException e1) {\n-        throw new UndeclaredThrowableException(e1);\n-      } catch (Exception ex) {\n-        throw new UndeclaredThrowableException(\n-            (RemoteException) se.getCause());\n-      }\n-    } else if (se.getCause() instanceof YarnRemoteException) {\n-      return (YarnRemoteException) se.getCause();\n-    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n-      throw (UndeclaredThrowableException) se.getCause();\n+  public static Void unwrapAndThrowException(ServiceException se)\n+      throws IOException, YarnRemoteException {\n+    Throwable cause \u003d se.getCause();\n+    if (cause \u003d\u003d null) {\n+      // SE generated by the RPC layer itself.\n+      throw new IOException(se);\n     } else {\n-      throw new UndeclaredThrowableException(se);\n+      if (cause instanceof RemoteException) {\n+        RemoteException re \u003d (RemoteException) cause;\n+        Class\u003c?\u003e realClass \u003d null;\n+        try {\n+          realClass \u003d Class.forName(re.getClassName());\n+        } catch (ClassNotFoundException cnf) {\n+          // Assume this to be a new exception type added to YARN. This isn\u0027t\n+          // absolutely correct since the RPC layer could add an exception as\n+          // well.\n+          throw instantiateException(YarnRemoteException.class, re);\n+        }\n+\n+        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n+          throw instantiateException(\n+              realClass.asSubclass(YarnRemoteException.class), re);\n+        } else if (IOException.class.isAssignableFrom(realClass)) {\n+          throw instantiateException(realClass.asSubclass(IOException.class),\n+              re);\n+        } else {\n+          throw re;\n+        }\n+        // RemoteException contains useful information as against the\n+        // java.lang.reflect exceptions.\n+\n+      } else if (cause instanceof IOException) {\n+        // RPC Client exception.\n+        throw (IOException) cause;\n+      } else {\n+        // Should not be generated.\n+        throw new IOException(se);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static Void unwrapAndThrowException(ServiceException se)\n      throws IOException, YarnRemoteException {\n    Throwable cause \u003d se.getCause();\n    if (cause \u003d\u003d null) {\n      // SE generated by the RPC layer itself.\n      throw new IOException(se);\n    } else {\n      if (cause instanceof RemoteException) {\n        RemoteException re \u003d (RemoteException) cause;\n        Class\u003c?\u003e realClass \u003d null;\n        try {\n          realClass \u003d Class.forName(re.getClassName());\n        } catch (ClassNotFoundException cnf) {\n          // Assume this to be a new exception type added to YARN. This isn\u0027t\n          // absolutely correct since the RPC layer could add an exception as\n          // well.\n          throw instantiateException(YarnRemoteException.class, re);\n        }\n\n        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(\n              realClass.asSubclass(YarnRemoteException.class), re);\n        } else if (IOException.class.isAssignableFrom(realClass)) {\n          throw instantiateException(realClass.asSubclass(IOException.class),\n              re);\n        } else {\n          throw re;\n        }\n        // RemoteException contains useful information as against the\n        // java.lang.reflect exceptions.\n\n      } else if (cause instanceof IOException) {\n        // RPC Client exception.\n        throw (IOException) cause;\n      } else {\n        // Should not be generated.\n        throw new IOException(se);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "2638bc67a48f923404d57ed2026c4997df6bd06e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-634. Modified YarnRemoteException to be not backed by PB and introduced a separate SerializedException record. Contributed by Siddharth Seth.\nMAPREDUCE-5239. Updated MR App to reflect YarnRemoteException changes after YARN-634. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481205 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/13 2:49 PM",
      "commitName": "2638bc67a48f923404d57ed2026c4997df6bd06e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 12:04 PM",
      "commitNameOld": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n       throws UndeclaredThrowableException {\n     if (se.getCause() instanceof RemoteException) {\n       try {\n         RemoteException re \u003d (RemoteException) se.getCause();\n         Class\u003c?\u003e realClass \u003d Class.forName(re.getClassName());\n         //YarnRemoteException is not rooted as IOException.\n         //Do the explicitly check if it is YarnRemoteException\n         if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n           Constructor\u003c? extends YarnRemoteException\u003e cn \u003d\n               realClass.asSubclass(YarnRemoteException.class).getConstructor(\n                   String.class);\n           cn.setAccessible(true);\n           YarnRemoteException ex \u003d cn.newInstance(re.getMessage());\n           ex.initCause(re);\n           return ex;\n         } else {\n-          throw ((RemoteException) se.getCause())\n-              .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n+          // TODO Fix in YARN-628.\n+          throw new IOException((RemoteException) se.getCause());\n         }\n       } catch (IOException e1) {\n         throw new UndeclaredThrowableException(e1);\n       } catch (Exception ex) {\n         throw new UndeclaredThrowableException(\n             (RemoteException) se.getCause());\n       }\n     } else if (se.getCause() instanceof YarnRemoteException) {\n       return (YarnRemoteException) se.getCause();\n     } else if (se.getCause() instanceof UndeclaredThrowableException) {\n       throw (UndeclaredThrowableException) se.getCause();\n     } else {\n       throw new UndeclaredThrowableException(se);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n      throws UndeclaredThrowableException {\n    if (se.getCause() instanceof RemoteException) {\n      try {\n        RemoteException re \u003d (RemoteException) se.getCause();\n        Class\u003c?\u003e realClass \u003d Class.forName(re.getClassName());\n        //YarnRemoteException is not rooted as IOException.\n        //Do the explicitly check if it is YarnRemoteException\n        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n          Constructor\u003c? extends YarnRemoteException\u003e cn \u003d\n              realClass.asSubclass(YarnRemoteException.class).getConstructor(\n                  String.class);\n          cn.setAccessible(true);\n          YarnRemoteException ex \u003d cn.newInstance(re.getMessage());\n          ex.initCause(re);\n          return ex;\n        } else {\n          // TODO Fix in YARN-628.\n          throw new IOException((RemoteException) se.getCause());\n        }\n      } catch (IOException e1) {\n        throw new UndeclaredThrowableException(e1);\n      } catch (Exception ex) {\n        throw new UndeclaredThrowableException(\n            (RemoteException) se.getCause());\n      }\n    } else if (se.getCause() instanceof YarnRemoteException) {\n      return (YarnRemoteException) se.getCause();\n    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n      throw (UndeclaredThrowableException) se.getCause();\n    } else {\n      throw new UndeclaredThrowableException(se);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
      "extendedDetails": {}
    },
    "92b7165a71656468f17ce8b760ce11e648932f0e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-629. Make YarnRemoteException not be rooted at IOException. Contributed by Xuan Gong.\nMAPREDUCE-5204. Handling YarnRemoteException separately from IOException in MR app after YARN-629. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479680 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/05/13 12:04 PM",
      "commitName": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/05/13 3:44 PM",
      "commitNameOld": "fc275fed66469daf07a62db174b1df0916c72143",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.85,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,34 @@\n   public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n       throws UndeclaredThrowableException {\n     if (se.getCause() instanceof RemoteException) {\n       try {\n-        throw ((RemoteException) se.getCause())\n-            .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n-      } catch (YarnRemoteException ex) {\n-        return ex;\n+        RemoteException re \u003d (RemoteException) se.getCause();\n+        Class\u003c?\u003e realClass \u003d Class.forName(re.getClassName());\n+        //YarnRemoteException is not rooted as IOException.\n+        //Do the explicitly check if it is YarnRemoteException\n+        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n+          Constructor\u003c? extends YarnRemoteException\u003e cn \u003d\n+              realClass.asSubclass(YarnRemoteException.class).getConstructor(\n+                  String.class);\n+          cn.setAccessible(true);\n+          YarnRemoteException ex \u003d cn.newInstance(re.getMessage());\n+          ex.initCause(re);\n+          return ex;\n+        } else {\n+          throw ((RemoteException) se.getCause())\n+              .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n+        }\n       } catch (IOException e1) {\n         throw new UndeclaredThrowableException(e1);\n+      } catch (Exception ex) {\n+        throw new UndeclaredThrowableException(\n+            (RemoteException) se.getCause());\n       }\n     } else if (se.getCause() instanceof YarnRemoteException) {\n       return (YarnRemoteException) se.getCause();\n     } else if (se.getCause() instanceof UndeclaredThrowableException) {\n       throw (UndeclaredThrowableException) se.getCause();\n     } else {\n       throw new UndeclaredThrowableException(se);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n      throws UndeclaredThrowableException {\n    if (se.getCause() instanceof RemoteException) {\n      try {\n        RemoteException re \u003d (RemoteException) se.getCause();\n        Class\u003c?\u003e realClass \u003d Class.forName(re.getClassName());\n        //YarnRemoteException is not rooted as IOException.\n        //Do the explicitly check if it is YarnRemoteException\n        if (YarnRemoteException.class.isAssignableFrom(realClass)) {\n          Constructor\u003c? extends YarnRemoteException\u003e cn \u003d\n              realClass.asSubclass(YarnRemoteException.class).getConstructor(\n                  String.class);\n          cn.setAccessible(true);\n          YarnRemoteException ex \u003d cn.newInstance(re.getMessage());\n          ex.initCause(re);\n          return ex;\n        } else {\n          throw ((RemoteException) se.getCause())\n              .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n        }\n      } catch (IOException e1) {\n        throw new UndeclaredThrowableException(e1);\n      } catch (Exception ex) {\n        throw new UndeclaredThrowableException(\n            (RemoteException) se.getCause());\n      }\n    } else if (se.getCause() instanceof YarnRemoteException) {\n      return (YarnRemoteException) se.getCause();\n    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n      throw (UndeclaredThrowableException) se.getCause();\n    } else {\n      throw new UndeclaredThrowableException(se);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
      "extendedDetails": {}
    },
    "fc275fed66469daf07a62db174b1df0916c72143": {
      "type": "Ymovefromfile",
      "commitMessage": "YARN-625. Move the utility method unwrapAndThrowException from YarnRemoteExceptionPBImpl to RPCUtil. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1478594 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/13 3:44 PM",
      "commitName": "fc275fed66469daf07a62db174b1df0916c72143",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/05/13 3:39 PM",
      "commitNameOld": "afa786098a440c5eb4c106f0e5475b083b85106c",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n-  public static YarnRemoteException unwrapAndThrowException(ServiceException se) \n-     throws UndeclaredThrowableException {\n+  public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n+      throws UndeclaredThrowableException {\n     if (se.getCause() instanceof RemoteException) {\n       try {\n         throw ((RemoteException) se.getCause())\n             .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n       } catch (YarnRemoteException ex) {\n         return ex;\n       } catch (IOException e1) {\n         throw new UndeclaredThrowableException(e1);\n       }\n     } else if (se.getCause() instanceof YarnRemoteException) {\n-      return (YarnRemoteException)se.getCause();\n+      return (YarnRemoteException) se.getCause();\n     } else if (se.getCause() instanceof UndeclaredThrowableException) {\n-      throw (UndeclaredThrowableException)se.getCause();\n+      throw (UndeclaredThrowableException) se.getCause();\n     } else {\n       throw new UndeclaredThrowableException(se);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static YarnRemoteException unwrapAndThrowException(ServiceException se)\n      throws UndeclaredThrowableException {\n    if (se.getCause() instanceof RemoteException) {\n      try {\n        throw ((RemoteException) se.getCause())\n            .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n      } catch (YarnRemoteException ex) {\n        return ex;\n      } catch (IOException e1) {\n        throw new UndeclaredThrowableException(e1);\n      }\n    } else if (se.getCause() instanceof YarnRemoteException) {\n      return (YarnRemoteException) se.getCause();\n    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n      throw (UndeclaredThrowableException) se.getCause();\n    } else {\n      throw new UndeclaredThrowableException(se);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/exceptions/impl/pb/YarnRemoteExceptionPBImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/ipc/RPCUtil.java",
        "oldMethodName": "unwrapAndThrowException",
        "newMethodName": "unwrapAndThrowException"
      }
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static YarnRemoteException unwrapAndThrowException(ServiceException se) \n     throws UndeclaredThrowableException {\n    if (se.getCause() instanceof RemoteException) {\n      try {\n        throw ((RemoteException) se.getCause())\n            .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n      } catch (YarnRemoteException ex) {\n        return ex;\n      } catch (IOException e1) {\n        throw new UndeclaredThrowableException(e1);\n      }\n    } else if (se.getCause() instanceof YarnRemoteException) {\n      return (YarnRemoteException)se.getCause();\n    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n      throw (UndeclaredThrowableException)se.getCause();\n    } else {\n      throw new UndeclaredThrowableException(se);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/exceptions/impl/pb/YarnRemoteExceptionPBImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/exceptions/impl/pb/YarnRemoteExceptionPBImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/exceptions/impl/pb/YarnRemoteExceptionPBImpl.java"
      }
    },
    "db3e592df0cd022d15a6acdeac3517c54d510ad2": {
      "type": "Yintroduced",
      "commitMessage": "REDUCE-3955. Change MR to use ProtobufRpcEngine from hadoop-common instead of ProtoOverHadoopRpcEngine. (Contributed by Jitendra Nath Pandey)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1306689 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/03/12 7:02 PM",
      "commitName": "db3e592df0cd022d15a6acdeac3517c54d510ad2",
      "commitAuthor": "Siddharth Seth",
      "diff": "@@ -0,0 +1,19 @@\n+  public static YarnRemoteException unwrapAndThrowException(ServiceException se) \n+     throws UndeclaredThrowableException {\n+    if (se.getCause() instanceof RemoteException) {\n+      try {\n+        throw ((RemoteException) se.getCause())\n+            .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n+      } catch (YarnRemoteException ex) {\n+        return ex;\n+      } catch (IOException e1) {\n+        throw new UndeclaredThrowableException(e1);\n+      }\n+    } else if (se.getCause() instanceof YarnRemoteException) {\n+      return (YarnRemoteException)se.getCause();\n+    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n+      throw (UndeclaredThrowableException)se.getCause();\n+    } else {\n+      throw new UndeclaredThrowableException(se);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static YarnRemoteException unwrapAndThrowException(ServiceException se) \n     throws UndeclaredThrowableException {\n    if (se.getCause() instanceof RemoteException) {\n      try {\n        throw ((RemoteException) se.getCause())\n            .unwrapRemoteException(YarnRemoteExceptionPBImpl.class);\n      } catch (YarnRemoteException ex) {\n        return ex;\n      } catch (IOException e1) {\n        throw new UndeclaredThrowableException(e1);\n      }\n    } else if (se.getCause() instanceof YarnRemoteException) {\n      return (YarnRemoteException)se.getCause();\n    } else if (se.getCause() instanceof UndeclaredThrowableException) {\n      throw (UndeclaredThrowableException)se.getCause();\n    } else {\n      throw new UndeclaredThrowableException(se);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/exceptions/impl/pb/YarnRemoteExceptionPBImpl.java"
    }
  }
}