{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineReaderUtils.java",
  "functionName": "split",
  "functionId": "split___str-String(modifiers-final)__delimiterChar-char(modifiers-final)__escapeChar-char(modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineReaderUtils.java",
  "functionStartLine": 65,
  "functionEndLine": 127,
  "numCommitsSeen": 5,
  "timeTaken": 953,
  "changeHistory": [
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
    "9d40d9d34ce3b88e868ae91fcc09377107c094c7"
  ],
  "changeHistoryShort": {
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3": "Ybodychange",
    "9d40d9d34ce3b88e868ae91fcc09377107c094c7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4446. Refactor reader API for better extensibility (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9d40d9d34ce3b88e868ae91fcc09377107c094c7",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   static List\u003cString\u003e split(final String str, final char delimiterChar,\n       final char escapeChar) throws IllegalArgumentException {\n     if (str \u003d\u003d null) {\n       return null;\n     }\n     int len \u003d str.length();\n     if (len \u003d\u003d 0) {\n       return Collections.emptyList();\n     }\n     List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n     // Keeps track of offset of the passed string.\n     int offset \u003d 0;\n     // Indicates start offset from which characters will be copied from original\n     // string to destination string. Resets when an escape or delimiter char is\n     // encountered.\n     int startOffset \u003d 0;\n     StringBuilder builder \u003d new StringBuilder(len);\n     // Iterate over the string till we reach the end.\n     while (offset \u003c len) {\n       if (str.charAt(offset) \u003d\u003d escapeChar) {\n         // An escape character must be followed by a delimiter or escape char\n         // but we have reached the end and have no further character to look at.\n         if (offset + 1 \u003e\u003d len) {\n           throw new IllegalArgumentException(\n               \"Escape char not properly escaped.\");\n         }\n         char nextChar \u003d str.charAt(offset + 1);\n         // Next character must be a delimiter or an escape char.\n         if (nextChar !\u003d escapeChar \u0026\u0026 nextChar !\u003d delimiterChar) {\n           throw new IllegalArgumentException(\n               \"Escape char or delimiter char not properly escaped.\");\n         }\n         // Copy contents from the offset where last escape or delimiter char was\n         // encountered.\n         if (startOffset \u003c offset) {\n           builder.append(str.substring(startOffset, offset));\n         }\n         builder.append(nextChar);\n         offset +\u003d 2;\n         // Reset the start offset as an escape char has been encountered.\n         startOffset \u003d offset;\n         continue;\n       } else if (str.charAt(offset) \u003d\u003d delimiterChar) {\n         // A delimiter has been encountered without an escape character.\n         // String needs to be split here. Copy remaining chars and add the\n         // string to list.\n         builder.append(str.substring(startOffset, offset));\n-        list.add(builder.toString());\n+        list.add(builder.toString().trim());\n         // Reset the start offset as a delimiter has been encountered.\n         startOffset \u003d ++offset;\n         builder \u003d new StringBuilder(len - offset);\n         continue;\n       }\n       offset++;\n     }\n     // Copy rest of the characters.\n     if (!str.isEmpty()) {\n       builder.append(str.substring(startOffset));\n     }\n     // Add the last part of delimited string to list.\n-    list.add(builder.toString());\n+    list.add(builder.toString().trim());\n     return list;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static List\u003cString\u003e split(final String str, final char delimiterChar,\n      final char escapeChar) throws IllegalArgumentException {\n    if (str \u003d\u003d null) {\n      return null;\n    }\n    int len \u003d str.length();\n    if (len \u003d\u003d 0) {\n      return Collections.emptyList();\n    }\n    List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n    // Keeps track of offset of the passed string.\n    int offset \u003d 0;\n    // Indicates start offset from which characters will be copied from original\n    // string to destination string. Resets when an escape or delimiter char is\n    // encountered.\n    int startOffset \u003d 0;\n    StringBuilder builder \u003d new StringBuilder(len);\n    // Iterate over the string till we reach the end.\n    while (offset \u003c len) {\n      if (str.charAt(offset) \u003d\u003d escapeChar) {\n        // An escape character must be followed by a delimiter or escape char\n        // but we have reached the end and have no further character to look at.\n        if (offset + 1 \u003e\u003d len) {\n          throw new IllegalArgumentException(\n              \"Escape char not properly escaped.\");\n        }\n        char nextChar \u003d str.charAt(offset + 1);\n        // Next character must be a delimiter or an escape char.\n        if (nextChar !\u003d escapeChar \u0026\u0026 nextChar !\u003d delimiterChar) {\n          throw new IllegalArgumentException(\n              \"Escape char or delimiter char not properly escaped.\");\n        }\n        // Copy contents from the offset where last escape or delimiter char was\n        // encountered.\n        if (startOffset \u003c offset) {\n          builder.append(str.substring(startOffset, offset));\n        }\n        builder.append(nextChar);\n        offset +\u003d 2;\n        // Reset the start offset as an escape char has been encountered.\n        startOffset \u003d offset;\n        continue;\n      } else if (str.charAt(offset) \u003d\u003d delimiterChar) {\n        // A delimiter has been encountered without an escape character.\n        // String needs to be split here. Copy remaining chars and add the\n        // string to list.\n        builder.append(str.substring(startOffset, offset));\n        list.add(builder.toString().trim());\n        // Reset the start offset as a delimiter has been encountered.\n        startOffset \u003d ++offset;\n        builder \u003d new StringBuilder(len - offset);\n        continue;\n      }\n      offset++;\n    }\n    // Copy rest of the characters.\n    if (!str.isEmpty()) {\n      builder.append(str.substring(startOffset));\n    }\n    // Add the last part of delimited string to list.\n    list.add(builder.toString().trim());\n    return list;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineReaderUtils.java",
      "extendedDetails": {}
    },
    "9d40d9d34ce3b88e868ae91fcc09377107c094c7": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4224. Support fetching entities by UID and change the REST\ninterface to conform to current REST APIs\u0027 in YARN. (Varun Saxena via\ngtcarrera9)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9d40d9d34ce3b88e868ae91fcc09377107c094c7",
      "commitAuthor": "Li Lu",
      "diff": "@@ -0,0 +1,63 @@\n+  static List\u003cString\u003e split(final String str, final char delimiterChar,\n+      final char escapeChar) throws IllegalArgumentException {\n+    if (str \u003d\u003d null) {\n+      return null;\n+    }\n+    int len \u003d str.length();\n+    if (len \u003d\u003d 0) {\n+      return Collections.emptyList();\n+    }\n+    List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n+    // Keeps track of offset of the passed string.\n+    int offset \u003d 0;\n+    // Indicates start offset from which characters will be copied from original\n+    // string to destination string. Resets when an escape or delimiter char is\n+    // encountered.\n+    int startOffset \u003d 0;\n+    StringBuilder builder \u003d new StringBuilder(len);\n+    // Iterate over the string till we reach the end.\n+    while (offset \u003c len) {\n+      if (str.charAt(offset) \u003d\u003d escapeChar) {\n+        // An escape character must be followed by a delimiter or escape char\n+        // but we have reached the end and have no further character to look at.\n+        if (offset + 1 \u003e\u003d len) {\n+          throw new IllegalArgumentException(\n+              \"Escape char not properly escaped.\");\n+        }\n+        char nextChar \u003d str.charAt(offset + 1);\n+        // Next character must be a delimiter or an escape char.\n+        if (nextChar !\u003d escapeChar \u0026\u0026 nextChar !\u003d delimiterChar) {\n+          throw new IllegalArgumentException(\n+              \"Escape char or delimiter char not properly escaped.\");\n+        }\n+        // Copy contents from the offset where last escape or delimiter char was\n+        // encountered.\n+        if (startOffset \u003c offset) {\n+          builder.append(str.substring(startOffset, offset));\n+        }\n+        builder.append(nextChar);\n+        offset +\u003d 2;\n+        // Reset the start offset as an escape char has been encountered.\n+        startOffset \u003d offset;\n+        continue;\n+      } else if (str.charAt(offset) \u003d\u003d delimiterChar) {\n+        // A delimiter has been encountered without an escape character.\n+        // String needs to be split here. Copy remaining chars and add the\n+        // string to list.\n+        builder.append(str.substring(startOffset, offset));\n+        list.add(builder.toString());\n+        // Reset the start offset as a delimiter has been encountered.\n+        startOffset \u003d ++offset;\n+        builder \u003d new StringBuilder(len - offset);\n+        continue;\n+      }\n+      offset++;\n+    }\n+    // Copy rest of the characters.\n+    if (!str.isEmpty()) {\n+      builder.append(str.substring(startOffset));\n+    }\n+    // Add the last part of delimited string to list.\n+    list.add(builder.toString());\n+    return list;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static List\u003cString\u003e split(final String str, final char delimiterChar,\n      final char escapeChar) throws IllegalArgumentException {\n    if (str \u003d\u003d null) {\n      return null;\n    }\n    int len \u003d str.length();\n    if (len \u003d\u003d 0) {\n      return Collections.emptyList();\n    }\n    List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n    // Keeps track of offset of the passed string.\n    int offset \u003d 0;\n    // Indicates start offset from which characters will be copied from original\n    // string to destination string. Resets when an escape or delimiter char is\n    // encountered.\n    int startOffset \u003d 0;\n    StringBuilder builder \u003d new StringBuilder(len);\n    // Iterate over the string till we reach the end.\n    while (offset \u003c len) {\n      if (str.charAt(offset) \u003d\u003d escapeChar) {\n        // An escape character must be followed by a delimiter or escape char\n        // but we have reached the end and have no further character to look at.\n        if (offset + 1 \u003e\u003d len) {\n          throw new IllegalArgumentException(\n              \"Escape char not properly escaped.\");\n        }\n        char nextChar \u003d str.charAt(offset + 1);\n        // Next character must be a delimiter or an escape char.\n        if (nextChar !\u003d escapeChar \u0026\u0026 nextChar !\u003d delimiterChar) {\n          throw new IllegalArgumentException(\n              \"Escape char or delimiter char not properly escaped.\");\n        }\n        // Copy contents from the offset where last escape or delimiter char was\n        // encountered.\n        if (startOffset \u003c offset) {\n          builder.append(str.substring(startOffset, offset));\n        }\n        builder.append(nextChar);\n        offset +\u003d 2;\n        // Reset the start offset as an escape char has been encountered.\n        startOffset \u003d offset;\n        continue;\n      } else if (str.charAt(offset) \u003d\u003d delimiterChar) {\n        // A delimiter has been encountered without an escape character.\n        // String needs to be split here. Copy remaining chars and add the\n        // string to list.\n        builder.append(str.substring(startOffset, offset));\n        list.add(builder.toString());\n        // Reset the start offset as a delimiter has been encountered.\n        startOffset \u003d ++offset;\n        builder \u003d new StringBuilder(len - offset);\n        continue;\n      }\n      offset++;\n    }\n    // Copy rest of the characters.\n    if (!str.isEmpty()) {\n      builder.append(str.substring(startOffset));\n    }\n    // Add the last part of delimited string to list.\n    list.add(builder.toString());\n    return list;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineReaderUtils.java"
    }
  }
}