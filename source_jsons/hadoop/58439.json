{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileSystemNodeLabelsStore.java",
  "functionName": "recover",
  "functionId": "recover",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
  "functionStartLine": 105,
  "functionEndLine": 107,
  "numCommitsSeen": 26,
  "timeTaken": 3710,
  "changeHistory": [
    "6f4bc49c6d153e03edcc9b3a796fb1ccc95334b0",
    "5af572b6443715b7a741296c1bd520a1840f9a7c",
    "755dda8dd8bb23864abc752bad506f223fcac010",
    "db1b674b50ddecf2774f4092d677c412722bdcb1",
    "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
    "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0",
    "e9c66e8fd2ccb658db2848e1ab911f1502de4de5",
    "db7f1653198b950e89567c06898d64f6b930a0ee"
  ],
  "changeHistoryShort": {
    "6f4bc49c6d153e03edcc9b3a796fb1ccc95334b0": "Ybodychange",
    "5af572b6443715b7a741296c1bd520a1840f9a7c": "Ybodychange",
    "755dda8dd8bb23864abc752bad506f223fcac010": "Ymultichange(Yparameterchange,Ybodychange)",
    "db1b674b50ddecf2774f4092d677c412722bdcb1": "Ymultichange(Yparameterchange,Ybodychange)",
    "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d": "Ybodychange",
    "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "e9c66e8fd2ccb658db2848e1ab911f1502de4de5": "Ybodychange",
    "db7f1653198b950e89567c06898d64f6b930a0ee": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6f4bc49c6d153e03edcc9b3a796fb1ccc95334b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7988. Refactor FSNodeLabelStore code for Node Attributes store support. Contributed by Bibin A Chundatt.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "6f4bc49c6d153e03edcc9b3a796fb1ccc95334b0",
      "commitAuthor": "Sunil G",
      "commitDateOld": "15/11/16 10:57 AM",
      "commitNameOld": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 665.65,
      "commitsBetweenForRepo": 4995,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,3 @@\n-  public void recover() throws YarnException,\n-      IOException {\n-    /*\n-     * Steps of recover\n-     * 1) Read from last mirror (from mirror or mirror.old)\n-     * 2) Read from last edit log, and apply such edit log\n-     * 3) Write new mirror to mirror.writing\n-     * 4) Rename mirror to mirror.old\n-     * 5) Move mirror.writing to mirror\n-     * 6) Remove mirror.old\n-     * 7) Remove edit log and create a new empty edit log \n-     */\n-    \n-    // Open mirror from serialized file\n-    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n-    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n-    \n-    loadFromMirror(mirrorPath, oldMirrorPath);\n-\n-    // Open and process editlog\n-    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n-    FSDataInputStream is;\n-    try {\n-      is \u003d fs.open(editLogPath);\n-    } catch (FileNotFoundException e) {\n-      is \u003d null;\n-    }\n-    if (null !\u003d is) {\n-\n-      while (true) {\n-        try {\n-          // read edit log one by one\n-          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n-          \n-          switch (type) {\n-          case ADD_LABELS: {\n-            List\u003cNodeLabel\u003e labels \u003d\n-                new AddToClusterNodeLabelsRequestPBImpl(\n-                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n-                    .getNodeLabels();\n-            mgr.addToCluserNodeLabels(labels);\n-            break;\n-          }\n-          case REMOVE_LABELS: {\n-            Collection\u003cString\u003e labels \u003d\n-                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n-                    .getNodeLabelsList();\n-            mgr.removeFromClusterNodeLabels(labels);\n-            break;\n-          }\n-          case NODE_TO_LABELS: {\n-            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n-                new ReplaceLabelsOnNodeRequestPBImpl(\n-                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n-                    .getNodeToLabels();\n-            if (mgr.isCentralizedConfiguration()) {\n-              /*\n-               * In case of Distributed NodeLabels setup,\n-               * ignoreNodeToLabelsMappings will be set to true and recover will\n-               * be invoked. As RM will collect the node labels from NM through\n-               * registration/HB\n-               */\n-              mgr.replaceLabelsOnNode(map);\n-            }\n-            break;\n-          }\n-          }\n-        } catch (EOFException e) {\n-          // EOF hit, break\n-          break;\n-        }\n-      }\n-      is.close();\n-    }\n-\n-    // Serialize current mirror to mirror.writing\n-    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n-    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n-    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n-        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n-    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n-        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n-    os.close();\n-    \n-    // Move mirror to mirror.old\n-    if (fs.exists(mirrorPath)) {\n-      fs.delete(oldMirrorPath, false);\n-      fs.rename(mirrorPath, oldMirrorPath);\n-    }\n-    \n-    // move mirror.writing to mirror\n-    fs.rename(writingMirrorPath, mirrorPath);\n-    fs.delete(writingMirrorPath, false);\n-    \n-    // remove mirror.old\n-    fs.delete(oldMirrorPath, false);\n-    \n-    // create a new editlog file\n-    editlogOs \u003d fs.create(editLogPath, true);\n-    editlogOs.close();\n-    \n-    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n-    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n+  public void recover() throws YarnException, IOException {\n+    super.recoverFromStore();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover() throws YarnException, IOException {\n    super.recoverFromStore();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
      "extendedDetails": {}
    },
    "5af572b6443715b7a741296c1bd520a1840f9a7c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13427. Eliminate needless uses of FileSystem#{exists(), isFile(), isDirectory()}. Contributed by Steve Loughran and Mingliang Liu\n",
      "commitDate": "15/11/16 10:57 AM",
      "commitName": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "18/10/16 11:06 AM",
      "commitNameOld": "b733a6f86262522e535cebc972baecbe6a6eab50",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 28.03,
      "commitsBetweenForRepo": 275,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,104 @@\n   public void recover() throws YarnException,\n       IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n     \n     loadFromMirror(mirrorPath, oldMirrorPath);\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n-    if (fs.exists(editLogPath)) {\n-      FSDataInputStream is \u003d fs.open(editLogPath);\n+    FSDataInputStream is;\n+    try {\n+      is \u003d fs.open(editLogPath);\n+    } catch (FileNotFoundException e) {\n+      is \u003d null;\n+    }\n+    if (null !\u003d is) {\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             List\u003cNodeLabel\u003e labels \u003d\n                 new AddToClusterNodeLabelsRequestPBImpl(\n                     AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                     .getNodeLabels();\n             mgr.addToCluserNodeLabels(labels);\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n             if (mgr.isCentralizedConfiguration()) {\n               /*\n                * In case of Distributed NodeLabels setup,\n                * ignoreNodeToLabelsMappings will be set to true and recover will\n                * be invoked. As RM will collect the node labels from NM through\n                * registration/HB\n                */\n               mgr.replaceLabelsOnNode(map);\n             }\n             break;\n           }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n+      is.close();\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover() throws YarnException,\n      IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n    \n    loadFromMirror(mirrorPath, oldMirrorPath);\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    FSDataInputStream is;\n    try {\n      is \u003d fs.open(editLogPath);\n    } catch (FileNotFoundException e) {\n      is \u003d null;\n    }\n    if (null !\u003d is) {\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            List\u003cNodeLabel\u003e labels \u003d\n                new AddToClusterNodeLabelsRequestPBImpl(\n                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.addToCluserNodeLabels(labels);\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            if (mgr.isCentralizedConfiguration()) {\n              /*\n               * In case of Distributed NodeLabels setup,\n               * ignoreNodeToLabelsMappings will be set to true and recover will\n               * be invoked. As RM will collect the node labels from NM through\n               * registration/HB\n               */\n              mgr.replaceLabelsOnNode(map);\n            }\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n      is.close();\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
      "extendedDetails": {}
    },
    "755dda8dd8bb23864abc752bad506f223fcac010": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4405. Support node label store in non-appendable file system. Contributed by Wangda Tan\n",
      "commitDate": "03/12/15 5:45 PM",
      "commitName": "755dda8dd8bb23864abc752bad506f223fcac010",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4405. Support node label store in non-appendable file system. Contributed by Wangda Tan\n",
          "commitDate": "03/12/15 5:45 PM",
          "commitName": "755dda8dd8bb23864abc752bad506f223fcac010",
          "commitAuthor": "Jian He",
          "commitDateOld": "24/11/15 3:47 PM",
          "commitNameOld": "f5acf94ecafb301a0cc8e8f91f19c8bcbc8da701",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 9.08,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,98 @@\n-  public void recover(boolean ignoreNodeToLabelsMappings) throws YarnException,\n+  public void recover() throws YarnException,\n       IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n-\n-    FSDataInputStream is \u003d null;\n-    if (fs.exists(mirrorPath)) {\n-      is \u003d fs.open(mirrorPath);\n-    } else if (fs.exists(oldMirrorPath)) {\n-      is \u003d fs.open(oldMirrorPath);\n-    }\n-\n-    if (null !\u003d is) {\n-      List\u003cNodeLabel\u003e labels \u003d\n-          new AddToClusterNodeLabelsRequestPBImpl(\n-              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n-      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n-          new ReplaceLabelsOnNodeRequestPBImpl(\n-              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n-              .getNodeToLabels();\n-      mgr.addToCluserNodeLabels(labels);\n-      mgr.replaceLabelsOnNode(nodeToLabels);\n-      is.close();\n-    }\n+    \n+    loadFromMirror(mirrorPath, oldMirrorPath);\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n-      is \u003d fs.open(editLogPath);\n+      FSDataInputStream is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             List\u003cNodeLabel\u003e labels \u003d\n                 new AddToClusterNodeLabelsRequestPBImpl(\n                     AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                     .getNodeLabels();\n             mgr.addToCluserNodeLabels(labels);\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n-            if (!ignoreNodeToLabelsMappings) {\n+            if (mgr.isCentralizedConfiguration()) {\n               /*\n                * In case of Distributed NodeLabels setup,\n                * ignoreNodeToLabelsMappings will be set to true and recover will\n                * be invoked. As RM will collect the node labels from NM through\n                * registration/HB\n                */\n               mgr.replaceLabelsOnNode(map);\n             }\n             break;\n           }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recover() throws YarnException,\n      IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n    \n    loadFromMirror(mirrorPath, oldMirrorPath);\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      FSDataInputStream is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            List\u003cNodeLabel\u003e labels \u003d\n                new AddToClusterNodeLabelsRequestPBImpl(\n                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.addToCluserNodeLabels(labels);\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            if (mgr.isCentralizedConfiguration()) {\n              /*\n               * In case of Distributed NodeLabels setup,\n               * ignoreNodeToLabelsMappings will be set to true and recover will\n               * be invoked. As RM will collect the node labels from NM through\n               * registration/HB\n               */\n              mgr.replaceLabelsOnNode(map);\n            }\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
          "extendedDetails": {
            "oldValue": "[ignoreNodeToLabelsMappings-boolean]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4405. Support node label store in non-appendable file system. Contributed by Wangda Tan\n",
          "commitDate": "03/12/15 5:45 PM",
          "commitName": "755dda8dd8bb23864abc752bad506f223fcac010",
          "commitAuthor": "Jian He",
          "commitDateOld": "24/11/15 3:47 PM",
          "commitNameOld": "f5acf94ecafb301a0cc8e8f91f19c8bcbc8da701",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 9.08,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,98 @@\n-  public void recover(boolean ignoreNodeToLabelsMappings) throws YarnException,\n+  public void recover() throws YarnException,\n       IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n-\n-    FSDataInputStream is \u003d null;\n-    if (fs.exists(mirrorPath)) {\n-      is \u003d fs.open(mirrorPath);\n-    } else if (fs.exists(oldMirrorPath)) {\n-      is \u003d fs.open(oldMirrorPath);\n-    }\n-\n-    if (null !\u003d is) {\n-      List\u003cNodeLabel\u003e labels \u003d\n-          new AddToClusterNodeLabelsRequestPBImpl(\n-              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n-      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n-          new ReplaceLabelsOnNodeRequestPBImpl(\n-              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n-              .getNodeToLabels();\n-      mgr.addToCluserNodeLabels(labels);\n-      mgr.replaceLabelsOnNode(nodeToLabels);\n-      is.close();\n-    }\n+    \n+    loadFromMirror(mirrorPath, oldMirrorPath);\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n-      is \u003d fs.open(editLogPath);\n+      FSDataInputStream is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             List\u003cNodeLabel\u003e labels \u003d\n                 new AddToClusterNodeLabelsRequestPBImpl(\n                     AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                     .getNodeLabels();\n             mgr.addToCluserNodeLabels(labels);\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n-            if (!ignoreNodeToLabelsMappings) {\n+            if (mgr.isCentralizedConfiguration()) {\n               /*\n                * In case of Distributed NodeLabels setup,\n                * ignoreNodeToLabelsMappings will be set to true and recover will\n                * be invoked. As RM will collect the node labels from NM through\n                * registration/HB\n                */\n               mgr.replaceLabelsOnNode(map);\n             }\n             break;\n           }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recover() throws YarnException,\n      IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n    \n    loadFromMirror(mirrorPath, oldMirrorPath);\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      FSDataInputStream is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            List\u003cNodeLabel\u003e labels \u003d\n                new AddToClusterNodeLabelsRequestPBImpl(\n                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.addToCluserNodeLabels(labels);\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            if (mgr.isCentralizedConfiguration()) {\n              /*\n               * In case of Distributed NodeLabels setup,\n               * ignoreNodeToLabelsMappings will be set to true and recover will\n               * be invoked. As RM will collect the node labels from NM through\n               * registration/HB\n               */\n              mgr.replaceLabelsOnNode(map);\n            }\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "db1b674b50ddecf2774f4092d677c412722bdcb1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2740. Fix NodeLabelsManager to properly handle node label modifications when distributed node label configuration enabled. (Naganarasimha G R via wangda)\n",
      "commitDate": "27/04/15 4:24 PM",
      "commitName": "db1b674b50ddecf2774f4092d677c412722bdcb1",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2740. Fix NodeLabelsManager to properly handle node label modifications when distributed node label configuration enabled. (Naganarasimha G R via wangda)\n",
          "commitDate": "27/04/15 4:24 PM",
          "commitName": "db1b674b50ddecf2774f4092d677c412722bdcb1",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "23/04/15 11:19 AM",
          "commitNameOld": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 4.21,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,107 +1,116 @@\n-  public void recover() throws YarnException, IOException {\n+  public void recover(boolean ignoreNodeToLabelsMappings) throws YarnException,\n+      IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n \n     FSDataInputStream is \u003d null;\n     if (fs.exists(mirrorPath)) {\n       is \u003d fs.open(mirrorPath);\n     } else if (fs.exists(oldMirrorPath)) {\n       is \u003d fs.open(oldMirrorPath);\n     }\n \n     if (null !\u003d is) {\n       List\u003cNodeLabel\u003e labels \u003d\n           new AddToClusterNodeLabelsRequestPBImpl(\n               AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n           new ReplaceLabelsOnNodeRequestPBImpl(\n               ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n               .getNodeToLabels();\n       mgr.addToCluserNodeLabels(labels);\n       mgr.replaceLabelsOnNode(nodeToLabels);\n       is.close();\n     }\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n       is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             List\u003cNodeLabel\u003e labels \u003d\n                 new AddToClusterNodeLabelsRequestPBImpl(\n                     AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                     .getNodeLabels();\n             mgr.addToCluserNodeLabels(labels);\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n-            mgr.replaceLabelsOnNode(map);\n+            if (!ignoreNodeToLabelsMappings) {\n+              /*\n+               * In case of Distributed NodeLabels setup,\n+               * ignoreNodeToLabelsMappings will be set to true and recover will\n+               * be invoked. As RM will collect the node labels from NM through\n+               * registration/HB\n+               */\n+              mgr.replaceLabelsOnNode(map);\n+            }\n             break;\n           }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recover(boolean ignoreNodeToLabelsMappings) throws YarnException,\n      IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n\n    FSDataInputStream is \u003d null;\n    if (fs.exists(mirrorPath)) {\n      is \u003d fs.open(mirrorPath);\n    } else if (fs.exists(oldMirrorPath)) {\n      is \u003d fs.open(oldMirrorPath);\n    }\n\n    if (null !\u003d is) {\n      List\u003cNodeLabel\u003e labels \u003d\n          new AddToClusterNodeLabelsRequestPBImpl(\n              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n          new ReplaceLabelsOnNodeRequestPBImpl(\n              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n              .getNodeToLabels();\n      mgr.addToCluserNodeLabels(labels);\n      mgr.replaceLabelsOnNode(nodeToLabels);\n      is.close();\n    }\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            List\u003cNodeLabel\u003e labels \u003d\n                new AddToClusterNodeLabelsRequestPBImpl(\n                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.addToCluserNodeLabels(labels);\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            if (!ignoreNodeToLabelsMappings) {\n              /*\n               * In case of Distributed NodeLabels setup,\n               * ignoreNodeToLabelsMappings will be set to true and recover will\n               * be invoked. As RM will collect the node labels from NM through\n               * registration/HB\n               */\n              mgr.replaceLabelsOnNode(map);\n            }\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[ignoreNodeToLabelsMappings-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2740. Fix NodeLabelsManager to properly handle node label modifications when distributed node label configuration enabled. (Naganarasimha G R via wangda)\n",
          "commitDate": "27/04/15 4:24 PM",
          "commitName": "db1b674b50ddecf2774f4092d677c412722bdcb1",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "23/04/15 11:19 AM",
          "commitNameOld": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 4.21,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,107 +1,116 @@\n-  public void recover() throws YarnException, IOException {\n+  public void recover(boolean ignoreNodeToLabelsMappings) throws YarnException,\n+      IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n \n     FSDataInputStream is \u003d null;\n     if (fs.exists(mirrorPath)) {\n       is \u003d fs.open(mirrorPath);\n     } else if (fs.exists(oldMirrorPath)) {\n       is \u003d fs.open(oldMirrorPath);\n     }\n \n     if (null !\u003d is) {\n       List\u003cNodeLabel\u003e labels \u003d\n           new AddToClusterNodeLabelsRequestPBImpl(\n               AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n           new ReplaceLabelsOnNodeRequestPBImpl(\n               ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n               .getNodeToLabels();\n       mgr.addToCluserNodeLabels(labels);\n       mgr.replaceLabelsOnNode(nodeToLabels);\n       is.close();\n     }\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n       is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             List\u003cNodeLabel\u003e labels \u003d\n                 new AddToClusterNodeLabelsRequestPBImpl(\n                     AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                     .getNodeLabels();\n             mgr.addToCluserNodeLabels(labels);\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n-            mgr.replaceLabelsOnNode(map);\n+            if (!ignoreNodeToLabelsMappings) {\n+              /*\n+               * In case of Distributed NodeLabels setup,\n+               * ignoreNodeToLabelsMappings will be set to true and recover will\n+               * be invoked. As RM will collect the node labels from NM through\n+               * registration/HB\n+               */\n+              mgr.replaceLabelsOnNode(map);\n+            }\n             break;\n           }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recover(boolean ignoreNodeToLabelsMappings) throws YarnException,\n      IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n\n    FSDataInputStream is \u003d null;\n    if (fs.exists(mirrorPath)) {\n      is \u003d fs.open(mirrorPath);\n    } else if (fs.exists(oldMirrorPath)) {\n      is \u003d fs.open(oldMirrorPath);\n    }\n\n    if (null !\u003d is) {\n      List\u003cNodeLabel\u003e labels \u003d\n          new AddToClusterNodeLabelsRequestPBImpl(\n              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n          new ReplaceLabelsOnNodeRequestPBImpl(\n              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n              .getNodeToLabels();\n      mgr.addToCluserNodeLabels(labels);\n      mgr.replaceLabelsOnNode(nodeToLabels);\n      is.close();\n    }\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            List\u003cNodeLabel\u003e labels \u003d\n                new AddToClusterNodeLabelsRequestPBImpl(\n                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.addToCluserNodeLabels(labels);\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            if (!ignoreNodeToLabelsMappings) {\n              /*\n               * In case of Distributed NodeLabels setup,\n               * ignoreNodeToLabelsMappings will be set to true and recover will\n               * be invoked. As RM will collect the node labels from NM through\n               * registration/HB\n               */\n              mgr.replaceLabelsOnNode(map);\n            }\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3413. Changed Nodelabel attributes (like exclusivity) to be settable only via addToClusterNodeLabels but not changeable at runtime. (Wangda Tan via vinodkv)\n",
      "commitDate": "23/04/15 11:19 AM",
      "commitName": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/03/15 7:04 PM",
      "commitNameOld": "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 33.68,
      "commitsBetweenForRepo": 282,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,107 @@\n   public void recover() throws YarnException, IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n \n     FSDataInputStream is \u003d null;\n     if (fs.exists(mirrorPath)) {\n       is \u003d fs.open(mirrorPath);\n     } else if (fs.exists(oldMirrorPath)) {\n       is \u003d fs.open(oldMirrorPath);\n     }\n \n     if (null !\u003d is) {\n-      Set\u003cString\u003e labels \u003d\n+      List\u003cNodeLabel\u003e labels \u003d\n           new AddToClusterNodeLabelsRequestPBImpl(\n               AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n           new ReplaceLabelsOnNodeRequestPBImpl(\n               ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n               .getNodeToLabels();\n       mgr.addToCluserNodeLabels(labels);\n       mgr.replaceLabelsOnNode(nodeToLabels);\n       is.close();\n     }\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n       is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n-            Collection\u003cString\u003e labels \u003d\n-                AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n-                    .getNodeLabelsList();\n-            mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n+            List\u003cNodeLabel\u003e labels \u003d\n+                new AddToClusterNodeLabelsRequestPBImpl(\n+                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n+                    .getNodeLabels();\n+            mgr.addToCluserNodeLabels(labels);\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n             mgr.replaceLabelsOnNode(map);\n             break;\n           }\n-          case UPDATE_NODE_LABELS: {\n-            List\u003cNodeLabel\u003e attributes \u003d\n-                new UpdateNodeLabelsRequestPBImpl(\n-                    UpdateNodeLabelsRequestProto.parseDelimitedFrom(is))\n-                    .getNodeLabels();\n-            mgr.updateNodeLabels(attributes);\n-            break;\n-          }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover() throws YarnException, IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n\n    FSDataInputStream is \u003d null;\n    if (fs.exists(mirrorPath)) {\n      is \u003d fs.open(mirrorPath);\n    } else if (fs.exists(oldMirrorPath)) {\n      is \u003d fs.open(oldMirrorPath);\n    }\n\n    if (null !\u003d is) {\n      List\u003cNodeLabel\u003e labels \u003d\n          new AddToClusterNodeLabelsRequestPBImpl(\n              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n          new ReplaceLabelsOnNodeRequestPBImpl(\n              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n              .getNodeToLabels();\n      mgr.addToCluserNodeLabels(labels);\n      mgr.replaceLabelsOnNode(nodeToLabels);\n      is.close();\n    }\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            List\u003cNodeLabel\u003e labels \u003d\n                new AddToClusterNodeLabelsRequestPBImpl(\n                    AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.addToCluserNodeLabels(labels);\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            mgr.replaceLabelsOnNode(map);\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
      "extendedDetails": {}
    },
    "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-3345. Add non-exclusive node label API. Contributed by Wangda Tan\n",
      "commitDate": "20/03/15 7:04 PM",
      "commitName": "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-3345. Add non-exclusive node label API. Contributed by Wangda Tan\n",
          "commitDate": "20/03/15 7:04 PM",
          "commitName": "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0",
          "commitAuthor": "Jian He",
          "commitDateOld": "17/10/14 6:26 PM",
          "commitNameOld": "e9c66e8fd2ccb658db2848e1ab911f1502de4de5",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 154.03,
          "commitsBetweenForRepo": 1239,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,106 +1,114 @@\n-  public void recover() throws IOException {\n+  public void recover() throws YarnException, IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n \n     FSDataInputStream is \u003d null;\n     if (fs.exists(mirrorPath)) {\n       is \u003d fs.open(mirrorPath);\n     } else if (fs.exists(oldMirrorPath)) {\n       is \u003d fs.open(oldMirrorPath);\n     }\n \n     if (null !\u003d is) {\n       Set\u003cString\u003e labels \u003d\n           new AddToClusterNodeLabelsRequestPBImpl(\n               AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n           new ReplaceLabelsOnNodeRequestPBImpl(\n               ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n               .getNodeToLabels();\n       mgr.addToCluserNodeLabels(labels);\n       mgr.replaceLabelsOnNode(nodeToLabels);\n       is.close();\n     }\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n       is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n             mgr.replaceLabelsOnNode(map);\n             break;\n           }\n+          case UPDATE_NODE_LABELS: {\n+            List\u003cNodeLabel\u003e attributes \u003d\n+                new UpdateNodeLabelsRequestPBImpl(\n+                    UpdateNodeLabelsRequestProto.parseDelimitedFrom(is))\n+                    .getNodeLabels();\n+            mgr.updateNodeLabels(attributes);\n+            break;\n+          }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recover() throws YarnException, IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n\n    FSDataInputStream is \u003d null;\n    if (fs.exists(mirrorPath)) {\n      is \u003d fs.open(mirrorPath);\n    } else if (fs.exists(oldMirrorPath)) {\n      is \u003d fs.open(oldMirrorPath);\n    }\n\n    if (null !\u003d is) {\n      Set\u003cString\u003e labels \u003d\n          new AddToClusterNodeLabelsRequestPBImpl(\n              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n          new ReplaceLabelsOnNodeRequestPBImpl(\n              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n              .getNodeToLabels();\n      mgr.addToCluserNodeLabels(labels);\n      mgr.replaceLabelsOnNode(nodeToLabels);\n      is.close();\n    }\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            mgr.replaceLabelsOnNode(map);\n            break;\n          }\n          case UPDATE_NODE_LABELS: {\n            List\u003cNodeLabel\u003e attributes \u003d\n                new UpdateNodeLabelsRequestPBImpl(\n                    UpdateNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.updateNodeLabels(attributes);\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[YarnException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3345. Add non-exclusive node label API. Contributed by Wangda Tan\n",
          "commitDate": "20/03/15 7:04 PM",
          "commitName": "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0",
          "commitAuthor": "Jian He",
          "commitDateOld": "17/10/14 6:26 PM",
          "commitNameOld": "e9c66e8fd2ccb658db2848e1ab911f1502de4de5",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 154.03,
          "commitsBetweenForRepo": 1239,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,106 +1,114 @@\n-  public void recover() throws IOException {\n+  public void recover() throws YarnException, IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n     Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n     Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n \n     FSDataInputStream is \u003d null;\n     if (fs.exists(mirrorPath)) {\n       is \u003d fs.open(mirrorPath);\n     } else if (fs.exists(oldMirrorPath)) {\n       is \u003d fs.open(oldMirrorPath);\n     }\n \n     if (null !\u003d is) {\n       Set\u003cString\u003e labels \u003d\n           new AddToClusterNodeLabelsRequestPBImpl(\n               AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n           new ReplaceLabelsOnNodeRequestPBImpl(\n               ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n               .getNodeToLabels();\n       mgr.addToCluserNodeLabels(labels);\n       mgr.replaceLabelsOnNode(nodeToLabels);\n       is.close();\n     }\n \n     // Open and process editlog\n     editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n       is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n             mgr.replaceLabelsOnNode(map);\n             break;\n           }\n+          case UPDATE_NODE_LABELS: {\n+            List\u003cNodeLabel\u003e attributes \u003d\n+                new UpdateNodeLabelsRequestPBImpl(\n+                    UpdateNodeLabelsRequestProto.parseDelimitedFrom(is))\n+                    .getNodeLabels();\n+            mgr.updateNodeLabels(attributes);\n+            break;\n+          }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n     Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recover() throws YarnException, IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n\n    FSDataInputStream is \u003d null;\n    if (fs.exists(mirrorPath)) {\n      is \u003d fs.open(mirrorPath);\n    } else if (fs.exists(oldMirrorPath)) {\n      is \u003d fs.open(oldMirrorPath);\n    }\n\n    if (null !\u003d is) {\n      Set\u003cString\u003e labels \u003d\n          new AddToClusterNodeLabelsRequestPBImpl(\n              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n          new ReplaceLabelsOnNodeRequestPBImpl(\n              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n              .getNodeToLabels();\n      mgr.addToCluserNodeLabels(labels);\n      mgr.replaceLabelsOnNode(nodeToLabels);\n      is.close();\n    }\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            mgr.replaceLabelsOnNode(map);\n            break;\n          }\n          case UPDATE_NODE_LABELS: {\n            List\u003cNodeLabel\u003e attributes \u003d\n                new UpdateNodeLabelsRequestPBImpl(\n                    UpdateNodeLabelsRequestProto.parseDelimitedFrom(is))\n                    .getNodeLabels();\n            mgr.updateNodeLabels(attributes);\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "e9c66e8fd2ccb658db2848e1ab911f1502de4de5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2705. Fixed bugs in ResourceManager node-label manager that were causing test-failures: added a dummy in-memory labels-manager. Contributed by Wangda Tan.\n",
      "commitDate": "17/10/14 6:26 PM",
      "commitName": "e9c66e8fd2ccb658db2848e1ab911f1502de4de5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/10/14 11:44 AM",
      "commitNameOld": "db7f1653198b950e89567c06898d64f6b930a0ee",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.28,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   public void recover() throws IOException {\n     /*\n      * Steps of recover\n      * 1) Read from last mirror (from mirror or mirror.old)\n      * 2) Read from last edit log, and apply such edit log\n      * 3) Write new mirror to mirror.writing\n      * 4) Rename mirror to mirror.old\n      * 5) Move mirror.writing to mirror\n      * 6) Remove mirror.old\n      * 7) Remove edit log and create a new empty edit log \n      */\n     \n     // Open mirror from serialized file\n-    Path mirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME);\n-    Path oldMirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME + \".old\");\n+    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n+    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n \n     FSDataInputStream is \u003d null;\n     if (fs.exists(mirrorPath)) {\n       is \u003d fs.open(mirrorPath);\n     } else if (fs.exists(oldMirrorPath)) {\n       is \u003d fs.open(oldMirrorPath);\n     }\n \n     if (null !\u003d is) {\n       Set\u003cString\u003e labels \u003d\n           new AddToClusterNodeLabelsRequestPBImpl(\n               AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n           new ReplaceLabelsOnNodeRequestPBImpl(\n               ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n               .getNodeToLabels();\n       mgr.addToCluserNodeLabels(labels);\n       mgr.replaceLabelsOnNode(nodeToLabels);\n       is.close();\n     }\n \n     // Open and process editlog\n-    editLogPath \u003d new Path(rootDirPath, EDITLOG_FILENAME);\n+    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n     if (fs.exists(editLogPath)) {\n       is \u003d fs.open(editLogPath);\n \n       while (true) {\n         try {\n           // read edit log one by one\n           SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n           \n           switch (type) {\n           case ADD_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n             break;\n           }\n           case REMOVE_LABELS: {\n             Collection\u003cString\u003e labels \u003d\n                 RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                     .getNodeLabelsList();\n             mgr.removeFromClusterNodeLabels(labels);\n             break;\n           }\n           case NODE_TO_LABELS: {\n             Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                 new ReplaceLabelsOnNodeRequestPBImpl(\n                     ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                     .getNodeToLabels();\n             mgr.replaceLabelsOnNode(map);\n             break;\n           }\n           }\n         } catch (EOFException e) {\n           // EOF hit, break\n           break;\n         }\n       }\n     }\n \n     // Serialize current mirror to mirror.writing\n-    Path writingMirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME + \".writing\");\n+    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n     FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n     ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n         .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n     ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n         .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n     os.close();\n     \n     // Move mirror to mirror.old\n     if (fs.exists(mirrorPath)) {\n       fs.delete(oldMirrorPath, false);\n       fs.rename(mirrorPath, oldMirrorPath);\n     }\n     \n     // move mirror.writing to mirror\n     fs.rename(writingMirrorPath, mirrorPath);\n     fs.delete(writingMirrorPath, false);\n     \n     // remove mirror.old\n     fs.delete(oldMirrorPath, false);\n     \n     // create a new editlog file\n     editlogOs \u003d fs.create(editLogPath, true);\n     editlogOs.close();\n     \n     LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n     LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover() throws IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".old\");\n\n    FSDataInputStream is \u003d null;\n    if (fs.exists(mirrorPath)) {\n      is \u003d fs.open(mirrorPath);\n    } else if (fs.exists(oldMirrorPath)) {\n      is \u003d fs.open(oldMirrorPath);\n    }\n\n    if (null !\u003d is) {\n      Set\u003cString\u003e labels \u003d\n          new AddToClusterNodeLabelsRequestPBImpl(\n              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n          new ReplaceLabelsOnNodeRequestPBImpl(\n              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n              .getNodeToLabels();\n      mgr.addToCluserNodeLabels(labels);\n      mgr.replaceLabelsOnNode(nodeToLabels);\n      is.close();\n    }\n\n    // Open and process editlog\n    editLogPath \u003d new Path(fsWorkingPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            mgr.replaceLabelsOnNode(map);\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(fsWorkingPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java",
      "extendedDetails": {}
    },
    "db7f1653198b950e89567c06898d64f6b930a0ee": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2494. Added NodeLabels Manager internal API and implementation. Contributed by Wangda Tan.\n",
      "commitDate": "10/10/14 11:44 AM",
      "commitName": "db7f1653198b950e89567c06898d64f6b930a0ee",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,106 @@\n+  public void recover() throws IOException {\n+    /*\n+     * Steps of recover\n+     * 1) Read from last mirror (from mirror or mirror.old)\n+     * 2) Read from last edit log, and apply such edit log\n+     * 3) Write new mirror to mirror.writing\n+     * 4) Rename mirror to mirror.old\n+     * 5) Move mirror.writing to mirror\n+     * 6) Remove mirror.old\n+     * 7) Remove edit log and create a new empty edit log \n+     */\n+    \n+    // Open mirror from serialized file\n+    Path mirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME);\n+    Path oldMirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME + \".old\");\n+\n+    FSDataInputStream is \u003d null;\n+    if (fs.exists(mirrorPath)) {\n+      is \u003d fs.open(mirrorPath);\n+    } else if (fs.exists(oldMirrorPath)) {\n+      is \u003d fs.open(oldMirrorPath);\n+    }\n+\n+    if (null !\u003d is) {\n+      Set\u003cString\u003e labels \u003d\n+          new AddToClusterNodeLabelsRequestPBImpl(\n+              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n+      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n+          new ReplaceLabelsOnNodeRequestPBImpl(\n+              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n+              .getNodeToLabels();\n+      mgr.addToCluserNodeLabels(labels);\n+      mgr.replaceLabelsOnNode(nodeToLabels);\n+      is.close();\n+    }\n+\n+    // Open and process editlog\n+    editLogPath \u003d new Path(rootDirPath, EDITLOG_FILENAME);\n+    if (fs.exists(editLogPath)) {\n+      is \u003d fs.open(editLogPath);\n+\n+      while (true) {\n+        try {\n+          // read edit log one by one\n+          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n+          \n+          switch (type) {\n+          case ADD_LABELS: {\n+            Collection\u003cString\u003e labels \u003d\n+                AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n+                    .getNodeLabelsList();\n+            mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n+            break;\n+          }\n+          case REMOVE_LABELS: {\n+            Collection\u003cString\u003e labels \u003d\n+                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n+                    .getNodeLabelsList();\n+            mgr.removeFromClusterNodeLabels(labels);\n+            break;\n+          }\n+          case NODE_TO_LABELS: {\n+            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n+                new ReplaceLabelsOnNodeRequestPBImpl(\n+                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n+                    .getNodeToLabels();\n+            mgr.replaceLabelsOnNode(map);\n+            break;\n+          }\n+          }\n+        } catch (EOFException e) {\n+          // EOF hit, break\n+          break;\n+        }\n+      }\n+    }\n+\n+    // Serialize current mirror to mirror.writing\n+    Path writingMirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME + \".writing\");\n+    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n+    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n+        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n+    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n+        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n+    os.close();\n+    \n+    // Move mirror to mirror.old\n+    if (fs.exists(mirrorPath)) {\n+      fs.delete(oldMirrorPath, false);\n+      fs.rename(mirrorPath, oldMirrorPath);\n+    }\n+    \n+    // move mirror.writing to mirror\n+    fs.rename(writingMirrorPath, mirrorPath);\n+    fs.delete(writingMirrorPath, false);\n+    \n+    // remove mirror.old\n+    fs.delete(oldMirrorPath, false);\n+    \n+    // create a new editlog file\n+    editlogOs \u003d fs.create(editLogPath, true);\n+    editlogOs.close();\n+    \n+    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n+    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover() throws IOException {\n    /*\n     * Steps of recover\n     * 1) Read from last mirror (from mirror or mirror.old)\n     * 2) Read from last edit log, and apply such edit log\n     * 3) Write new mirror to mirror.writing\n     * 4) Rename mirror to mirror.old\n     * 5) Move mirror.writing to mirror\n     * 6) Remove mirror.old\n     * 7) Remove edit log and create a new empty edit log \n     */\n    \n    // Open mirror from serialized file\n    Path mirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME);\n    Path oldMirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME + \".old\");\n\n    FSDataInputStream is \u003d null;\n    if (fs.exists(mirrorPath)) {\n      is \u003d fs.open(mirrorPath);\n    } else if (fs.exists(oldMirrorPath)) {\n      is \u003d fs.open(oldMirrorPath);\n    }\n\n    if (null !\u003d is) {\n      Set\u003cString\u003e labels \u003d\n          new AddToClusterNodeLabelsRequestPBImpl(\n              AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)).getNodeLabels();\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels \u003d\n          new ReplaceLabelsOnNodeRequestPBImpl(\n              ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n              .getNodeToLabels();\n      mgr.addToCluserNodeLabels(labels);\n      mgr.replaceLabelsOnNode(nodeToLabels);\n      is.close();\n    }\n\n    // Open and process editlog\n    editLogPath \u003d new Path(rootDirPath, EDITLOG_FILENAME);\n    if (fs.exists(editLogPath)) {\n      is \u003d fs.open(editLogPath);\n\n      while (true) {\n        try {\n          // read edit log one by one\n          SerializedLogType type \u003d SerializedLogType.values()[is.readInt()];\n          \n          switch (type) {\n          case ADD_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                AddToClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.addToCluserNodeLabels(Sets.newHashSet(labels.iterator()));\n            break;\n          }\n          case REMOVE_LABELS: {\n            Collection\u003cString\u003e labels \u003d\n                RemoveFromClusterNodeLabelsRequestProto.parseDelimitedFrom(is)\n                    .getNodeLabelsList();\n            mgr.removeFromClusterNodeLabels(labels);\n            break;\n          }\n          case NODE_TO_LABELS: {\n            Map\u003cNodeId, Set\u003cString\u003e\u003e map \u003d\n                new ReplaceLabelsOnNodeRequestPBImpl(\n                    ReplaceLabelsOnNodeRequestProto.parseDelimitedFrom(is))\n                    .getNodeToLabels();\n            mgr.replaceLabelsOnNode(map);\n            break;\n          }\n          }\n        } catch (EOFException e) {\n          // EOF hit, break\n          break;\n        }\n      }\n    }\n\n    // Serialize current mirror to mirror.writing\n    Path writingMirrorPath \u003d new Path(rootDirPath, MIRROR_FILENAME + \".writing\");\n    FSDataOutputStream os \u003d fs.create(writingMirrorPath, true);\n    ((AddToClusterNodeLabelsRequestPBImpl) AddToClusterNodeLabelsRequestPBImpl\n        .newInstance(mgr.getClusterNodeLabels())).getProto().writeDelimitedTo(os);\n    ((ReplaceLabelsOnNodeRequestPBImpl) ReplaceLabelsOnNodeRequest\n        .newInstance(mgr.getNodeLabels())).getProto().writeDelimitedTo(os);\n    os.close();\n    \n    // Move mirror to mirror.old\n    if (fs.exists(mirrorPath)) {\n      fs.delete(oldMirrorPath, false);\n      fs.rename(mirrorPath, oldMirrorPath);\n    }\n    \n    // move mirror.writing to mirror\n    fs.rename(writingMirrorPath, mirrorPath);\n    fs.delete(writingMirrorPath, false);\n    \n    // remove mirror.old\n    fs.delete(oldMirrorPath, false);\n    \n    // create a new editlog file\n    editlogOs \u003d fs.create(editLogPath, true);\n    editlogOs.close();\n    \n    LOG.info(\"Finished write mirror at:\" + mirrorPath.toString());\n    LOG.info(\"Finished create editlog file at:\" + editLogPath.toString());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/FileSystemNodeLabelsStore.java"
    }
  }
}