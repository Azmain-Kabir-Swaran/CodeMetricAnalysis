{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueueManager.java",
  "functionName": "updateAllocationConfiguration",
  "functionId": "updateAllocationConfiguration___queueConf-AllocationConfiguration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
  "functionStartLine": 594,
  "functionEndLine": 618,
  "numCommitsSeen": 52,
  "timeTaken": 5106,
  "changeHistory": [
    "10d0e4be6eade7c1685b9c6962bc9b18e33122a8",
    "86bc6425d425913899f1d951498bd040e453b3d0",
    "11be3f70e029c2324b167563168c8a254d234aef",
    "e224c9623493d6c4c2f3ff731fd3c72c0f448b19",
    "f6ea9be5473ab66798b0536317d2f32c5348eb57",
    "f979d779e192ac05906b7eb880dfc8884d0078a0",
    "a0b5a0a419dfc07b7ac45c06b11b4c8dc7e79958",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
    "0097b15e2150f95745f64179a0ef4644e96128f5",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
    "f4fd050dee83ecbff0a92b28c3a51ae353f95c24",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc"
  ],
  "changeHistoryShort": {
    "10d0e4be6eade7c1685b9c6962bc9b18e33122a8": "Ybodychange",
    "86bc6425d425913899f1d951498bd040e453b3d0": "Ybodychange",
    "11be3f70e029c2324b167563168c8a254d234aef": "Ybodychange",
    "e224c9623493d6c4c2f3ff731fd3c72c0f448b19": "Ybodychange",
    "f6ea9be5473ab66798b0536317d2f32c5348eb57": "Ybodychange",
    "f979d779e192ac05906b7eb880dfc8884d0078a0": "Ybodychange",
    "a0b5a0a419dfc07b7ac45c06b11b4c8dc7e79958": "Ybodychange",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": "Ybodychange",
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9": "Ybodychange",
    "0097b15e2150f95745f64179a0ef4644e96128f5": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": "Ybodychange",
    "f4fd050dee83ecbff0a92b28c3a51ae353f95c24": "Ybodychange",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "10d0e4be6eade7c1685b9c6962bc9b18e33122a8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8325. Miscellaneous QueueManager code clean up. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "12/06/18 10:11 AM",
      "commitName": "10d0e4be6eade7c1685b9c6962bc9b18e33122a8",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "24/05/18 5:12 PM",
      "commitNameOld": "86bc6425d425913899f1d951498bd040e453b3d0",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 18.71,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,25 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n-    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n+    // Create leaf queues and the parent queues in a leaf\u0027s\n+    // ancestry if they do not exist\n     synchronized (queues) {\n       // Verify and set scheduling policies for existing queues before creating\n       // any queue, since we need parent policies to determine if we can create\n       // its children.\n       if (!rootQueue.verifyAndSetPolicyFromConf(queueConf)) {\n         LOG.error(\"Setting scheduling policies for existing queues failed!\");\n       }\n \n       ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf, FSQueueType.LEAF);\n \n       // At this point all leaves and \u0027parents with\n       // at least one child\u0027 would have been created.\n       // Now create parents with no configured leaf.\n       ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf,\n           FSQueueType.PARENT);\n     }\n \n     // Initialize all queues recursively\n     rootQueue.reinit(true);\n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s\n    // ancestry if they do not exist\n    synchronized (queues) {\n      // Verify and set scheduling policies for existing queues before creating\n      // any queue, since we need parent policies to determine if we can create\n      // its children.\n      if (!rootQueue.verifyAndSetPolicyFromConf(queueConf)) {\n        LOG.error(\"Setting scheduling policies for existing queues failed!\");\n      }\n\n      ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf, FSQueueType.LEAF);\n\n      // At this point all leaves and \u0027parents with\n      // at least one child\u0027 would have been created.\n      // Now create parents with no configured leaf.\n      ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf,\n          FSQueueType.PARENT);\n    }\n\n    // Initialize all queues recursively\n    rootQueue.reinit(true);\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "86bc6425d425913899f1d951498bd040e453b3d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8191. Fair scheduler: queue deletion without RM restart. (Gergo Repas via Haibo Chen)\n",
      "commitDate": "24/05/18 5:12 PM",
      "commitName": "86bc6425d425913899f1d951498bd040e453b3d0",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "05/10/17 11:51 PM",
      "commitNameOld": "99292adcefdc6b8f280b8e100605fb39f755c38a",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 230.72,
      "commitsBetweenForRepo": 2231,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,24 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     synchronized (queues) {\n       // Verify and set scheduling policies for existing queues before creating\n       // any queue, since we need parent policies to determine if we can create\n       // its children.\n       if (!rootQueue.verifyAndSetPolicyFromConf(queueConf)) {\n         LOG.error(\"Setting scheduling policies for existing queues failed!\");\n       }\n \n-      for (String name : queueConf.getConfiguredQueues().get(\n-              FSQueueType.LEAF)) {\n-        if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n-          getLeafQueue(name, true, false);\n-        }\n-      }\n+      ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf, FSQueueType.LEAF);\n+\n       // At this point all leaves and \u0027parents with\n       // at least one child\u0027 would have been created.\n       // Now create parents with no configured leaf.\n-      for (String name : queueConf.getConfiguredQueues().get(\n-          FSQueueType.PARENT)) {\n-        if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n-          getParentQueue(name, true, false);\n-        }\n-      }\n+      ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf,\n+          FSQueueType.PARENT);\n     }\n \n     // Initialize all queues recursively\n     rootQueue.reinit(true);\n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    synchronized (queues) {\n      // Verify and set scheduling policies for existing queues before creating\n      // any queue, since we need parent policies to determine if we can create\n      // its children.\n      if (!rootQueue.verifyAndSetPolicyFromConf(queueConf)) {\n        LOG.error(\"Setting scheduling policies for existing queues failed!\");\n      }\n\n      ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf, FSQueueType.LEAF);\n\n      // At this point all leaves and \u0027parents with\n      // at least one child\u0027 would have been created.\n      // Now create parents with no configured leaf.\n      ensureQueueExistsAndIsCompatibleAndIsStatic(queueConf,\n          FSQueueType.PARENT);\n    }\n\n    // Initialize all queues recursively\n    rootQueue.reinit(true);\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "11be3f70e029c2324b167563168c8a254d234aef": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4212. FairScheduler: Can\u0027t create a DRF queue under a FAIR policy queue. (Yufei Gu via kasha)\n",
      "commitDate": "15/02/17 11:51 PM",
      "commitName": "11be3f70e029c2324b167563168c8a254d234aef",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/01/17 5:01 PM",
      "commitNameOld": "e224c9623493d6c4c2f3ff731fd3c72c0f448b19",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 29.28,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,32 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     synchronized (queues) {\n+      // Verify and set scheduling policies for existing queues before creating\n+      // any queue, since we need parent policies to determine if we can create\n+      // its children.\n+      if (!rootQueue.verifyAndSetPolicyFromConf(queueConf)) {\n+        LOG.error(\"Setting scheduling policies for existing queues failed!\");\n+      }\n+\n       for (String name : queueConf.getConfiguredQueues().get(\n               FSQueueType.LEAF)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n           getLeafQueue(name, true, false);\n         }\n       }\n       // At this point all leaves and \u0027parents with\n       // at least one child\u0027 would have been created.\n       // Now create parents with no configured leaf.\n       for (String name : queueConf.getConfiguredQueues().get(\n           FSQueueType.PARENT)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n           getParentQueue(name, true, false);\n         }\n       }\n     }\n \n     // Initialize all queues recursively\n     rootQueue.reinit(true);\n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    synchronized (queues) {\n      // Verify and set scheduling policies for existing queues before creating\n      // any queue, since we need parent policies to determine if we can create\n      // its children.\n      if (!rootQueue.verifyAndSetPolicyFromConf(queueConf)) {\n        LOG.error(\"Setting scheduling policies for existing queues failed!\");\n      }\n\n      for (String name : queueConf.getConfiguredQueues().get(\n              FSQueueType.LEAF)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n          getLeafQueue(name, true, false);\n        }\n      }\n      // At this point all leaves and \u0027parents with\n      // at least one child\u0027 would have been created.\n      // Now create parents with no configured leaf.\n      for (String name : queueConf.getConfiguredQueues().get(\n          FSQueueType.PARENT)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n          getParentQueue(name, true, false);\n        }\n      }\n    }\n\n    // Initialize all queues recursively\n    rootQueue.reinit(true);\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "e224c9623493d6c4c2f3ff731fd3c72c0f448b19": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5831. FairScheduler: Propagate allowPreemptionFrom flag all the way down to the app. (Yufei Gu via kasha)\n",
      "commitDate": "17/01/17 5:01 PM",
      "commitName": "e224c9623493d6c4c2f3ff731fd3c72c0f448b19",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "02/09/16 2:56 PM",
      "commitNameOld": "f6ea9be5473ab66798b0536317d2f32c5348eb57",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 137.13,
      "commitsBetweenForRepo": 894,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,25 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     synchronized (queues) {\n       for (String name : queueConf.getConfiguredQueues().get(\n               FSQueueType.LEAF)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n           getLeafQueue(name, true, false);\n         }\n       }\n       // At this point all leaves and \u0027parents with\n       // at least one child\u0027 would have been created.\n       // Now create parents with no configured leaf.\n       for (String name : queueConf.getConfiguredQueues().get(\n           FSQueueType.PARENT)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n           getParentQueue(name, true, false);\n         }\n       }\n     }\n-    rootQueue.recomputeSteadyShares();\n \n-    for (FSQueue queue : queues.values()) {\n-      queue.init();\n-    }\n-\n+    // Initialize all queues recursively\n+    rootQueue.reinit(true);\n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n-    // Update the fair share preemption timeouts and preemption for all queues\n-    // recursively\n-    rootQueue.updatePreemptionVariables();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    synchronized (queues) {\n      for (String name : queueConf.getConfiguredQueues().get(\n              FSQueueType.LEAF)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n          getLeafQueue(name, true, false);\n        }\n      }\n      // At this point all leaves and \u0027parents with\n      // at least one child\u0027 would have been created.\n      // Now create parents with no configured leaf.\n      for (String name : queueConf.getConfiguredQueues().get(\n          FSQueueType.PARENT)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n          getParentQueue(name, true, false);\n        }\n      }\n    }\n\n    // Initialize all queues recursively\n    rootQueue.reinit(true);\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "f6ea9be5473ab66798b0536317d2f32c5348eb57": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5264. Store all queue-specific information in FSQueue. (Yufei Gu via kasha)\n",
      "commitDate": "02/09/16 2:56 PM",
      "commitName": "f6ea9be5473ab66798b0536317d2f32c5348eb57",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/08/16 5:40 PM",
      "commitNameOld": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 15.89,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,31 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     synchronized (queues) {\n       for (String name : queueConf.getConfiguredQueues().get(\n               FSQueueType.LEAF)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n           getLeafQueue(name, true, false);\n         }\n       }\n       // At this point all leaves and \u0027parents with\n       // at least one child\u0027 would have been created.\n       // Now create parents with no configured leaf.\n       for (String name : queueConf.getConfiguredQueues().get(\n           FSQueueType.PARENT)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n           getParentQueue(name, true, false);\n         }\n       }\n     }\n     rootQueue.recomputeSteadyShares();\n \n     for (FSQueue queue : queues.values()) {\n-      // Update queue metrics\n-      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n-      queueMetrics.setMinShare(queue.getMinShare());\n-      queueMetrics.setMaxShare(queue.getMaxShare());\n-      // Set scheduling policies and update queue metrics\n-      try {\n-        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n-        policy.initialize(scheduler.getClusterResource());\n-        queue.setPolicy(policy);\n-\n-        queueMetrics.setMaxApps(queueConf.getQueueMaxApps(queue.getName()));\n-        queueMetrics.setSchedulingPolicy(policy.getName());\n-      } catch (AllocationConfigurationException ex) {\n-        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n-            + queue.getName(), ex);\n-      }\n+      queue.init();\n     }\n \n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n     // Update the fair share preemption timeouts and preemption for all queues\n     // recursively\n     rootQueue.updatePreemptionVariables();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    synchronized (queues) {\n      for (String name : queueConf.getConfiguredQueues().get(\n              FSQueueType.LEAF)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n          getLeafQueue(name, true, false);\n        }\n      }\n      // At this point all leaves and \u0027parents with\n      // at least one child\u0027 would have been created.\n      // Now create parents with no configured leaf.\n      for (String name : queueConf.getConfiguredQueues().get(\n          FSQueueType.PARENT)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n          getParentQueue(name, true, false);\n        }\n      }\n    }\n    rootQueue.recomputeSteadyShares();\n\n    for (FSQueue queue : queues.values()) {\n      queue.init();\n    }\n\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n    // Update the fair share preemption timeouts and preemption for all queues\n    // recursively\n    rootQueue.updatePreemptionVariables();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "f979d779e192ac05906b7eb880dfc8884d0078a0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4878. Expose scheduling policy and max running apps over JMX for Yarn queues. (Yufei Gu via kasha)\n",
      "commitDate": "24/05/16 10:54 AM",
      "commitName": "f979d779e192ac05906b7eb880dfc8884d0078a0",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "29/09/15 7:55 AM",
      "commitNameOld": "a0b5a0a419dfc07b7ac45c06b11b4c8dc7e79958",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 238.12,
      "commitsBetweenForRepo": 1574,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     synchronized (queues) {\n       for (String name : queueConf.getConfiguredQueues().get(\n               FSQueueType.LEAF)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n           getLeafQueue(name, true, false);\n         }\n       }\n       // At this point all leaves and \u0027parents with\n       // at least one child\u0027 would have been created.\n       // Now create parents with no configured leaf.\n       for (String name : queueConf.getConfiguredQueues().get(\n           FSQueueType.PARENT)) {\n         if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n           getParentQueue(name, true, false);\n         }\n       }\n     }\n     rootQueue.recomputeSteadyShares();\n \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n-      // Set scheduling policies\n+      // Set scheduling policies and update queue metrics\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n         policy.initialize(scheduler.getClusterResource());\n         queue.setPolicy(policy);\n+\n+        queueMetrics.setMaxApps(queueConf.getQueueMaxApps(queue.getName()));\n+        queueMetrics.setSchedulingPolicy(policy.getName());\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n \n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n     // Update the fair share preemption timeouts and preemption for all queues\n     // recursively\n     rootQueue.updatePreemptionVariables();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    synchronized (queues) {\n      for (String name : queueConf.getConfiguredQueues().get(\n              FSQueueType.LEAF)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n          getLeafQueue(name, true, false);\n        }\n      }\n      // At this point all leaves and \u0027parents with\n      // at least one child\u0027 would have been created.\n      // Now create parents with no configured leaf.\n      for (String name : queueConf.getConfiguredQueues().get(\n          FSQueueType.PARENT)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n          getParentQueue(name, true, false);\n        }\n      }\n    }\n    rootQueue.recomputeSteadyShares();\n\n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies and update queue metrics\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterResource());\n        queue.setPolicy(policy);\n\n        queueMetrics.setMaxApps(queueConf.getQueueMaxApps(queue.getName()));\n        queueMetrics.setSchedulingPolicy(policy.getName());\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n    // Update the fair share preemption timeouts and preemption for all queues\n    // recursively\n    rootQueue.updatePreemptionVariables();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "a0b5a0a419dfc07b7ac45c06b11b4c8dc7e79958": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4066. Large number of queues choke fair scheduler. (Johan Gustavsson via kasha)\n",
      "commitDate": "29/09/15 7:55 AM",
      "commitName": "a0b5a0a419dfc07b7ac45c06b11b4c8dc7e79958",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "28/09/15 9:05 AM",
      "commitNameOld": "fb2e525c0775ccf218c8980676e9fb4005a406a6",
      "commitAuthorOld": "Anubhav Dhoot",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,43 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n-    for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n-      if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n-        getLeafQueue(name, true);\n+    synchronized (queues) {\n+      for (String name : queueConf.getConfiguredQueues().get(\n+              FSQueueType.LEAF)) {\n+        if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n+          getLeafQueue(name, true, false);\n+        }\n+      }\n+      // At this point all leaves and \u0027parents with\n+      // at least one child\u0027 would have been created.\n+      // Now create parents with no configured leaf.\n+      for (String name : queueConf.getConfiguredQueues().get(\n+          FSQueueType.PARENT)) {\n+        if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n+          getParentQueue(name, true, false);\n+        }\n       }\n     }\n+    rootQueue.recomputeSteadyShares();\n \n-    // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n-    // Now create parents with no configured leaf.\n-    for (String name : queueConf.getConfiguredQueues().get(\n-        FSQueueType.PARENT)) {\n-      if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n-        getParentQueue(name, true);\n-      }\n-    }\n-    \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n       // Set scheduling policies\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n         policy.initialize(scheduler.getClusterResource());\n         queue.setPolicy(policy);\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n \n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n     // Update the fair share preemption timeouts and preemption for all queues\n     // recursively\n     rootQueue.updatePreemptionVariables();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    synchronized (queues) {\n      for (String name : queueConf.getConfiguredQueues().get(\n              FSQueueType.LEAF)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n          getLeafQueue(name, true, false);\n        }\n      }\n      // At this point all leaves and \u0027parents with\n      // at least one child\u0027 would have been created.\n      // Now create parents with no configured leaf.\n      for (String name : queueConf.getConfiguredQueues().get(\n          FSQueueType.PARENT)) {\n        if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n          getParentQueue(name, true, false);\n        }\n      }\n    }\n    rootQueue.recomputeSteadyShares();\n\n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterResource());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n    // Update the fair share preemption timeouts and preemption for all queues\n    // recursively\n    rootQueue.updatePreemptionVariables();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2394. FairScheduler: Configure fairSharePreemptionThreshold per queue. (Wei Yan via kasha)\n",
      "commitDate": "03/09/14 10:27 AM",
      "commitName": "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "30/08/14 1:17 AM",
      "commitNameOld": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n         getLeafQueue(name, true);\n       }\n     }\n \n     // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n     // Now create parents with no configured leaf.\n     for (String name : queueConf.getConfiguredQueues().get(\n         FSQueueType.PARENT)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n         getParentQueue(name, true);\n       }\n     }\n     \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n       // Set scheduling policies\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n         policy.initialize(scheduler.getClusterResource());\n         queue.setPolicy(policy);\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n \n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n-    // Update the fair share preemption timeouts for all queues recursively\n-    rootQueue.updatePreemptionTimeouts();\n+    // Update the fair share preemption timeouts and preemption for all queues\n+    // recursively\n+    rootQueue.updatePreemptionVariables();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n        getLeafQueue(name, true);\n      }\n    }\n\n    // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n    // Now create parents with no configured leaf.\n    for (String name : queueConf.getConfiguredQueues().get(\n        FSQueueType.PARENT)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n        getParentQueue(name, true);\n      }\n    }\n    \n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterResource());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n    // Update the fair share preemption timeouts and preemption for all queues\n    // recursively\n    rootQueue.updatePreemptionVariables();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2395. FairScheduler: Preemption timeout should be configurable per queue. (Wei Yan via kasha)\n",
      "commitDate": "30/08/14 1:17 AM",
      "commitName": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "22/08/14 8:44 AM",
      "commitNameOld": "0097b15e2150f95745f64179a0ef4644e96128f5",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 7.69,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n         getLeafQueue(name, true);\n       }\n     }\n \n     // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n     // Now create parents with no configured leaf.\n     for (String name : queueConf.getConfiguredQueues().get(\n         FSQueueType.PARENT)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n         getParentQueue(name, true);\n       }\n     }\n     \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n       // Set scheduling policies\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n         policy.initialize(scheduler.getClusterResource());\n         queue.setPolicy(policy);\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n \n     // Update steady fair shares for all queues\n     rootQueue.recomputeSteadyShares();\n+    // Update the fair share preemption timeouts for all queues recursively\n+    rootQueue.updatePreemptionTimeouts();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n        getLeafQueue(name, true);\n      }\n    }\n\n    // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n    // Now create parents with no configured leaf.\n    for (String name : queueConf.getConfiguredQueues().get(\n        FSQueueType.PARENT)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n        getParentQueue(name, true);\n      }\n    }\n    \n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterResource());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n    // Update the fair share preemption timeouts for all queues recursively\n    rootQueue.updatePreemptionTimeouts();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "0097b15e2150f95745f64179a0ef4644e96128f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2393. FairScheduler: Add the notion of steady fair share. (Wei Yan via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1619845 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/08/14 8:44 AM",
      "commitName": "0097b15e2150f95745f64179a0ef4644e96128f5",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "21/05/14 10:32 PM",
      "commitNameOld": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 92.43,
      "commitsBetweenForRepo": 701,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,36 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n         getLeafQueue(name, true);\n       }\n     }\n \n     // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n     // Now create parents with no configured leaf.\n     for (String name : queueConf.getConfiguredQueues().get(\n         FSQueueType.PARENT)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n         getParentQueue(name, true);\n       }\n     }\n     \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n       // Set scheduling policies\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n         policy.initialize(scheduler.getClusterResource());\n         queue.setPolicy(policy);\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n+\n+    // Update steady fair shares for all queues\n+    rootQueue.recomputeSteadyShares();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n        getLeafQueue(name, true);\n      }\n    }\n\n    // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n    // Now create parents with no configured leaf.\n    for (String name : queueConf.getConfiguredQueues().get(\n        FSQueueType.PARENT)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n        getParentQueue(name, true);\n      }\n    }\n    \n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterResource());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n\n    // Update steady fair shares for all queues\n    rootQueue.recomputeSteadyShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/05/14 12:21 AM",
      "commitNameOld": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 13.92,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n     for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n         getLeafQueue(name, true);\n       }\n     }\n \n     // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n     // Now create parents with no configured leaf.\n     for (String name : queueConf.getConfiguredQueues().get(\n         FSQueueType.PARENT)) {\n       if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n         getParentQueue(name, true);\n       }\n     }\n     \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n       // Set scheduling policies\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n-        policy.initialize(scheduler.getClusterCapacity());\n+        policy.initialize(scheduler.getClusterResource());\n         queue.setPolicy(policy);\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n        getLeafQueue(name, true);\n      }\n    }\n\n    // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n    // Now create parents with no configured leaf.\n    for (String name : queueConf.getConfiguredQueues().get(\n        FSQueueType.PARENT)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n        getParentQueue(name, true);\n      }\n    }\n    \n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterResource());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/14 12:21 AM",
      "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "14/01/14 2:33 PM",
      "commitNameOld": "f4fd050dee83ecbff0a92b28c3a51ae353f95c24",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 113.37,
      "commitsBetweenForRepo": 860,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,33 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n-    // Make sure all queues exist\n-    for (String name : queueConf.getQueueNames()) {\n-      if (removeEmptyIncompatibleQueues(name)) {\n+    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n+    for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n+      if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n         getLeafQueue(name, true);\n       }\n     }\n+\n+    // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n+    // Now create parents with no configured leaf.\n+    for (String name : queueConf.getConfiguredQueues().get(\n+        FSQueueType.PARENT)) {\n+      if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n+        getParentQueue(name, true);\n+      }\n+    }\n     \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n       // Set scheduling policies\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n         policy.initialize(scheduler.getClusterCapacity());\n         queue.setPolicy(policy);\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Create leaf queues and the parent queues in a leaf\u0027s ancestry if they do not exist\n    for (String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.LEAF)) {\n        getLeafQueue(name, true);\n      }\n    }\n\n    // At this point all leaves and \u0027parents with at least one child\u0027 would have been created.\n    // Now create parents with no configured leaf.\n    for (String name : queueConf.getConfiguredQueues().get(\n        FSQueueType.PARENT)) {\n      if (removeEmptyIncompatibleQueues(name, FSQueueType.PARENT)) {\n        getParentQueue(name, true);\n      }\n    }\n    \n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterCapacity());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "f4fd050dee83ecbff0a92b28c3a51ae353f95c24": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1567. In Fair Scheduler, allow empty queues to change between leaf and parent on allocation file reload (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1558228 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/01/14 2:33 PM",
      "commitName": "f4fd050dee83ecbff0a92b28c3a51ae353f95c24",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "04/12/13 7:26 PM",
      "commitNameOld": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 40.8,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,24 @@\n   public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n     // Make sure all queues exist\n     for (String name : queueConf.getQueueNames()) {\n-      getLeafQueue(name, true);\n+      if (removeEmptyIncompatibleQueues(name)) {\n+        getLeafQueue(name, true);\n+      }\n     }\n     \n     for (FSQueue queue : queues.values()) {\n       // Update queue metrics\n       FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n       queueMetrics.setMinShare(queue.getMinShare());\n       queueMetrics.setMaxShare(queue.getMaxShare());\n       // Set scheduling policies\n       try {\n         SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n         policy.initialize(scheduler.getClusterCapacity());\n         queue.setPolicy(policy);\n       } catch (AllocationConfigurationException ex) {\n         LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n             + queue.getName(), ex);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Make sure all queues exist\n    for (String name : queueConf.getQueueNames()) {\n      if (removeEmptyIncompatibleQueues(name)) {\n        getLeafQueue(name, true);\n      }\n    }\n    \n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterCapacity());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 7:26 PM",
      "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthor": "Sanford Ryza",
      "diff": "@@ -0,0 +1,22 @@\n+  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n+    // Make sure all queues exist\n+    for (String name : queueConf.getQueueNames()) {\n+      getLeafQueue(name, true);\n+    }\n+    \n+    for (FSQueue queue : queues.values()) {\n+      // Update queue metrics\n+      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n+      queueMetrics.setMinShare(queue.getMinShare());\n+      queueMetrics.setMaxShare(queue.getMaxShare());\n+      // Set scheduling policies\n+      try {\n+        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n+        policy.initialize(scheduler.getClusterCapacity());\n+        queue.setPolicy(policy);\n+      } catch (AllocationConfigurationException ex) {\n+        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n+            + queue.getName(), ex);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateAllocationConfiguration(AllocationConfiguration queueConf) {\n    // Make sure all queues exist\n    for (String name : queueConf.getQueueNames()) {\n      getLeafQueue(name, true);\n    }\n    \n    for (FSQueue queue : queues.values()) {\n      // Update queue metrics\n      FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n      queueMetrics.setMinShare(queue.getMinShare());\n      queueMetrics.setMaxShare(queue.getMaxShare());\n      // Set scheduling policies\n      try {\n        SchedulingPolicy policy \u003d queueConf.getSchedulingPolicy(queue.getName());\n        policy.initialize(scheduler.getClusterCapacity());\n        queue.setPolicy(policy);\n      } catch (AllocationConfigurationException ex) {\n        LOG.warn(\"Cannot apply configured scheduling policy to queue \"\n            + queue.getName(), ex);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java"
    }
  }
}