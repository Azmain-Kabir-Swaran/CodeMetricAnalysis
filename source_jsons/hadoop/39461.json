{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractCSQueue.java",
  "functionName": "setupQueueConfigs",
  "functionId": "setupQueueConfigs___clusterResource-Resource__configuration-CapacitySchedulerConfiguration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
  "functionStartLine": 352,
  "functionEndLine": 464,
  "numCommitsSeen": 76,
  "timeTaken": 6540,
  "changeHistory": [
    "e578e52aae01248507e089b406fe038ab8e84207",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "a4bd64e724cbe2ef639c984ddfe2da3baf170a96",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
    "949721508467968d5f46170353716ad04349cd6f",
    "bddfe42e2ccda2e6cc9d149461640ba36eca5922",
    "c5e6e3de1c31eda052f89eddd7bba288625936b9",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c"
  ],
  "changeHistoryShort": {
    "e578e52aae01248507e089b406fe038ab8e84207": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "a4bd64e724cbe2ef639c984ddfe2da3baf170a96": "Ybodychange",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": "Ybodychange",
    "949721508467968d5f46170353716ad04349cd6f": "Ybodychange",
    "bddfe42e2ccda2e6cc9d149461640ba36eca5922": "Ybodychange",
    "c5e6e3de1c31eda052f89eddd7bba288625936b9": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e578e52aae01248507e089b406fe038ab8e84207": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10084. Allow inheritance of max app lifetime / default app lifetime. Contributed by Eric Payne.\n",
      "commitDate": "28/01/20 7:54 PM",
      "commitName": "e578e52aae01248507e089b406fe038ab8e84207",
      "commitAuthor": "Eric Badger",
      "commitDateOld": "31/08/19 9:30 PM",
      "commitNameOld": "c7ef4fb74acacdb184d12bafadd8fb040b5c04b6",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 149.98,
      "commitsBetweenForRepo": 731,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,113 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration configuration) throws\n       IOException {\n \n     writeLock.lock();\n     try {\n       // get labels\n       this.accessibleLabels \u003d\n           configuration.getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           configuration.getDefaultNodeLabelExpression(\n               getQueuePath());\n       this.resourceTypes \u003d new HashSet\u003cString\u003e();\n       for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n         resourceTypes.add(type.toString().toLowerCase());\n       }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities(configuration);\n \n       // Also fetch minimum/maximum resource constraint for this queue if\n       // configured.\n       capacityConfigType \u003d CapacityConfigType.NONE;\n       updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n \n       // Setup queue\u0027s maximumAllocation respecting the global setting\n       // and queue setting\n       setupMaximumAllocation(configuration);\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d configuration\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d configuration.getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n           configuration);\n       this.intraQueuePreemptionDisabledInHierarchy \u003d\n           isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n \n       this.priority \u003d configuration.getQueuePriority(\n           getQueuePath());\n \n       // Update multi-node sorting algorithm for scheduling as configured.\n       setMultiNodeSortingPolicyName(\n           configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n \n       this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n+\n+      maxApplicationLifetime \u003d getInheritedMaxAppLifetime(this, configuration);\n+      defaultApplicationLifetime \u003d\n+          getInheritedDefaultAppLifetime(this, configuration,\n+              maxApplicationLifetime);\n+      if (maxApplicationLifetime \u003e 0 \u0026\u0026\n+          defaultApplicationLifetime \u003e maxApplicationLifetime) {\n+        throw new YarnRuntimeException(\n+            \"Default lifetime \" + defaultApplicationLifetime\n+                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n+      }\n+      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n+          ? defaultApplicationLifetime : maxApplicationLifetime;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    writeLock.lock();\n    try {\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      // Setup queue\u0027s maximumAllocation respecting the global setting\n      // and queue setting\n      setupMaximumAllocation(configuration);\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n      this.intraQueuePreemptionDisabledInHierarchy \u003d\n          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      // Update multi-node sorting algorithm for scheduling as configured.\n      setMultiNodeSortingPolicyName(\n          configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n\n      maxApplicationLifetime \u003d getInheritedMaxAppLifetime(this, configuration);\n      defaultApplicationLifetime \u003d\n          getInheritedDefaultAppLifetime(this, configuration,\n              maxApplicationLifetime);\n      if (maxApplicationLifetime \u003e 0 \u0026\u0026\n          defaultApplicationLifetime \u003e maxApplicationLifetime) {\n        throw new YarnRuntimeException(\n            \"Default lifetime \" + defaultApplicationLifetime\n                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n      }\n      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n          ? defaultApplicationLifetime : maxApplicationLifetime;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration configuration) throws\n       IOException {\n \n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           configuration.getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           configuration.getDefaultNodeLabelExpression(\n               getQueuePath());\n       this.resourceTypes \u003d new HashSet\u003cString\u003e();\n       for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n         resourceTypes.add(type.toString().toLowerCase());\n       }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities(configuration);\n \n       // Also fetch minimum/maximum resource constraint for this queue if\n       // configured.\n       capacityConfigType \u003d CapacityConfigType.NONE;\n       updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n \n       // Setup queue\u0027s maximumAllocation respecting the global setting\n       // and queue setting\n       setupMaximumAllocation(configuration);\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d configuration\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d configuration.getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n           configuration);\n       this.intraQueuePreemptionDisabledInHierarchy \u003d\n           isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n \n       this.priority \u003d configuration.getQueuePriority(\n           getQueuePath());\n \n       // Update multi-node sorting algorithm for scheduling as configured.\n       setMultiNodeSortingPolicyName(\n           configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n \n       this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    writeLock.lock();\n    try {\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      // Setup queue\u0027s maximumAllocation respecting the global setting\n      // and queue setting\n      setupMaximumAllocation(configuration);\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n      this.intraQueuePreemptionDisabledInHierarchy \u003d\n          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      // Update multi-node sorting algorithm for scheduling as configured.\n      setMultiNodeSortingPolicyName(\n          configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "a4bd64e724cbe2ef639c984ddfe2da3baf170a96": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9116. Capacity Scheduler: implements queue level maximum-allocation inheritance. Contributed by Aihua Xu.\n",
      "commitDate": "24/01/19 1:53 AM",
      "commitName": "a4bd64e724cbe2ef639c984ddfe2da3baf170a96",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "21/08/18 7:42 AM",
      "commitNameOld": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 155.8,
      "commitsBetweenForRepo": 1233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration configuration) throws\n       IOException {\n \n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           configuration.getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           configuration.getDefaultNodeLabelExpression(\n               getQueuePath());\n       this.resourceTypes \u003d new HashSet\u003cString\u003e();\n       for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n         resourceTypes.add(type.toString().toLowerCase());\n       }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities(configuration);\n \n       // Also fetch minimum/maximum resource constraint for this queue if\n       // configured.\n       capacityConfigType \u003d CapacityConfigType.NONE;\n       updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n \n-      this.maximumAllocation \u003d\n-          configuration.getMaximumAllocationPerQueue(\n-              getQueuePath());\n+      // Setup queue\u0027s maximumAllocation respecting the global setting\n+      // and queue setting\n+      setupMaximumAllocation(configuration);\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d configuration\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d configuration.getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n           configuration);\n       this.intraQueuePreemptionDisabledInHierarchy \u003d\n           isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n \n       this.priority \u003d configuration.getQueuePriority(\n           getQueuePath());\n \n       // Update multi-node sorting algorithm for scheduling as configured.\n       setMultiNodeSortingPolicyName(\n           configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n \n       this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      // Setup queue\u0027s maximumAllocation respecting the global setting\n      // and queue setting\n      setupMaximumAllocation(configuration);\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n      this.intraQueuePreemptionDisabledInHierarchy \u003d\n          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      // Update multi-node sorting algorithm for scheduling as configured.\n      setMultiNodeSortingPolicyName(\n          configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
      "commitDate": "21/08/18 7:42 AM",
      "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 69.96,
      "commitsBetweenForRepo": 500,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,100 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration configuration) throws\n       IOException {\n \n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           configuration.getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           configuration.getDefaultNodeLabelExpression(\n               getQueuePath());\n       this.resourceTypes \u003d new HashSet\u003cString\u003e();\n       for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n         resourceTypes.add(type.toString().toLowerCase());\n       }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities(configuration);\n \n       // Also fetch minimum/maximum resource constraint for this queue if\n       // configured.\n       capacityConfigType \u003d CapacityConfigType.NONE;\n       updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n \n       this.maximumAllocation \u003d\n           configuration.getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d configuration\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d configuration.getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n           configuration);\n       this.intraQueuePreemptionDisabledInHierarchy \u003d\n           isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n \n       this.priority \u003d configuration.getQueuePriority(\n           getQueuePath());\n \n+      // Update multi-node sorting algorithm for scheduling as configured.\n+      setMultiNodeSortingPolicyName(\n+          configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n+\n       this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      this.maximumAllocation \u003d\n          configuration.getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n      this.intraQueuePreemptionDisabledInHierarchy \u003d\n          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      // Update multi-node sorting algorithm for scheduling as configured.\n      setMultiNodeSortingPolicyName(\n          configuration.getMultiNodesSortingAlgorithmPolicy(getQueuePath()));\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "949721508467968d5f46170353716ad04349cd6f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7813. Capacity Scheduler Intra-queue Preemption should be configurable for each queue. Contributed by Eric Payne\n",
      "commitDate": "19/02/18 12:06 PM",
      "commitName": "949721508467968d5f46170353716ad04349cd6f",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "14/02/18 12:29 PM",
      "commitNameOld": "bddfe42e2ccda2e6cc9d149461640ba36eca5922",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 4.98,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,96 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration configuration) throws\n       IOException {\n \n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           configuration.getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           configuration.getDefaultNodeLabelExpression(\n               getQueuePath());\n       this.resourceTypes \u003d new HashSet\u003cString\u003e();\n       for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n         resourceTypes.add(type.toString().toLowerCase());\n       }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities(configuration);\n \n       // Also fetch minimum/maximum resource constraint for this queue if\n       // configured.\n       capacityConfigType \u003d CapacityConfigType.NONE;\n       updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n \n       this.maximumAllocation \u003d\n           configuration.getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d configuration\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d configuration.getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n           configuration);\n+      this.intraQueuePreemptionDisabledInHierarchy \u003d\n+          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n \n       this.priority \u003d configuration.getQueuePriority(\n           getQueuePath());\n \n       this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      this.maximumAllocation \u003d\n          configuration.getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n      this.intraQueuePreemptionDisabledInHierarchy \u003d\n          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "bddfe42e2ccda2e6cc9d149461640ba36eca5922": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7813: Capacity Scheduler Intra-queue Preemption should be configurable for each queue\"\n\nThis reverts commit c5e6e3de1c31eda052f89eddd7bba288625936b9.\n",
      "commitDate": "14/02/18 12:29 PM",
      "commitName": "bddfe42e2ccda2e6cc9d149461640ba36eca5922",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "13/02/18 8:11 AM",
      "commitNameOld": "c5e6e3de1c31eda052f89eddd7bba288625936b9",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 1.18,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,94 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration configuration) throws\n       IOException {\n \n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           configuration.getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           configuration.getDefaultNodeLabelExpression(\n               getQueuePath());\n       this.resourceTypes \u003d new HashSet\u003cString\u003e();\n       for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n         resourceTypes.add(type.toString().toLowerCase());\n       }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities(configuration);\n \n       // Also fetch minimum/maximum resource constraint for this queue if\n       // configured.\n       capacityConfigType \u003d CapacityConfigType.NONE;\n       updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n \n       this.maximumAllocation \u003d\n           configuration.getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d configuration\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d configuration.getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n           configuration);\n-      this.intraQueuePreemptionDisabledInHierarchy \u003d\n-          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n \n       this.priority \u003d configuration.getQueuePriority(\n           getQueuePath());\n \n       this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      this.maximumAllocation \u003d\n          configuration.getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "c5e6e3de1c31eda052f89eddd7bba288625936b9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7813: Capacity Scheduler Intra-queue Preemption should be configurable for each queue\n",
      "commitDate": "13/02/18 8:11 AM",
      "commitName": "c5e6e3de1c31eda052f89eddd7bba288625936b9",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "13/12/17 9:19 AM",
      "commitNameOld": "cb87e4dc927731e32b0bbcf678bb5600835ff28d",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 61.95,
      "commitsBetweenForRepo": 362,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,96 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration configuration) throws\n       IOException {\n \n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           configuration.getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           configuration.getDefaultNodeLabelExpression(\n               getQueuePath());\n       this.resourceTypes \u003d new HashSet\u003cString\u003e();\n       for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n         resourceTypes.add(type.toString().toLowerCase());\n       }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities(configuration);\n \n       // Also fetch minimum/maximum resource constraint for this queue if\n       // configured.\n       capacityConfigType \u003d CapacityConfigType.NONE;\n       updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n \n       this.maximumAllocation \u003d\n           configuration.getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d configuration\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d configuration.getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n           configuration);\n+      this.intraQueuePreemptionDisabledInHierarchy \u003d\n+          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n \n       this.priority \u003d configuration.getQueuePriority(\n           getQueuePath());\n \n       this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      this.maximumAllocation \u003d\n          configuration.getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n      this.intraQueuePreemptionDisabledInHierarchy \u003d\n          isIntraQueueHierarchyPreemptionDisabled(this, configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,94 @@\n+  protected void setupQueueConfigs(Resource clusterResource,\n+      CapacitySchedulerConfiguration configuration) throws\n+      IOException {\n+\n+    try {\n+      writeLock.lock();\n+      // get labels\n+      this.accessibleLabels \u003d\n+          configuration.getAccessibleNodeLabels(getQueuePath());\n+      this.defaultLabelExpression \u003d\n+          configuration.getDefaultNodeLabelExpression(\n+              getQueuePath());\n+      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n+      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n+        resourceTypes.add(type.toString().toLowerCase());\n+      }\n+\n+      // inherit from parent if labels not set\n+      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n+        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n+      }\n+\n+      // inherit from parent if labels not set\n+      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n+          \u0026\u0026 this.accessibleLabels.containsAll(\n+          parent.getAccessibleNodeLabels())) {\n+        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n+      }\n+\n+      // After we setup labels, we can setup capacities\n+      setupConfigurableCapacities(configuration);\n+\n+      // Also fetch minimum/maximum resource constraint for this queue if\n+      // configured.\n+      capacityConfigType \u003d CapacityConfigType.NONE;\n+      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n+\n+      this.maximumAllocation \u003d\n+          configuration.getMaximumAllocationPerQueue(\n+              getQueuePath());\n+\n+      // initialized the queue state based on previous state, configured state\n+      // and its parent state.\n+      QueueState previous \u003d getState();\n+      QueueState configuredState \u003d configuration\n+          .getConfiguredState(getQueuePath());\n+      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n+      initializeQueueState(previous, configuredState, parentState);\n+\n+      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n+\n+      this.acls \u003d configuration.getAcls(getQueuePath());\n+\n+      // Update metrics\n+      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n+          this, labelManager, null);\n+\n+      // Check if labels of this queue is a subset of parent queue, only do this\n+      // when we not root\n+      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n+        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n+            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n+          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n+          if (this.getAccessibleNodeLabels().contains(\n+              RMNodeLabelsManager.ANY)) {\n+            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n+                + \"but child\u0027s accessible queue is *\");\n+          } else{\n+            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n+                parent.getAccessibleNodeLabels());\n+            if (!diff.isEmpty()) {\n+              throw new IOException(\n+                  \"Some labels of child queue is not a subset \"\n+                      + \"of parent queue, these labels\u003d[\" + StringUtils\n+                      .join(diff, \",\") + \"]\");\n+            }\n+          }\n+        }\n+      }\n+\n+      this.reservationsContinueLooking \u003d\n+          csContext.getConfiguration().getReservationContinueLook();\n+\n+      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n+          configuration);\n+\n+      this.priority \u003d configuration.getQueuePriority(\n+          getQueuePath());\n+\n+      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration configuration) throws\n      IOException {\n\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          configuration.getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          configuration.getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities(configuration);\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      this.maximumAllocation \u003d\n          configuration.getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d configuration\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d configuration.getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this,\n          configuration);\n\n      this.priority \u003d configuration.getQueuePriority(\n          getQueuePath());\n\n      this.userWeights \u003d getUserWeightsFromHierarchy(configuration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java"
    }
  }
}