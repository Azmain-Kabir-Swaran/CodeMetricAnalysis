{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AppLogAggregatorImpl.java",
  "functionName": "doAppLogAggregation",
  "functionId": "doAppLogAggregation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
  "functionStartLine": 488,
  "functionEndLine": 529,
  "numCommitsSeen": 72,
  "timeTaken": 12660,
  "changeHistory": [
    "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
    "25e2b02122c4ed760227ab33c49d3445c23b9276",
    "863079bb874ba77918ca1c0741eae10e245995c8",
    "ab0b958a522d502426b91b6e4ab6dd29caccc372",
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
    "cb81bac0029fce3a9726df3523f0b692cd3375b8",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b",
    "5a1b33507b935f91d6dee6056fe840e778fb198e",
    "f0a6d06485102ae6a58c46ee0b3b0aac8fcc0d74",
    "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "611294084103532fa599d97921339c281684681c",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "b22f56c4719e63bd4f6edc2a075e0bcdb9442255": "Ymultichange(Yexceptionschange,Ybodychange)",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": "Ybodychange",
    "25e2b02122c4ed760227ab33c49d3445c23b9276": "Ybodychange",
    "863079bb874ba77918ca1c0741eae10e245995c8": "Ybodychange",
    "ab0b958a522d502426b91b6e4ab6dd29caccc372": "Ybodychange",
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000": "Ybodychange",
    "cb81bac0029fce3a9726df3523f0b692cd3375b8": "Ybodychange",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": "Ybodychange",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": "Ybodychange",
    "5a1b33507b935f91d6dee6056fe840e778fb198e": "Ybodychange",
    "f0a6d06485102ae6a58c46ee0b3b0aac8fcc0d74": "Ybodychange",
    "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "611294084103532fa599d97921339c281684681c": "Ymultichange(Yrename,Ymodifierchange,Ybodychange)",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ybodychange",
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Ymultichange(Ymovefromfile,Yexceptionschange,Ybodychange,Yparameterchange)",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b22f56c4719e63bd4f6edc2a075e0bcdb9442255": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-8273. Log aggregation does not warn if HDFS quota in target directory is exceeded (grepas via rkanter)\n",
      "commitDate": "22/05/18 2:24 PM",
      "commitName": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-8273. Log aggregation does not warn if HDFS quota in target directory is exceeded (grepas via rkanter)\n",
          "commitDate": "22/05/18 2:24 PM",
          "commitName": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "15/03/18 1:26 PM",
          "commitNameOld": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 68.04,
          "commitsBetweenForRepo": 1090,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,42 @@\n-  private void doAppLogAggregation() {\n+  private void doAppLogAggregation() throws LogAggregationDFSException {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n           waiting.set(true);\n           if (logControllerContext.isLogAggregationInRolling()) {\n             wait(logControllerContext.getRollingMonitorInterval() * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n             uploadLogsForContainers(false);\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n+        } catch (LogAggregationDFSException e) {\n+          this.appFinishing.set(true);\n+          throw e;\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n-    // App is finished, upload the container logs.\n-    uploadLogsForContainers(true);\n+    try {\n+      // App is finished, upload the container logs.\n+      uploadLogsForContainers(true);\n \n-    doAppLogAggregationPostCleanUp();\n+      doAppLogAggregationPostCleanUp();\n+    } catch (LogAggregationDFSException e) {\n+      LOG.error(\"Error during log aggregation\", e);\n+    }\n \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doAppLogAggregation() throws LogAggregationDFSException {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          waiting.set(true);\n          if (logControllerContext.isLogAggregationInRolling()) {\n            wait(logControllerContext.getRollingMonitorInterval() * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers(false);\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        } catch (LogAggregationDFSException e) {\n          this.appFinishing.set(true);\n          throw e;\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    try {\n      // App is finished, upload the container logs.\n      uploadLogsForContainers(true);\n\n      doAppLogAggregationPostCleanUp();\n    } catch (LogAggregationDFSException e) {\n      LOG.error(\"Error during log aggregation\", e);\n    }\n\n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[LogAggregationDFSException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8273. Log aggregation does not warn if HDFS quota in target directory is exceeded (grepas via rkanter)\n",
          "commitDate": "22/05/18 2:24 PM",
          "commitName": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "15/03/18 1:26 PM",
          "commitNameOld": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 68.04,
          "commitsBetweenForRepo": 1090,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,42 @@\n-  private void doAppLogAggregation() {\n+  private void doAppLogAggregation() throws LogAggregationDFSException {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n           waiting.set(true);\n           if (logControllerContext.isLogAggregationInRolling()) {\n             wait(logControllerContext.getRollingMonitorInterval() * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n             uploadLogsForContainers(false);\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n+        } catch (LogAggregationDFSException e) {\n+          this.appFinishing.set(true);\n+          throw e;\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n-    // App is finished, upload the container logs.\n-    uploadLogsForContainers(true);\n+    try {\n+      // App is finished, upload the container logs.\n+      uploadLogsForContainers(true);\n \n-    doAppLogAggregationPostCleanUp();\n+      doAppLogAggregationPostCleanUp();\n+    } catch (LogAggregationDFSException e) {\n+      LOG.error(\"Error during log aggregation\", e);\n+    }\n \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doAppLogAggregation() throws LogAggregationDFSException {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          waiting.set(true);\n          if (logControllerContext.isLogAggregationInRolling()) {\n            wait(logControllerContext.getRollingMonitorInterval() * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers(false);\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        } catch (LogAggregationDFSException e) {\n          this.appFinishing.set(true);\n          throw e;\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    try {\n      // App is finished, upload the container logs.\n      uploadLogsForContainers(true);\n\n      doAppLogAggregationPostCleanUp();\n    } catch (LogAggregationDFSException e) {\n      LOG.error(\"Error during log aggregation\", e);\n    }\n\n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6876. Create an abstract log writer for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "24/08/17 1:36 PM",
      "commitName": "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 2.52,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private void doAppLogAggregation() {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n           waiting.set(true);\n-          if (logAggregationInRolling) {\n-            wait(this.rollingMonitorInterval * 1000);\n+          if (logControllerContext.isLogAggregationInRolling()) {\n+            wait(logControllerContext.getRollingMonitorInterval() * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n             uploadLogsForContainers(false);\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n     // App is finished, upload the container logs.\n     uploadLogsForContainers(true);\n \n     doAppLogAggregationPostCleanUp();\n \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          waiting.set(true);\n          if (logControllerContext.isLogAggregationInRolling()) {\n            wait(logControllerContext.getRollingMonitorInterval() * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers(false);\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // App is finished, upload the container logs.\n    uploadLogsForContainers(true);\n\n    doAppLogAggregationPostCleanUp();\n\n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "25e2b02122c4ed760227ab33c49d3445c23b9276": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3476. Nodemanager can fail to delete local logs if log aggregation fails. Contributed by Rohith\n",
      "commitDate": "08/05/15 3:45 PM",
      "commitName": "25e2b02122c4ed760227ab33c49d3445c23b9276",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "17/04/15 1:18 PM",
      "commitNameOld": "1db355a875c3ecc40a244045c6812e00c8d36ef1",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 21.1,
      "commitsBetweenForRepo": 253,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,35 @@\n   private void doAppLogAggregation() {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n           waiting.set(true);\n           if (logAggregationInRolling) {\n             wait(this.rollingMonitorInterval * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n             uploadLogsForContainers(false);\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n     // App is finished, upload the container logs.\n     uploadLogsForContainers(true);\n \n-    // Remove the local app-log-dirs\n-    List\u003cPath\u003e localAppLogDirs \u003d new ArrayList\u003cPath\u003e();\n-    for (String rootLogDir : dirsHandler.getLogDirsForCleanup()) {\n-      Path logPath \u003d new Path(rootLogDir, applicationId);\n-      try {\n-        // check if log dir exists\n-        lfs.getFileStatus(logPath);\n-        localAppLogDirs.add(logPath);\n-      } catch (UnsupportedFileSystemException ue) {\n-        LOG.warn(\"Log dir \" + rootLogDir + \"is an unsupported file system\", ue);\n-        continue;\n-      } catch (IOException fe) {\n-        continue;\n-      }\n-    }\n+    doAppLogAggregationPostCleanUp();\n \n-    if (localAppLogDirs.size() \u003e 0) {\n-      this.delService.delete(this.userUgi.getShortUserName(), null,\n-        localAppLogDirs.toArray(new Path[localAppLogDirs.size()]));\n-    }\n-    \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n-    this.appAggregationFinished.set(true);    \n+    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          waiting.set(true);\n          if (logAggregationInRolling) {\n            wait(this.rollingMonitorInterval * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers(false);\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // App is finished, upload the container logs.\n    uploadLogsForContainers(true);\n\n    doAppLogAggregationPostCleanUp();\n\n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "863079bb874ba77918ca1c0741eae10e245995c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
      "commitDate": "12/03/15 1:32 PM",
      "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/02/15 2:02 PM",
      "commitNameOld": "f56c65bb3eb9436b67de2df63098e26589e70e56",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 19.94,
      "commitsBetweenForRepo": 149,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private void doAppLogAggregation() {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n           waiting.set(true);\n-          if (this.rollingMonitorInterval \u003e 0) {\n+          if (logAggregationInRolling) {\n             wait(this.rollingMonitorInterval * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n-            uploadLogsForContainers();\n+            uploadLogsForContainers(false);\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n     // App is finished, upload the container logs.\n-    uploadLogsForContainers();\n+    uploadLogsForContainers(true);\n \n     // Remove the local app-log-dirs\n     List\u003cPath\u003e localAppLogDirs \u003d new ArrayList\u003cPath\u003e();\n     for (String rootLogDir : dirsHandler.getLogDirsForCleanup()) {\n       Path logPath \u003d new Path(rootLogDir, applicationId);\n       try {\n         // check if log dir exists\n         lfs.getFileStatus(logPath);\n         localAppLogDirs.add(logPath);\n       } catch (UnsupportedFileSystemException ue) {\n         LOG.warn(\"Log dir \" + rootLogDir + \"is an unsupported file system\", ue);\n         continue;\n       } catch (IOException fe) {\n         continue;\n       }\n     }\n \n     if (localAppLogDirs.size() \u003e 0) {\n       this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs.toArray(new Path[localAppLogDirs.size()]));\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          waiting.set(true);\n          if (logAggregationInRolling) {\n            wait(this.rollingMonitorInterval * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers(false);\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // App is finished, upload the container logs.\n    uploadLogsForContainers(true);\n\n    // Remove the local app-log-dirs\n    List\u003cPath\u003e localAppLogDirs \u003d new ArrayList\u003cPath\u003e();\n    for (String rootLogDir : dirsHandler.getLogDirsForCleanup()) {\n      Path logPath \u003d new Path(rootLogDir, applicationId);\n      try {\n        // check if log dir exists\n        lfs.getFileStatus(logPath);\n        localAppLogDirs.add(logPath);\n      } catch (UnsupportedFileSystemException ue) {\n        LOG.warn(\"Log dir \" + rootLogDir + \"is an unsupported file system\", ue);\n        continue;\n      } catch (IOException fe) {\n        continue;\n      }\n    }\n\n    if (localAppLogDirs.size() \u003e 0) {\n      this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs.toArray(new Path[localAppLogDirs.size()]));\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "ab0b958a522d502426b91b6e4ab6dd29caccc372": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2749. Fix some testcases from TestLogAggregationService fails in trunk. (Contributed by Xuan Gong)\n",
      "commitDate": "15/02/15 6:46 AM",
      "commitName": "ab0b958a522d502426b91b6e4ab6dd29caccc372",
      "commitAuthor": "Junping Du",
      "commitDateOld": "12/11/14 11:07 AM",
      "commitNameOld": "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 94.82,
      "commitsBetweenForRepo": 687,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,54 @@\n   private void doAppLogAggregation() {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n+          waiting.set(true);\n           if (this.rollingMonitorInterval \u003e 0) {\n             wait(this.rollingMonitorInterval * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n             uploadLogsForContainers();\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n     // App is finished, upload the container logs.\n     uploadLogsForContainers();\n \n     // Remove the local app-log-dirs\n     List\u003cPath\u003e localAppLogDirs \u003d new ArrayList\u003cPath\u003e();\n     for (String rootLogDir : dirsHandler.getLogDirsForCleanup()) {\n       Path logPath \u003d new Path(rootLogDir, applicationId);\n       try {\n         // check if log dir exists\n         lfs.getFileStatus(logPath);\n         localAppLogDirs.add(logPath);\n       } catch (UnsupportedFileSystemException ue) {\n         LOG.warn(\"Log dir \" + rootLogDir + \"is an unsupported file system\", ue);\n         continue;\n       } catch (IOException fe) {\n         continue;\n       }\n     }\n \n     if (localAppLogDirs.size() \u003e 0) {\n       this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs.toArray(new Path[localAppLogDirs.size()]));\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          waiting.set(true);\n          if (this.rollingMonitorInterval \u003e 0) {\n            wait(this.rollingMonitorInterval * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers();\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // App is finished, upload the container logs.\n    uploadLogsForContainers();\n\n    // Remove the local app-log-dirs\n    List\u003cPath\u003e localAppLogDirs \u003d new ArrayList\u003cPath\u003e();\n    for (String rootLogDir : dirsHandler.getLogDirsForCleanup()) {\n      Path logPath \u003d new Path(rootLogDir, applicationId);\n      try {\n        // check if log dir exists\n        lfs.getFileStatus(logPath);\n        localAppLogDirs.add(logPath);\n      } catch (UnsupportedFileSystemException ue) {\n        LOG.warn(\"Log dir \" + rootLogDir + \"is an unsupported file system\", ue);\n        continue;\n      } catch (IOException fe) {\n        continue;\n      }\n    }\n\n    if (localAppLogDirs.size() \u003e 0) {\n      this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs.toArray(new Path[localAppLogDirs.size()]));\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000": {
      "type": "Ybodychange",
      "commitMessage": "YARN-90. NodeManager should identify failed disks becoming good again. Contributed by Varun Vasudev\n",
      "commitDate": "21/10/14 10:31 AM",
      "commitName": "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/10/14 3:22 PM",
      "commitNameOld": "0af1a2b5bc1469ba22edb63cd58f9b436b1dc4d3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 5.8,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,53 @@\n   private void doAppLogAggregation() {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n           if (this.rollingMonitorInterval \u003e 0) {\n             wait(this.rollingMonitorInterval * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n             uploadLogsForContainers();\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n     // App is finished, upload the container logs.\n     uploadLogsForContainers();\n \n     // Remove the local app-log-dirs\n-    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n-    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n-    int index \u003d 0;\n-    for (String rootLogDir : rootLogDirs) {\n-      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n-      index++;\n+    List\u003cPath\u003e localAppLogDirs \u003d new ArrayList\u003cPath\u003e();\n+    for (String rootLogDir : dirsHandler.getLogDirsForCleanup()) {\n+      Path logPath \u003d new Path(rootLogDir, applicationId);\n+      try {\n+        // check if log dir exists\n+        lfs.getFileStatus(logPath);\n+        localAppLogDirs.add(logPath);\n+      } catch (UnsupportedFileSystemException ue) {\n+        LOG.warn(\"Log dir \" + rootLogDir + \"is an unsupported file system\", ue);\n+        continue;\n+      } catch (IOException fe) {\n+        continue;\n+      }\n     }\n-    this.delService.delete(this.userUgi.getShortUserName(), null,\n-        localAppLogDirs);\n+\n+    if (localAppLogDirs.size() \u003e 0) {\n+      this.delService.delete(this.userUgi.getShortUserName(), null,\n+        localAppLogDirs.toArray(new Path[localAppLogDirs.size()]));\n+    }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          if (this.rollingMonitorInterval \u003e 0) {\n            wait(this.rollingMonitorInterval * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers();\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // App is finished, upload the container logs.\n    uploadLogsForContainers();\n\n    // Remove the local app-log-dirs\n    List\u003cPath\u003e localAppLogDirs \u003d new ArrayList\u003cPath\u003e();\n    for (String rootLogDir : dirsHandler.getLogDirsForCleanup()) {\n      Path logPath \u003d new Path(rootLogDir, applicationId);\n      try {\n        // check if log dir exists\n        lfs.getFileStatus(logPath);\n        localAppLogDirs.add(logPath);\n      } catch (UnsupportedFileSystemException ue) {\n        LOG.warn(\"Log dir \" + rootLogDir + \"is an unsupported file system\", ue);\n        continue;\n      } catch (IOException fe) {\n        continue;\n      }\n    }\n\n    if (localAppLogDirs.size() \u003e 0) {\n      this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs.toArray(new Path[localAppLogDirs.size()]));\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "cb81bac0029fce3a9726df3523f0b692cd3375b8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2583. Modified AggregatedLogDeletionService to be able to delete rolling aggregated logs. Contributed by Xuan Gong.\n",
      "commitDate": "10/10/14 12:11 AM",
      "commitName": "cb81bac0029fce3a9726df3523f0b692cd3375b8",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "03/10/14 12:15 PM",
      "commitNameOld": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.5,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,43 @@\n   private void doAppLogAggregation() {\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n-          if (this.logAggregationContext !\u003d null \u0026\u0026 this.logAggregationContext\n-              .getRollingIntervalSeconds() \u003e 0) {\n-            wait(this.logAggregationContext.getRollingIntervalSeconds() * 1000);\n+          if (this.rollingMonitorInterval \u003e 0) {\n+            wait(this.rollingMonitorInterval * 1000);\n             if (this.appFinishing.get() || this.aborted.get()) {\n               break;\n             }\n             uploadLogsForContainers();\n           } else {\n             wait(THREAD_SLEEP_TIME);\n           }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n     // App is finished, upload the container logs.\n     uploadLogsForContainers();\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          if (this.rollingMonitorInterval \u003e 0) {\n            wait(this.rollingMonitorInterval * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers();\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // App is finished, upload the container logs.\n    uploadLogsForContainers();\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
      "commitDate": "03/10/14 12:15 PM",
      "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/08/14 3:56 AM",
      "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 52.35,
      "commitsBetweenForRepo": 563,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,44 @@\n   private void doAppLogAggregation() {\n-    ContainerId containerId;\n-\n     while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n-          wait(THREAD_SLEEP_TIME);\n+          if (this.logAggregationContext !\u003d null \u0026\u0026 this.logAggregationContext\n+              .getRollingIntervalSeconds() \u003e 0) {\n+            wait(this.logAggregationContext.getRollingIntervalSeconds() * 1000);\n+            if (this.appFinishing.get() || this.aborted.get()) {\n+              break;\n+            }\n+            uploadLogsForContainers();\n+          } else {\n+            wait(THREAD_SLEEP_TIME);\n+          }\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     if (this.aborted.get()) {\n       return;\n     }\n \n-    // Application is finished. Finish pending-containers\n-    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n-      uploadLogsForContainer(containerId);\n-    }\n+    // App is finished, upload the container logs.\n+    uploadLogsForContainers();\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n-\n-    if (this.writer !\u003d null) {\n-      this.writer.close();\n-      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n-    }\n-\n-    try {\n-      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n-        @Override\n-        public Object run() throws Exception {\n-          FileSystem remoteFS \u003d FileSystem.get(conf);\n-          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n-          return null;\n-        }\n-      });\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to move temporary log file to final location: [\"\n-          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n-          + \"]\", e);\n-    }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          if (this.logAggregationContext !\u003d null \u0026\u0026 this.logAggregationContext\n              .getRollingIntervalSeconds() \u003e 0) {\n            wait(this.logAggregationContext.getRollingIntervalSeconds() * 1000);\n            if (this.appFinishing.get() || this.aborted.get()) {\n              break;\n            }\n            uploadLogsForContainers();\n          } else {\n            wait(THREAD_SLEEP_TIME);\n          }\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // App is finished, upload the container logs.\n    uploadLogsForContainers();\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1337. Recover containers upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 3:56 AM",
      "commitName": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthor": "Junping Du",
      "commitDateOld": "16/12/13 11:27 AM",
      "commitNameOld": "5a1b33507b935f91d6dee6056fe840e778fb198e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 238.64,
      "commitsBetweenForRepo": 1625,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,59 @@\n   private void doAppLogAggregation() {\n     ContainerId containerId;\n \n-    while (!this.appFinishing.get()) {\n+    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n       synchronized(this) {\n         try {\n           wait(THREAD_SLEEP_TIME);\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n+    if (this.aborted.get()) {\n+      return;\n+    }\n+\n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.close();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n \n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get() \u0026\u0026 !this.aborted.get()) {\n      synchronized(this) {\n        try {\n          wait(THREAD_SLEEP_TIME);\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    if (this.aborted.get()) {\n      return;\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.close();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "5a1b33507b935f91d6dee6056fe840e778fb198e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1145. Fixed a potential file-handle leak in the web interface for displaying aggregated logs. Contributed by Rohith Sharma.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551326 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/12/13 11:27 AM",
      "commitName": "5a1b33507b935f91d6dee6056fe840e778fb198e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/05/13 4:14 PM",
      "commitNameOld": "5420f287ccc83df69b6725942754c82b89e46b3e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 200.84,
      "commitsBetweenForRepo": 1311,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   private void doAppLogAggregation() {\n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       synchronized(this) {\n         try {\n           wait(THREAD_SLEEP_TIME);\n         } catch (InterruptedException e) {\n           LOG.warn(\"PendingContainers queue is interrupted\");\n           this.appFinishing.set(true);\n         }\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n-      this.writer.closeWriter();\n+      this.writer.close();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n \n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      synchronized(this) {\n        try {\n          wait(THREAD_SLEEP_TIME);\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.close();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "f0a6d06485102ae6a58c46ee0b3b0aac8fcc0d74": {
      "type": "Ybodychange",
      "commitMessage": "YARN-219. NM should aggregate logs when application finishes. (bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1411289 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/11/12 8:41 AM",
      "commitName": "f0a6d06485102ae6a58c46ee0b3b0aac8fcc0d74",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "05/09/12 12:39 PM",
      "commitNameOld": "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 74.88,
      "commitsBetweenForRepo": 441,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,55 @@\n   private void doAppLogAggregation() {\n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n-      try {\n-        containerId \u003d this.pendingContainers.poll();\n-        if (containerId \u003d\u003d null) {\n-          Thread.sleep(THREAD_SLEEP_TIME);\n-        } else {\n-          uploadLogsForContainer(containerId);\n+      synchronized(this) {\n+        try {\n+          wait(THREAD_SLEEP_TIME);\n+        } catch (InterruptedException e) {\n+          LOG.warn(\"PendingContainers queue is interrupted\");\n+          this.appFinishing.set(true);\n         }\n-      } catch (InterruptedException e) {\n-        LOG.warn(\"PendingContainers queue is interrupted\");\n-        this.appFinishing.set(true);\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n \n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n     this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      synchronized(this) {\n        try {\n          wait(THREAD_SLEEP_TIME);\n        } catch (InterruptedException e) {\n          LOG.warn(\"PendingContainers queue is interrupted\");\n          this.appFinishing.set(true);\n        }\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-68. NodeManager will refuse to shutdown indefinitely due to container log aggregation (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1381317 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/09/12 12:39 PM",
      "commitName": "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 28.6,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,58 @@\n   private void doAppLogAggregation() {\n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       try {\n         containerId \u003d this.pendingContainers.poll();\n         if (containerId \u003d\u003d null) {\n           Thread.sleep(THREAD_SLEEP_TIME);\n         } else {\n           uploadLogsForContainer(containerId);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"PendingContainers queue is interrupted\");\n+        this.appFinishing.set(true);\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n \n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n+    this.appAggregationFinished.set(true);    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n        this.appFinishing.set(true);\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n    this.appAggregationFinished.set(true);    \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java"
      }
    },
    "611294084103532fa599d97921339c281684681c": {
      "type": "Ymultichange(Yrename,Ymodifierchange,Ybodychange)",
      "commitMessage": "MAPREDUCE 3738. NM can hang during shutdown if AppLogAggregatorImpl thread dies unexpectedly. (Contributed by Jason Lowe) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1293060 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/02/12 6:12 PM",
      "commitName": "611294084103532fa599d97921339c281684681c",
      "commitAuthor": "Siddharth Seth",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "MAPREDUCE 3738. NM can hang during shutdown if AppLogAggregatorImpl thread dies unexpectedly. (Contributed by Jason Lowe) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1293060 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/02/12 6:12 PM",
          "commitName": "611294084103532fa599d97921339c281684681c",
          "commitAuthor": "Siddharth Seth",
          "commitDateOld": "14/12/11 11:55 AM",
          "commitNameOld": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 71.26,
          "commitsBetweenForRepo": 374,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,56 @@\n-  public void run() {    \n+  private void doAppLogAggregation() {\n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       try {\n         containerId \u003d this.pendingContainers.poll();\n         if (containerId \u003d\u003d null) {\n           Thread.sleep(THREAD_SLEEP_TIME);\n         } else {\n           uploadLogsForContainer(containerId);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n \n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n-        \n-    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "run",
            "newValue": "doAppLogAggregation"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "MAPREDUCE 3738. NM can hang during shutdown if AppLogAggregatorImpl thread dies unexpectedly. (Contributed by Jason Lowe) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1293060 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/02/12 6:12 PM",
          "commitName": "611294084103532fa599d97921339c281684681c",
          "commitAuthor": "Siddharth Seth",
          "commitDateOld": "14/12/11 11:55 AM",
          "commitNameOld": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 71.26,
          "commitsBetweenForRepo": 374,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,56 @@\n-  public void run() {    \n+  private void doAppLogAggregation() {\n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       try {\n         containerId \u003d this.pendingContainers.poll();\n         if (containerId \u003d\u003d null) {\n           Thread.sleep(THREAD_SLEEP_TIME);\n         } else {\n           uploadLogsForContainer(containerId);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n \n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n-        \n-    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE 3738. NM can hang during shutdown if AppLogAggregatorImpl thread dies unexpectedly. (Contributed by Jason Lowe) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1293060 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/02/12 6:12 PM",
          "commitName": "611294084103532fa599d97921339c281684681c",
          "commitAuthor": "Siddharth Seth",
          "commitDateOld": "14/12/11 11:55 AM",
          "commitNameOld": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 71.26,
          "commitsBetweenForRepo": 374,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,56 @@\n-  public void run() {    \n+  private void doAppLogAggregation() {\n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       try {\n         containerId \u003d this.pendingContainers.poll();\n         if (containerId \u003d\u003d null) {\n           Thread.sleep(THREAD_SLEEP_TIME);\n         } else {\n           uploadLogsForContainer(containerId);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n     Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n     for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n \n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n-        \n-    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doAppLogAggregation() {\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "03/11/11 1:02 AM",
      "commitNameOld": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 26.64,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,57 @@\n   public void run() {    \n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       try {\n         containerId \u003d this.pendingContainers.poll();\n         if (containerId \u003d\u003d null) {\n           Thread.sleep(THREAD_SLEEP_TIME);\n         } else {\n           uploadLogsForContainer(containerId);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n-    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n+    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n+    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n     int index \u003d 0;\n-    for (String rootLogDir : this.rootLogDirs) {\n+    for (String rootLogDir : rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n             ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n         \n     this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {    \n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    List\u003cString\u003e rootLogDirs \u003d dirsHandler.getLogDirs();\n    Path[] localAppLogDirs \u003d new Path[rootLogDirs.size()];\n    int index \u003d 0;\n    for (String rootLogDir : rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n        \n    this.appAggregationFinished.set(true);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2696. Fixed NodeManager to cleanup logs in a thread when logs\u0027 aggregation is not enabled. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195383 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 2:55 AM",
      "commitName": "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/11 11:45 PM",
      "commitNameOld": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.13,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   public void run() {    \n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       try {\n         containerId \u003d this.pendingContainers.poll();\n         if (containerId \u003d\u003d null) {\n           Thread.sleep(THREAD_SLEEP_TIME);\n         } else {\n           uploadLogsForContainer(containerId);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n     int index \u003d 0;\n     for (String rootLogDir : this.rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n     try {\n       userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           FileSystem remoteFS \u003d FileSystem.get(conf);\n           remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n           return null;\n         }\n       });\n     } catch (Exception e) {\n       LOG.error(\"Failed to move temporary log file to final location: [\"\n           + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n           + \"]\", e);\n     }\n     \n     this.dispatcher.getEventHandler().handle(\n         new ApplicationEvent(this.appId,\n-            ApplicationEventType.APPLICATION_LOG_AGGREGATION_FINISHED));\n+            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n         \n     this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {    \n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n    int index \u003d 0;\n    for (String rootLogDir : this.rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));\n        \n    this.appAggregationFinished.set(true);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 64.27,
      "commitsBetweenForRepo": 481,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,56 @@\n-  public void run() {\n-\n+  public void run() {    \n     ContainerId containerId;\n \n     while (!this.appFinishing.get()) {\n       try {\n         containerId \u003d this.pendingContainers.poll();\n         if (containerId \u003d\u003d null) {\n           Thread.sleep(THREAD_SLEEP_TIME);\n         } else {\n           uploadLogsForContainer(containerId);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n \n     // Application is finished. Finish pending-containers\n     while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n       uploadLogsForContainer(containerId);\n     }\n \n     // Remove the local app-log-dirs\n     Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n     int index \u003d 0;\n     for (String rootLogDir : this.rootLogDirs) {\n       localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n       index++;\n     }\n     this.delService.delete(this.userUgi.getShortUserName(), null,\n         localAppLogDirs);\n \n     if (this.writer !\u003d null) {\n       this.writer.closeWriter();\n       LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n     }\n-\n+    try {\n+      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+        @Override\n+        public Object run() throws Exception {\n+          FileSystem remoteFS \u003d FileSystem.get(conf);\n+          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n+          return null;\n+        }\n+      });\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to move temporary log file to final location: [\"\n+          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n+          + \"]\", e);\n+    }\n+    \n+    this.dispatcher.getEventHandler().handle(\n+        new ApplicationEvent(this.appId,\n+            ApplicationEventType.APPLICATION_LOG_AGGREGATION_FINISHED));\n+        \n     this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {    \n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n    int index \u003d 0;\n    for (String rootLogDir : this.rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n    try {\n      userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          FileSystem remoteFS \u003d FileSystem.get(conf);\n          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);\n          return null;\n        }\n      });\n    } catch (Exception e) {\n      LOG.error(\"Failed to move temporary log file to final location: [\"\n          + remoteNodeTmpLogFileForApp + \"] to [\" + remoteNodeLogFileForApp\n          + \"]\", e);\n    }\n    \n    this.dispatcher.getEventHandler().handle(\n        new ApplicationEvent(this.appId,\n            ApplicationEventType.APPLICATION_LOG_AGGREGATION_FINISHED));\n        \n    this.appAggregationFinished.set(true);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void run() {\n\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n    int index \u003d 0;\n    for (String rootLogDir : this.rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    this.appAggregationFinished.set(true);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Ymultichange(Ymovefromfile,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,39 @@\n-  public void run(final JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, ClassNotFoundException, InterruptedException {\n-    this.umbilical \u003d umbilical;\n+  public void run() {\n \n-    if (isMapTask()) {\n-      // If there are no reducers then there won\u0027t be any sort. Hence the map \n-      // phase will govern the entire attempt\u0027s progress.\n-      if (conf.getNumReduceTasks() \u003d\u003d 0) {\n-        mapPhase \u003d getProgress().addPhase(\"map\", 1.0f);\n-      } else {\n-        // If there are reducers then the entire attempt\u0027s progress will be \n-        // split between the map phase (67%) and the sort phase (33%).\n-        mapPhase \u003d getProgress().addPhase(\"map\", 0.667f);\n-        sortPhase  \u003d getProgress().addPhase(\"sort\", 0.333f);\n+    ContainerId containerId;\n+\n+    while (!this.appFinishing.get()) {\n+      try {\n+        containerId \u003d this.pendingContainers.poll();\n+        if (containerId \u003d\u003d null) {\n+          Thread.sleep(THREAD_SLEEP_TIME);\n+        } else {\n+          uploadLogsForContainer(containerId);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n-    TaskReporter reporter \u003d startReporter(umbilical);\n- \n-    boolean useNewApi \u003d job.getUseNewMapper();\n-    initialize(job, getJobID(), reporter, useNewApi);\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n+    // Application is finished. Finish pending-containers\n+    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n+      uploadLogsForContainer(containerId);\n     }\n \n-    if (useNewApi) {\n-      runNewMapper(job, splitMetaInfo, umbilical, reporter);\n-    } else {\n-      runOldMapper(job, splitMetaInfo, umbilical, reporter);\n+    // Remove the local app-log-dirs\n+    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n+    int index \u003d 0;\n+    for (String rootLogDir : this.rootLogDirs) {\n+      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n+      index++;\n     }\n-    done(umbilical, reporter);\n+    this.delService.delete(this.userUgi.getShortUserName(), null,\n+        localAppLogDirs);\n+\n+    if (this.writer !\u003d null) {\n+      this.writer.closeWriter();\n+      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n+    }\n+\n+    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void run() {\n\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n    int index \u003d 0;\n    for (String rootLogDir : this.rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    this.appAggregationFinished.set(true);\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldPath": "mapreduce/src/java/org/apache/hadoop/mapred/MapTask.java",
            "newPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
            "oldMethodName": "run",
            "newMethodName": "run"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,39 @@\n-  public void run(final JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, ClassNotFoundException, InterruptedException {\n-    this.umbilical \u003d umbilical;\n+  public void run() {\n \n-    if (isMapTask()) {\n-      // If there are no reducers then there won\u0027t be any sort. Hence the map \n-      // phase will govern the entire attempt\u0027s progress.\n-      if (conf.getNumReduceTasks() \u003d\u003d 0) {\n-        mapPhase \u003d getProgress().addPhase(\"map\", 1.0f);\n-      } else {\n-        // If there are reducers then the entire attempt\u0027s progress will be \n-        // split between the map phase (67%) and the sort phase (33%).\n-        mapPhase \u003d getProgress().addPhase(\"map\", 0.667f);\n-        sortPhase  \u003d getProgress().addPhase(\"sort\", 0.333f);\n+    ContainerId containerId;\n+\n+    while (!this.appFinishing.get()) {\n+      try {\n+        containerId \u003d this.pendingContainers.poll();\n+        if (containerId \u003d\u003d null) {\n+          Thread.sleep(THREAD_SLEEP_TIME);\n+        } else {\n+          uploadLogsForContainer(containerId);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n-    TaskReporter reporter \u003d startReporter(umbilical);\n- \n-    boolean useNewApi \u003d job.getUseNewMapper();\n-    initialize(job, getJobID(), reporter, useNewApi);\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n+    // Application is finished. Finish pending-containers\n+    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n+      uploadLogsForContainer(containerId);\n     }\n \n-    if (useNewApi) {\n-      runNewMapper(job, splitMetaInfo, umbilical, reporter);\n-    } else {\n-      runOldMapper(job, splitMetaInfo, umbilical, reporter);\n+    // Remove the local app-log-dirs\n+    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n+    int index \u003d 0;\n+    for (String rootLogDir : this.rootLogDirs) {\n+      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n+      index++;\n     }\n-    done(umbilical, reporter);\n+    this.delService.delete(this.userUgi.getShortUserName(), null,\n+        localAppLogDirs);\n+\n+    if (this.writer !\u003d null) {\n+      this.writer.closeWriter();\n+      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n+    }\n+\n+    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void run() {\n\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n    int index \u003d 0;\n    for (String rootLogDir : this.rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    this.appAggregationFinished.set(true);\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[IOException, ClassNotFoundException, InterruptedException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,39 @@\n-  public void run(final JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, ClassNotFoundException, InterruptedException {\n-    this.umbilical \u003d umbilical;\n+  public void run() {\n \n-    if (isMapTask()) {\n-      // If there are no reducers then there won\u0027t be any sort. Hence the map \n-      // phase will govern the entire attempt\u0027s progress.\n-      if (conf.getNumReduceTasks() \u003d\u003d 0) {\n-        mapPhase \u003d getProgress().addPhase(\"map\", 1.0f);\n-      } else {\n-        // If there are reducers then the entire attempt\u0027s progress will be \n-        // split between the map phase (67%) and the sort phase (33%).\n-        mapPhase \u003d getProgress().addPhase(\"map\", 0.667f);\n-        sortPhase  \u003d getProgress().addPhase(\"sort\", 0.333f);\n+    ContainerId containerId;\n+\n+    while (!this.appFinishing.get()) {\n+      try {\n+        containerId \u003d this.pendingContainers.poll();\n+        if (containerId \u003d\u003d null) {\n+          Thread.sleep(THREAD_SLEEP_TIME);\n+        } else {\n+          uploadLogsForContainer(containerId);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n-    TaskReporter reporter \u003d startReporter(umbilical);\n- \n-    boolean useNewApi \u003d job.getUseNewMapper();\n-    initialize(job, getJobID(), reporter, useNewApi);\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n+    // Application is finished. Finish pending-containers\n+    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n+      uploadLogsForContainer(containerId);\n     }\n \n-    if (useNewApi) {\n-      runNewMapper(job, splitMetaInfo, umbilical, reporter);\n-    } else {\n-      runOldMapper(job, splitMetaInfo, umbilical, reporter);\n+    // Remove the local app-log-dirs\n+    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n+    int index \u003d 0;\n+    for (String rootLogDir : this.rootLogDirs) {\n+      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n+      index++;\n     }\n-    done(umbilical, reporter);\n+    this.delService.delete(this.userUgi.getShortUserName(), null,\n+        localAppLogDirs);\n+\n+    if (this.writer !\u003d null) {\n+      this.writer.closeWriter();\n+      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n+    }\n+\n+    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void run() {\n\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n    int index \u003d 0;\n    for (String rootLogDir : this.rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    this.appAggregationFinished.set(true);\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,39 @@\n-  public void run(final JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, ClassNotFoundException, InterruptedException {\n-    this.umbilical \u003d umbilical;\n+  public void run() {\n \n-    if (isMapTask()) {\n-      // If there are no reducers then there won\u0027t be any sort. Hence the map \n-      // phase will govern the entire attempt\u0027s progress.\n-      if (conf.getNumReduceTasks() \u003d\u003d 0) {\n-        mapPhase \u003d getProgress().addPhase(\"map\", 1.0f);\n-      } else {\n-        // If there are reducers then the entire attempt\u0027s progress will be \n-        // split between the map phase (67%) and the sort phase (33%).\n-        mapPhase \u003d getProgress().addPhase(\"map\", 0.667f);\n-        sortPhase  \u003d getProgress().addPhase(\"sort\", 0.333f);\n+    ContainerId containerId;\n+\n+    while (!this.appFinishing.get()) {\n+      try {\n+        containerId \u003d this.pendingContainers.poll();\n+        if (containerId \u003d\u003d null) {\n+          Thread.sleep(THREAD_SLEEP_TIME);\n+        } else {\n+          uploadLogsForContainer(containerId);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"PendingContainers queue is interrupted\");\n       }\n     }\n-    TaskReporter reporter \u003d startReporter(umbilical);\n- \n-    boolean useNewApi \u003d job.getUseNewMapper();\n-    initialize(job, getJobID(), reporter, useNewApi);\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n+    // Application is finished. Finish pending-containers\n+    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n+      uploadLogsForContainer(containerId);\n     }\n \n-    if (useNewApi) {\n-      runNewMapper(job, splitMetaInfo, umbilical, reporter);\n-    } else {\n-      runOldMapper(job, splitMetaInfo, umbilical, reporter);\n+    // Remove the local app-log-dirs\n+    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n+    int index \u003d 0;\n+    for (String rootLogDir : this.rootLogDirs) {\n+      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n+      index++;\n     }\n-    done(umbilical, reporter);\n+    this.delService.delete(this.userUgi.getShortUserName(), null,\n+        localAppLogDirs);\n+\n+    if (this.writer !\u003d null) {\n+      this.writer.closeWriter();\n+      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n+    }\n+\n+    this.appAggregationFinished.set(true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void run() {\n\n    ContainerId containerId;\n\n    while (!this.appFinishing.get()) {\n      try {\n        containerId \u003d this.pendingContainers.poll();\n        if (containerId \u003d\u003d null) {\n          Thread.sleep(THREAD_SLEEP_TIME);\n        } else {\n          uploadLogsForContainer(containerId);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"PendingContainers queue is interrupted\");\n      }\n    }\n\n    // Application is finished. Finish pending-containers\n    while ((containerId \u003d this.pendingContainers.poll()) !\u003d null) {\n      uploadLogsForContainer(containerId);\n    }\n\n    // Remove the local app-log-dirs\n    Path[] localAppLogDirs \u003d new Path[this.rootLogDirs.length];\n    int index \u003d 0;\n    for (String rootLogDir : this.rootLogDirs) {\n      localAppLogDirs[index] \u003d new Path(rootLogDir, this.applicationId);\n      index++;\n    }\n    this.delService.delete(this.userUgi.getShortUserName(), null,\n        localAppLogDirs);\n\n    if (this.writer !\u003d null) {\n      this.writer.closeWriter();\n      LOG.info(\"Finished aggregate log-file for app \" + this.applicationId);\n    }\n\n    this.appAggregationFinished.set(true);\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[job-JobConf(modifiers-final), umbilical-TaskUmbilicalProtocol(modifiers-final)]",
            "newValue": "[]"
          }
        }
      ]
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,42 @@\n+  public void run(final JobConf job, final TaskUmbilicalProtocol umbilical)\n+    throws IOException, ClassNotFoundException, InterruptedException {\n+    this.umbilical \u003d umbilical;\n+\n+    if (isMapTask()) {\n+      // If there are no reducers then there won\u0027t be any sort. Hence the map \n+      // phase will govern the entire attempt\u0027s progress.\n+      if (conf.getNumReduceTasks() \u003d\u003d 0) {\n+        mapPhase \u003d getProgress().addPhase(\"map\", 1.0f);\n+      } else {\n+        // If there are reducers then the entire attempt\u0027s progress will be \n+        // split between the map phase (67%) and the sort phase (33%).\n+        mapPhase \u003d getProgress().addPhase(\"map\", 0.667f);\n+        sortPhase  \u003d getProgress().addPhase(\"sort\", 0.333f);\n+      }\n+    }\n+    TaskReporter reporter \u003d startReporter(umbilical);\n+ \n+    boolean useNewApi \u003d job.getUseNewMapper();\n+    initialize(job, getJobID(), reporter, useNewApi);\n+\n+    // check if it is a cleanupJobTask\n+    if (jobCleanup) {\n+      runJobCleanupTask(umbilical, reporter);\n+      return;\n+    }\n+    if (jobSetup) {\n+      runJobSetupTask(umbilical, reporter);\n+      return;\n+    }\n+    if (taskCleanup) {\n+      runTaskCleanupTask(umbilical, reporter);\n+      return;\n+    }\n+\n+    if (useNewApi) {\n+      runNewMapper(job, splitMetaInfo, umbilical, reporter);\n+    } else {\n+      runOldMapper(job, splitMetaInfo, umbilical, reporter);\n+    }\n+    done(umbilical, reporter);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run(final JobConf job, final TaskUmbilicalProtocol umbilical)\n    throws IOException, ClassNotFoundException, InterruptedException {\n    this.umbilical \u003d umbilical;\n\n    if (isMapTask()) {\n      // If there are no reducers then there won\u0027t be any sort. Hence the map \n      // phase will govern the entire attempt\u0027s progress.\n      if (conf.getNumReduceTasks() \u003d\u003d 0) {\n        mapPhase \u003d getProgress().addPhase(\"map\", 1.0f);\n      } else {\n        // If there are reducers then the entire attempt\u0027s progress will be \n        // split between the map phase (67%) and the sort phase (33%).\n        mapPhase \u003d getProgress().addPhase(\"map\", 0.667f);\n        sortPhase  \u003d getProgress().addPhase(\"sort\", 0.333f);\n      }\n    }\n    TaskReporter reporter \u003d startReporter(umbilical);\n \n    boolean useNewApi \u003d job.getUseNewMapper();\n    initialize(job, getJobID(), reporter, useNewApi);\n\n    // check if it is a cleanupJobTask\n    if (jobCleanup) {\n      runJobCleanupTask(umbilical, reporter);\n      return;\n    }\n    if (jobSetup) {\n      runJobSetupTask(umbilical, reporter);\n      return;\n    }\n    if (taskCleanup) {\n      runTaskCleanupTask(umbilical, reporter);\n      return;\n    }\n\n    if (useNewApi) {\n      runNewMapper(job, splitMetaInfo, umbilical, reporter);\n    } else {\n      runOldMapper(job, splitMetaInfo, umbilical, reporter);\n    }\n    done(umbilical, reporter);\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/MapTask.java"
    }
  }
}