{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMCommunicator.java",
  "functionName": "doUnregistration",
  "functionId": "doUnregistration",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMCommunicator.java",
  "functionStartLine": 200,
  "functionEndLine": 246,
  "numCommitsSeen": 51,
  "timeTaken": 1572,
  "changeHistory": [
    "735fce5bec17f4e1799daf922625c475cf588114",
    "875592220fb250ff9d0bba73c8ace9858fd369fd",
    "f0799c55360e1e77224955f331892390e4361729"
  ],
  "changeHistoryShort": {
    "735fce5bec17f4e1799daf922625c475cf588114": "Ybodychange",
    "875592220fb250ff9d0bba73c8ace9858fd369fd": "Ybodychange",
    "f0799c55360e1e77224955f331892390e4361729": "Yintroduced"
  },
  "changeHistoryDetails": {
    "735fce5bec17f4e1799daf922625c475cf588114": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6927. MR job should only set tracking url if history was successfully written. Contributed by Eric Badger\n",
      "commitDate": "08/08/17 12:46 PM",
      "commitName": "735fce5bec17f4e1799daf922625c475cf588114",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/08/15 12:52 AM",
      "commitNameOld": "8dfec7a1979e8f70f8355c096874921d368342ef",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 724.5,
      "commitsBetweenForRepo": 4711,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,47 @@\n   protected void doUnregistration()\n       throws YarnException, IOException, InterruptedException {\n     FinalApplicationStatus finishState \u003d FinalApplicationStatus.UNDEFINED;\n     JobImpl jobImpl \u003d (JobImpl)job;\n     if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.SUCCEEDED) {\n       finishState \u003d FinalApplicationStatus.SUCCEEDED;\n     } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.KILLED\n         || (jobImpl.getInternalState() \u003d\u003d JobStateInternal.RUNNING \u0026\u0026 isSignalled)) {\n       finishState \u003d FinalApplicationStatus.KILLED;\n     } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.FAILED\n         || jobImpl.getInternalState() \u003d\u003d JobStateInternal.ERROR) {\n       finishState \u003d FinalApplicationStatus.FAILED;\n     }\n     StringBuffer sb \u003d new StringBuffer();\n     for (String s : job.getDiagnostics()) {\n       sb.append(s).append(\"\\n\");\n     }\n     LOG.info(\"Setting job diagnostics to \" + sb.toString());\n \n-    String historyUrl \u003d\n-        MRWebAppUtil.getApplicationWebURLOnJHSWithScheme(getConfig(),\n-            context.getApplicationID());\n+    String historyUrl \u003d context.getHistoryUrl();\n     LOG.info(\"History url is \" + historyUrl);\n     FinishApplicationMasterRequest request \u003d\n         FinishApplicationMasterRequest.newInstance(finishState,\n           sb.toString(), historyUrl);\n     try {\n       while (true) {\n         FinishApplicationMasterResponse response \u003d\n             scheduler.finishApplicationMaster(request);\n         if (response.getIsUnregistered()) {\n           // When excepting ClientService, other services are already stopped,\n           // it is safe to let clients know the final states. ClientService\n           // should wait for some time so clients have enough time to know the\n           // final states.\n           RunningAppContext raContext \u003d (RunningAppContext) context;\n           raContext.markSuccessfulUnregistration();\n           break;\n         }\n         LOG.info(\"Waiting for application to be successfully unregistered.\");\n         Thread.sleep(rmPollInterval);\n       }\n     } catch (ApplicationMasterNotRegisteredException e) {\n       // RM might have restarted or failed over and so lost the fact that AM had\n       // registered before.\n       register();\n       doUnregistration();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doUnregistration()\n      throws YarnException, IOException, InterruptedException {\n    FinalApplicationStatus finishState \u003d FinalApplicationStatus.UNDEFINED;\n    JobImpl jobImpl \u003d (JobImpl)job;\n    if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.SUCCEEDED) {\n      finishState \u003d FinalApplicationStatus.SUCCEEDED;\n    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.KILLED\n        || (jobImpl.getInternalState() \u003d\u003d JobStateInternal.RUNNING \u0026\u0026 isSignalled)) {\n      finishState \u003d FinalApplicationStatus.KILLED;\n    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.FAILED\n        || jobImpl.getInternalState() \u003d\u003d JobStateInternal.ERROR) {\n      finishState \u003d FinalApplicationStatus.FAILED;\n    }\n    StringBuffer sb \u003d new StringBuffer();\n    for (String s : job.getDiagnostics()) {\n      sb.append(s).append(\"\\n\");\n    }\n    LOG.info(\"Setting job diagnostics to \" + sb.toString());\n\n    String historyUrl \u003d context.getHistoryUrl();\n    LOG.info(\"History url is \" + historyUrl);\n    FinishApplicationMasterRequest request \u003d\n        FinishApplicationMasterRequest.newInstance(finishState,\n          sb.toString(), historyUrl);\n    try {\n      while (true) {\n        FinishApplicationMasterResponse response \u003d\n            scheduler.finishApplicationMaster(request);\n        if (response.getIsUnregistered()) {\n          // When excepting ClientService, other services are already stopped,\n          // it is safe to let clients know the final states. ClientService\n          // should wait for some time so clients have enough time to know the\n          // final states.\n          RunningAppContext raContext \u003d (RunningAppContext) context;\n          raContext.markSuccessfulUnregistration();\n          break;\n        }\n        LOG.info(\"Waiting for application to be successfully unregistered.\");\n        Thread.sleep(rmPollInterval);\n      }\n    } catch (ApplicationMasterNotRegisteredException e) {\n      // RM might have restarted or failed over and so lost the fact that AM had\n      // registered before.\n      register();\n      doUnregistration();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMCommunicator.java",
      "extendedDetails": {}
    },
    "875592220fb250ff9d0bba73c8ace9858fd369fd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5910. Make MR AM resync with RM in case of work-preserving RM-restart. Contributed by Rohith\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611434 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/07/14 11:46 AM",
      "commitName": "875592220fb250ff9d0bba73c8ace9858fd369fd",
      "commitAuthor": "Jian He",
      "commitDateOld": "11/07/14 1:45 AM",
      "commitNameOld": "64306aa1b5f280e5ffaf2186bef706acd93b1412",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 6.42,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,49 @@\n   protected void doUnregistration()\n       throws YarnException, IOException, InterruptedException {\n     FinalApplicationStatus finishState \u003d FinalApplicationStatus.UNDEFINED;\n     JobImpl jobImpl \u003d (JobImpl)job;\n     if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.SUCCEEDED) {\n       finishState \u003d FinalApplicationStatus.SUCCEEDED;\n     } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.KILLED\n         || (jobImpl.getInternalState() \u003d\u003d JobStateInternal.RUNNING \u0026\u0026 isSignalled)) {\n       finishState \u003d FinalApplicationStatus.KILLED;\n     } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.FAILED\n         || jobImpl.getInternalState() \u003d\u003d JobStateInternal.ERROR) {\n       finishState \u003d FinalApplicationStatus.FAILED;\n     }\n     StringBuffer sb \u003d new StringBuffer();\n     for (String s : job.getDiagnostics()) {\n       sb.append(s).append(\"\\n\");\n     }\n     LOG.info(\"Setting job diagnostics to \" + sb.toString());\n \n     String historyUrl \u003d\n         MRWebAppUtil.getApplicationWebURLOnJHSWithScheme(getConfig(),\n             context.getApplicationID());\n     LOG.info(\"History url is \" + historyUrl);\n     FinishApplicationMasterRequest request \u003d\n         FinishApplicationMasterRequest.newInstance(finishState,\n           sb.toString(), historyUrl);\n-    while (true) {\n-      FinishApplicationMasterResponse response \u003d\n-          scheduler.finishApplicationMaster(request);\n-      if (response.getIsUnregistered()) {\n-        // When excepting ClientService, other services are already stopped,\n-        // it is safe to let clients know the final states. ClientService\n-        // should wait for some time so clients have enough time to know the\n-        // final states.\n-        RunningAppContext raContext \u003d (RunningAppContext) context;\n-        raContext.markSuccessfulUnregistration();\n-        break;\n+    try {\n+      while (true) {\n+        FinishApplicationMasterResponse response \u003d\n+            scheduler.finishApplicationMaster(request);\n+        if (response.getIsUnregistered()) {\n+          // When excepting ClientService, other services are already stopped,\n+          // it is safe to let clients know the final states. ClientService\n+          // should wait for some time so clients have enough time to know the\n+          // final states.\n+          RunningAppContext raContext \u003d (RunningAppContext) context;\n+          raContext.markSuccessfulUnregistration();\n+          break;\n+        }\n+        LOG.info(\"Waiting for application to be successfully unregistered.\");\n+        Thread.sleep(rmPollInterval);\n       }\n-      LOG.info(\"Waiting for application to be successfully unregistered.\");\n-      Thread.sleep(rmPollInterval);\n+    } catch (ApplicationMasterNotRegisteredException e) {\n+      // RM might have restarted or failed over and so lost the fact that AM had\n+      // registered before.\n+      register();\n+      doUnregistration();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doUnregistration()\n      throws YarnException, IOException, InterruptedException {\n    FinalApplicationStatus finishState \u003d FinalApplicationStatus.UNDEFINED;\n    JobImpl jobImpl \u003d (JobImpl)job;\n    if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.SUCCEEDED) {\n      finishState \u003d FinalApplicationStatus.SUCCEEDED;\n    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.KILLED\n        || (jobImpl.getInternalState() \u003d\u003d JobStateInternal.RUNNING \u0026\u0026 isSignalled)) {\n      finishState \u003d FinalApplicationStatus.KILLED;\n    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.FAILED\n        || jobImpl.getInternalState() \u003d\u003d JobStateInternal.ERROR) {\n      finishState \u003d FinalApplicationStatus.FAILED;\n    }\n    StringBuffer sb \u003d new StringBuffer();\n    for (String s : job.getDiagnostics()) {\n      sb.append(s).append(\"\\n\");\n    }\n    LOG.info(\"Setting job diagnostics to \" + sb.toString());\n\n    String historyUrl \u003d\n        MRWebAppUtil.getApplicationWebURLOnJHSWithScheme(getConfig(),\n            context.getApplicationID());\n    LOG.info(\"History url is \" + historyUrl);\n    FinishApplicationMasterRequest request \u003d\n        FinishApplicationMasterRequest.newInstance(finishState,\n          sb.toString(), historyUrl);\n    try {\n      while (true) {\n        FinishApplicationMasterResponse response \u003d\n            scheduler.finishApplicationMaster(request);\n        if (response.getIsUnregistered()) {\n          // When excepting ClientService, other services are already stopped,\n          // it is safe to let clients know the final states. ClientService\n          // should wait for some time so clients have enough time to know the\n          // final states.\n          RunningAppContext raContext \u003d (RunningAppContext) context;\n          raContext.markSuccessfulUnregistration();\n          break;\n        }\n        LOG.info(\"Waiting for application to be successfully unregistered.\");\n        Thread.sleep(rmPollInterval);\n      }\n    } catch (ApplicationMasterNotRegisteredException e) {\n      // RM might have restarted or failed over and so lost the fact that AM had\n      // registered before.\n      register();\n      doUnregistration();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMCommunicator.java",
      "extendedDetails": {}
    },
    "f0799c55360e1e77224955f331892390e4361729": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5562. Fixed MR App Master to perform pending tasks like staging-dir cleanup, sending job-end notification correctly when unregister with RM fails. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/10/13 1:53 PM",
      "commitName": "f0799c55360e1e77224955f331892390e4361729",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,42 @@\n+  protected void doUnregistration()\n+      throws YarnException, IOException, InterruptedException {\n+    FinalApplicationStatus finishState \u003d FinalApplicationStatus.UNDEFINED;\n+    JobImpl jobImpl \u003d (JobImpl)job;\n+    if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.SUCCEEDED) {\n+      finishState \u003d FinalApplicationStatus.SUCCEEDED;\n+    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.KILLED\n+        || (jobImpl.getInternalState() \u003d\u003d JobStateInternal.RUNNING \u0026\u0026 isSignalled)) {\n+      finishState \u003d FinalApplicationStatus.KILLED;\n+    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.FAILED\n+        || jobImpl.getInternalState() \u003d\u003d JobStateInternal.ERROR) {\n+      finishState \u003d FinalApplicationStatus.FAILED;\n+    }\n+    StringBuffer sb \u003d new StringBuffer();\n+    for (String s : job.getDiagnostics()) {\n+      sb.append(s).append(\"\\n\");\n+    }\n+    LOG.info(\"Setting job diagnostics to \" + sb.toString());\n+\n+    String historyUrl \u003d\n+        MRWebAppUtil.getApplicationWebURLOnJHSWithScheme(getConfig(),\n+            context.getApplicationID());\n+    LOG.info(\"History url is \" + historyUrl);\n+    FinishApplicationMasterRequest request \u003d\n+        FinishApplicationMasterRequest.newInstance(finishState,\n+          sb.toString(), historyUrl);\n+    while (true) {\n+      FinishApplicationMasterResponse response \u003d\n+          scheduler.finishApplicationMaster(request);\n+      if (response.getIsUnregistered()) {\n+        // When excepting ClientService, other services are already stopped,\n+        // it is safe to let clients know the final states. ClientService\n+        // should wait for some time so clients have enough time to know the\n+        // final states.\n+        RunningAppContext raContext \u003d (RunningAppContext) context;\n+        raContext.markSuccessfulUnregistration();\n+        break;\n+      }\n+      LOG.info(\"Waiting for application to be successfully unregistered.\");\n+      Thread.sleep(rmPollInterval);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doUnregistration()\n      throws YarnException, IOException, InterruptedException {\n    FinalApplicationStatus finishState \u003d FinalApplicationStatus.UNDEFINED;\n    JobImpl jobImpl \u003d (JobImpl)job;\n    if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.SUCCEEDED) {\n      finishState \u003d FinalApplicationStatus.SUCCEEDED;\n    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.KILLED\n        || (jobImpl.getInternalState() \u003d\u003d JobStateInternal.RUNNING \u0026\u0026 isSignalled)) {\n      finishState \u003d FinalApplicationStatus.KILLED;\n    } else if (jobImpl.getInternalState() \u003d\u003d JobStateInternal.FAILED\n        || jobImpl.getInternalState() \u003d\u003d JobStateInternal.ERROR) {\n      finishState \u003d FinalApplicationStatus.FAILED;\n    }\n    StringBuffer sb \u003d new StringBuffer();\n    for (String s : job.getDiagnostics()) {\n      sb.append(s).append(\"\\n\");\n    }\n    LOG.info(\"Setting job diagnostics to \" + sb.toString());\n\n    String historyUrl \u003d\n        MRWebAppUtil.getApplicationWebURLOnJHSWithScheme(getConfig(),\n            context.getApplicationID());\n    LOG.info(\"History url is \" + historyUrl);\n    FinishApplicationMasterRequest request \u003d\n        FinishApplicationMasterRequest.newInstance(finishState,\n          sb.toString(), historyUrl);\n    while (true) {\n      FinishApplicationMasterResponse response \u003d\n          scheduler.finishApplicationMaster(request);\n      if (response.getIsUnregistered()) {\n        // When excepting ClientService, other services are already stopped,\n        // it is safe to let clients know the final states. ClientService\n        // should wait for some time so clients have enough time to know the\n        // final states.\n        RunningAppContext raContext \u003d (RunningAppContext) context;\n        raContext.markSuccessfulUnregistration();\n        break;\n      }\n      LOG.info(\"Waiting for application to be successfully unregistered.\");\n      Thread.sleep(rmPollInterval);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMCommunicator.java"
    }
  }
}