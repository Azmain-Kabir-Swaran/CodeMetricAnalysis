{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SequenceFile.java",
  "functionName": "init",
  "functionId": "init___tempReader-boolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
  "functionStartLine": 1956,
  "functionEndLine": 2095,
  "numCommitsSeen": 46,
  "timeTaken": 3839,
  "changeHistory": [
    "513ec3de194f705ca342de16829e1f85be227e7f",
    "039a1f9e968690cb66af224858e6e64b4f0b2926",
    "b5ca649bff01c906033d71c9f983b4cdaa71a9d1",
    "6681523c870541390864e021cbe1908b6797f622",
    "0f122c209d7346e7913907dec86aa8cf221dd8f2",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "750fb2dbc1c077c9ca7ce889332a597d4a65388f",
    "98beeca09d2e527c3507989dbae267c2313ae15a",
    "c9cc61e8538925081b6ed92596e599d23c8a5542",
    "d6428581ff6ad7859d69b41318bd6fe4736d022d",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "513ec3de194f705ca342de16829e1f85be227e7f": "Ybodychange",
    "039a1f9e968690cb66af224858e6e64b4f0b2926": "Ybodychange",
    "b5ca649bff01c906033d71c9f983b4cdaa71a9d1": "Ybodychange",
    "6681523c870541390864e021cbe1908b6797f622": "Ybodychange",
    "0f122c209d7346e7913907dec86aa8cf221dd8f2": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "750fb2dbc1c077c9ca7ce889332a597d4a65388f": "Ybodychange",
    "98beeca09d2e527c3507989dbae267c2313ae15a": "Ybodychange",
    "c9cc61e8538925081b6ed92596e599d23c8a5542": "Ybodychange",
    "d6428581ff6ad7859d69b41318bd6fe4736d022d": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "513ec3de194f705ca342de16829e1f85be227e7f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9692. Improving log message when SequenceFile reader throws EOFException on zero-length file. (Zhe Zhang and Chu Tong via ozawa)\n",
      "commitDate": "22/10/15 2:50 PM",
      "commitName": "513ec3de194f705ca342de16829e1f85be227e7f",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "22/10/15 2:48 PM",
      "commitNameOld": "039a1f9e968690cb66af224858e6e64b4f0b2926",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,140 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n-      in.readFully(versionBlock);\n+      String exceptionMsg \u003d this + \" not a SequenceFile\";\n+\n+      // Try to read sequence file header.\n+      try {\n+        in.readFully(versionBlock);\n+      } catch (EOFException e) {\n+        throw new EOFException(exceptionMsg);\n+      }\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n-          (versionBlock[2] !\u003d VERSION[2]))\n+          (versionBlock[2] !\u003d VERSION[2])) {\n         throw new IOException(this + \" not a SequenceFile\");\n+      }\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n-      if (version \u003e VERSION[3])\n+      if (version \u003e VERSION[3]) {\n         throw new VersionMismatchException(VERSION[3], version);\n+      }\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toStringChecked(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toStringChecked(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n         headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n           getDeserializer(serializationFactory, getKeyClass());\n         if (this.keyDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Key class: \u0027\"\n                   + getKeyClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n           getDeserializer(serializationFactory, getValueClass());\n         if (this.valDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Value class: \u0027\"\n                   + getValueClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      String exceptionMsg \u003d this + \" not a SequenceFile\";\n\n      // Try to read sequence file header.\n      try {\n        in.readFully(versionBlock);\n      } catch (EOFException e) {\n        throw new EOFException(exceptionMsg);\n      }\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2])) {\n        throw new IOException(this + \" not a SequenceFile\");\n      }\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3]) {\n        throw new VersionMismatchException(VERSION[3], version);\n      }\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toStringChecked(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toStringChecked(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (this.keyDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Key class: \u0027\"\n                  + getKeyClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        if (this.valDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Value class: \u0027\"\n                  + getValueClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "039a1f9e968690cb66af224858e6e64b4f0b2926": {
      "type": "Ybodychange",
      "commitMessage": "Revert HADOOP-9692.\n\nThis reverts commit 381610da620121c02073dbbaac669b80b41959b4.\nThis reverts commit b5ca649bff01c906033d71c9f983b4cdaa71a9d1.\n",
      "commitDate": "22/10/15 2:48 PM",
      "commitName": "039a1f9e968690cb66af224858e6e64b4f0b2926",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "21/10/15 7:55 PM",
      "commitNameOld": "b5ca649bff01c906033d71c9f983b4cdaa71a9d1",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,131 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n-      String exceptionMsg \u003d this + \" not a SequenceFile\";\n-\n-      // Try to read sequence file header.\n-      try {\n-        in.readFully(versionBlock);\n-      } catch (EOFException e) {\n-        throw new EOFException(exceptionMsg);\n-      }\n+      in.readFully(versionBlock);\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n-          (versionBlock[2] !\u003d VERSION[2])) {\n+          (versionBlock[2] !\u003d VERSION[2]))\n         throw new IOException(this + \" not a SequenceFile\");\n-      }\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n-      if (version \u003e VERSION[3]) {\n+      if (version \u003e VERSION[3])\n         throw new VersionMismatchException(VERSION[3], version);\n-      }\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toStringChecked(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toStringChecked(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n         headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n           getDeserializer(serializationFactory, getKeyClass());\n         if (this.keyDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Key class: \u0027\"\n                   + getKeyClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n           getDeserializer(serializationFactory, getValueClass());\n         if (this.valDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Value class: \u0027\"\n                   + getValueClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toStringChecked(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toStringChecked(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (this.keyDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Key class: \u0027\"\n                  + getKeyClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        if (this.valDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Value class: \u0027\"\n                  + getValueClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "b5ca649bff01c906033d71c9f983b4cdaa71a9d1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9692. SequenceFile reader throws EOFException on zero-length file. Contributed by Zhe Zhang and Chu Tong.\n",
      "commitDate": "21/10/15 7:55 PM",
      "commitName": "b5ca649bff01c906033d71c9f983b4cdaa71a9d1",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/06/15 2:09 AM",
      "commitNameOld": "295d678be8853a52c3ec3da43d9265478d6632b3",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 125.74,
      "commitsBetweenForRepo": 846,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,140 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n-      in.readFully(versionBlock);\n+      String exceptionMsg \u003d this + \" not a SequenceFile\";\n+\n+      // Try to read sequence file header.\n+      try {\n+        in.readFully(versionBlock);\n+      } catch (EOFException e) {\n+        throw new EOFException(exceptionMsg);\n+      }\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n-          (versionBlock[2] !\u003d VERSION[2]))\n+          (versionBlock[2] !\u003d VERSION[2])) {\n         throw new IOException(this + \" not a SequenceFile\");\n+      }\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n-      if (version \u003e VERSION[3])\n+      if (version \u003e VERSION[3]) {\n         throw new VersionMismatchException(VERSION[3], version);\n+      }\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toStringChecked(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toStringChecked(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n         headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n           getDeserializer(serializationFactory, getKeyClass());\n         if (this.keyDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Key class: \u0027\"\n                   + getKeyClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n           getDeserializer(serializationFactory, getValueClass());\n         if (this.valDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Value class: \u0027\"\n                   + getValueClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      String exceptionMsg \u003d this + \" not a SequenceFile\";\n\n      // Try to read sequence file header.\n      try {\n        in.readFully(versionBlock);\n      } catch (EOFException e) {\n        throw new EOFException(exceptionMsg);\n      }\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2])) {\n        throw new IOException(this + \" not a SequenceFile\");\n      }\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3]) {\n        throw new VersionMismatchException(VERSION[3], version);\n      }\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toStringChecked(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toStringChecked(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (this.keyDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Key class: \u0027\"\n                  + getKeyClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        if (this.valDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Value class: \u0027\"\n                  + getValueClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "6681523c870541390864e021cbe1908b6797f622": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4282. TestEditLog.testFuzzSequences FAILED in all pre-commit test. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1418214 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/12/12 12:18 AM",
      "commitName": "6681523c870541390864e021cbe1908b6797f622",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 104.3,
      "commitsBetweenForRepo": 567,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,131 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n       in.readFully(versionBlock);\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n           (versionBlock[2] !\u003d VERSION[2]))\n         throw new IOException(this + \" not a SequenceFile\");\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n       if (version \u003e VERSION[3])\n         throw new VersionMismatchException(VERSION[3], version);\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n-        keyClassName \u003d className.toString(); // key class name\n+        keyClassName \u003d className.toStringChecked(); // key class name\n \n         className.readFields(in);\n-        valClassName \u003d className.toString(); // val class name\n+        valClassName \u003d className.toStringChecked(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n         headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n           getDeserializer(serializationFactory, getKeyClass());\n         if (this.keyDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Key class: \u0027\"\n                   + getKeyClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n           getDeserializer(serializationFactory, getValueClass());\n         if (this.valDeserializer \u003d\u003d null) {\n           throw new IOException(\n               \"Could not find a deserializer for the Value class: \u0027\"\n                   + getValueClass().getCanonicalName() + \"\u0027. \"\n                   + \"Please ensure that the configuration \u0027\" +\n                   CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                   + \"properly configured, if you\u0027re using \"\n                   + \"custom serialization.\");\n         }\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toStringChecked(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toStringChecked(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (this.keyDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Key class: \u0027\"\n                  + getKeyClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        if (this.valDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Value class: \u0027\"\n                  + getValueClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "0f122c209d7346e7913907dec86aa8cf221dd8f2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8531. SequenceFile Writer can throw out a better error if a serializer or deserializer isn\u0027t available. Contributed by Madhukara Phatak. (harsh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361933 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 1:33 AM",
      "commitName": "0f122c209d7346e7913907dec86aa8cf221dd8f2",
      "commitAuthor": "Harsh J",
      "commitDateOld": "12/07/12 12:01 PM",
      "commitNameOld": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 3.56,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,131 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n       in.readFully(versionBlock);\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n           (versionBlock[2] !\u003d VERSION[2]))\n         throw new IOException(this + \" not a SequenceFile\");\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n       if (version \u003e VERSION[3])\n         throw new VersionMismatchException(VERSION[3], version);\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toString(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toString(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n         headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n           getDeserializer(serializationFactory, getKeyClass());\n+        if (this.keyDeserializer \u003d\u003d null) {\n+          throw new IOException(\n+              \"Could not find a deserializer for the Key class: \u0027\"\n+                  + getKeyClass().getCanonicalName() + \"\u0027. \"\n+                  + \"Please ensure that the configuration \u0027\" +\n+                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n+                  + \"properly configured, if you\u0027re using \"\n+                  + \"custom serialization.\");\n+        }\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n           getDeserializer(serializationFactory, getValueClass());\n+        if (this.valDeserializer \u003d\u003d null) {\n+          throw new IOException(\n+              \"Could not find a deserializer for the Value class: \u0027\"\n+                  + getValueClass().getCanonicalName() + \"\u0027. \"\n+                  + \"Please ensure that the configuration \u0027\" +\n+                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n+                  + \"properly configured, if you\u0027re using \"\n+                  + \"custom serialization.\");\n+        }\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (this.keyDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Key class: \u0027\"\n                  + getKeyClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        if (this.valDeserializer \u003d\u003d null) {\n          throw new IOException(\n              \"Could not find a deserializer for the Value class: \u0027\"\n                  + getValueClass().getCanonicalName() + \"\u0027. \"\n                  + \"Please ensure that the configuration \u0027\" +\n                  CommonConfigurationKeys.IO_SERIALIZATIONS_KEY + \"\u0027 is \"\n                  + \"properly configured, if you\u0027re using \"\n                  + \"custom serialization.\");\n        }\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/io/SequenceFile.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/io/SequenceFile.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/io/SequenceFile.java",
        "newPath": "common/src/java/org/apache/hadoop/io/SequenceFile.java"
      }
    },
    "750fb2dbc1c077c9ca7ce889332a597d4a65388f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6698. Revert the io.serialization package to 0.20.2\u0027s api. Reverted HADOOP-6165, HADOOP-6443, HADOOP-6323, and HADOOP-6420.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@939412 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/04/10 11:09 AM",
      "commitName": "750fb2dbc1c077c9ca7ce889332a597d4a65388f",
      "commitAuthor": "Thomas White",
      "commitDateOld": "22/03/10 12:08 PM",
      "commitNameOld": "0485fe23ba76f7d96a198aed00f392fd571124bc",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 37.96,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,113 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n       in.readFully(versionBlock);\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n           (versionBlock[2] !\u003d VERSION[2]))\n         throw new IOException(this + \" not a SequenceFile\");\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n       if (version \u003e VERSION[3])\n         throw new VersionMismatchException(VERSION[3], version);\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toString(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toString(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n         headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n-          getDeserializer(serializationFactory, getKeyClass(), metadata);\n+          getDeserializer(serializationFactory, getKeyClass());\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n-          getDeserializer(serializationFactory, getValueClass(), metadata);\n+          getDeserializer(serializationFactory, getValueClass());\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "98beeca09d2e527c3507989dbae267c2313ae15a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6307. Add a new SequenceFile.Reader constructor in order to support reading on un-closed file.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@886003 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/12/09 3:25 PM",
      "commitName": "98beeca09d2e527c3507989dbae267c2313ae15a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/09/09 12:38 AM",
      "commitNameOld": "c9cc61e8538925081b6ed92596e599d23c8a5542",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 81.66,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,113 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n       in.readFully(versionBlock);\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n           (versionBlock[2] !\u003d VERSION[2]))\n-        throw new IOException(file + \" not a SequenceFile\");\n+        throw new IOException(this + \" not a SequenceFile\");\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n       if (version \u003e VERSION[3])\n         throw new VersionMismatchException(VERSION[3], version);\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toString(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toString(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n         headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n           getDeserializer(serializationFactory, getKeyClass(), metadata);\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n           getDeserializer(serializationFactory, getValueClass(), metadata);\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(this + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass(), metadata);\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass(), metadata);\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "c9cc61e8538925081b6ed92596e599d23c8a5542": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6196. Fix a bug in SequenceFile.Reader where syncing within the header\nwould cause the reader to read the sync marker as a record. Contributed by Jay Booth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@813698 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/09 12:38 AM",
      "commitName": "c9cc61e8538925081b6ed92596e599d23c8a5542",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "02/09/09 6:36 PM",
      "commitNameOld": "d6428581ff6ad7859d69b41318bd6fe4736d022d",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 8.25,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,113 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n       in.readFully(versionBlock);\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n           (versionBlock[2] !\u003d VERSION[2]))\n         throw new IOException(file + \" not a SequenceFile\");\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n       if (version \u003e VERSION[3])\n         throw new VersionMismatchException(VERSION[3], version);\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toString(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toString(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n+        headerEnd \u003d in.getPos();                  // record end of header\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n           getDeserializer(serializationFactory, getKeyClass(), metadata);\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n           getDeserializer(serializationFactory, getValueClass(), metadata);\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(file + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n        headerEnd \u003d in.getPos();                  // record end of header\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass(), metadata);\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass(), metadata);\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "d6428581ff6ad7859d69b41318bd6fe4736d022d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6165. Add metadata to Serializations.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@810756 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/09/09 6:36 PM",
      "commitName": "d6428581ff6ad7859d69b41318bd6fe4736d022d",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/06/09 2:10 PM",
      "commitNameOld": "5c7b7adacb47242fe4c82e982cb06e6276f6f862",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 93.18,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,112 @@\n     private void init(boolean tempReader) throws IOException {\n       byte[] versionBlock \u003d new byte[VERSION.length];\n       in.readFully(versionBlock);\n \n       if ((versionBlock[0] !\u003d VERSION[0]) ||\n           (versionBlock[1] !\u003d VERSION[1]) ||\n           (versionBlock[2] !\u003d VERSION[2]))\n         throw new IOException(file + \" not a SequenceFile\");\n \n       // Set \u0027version\u0027\n       version \u003d versionBlock[3];\n       if (version \u003e VERSION[3])\n         throw new VersionMismatchException(VERSION[3], version);\n \n       if (version \u003c BLOCK_COMPRESS_VERSION) {\n         UTF8 className \u003d new UTF8();\n \n         className.readFields(in);\n         keyClassName \u003d className.toString(); // key class name\n \n         className.readFields(in);\n         valClassName \u003d className.toString(); // val class name\n       } else {\n         keyClassName \u003d Text.readString(in);\n         valClassName \u003d Text.readString(in);\n       }\n \n       if (version \u003e 2) {                          // if version \u003e 2\n         this.decompress \u003d in.readBoolean();       // is compressed?\n       } else {\n         decompress \u003d false;\n       }\n \n       if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n         this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n       } else {\n         blockCompressed \u003d false;\n       }\n       \n       // if version \u003e\u003d 5\n       // setup the compression codec\n       if (decompress) {\n         if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n           String codecClassname \u003d Text.readString(in);\n           try {\n             Class\u003c? extends CompressionCodec\u003e codecClass\n               \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n             this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n           } catch (ClassNotFoundException cnfe) {\n             throw new IllegalArgumentException(\"Unknown codec: \" + \n                                                codecClassname, cnfe);\n           }\n         } else {\n           codec \u003d new DefaultCodec();\n           ((Configurable)codec).setConf(conf);\n         }\n       }\n       \n       this.metadata \u003d new Metadata();\n       if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n         this.metadata.readFields(in);\n       }\n       \n       if (version \u003e 1) {                          // if version \u003e 1\n         in.readFully(sync);                       // read sync bytes\n       }\n       \n       // Initialize... *not* if this we are constructing a temporary Reader\n       if (!tempReader) {\n         valBuffer \u003d new DataInputBuffer();\n         if (decompress) {\n           valDecompressor \u003d CodecPool.getDecompressor(codec);\n           valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n           valIn \u003d new DataInputStream(valInFilter);\n         } else {\n           valIn \u003d valBuffer;\n         }\n \n         if (blockCompressed) {\n           keyLenBuffer \u003d new DataInputBuffer();\n           keyBuffer \u003d new DataInputBuffer();\n           valLenBuffer \u003d new DataInputBuffer();\n \n           keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                    keyLenDecompressor);\n           keyLenIn \u003d new DataInputStream(keyLenInFilter);\n \n           keyDecompressor \u003d CodecPool.getDecompressor(codec);\n           keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n           keyIn \u003d new DataInputStream(keyInFilter);\n \n           valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n           valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                    valLenDecompressor);\n           valLenIn \u003d new DataInputStream(valLenInFilter);\n         }\n         \n         SerializationFactory serializationFactory \u003d\n           new SerializationFactory(conf);\n         this.keyDeserializer \u003d\n-          getDeserializer(serializationFactory, getKeyClass());\n+          getDeserializer(serializationFactory, getKeyClass(), metadata);\n         if (!blockCompressed) {\n           this.keyDeserializer.open(valBuffer);\n         } else {\n           this.keyDeserializer.open(keyIn);\n         }\n         this.valDeserializer \u003d\n-          getDeserializer(serializationFactory, getValueClass());\n+          getDeserializer(serializationFactory, getValueClass(), metadata);\n         this.valDeserializer.open(valIn);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(file + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass(), metadata);\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass(), metadata);\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/io/SequenceFile.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,112 @@\n+    private void init(boolean tempReader) throws IOException {\n+      byte[] versionBlock \u003d new byte[VERSION.length];\n+      in.readFully(versionBlock);\n+\n+      if ((versionBlock[0] !\u003d VERSION[0]) ||\n+          (versionBlock[1] !\u003d VERSION[1]) ||\n+          (versionBlock[2] !\u003d VERSION[2]))\n+        throw new IOException(file + \" not a SequenceFile\");\n+\n+      // Set \u0027version\u0027\n+      version \u003d versionBlock[3];\n+      if (version \u003e VERSION[3])\n+        throw new VersionMismatchException(VERSION[3], version);\n+\n+      if (version \u003c BLOCK_COMPRESS_VERSION) {\n+        UTF8 className \u003d new UTF8();\n+\n+        className.readFields(in);\n+        keyClassName \u003d className.toString(); // key class name\n+\n+        className.readFields(in);\n+        valClassName \u003d className.toString(); // val class name\n+      } else {\n+        keyClassName \u003d Text.readString(in);\n+        valClassName \u003d Text.readString(in);\n+      }\n+\n+      if (version \u003e 2) {                          // if version \u003e 2\n+        this.decompress \u003d in.readBoolean();       // is compressed?\n+      } else {\n+        decompress \u003d false;\n+      }\n+\n+      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n+        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n+      } else {\n+        blockCompressed \u003d false;\n+      }\n+      \n+      // if version \u003e\u003d 5\n+      // setup the compression codec\n+      if (decompress) {\n+        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n+          String codecClassname \u003d Text.readString(in);\n+          try {\n+            Class\u003c? extends CompressionCodec\u003e codecClass\n+              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n+            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n+          } catch (ClassNotFoundException cnfe) {\n+            throw new IllegalArgumentException(\"Unknown codec: \" + \n+                                               codecClassname, cnfe);\n+          }\n+        } else {\n+          codec \u003d new DefaultCodec();\n+          ((Configurable)codec).setConf(conf);\n+        }\n+      }\n+      \n+      this.metadata \u003d new Metadata();\n+      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n+        this.metadata.readFields(in);\n+      }\n+      \n+      if (version \u003e 1) {                          // if version \u003e 1\n+        in.readFully(sync);                       // read sync bytes\n+      }\n+      \n+      // Initialize... *not* if this we are constructing a temporary Reader\n+      if (!tempReader) {\n+        valBuffer \u003d new DataInputBuffer();\n+        if (decompress) {\n+          valDecompressor \u003d CodecPool.getDecompressor(codec);\n+          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n+          valIn \u003d new DataInputStream(valInFilter);\n+        } else {\n+          valIn \u003d valBuffer;\n+        }\n+\n+        if (blockCompressed) {\n+          keyLenBuffer \u003d new DataInputBuffer();\n+          keyBuffer \u003d new DataInputBuffer();\n+          valLenBuffer \u003d new DataInputBuffer();\n+\n+          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n+          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n+                                                   keyLenDecompressor);\n+          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n+\n+          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n+          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n+          keyIn \u003d new DataInputStream(keyInFilter);\n+\n+          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n+          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n+                                                   valLenDecompressor);\n+          valLenIn \u003d new DataInputStream(valLenInFilter);\n+        }\n+        \n+        SerializationFactory serializationFactory \u003d\n+          new SerializationFactory(conf);\n+        this.keyDeserializer \u003d\n+          getDeserializer(serializationFactory, getKeyClass());\n+        if (!blockCompressed) {\n+          this.keyDeserializer.open(valBuffer);\n+        } else {\n+          this.keyDeserializer.open(keyIn);\n+        }\n+        this.valDeserializer \u003d\n+          getDeserializer(serializationFactory, getValueClass());\n+        this.valDeserializer.open(valIn);\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void init(boolean tempReader) throws IOException {\n      byte[] versionBlock \u003d new byte[VERSION.length];\n      in.readFully(versionBlock);\n\n      if ((versionBlock[0] !\u003d VERSION[0]) ||\n          (versionBlock[1] !\u003d VERSION[1]) ||\n          (versionBlock[2] !\u003d VERSION[2]))\n        throw new IOException(file + \" not a SequenceFile\");\n\n      // Set \u0027version\u0027\n      version \u003d versionBlock[3];\n      if (version \u003e VERSION[3])\n        throw new VersionMismatchException(VERSION[3], version);\n\n      if (version \u003c BLOCK_COMPRESS_VERSION) {\n        UTF8 className \u003d new UTF8();\n\n        className.readFields(in);\n        keyClassName \u003d className.toString(); // key class name\n\n        className.readFields(in);\n        valClassName \u003d className.toString(); // val class name\n      } else {\n        keyClassName \u003d Text.readString(in);\n        valClassName \u003d Text.readString(in);\n      }\n\n      if (version \u003e 2) {                          // if version \u003e 2\n        this.decompress \u003d in.readBoolean();       // is compressed?\n      } else {\n        decompress \u003d false;\n      }\n\n      if (version \u003e\u003d BLOCK_COMPRESS_VERSION) {    // if version \u003e\u003d 4\n        this.blockCompressed \u003d in.readBoolean();  // is block-compressed?\n      } else {\n        blockCompressed \u003d false;\n      }\n      \n      // if version \u003e\u003d 5\n      // setup the compression codec\n      if (decompress) {\n        if (version \u003e\u003d CUSTOM_COMPRESS_VERSION) {\n          String codecClassname \u003d Text.readString(in);\n          try {\n            Class\u003c? extends CompressionCodec\u003e codecClass\n              \u003d conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);\n            this.codec \u003d ReflectionUtils.newInstance(codecClass, conf);\n          } catch (ClassNotFoundException cnfe) {\n            throw new IllegalArgumentException(\"Unknown codec: \" + \n                                               codecClassname, cnfe);\n          }\n        } else {\n          codec \u003d new DefaultCodec();\n          ((Configurable)codec).setConf(conf);\n        }\n      }\n      \n      this.metadata \u003d new Metadata();\n      if (version \u003e\u003d VERSION_WITH_METADATA) {    // if version \u003e\u003d 6\n        this.metadata.readFields(in);\n      }\n      \n      if (version \u003e 1) {                          // if version \u003e 1\n        in.readFully(sync);                       // read sync bytes\n      }\n      \n      // Initialize... *not* if this we are constructing a temporary Reader\n      if (!tempReader) {\n        valBuffer \u003d new DataInputBuffer();\n        if (decompress) {\n          valDecompressor \u003d CodecPool.getDecompressor(codec);\n          valInFilter \u003d codec.createInputStream(valBuffer, valDecompressor);\n          valIn \u003d new DataInputStream(valInFilter);\n        } else {\n          valIn \u003d valBuffer;\n        }\n\n        if (blockCompressed) {\n          keyLenBuffer \u003d new DataInputBuffer();\n          keyBuffer \u003d new DataInputBuffer();\n          valLenBuffer \u003d new DataInputBuffer();\n\n          keyLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyLenInFilter \u003d codec.createInputStream(keyLenBuffer, \n                                                   keyLenDecompressor);\n          keyLenIn \u003d new DataInputStream(keyLenInFilter);\n\n          keyDecompressor \u003d CodecPool.getDecompressor(codec);\n          keyInFilter \u003d codec.createInputStream(keyBuffer, keyDecompressor);\n          keyIn \u003d new DataInputStream(keyInFilter);\n\n          valLenDecompressor \u003d CodecPool.getDecompressor(codec);\n          valLenInFilter \u003d codec.createInputStream(valLenBuffer, \n                                                   valLenDecompressor);\n          valLenIn \u003d new DataInputStream(valLenInFilter);\n        }\n        \n        SerializationFactory serializationFactory \u003d\n          new SerializationFactory(conf);\n        this.keyDeserializer \u003d\n          getDeserializer(serializationFactory, getKeyClass());\n        if (!blockCompressed) {\n          this.keyDeserializer.open(valBuffer);\n        } else {\n          this.keyDeserializer.open(keyIn);\n        }\n        this.valDeserializer \u003d\n          getDeserializer(serializationFactory, getValueClass());\n        this.valDeserializer.open(valIn);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/io/SequenceFile.java"
    }
  }
}