{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockChecksumHelper.java",
  "functionName": "checksumBlock",
  "functionId": "checksumBlock___block-ExtendedBlock__blockIdx-int__blockToken-Token__BlockTokenIdentifier____targetDatanode-DatanodeInfo",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockChecksumHelper.java",
  "functionStartLine": 594,
  "functionEndLine": 680,
  "numCommitsSeen": 8,
  "timeTaken": 2191,
  "changeHistory": [
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
    "d749cf65e1ab0e0daf5be86931507183f189e855",
    "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720"
  ],
  "changeHistoryShort": {
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf": "Ybodychange",
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f": "Ybodychange",
    "d749cf65e1ab0e0daf5be86931507183f189e855": "Ybodychange",
    "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13056. Expose file-level composite CRCs in HDFS which are comparable across different instances/layouts. Contributed by Dennis Huo.\n",
      "commitDate": "10/04/18 9:31 PM",
      "commitName": "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "14/03/17 4:41 PM",
      "commitNameOld": "cc1292e73acd39c1f1023ad4841ffe30176f7daf",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 392.2,
      "commitsBetweenForRepo": 2722,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,87 @@\n     private void checksumBlock(ExtendedBlock block, int blockIdx,\n                                Token\u003cBlockTokenIdentifier\u003e blockToken,\n                                DatanodeInfo targetDatanode) throws IOException {\n       int timeout \u003d 3000;\n       try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n           timeout, block, blockToken)) {\n \n         LOG.debug(\"write to {}: {}, block\u003d{}\",\n             getDatanode(), Op.BLOCK_CHECKSUM, block);\n \n-        // get block MD5\n-        createSender(pair).blockChecksum(block, blockToken);\n+        // get block checksum\n+        // A BlockGroupCheckum of type COMPOSITE_CRC uses underlying\n+        // BlockChecksums also of type COMPOSITE_CRC but with\n+        // stripeLength \u003d\u003d ecPolicy.getCellSize().\n+        BlockChecksumOptions childOptions;\n+        BlockChecksumType groupChecksumType \u003d\n+            getBlockChecksumOptions().getBlockChecksumType();\n+        switch (groupChecksumType) {\n+        case MD5CRC:\n+          childOptions \u003d getBlockChecksumOptions();\n+          break;\n+        case COMPOSITE_CRC:\n+          childOptions \u003d new BlockChecksumOptions(\n+              BlockChecksumType.COMPOSITE_CRC, ecPolicy.getCellSize());\n+          break;\n+        default:\n+          throw new IOException(\n+              \"Unknown BlockChecksumType: \" + groupChecksumType);\n+        }\n+        createSender(pair).blockChecksum(block, blockToken, childOptions);\n \n         final DataTransferProtos.BlockOpResponseProto reply \u003d\n             DataTransferProtos.BlockOpResponseProto.parseFrom(\n                 PBHelperClient.vintPrefixed(pair.in));\n \n         String logInfo \u003d \"for block \" + block\n             + \" from datanode \" + targetDatanode;\n         DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n \n         DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n             reply.getChecksumResponse();\n \n         // read crc-type\n         final DataChecksum.Type ct;\n         if (checksumData.hasCrcType()) {\n           ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n         } else {\n           LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \"\n               + \"inferring checksum by reading first byte\");\n           ct \u003d DataChecksum.Type.DEFAULT;\n         }\n \n         setOrVerifyChecksumProperties(blockIdx, checksumData.getBytesPerCrc(),\n             checksumData.getCrcPerBlock(), ct);\n-        //read md5\n-        final MD5Hash md5 \u003d new MD5Hash(checksumData.getMd5().toByteArray());\n-        md5.write(md5writer);\n-        LOG.debug(\"got reply from datanode:{}, md5\u003d{}\", targetDatanode, md5);\n+\n+        switch (groupChecksumType) {\n+        case MD5CRC:\n+          //read md5\n+          final MD5Hash md5 \u003d\n+              new MD5Hash(checksumData.getBlockChecksum().toByteArray());\n+          md5.write(blockChecksumBuf);\n+          LOG.debug(\"got reply from datanode:{}, md5\u003d{}\",\n+              targetDatanode, md5);\n+          break;\n+        case COMPOSITE_CRC:\n+          BlockChecksumType returnedType \u003d PBHelperClient.convert(\n+              checksumData.getBlockChecksumOptions().getBlockChecksumType());\n+          if (returnedType !\u003d BlockChecksumType.COMPOSITE_CRC) {\n+            throw new IOException(String.format(\n+                \"Unexpected blockChecksumType \u0027%s\u0027, expecting COMPOSITE_CRC\",\n+                returnedType));\n+          }\n+          byte[] checksumBytes \u003d\n+              checksumData.getBlockChecksum().toByteArray();\n+          blockChecksumBuf.write(checksumBytes, 0, checksumBytes.length);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"got reply from datanode:{} for blockIdx:{}, checksum:{}\",\n+                targetDatanode, blockIdx,\n+                CrcUtil.toMultiCrcString(checksumBytes));\n+          }\n+          break;\n+        default:\n+          throw new IOException(\n+              \"Unknown BlockChecksumType: \" + groupChecksumType);\n+        }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checksumBlock(ExtendedBlock block, int blockIdx,\n                               Token\u003cBlockTokenIdentifier\u003e blockToken,\n                               DatanodeInfo targetDatanode) throws IOException {\n      int timeout \u003d 3000;\n      try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n          timeout, block, blockToken)) {\n\n        LOG.debug(\"write to {}: {}, block\u003d{}\",\n            getDatanode(), Op.BLOCK_CHECKSUM, block);\n\n        // get block checksum\n        // A BlockGroupCheckum of type COMPOSITE_CRC uses underlying\n        // BlockChecksums also of type COMPOSITE_CRC but with\n        // stripeLength \u003d\u003d ecPolicy.getCellSize().\n        BlockChecksumOptions childOptions;\n        BlockChecksumType groupChecksumType \u003d\n            getBlockChecksumOptions().getBlockChecksumType();\n        switch (groupChecksumType) {\n        case MD5CRC:\n          childOptions \u003d getBlockChecksumOptions();\n          break;\n        case COMPOSITE_CRC:\n          childOptions \u003d new BlockChecksumOptions(\n              BlockChecksumType.COMPOSITE_CRC, ecPolicy.getCellSize());\n          break;\n        default:\n          throw new IOException(\n              \"Unknown BlockChecksumType: \" + groupChecksumType);\n        }\n        createSender(pair).blockChecksum(block, blockToken, childOptions);\n\n        final DataTransferProtos.BlockOpResponseProto reply \u003d\n            DataTransferProtos.BlockOpResponseProto.parseFrom(\n                PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for block \" + block\n            + \" from datanode \" + targetDatanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n            reply.getChecksumResponse();\n\n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \"\n              + \"inferring checksum by reading first byte\");\n          ct \u003d DataChecksum.Type.DEFAULT;\n        }\n\n        setOrVerifyChecksumProperties(blockIdx, checksumData.getBytesPerCrc(),\n            checksumData.getCrcPerBlock(), ct);\n\n        switch (groupChecksumType) {\n        case MD5CRC:\n          //read md5\n          final MD5Hash md5 \u003d\n              new MD5Hash(checksumData.getBlockChecksum().toByteArray());\n          md5.write(blockChecksumBuf);\n          LOG.debug(\"got reply from datanode:{}, md5\u003d{}\",\n              targetDatanode, md5);\n          break;\n        case COMPOSITE_CRC:\n          BlockChecksumType returnedType \u003d PBHelperClient.convert(\n              checksumData.getBlockChecksumOptions().getBlockChecksumType());\n          if (returnedType !\u003d BlockChecksumType.COMPOSITE_CRC) {\n            throw new IOException(String.format(\n                \"Unexpected blockChecksumType \u0027%s\u0027, expecting COMPOSITE_CRC\",\n                returnedType));\n          }\n          byte[] checksumBytes \u003d\n              checksumData.getBlockChecksum().toByteArray();\n          blockChecksumBuf.write(checksumBytes, 0, checksumBytes.length);\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"got reply from datanode:{} for blockIdx:{}, checksum:{}\",\n                targetDatanode, blockIdx,\n                CrcUtil.toMultiCrcString(checksumBytes));\n          }\n          break;\n        default:\n          throw new IOException(\n              \"Unknown BlockChecksumType: \" + groupChecksumType);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockChecksumHelper.java",
      "extendedDetails": {}
    },
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10460. Recompute block checksum for a particular range less than file size on the fly by reconstructing missed block. Contributed by Rakesh R\n",
      "commitDate": "24/06/16 2:39 AM",
      "commitName": "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "01/06/16 9:56 PM",
      "commitNameOld": "d749cf65e1ab0e0daf5be86931507183f189e855",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 22.2,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,42 @@\n     private void checksumBlock(ExtendedBlock block, int blockIdx,\n                                Token\u003cBlockTokenIdentifier\u003e blockToken,\n                                DatanodeInfo targetDatanode) throws IOException {\n       int timeout \u003d 3000;\n       try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n           timeout, block, blockToken)) {\n \n         LOG.debug(\"write to {}: {}, block\u003d{}\",\n             getDatanode(), Op.BLOCK_CHECKSUM, block);\n \n         // get block MD5\n         createSender(pair).blockChecksum(block, blockToken);\n \n         final DataTransferProtos.BlockOpResponseProto reply \u003d\n             DataTransferProtos.BlockOpResponseProto.parseFrom(\n                 PBHelperClient.vintPrefixed(pair.in));\n \n         String logInfo \u003d \"for block \" + block\n             + \" from datanode \" + targetDatanode;\n         DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n \n         DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n             reply.getChecksumResponse();\n \n         // read crc-type\n         final DataChecksum.Type ct;\n         if (checksumData.hasCrcType()) {\n           ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n         } else {\n           LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \"\n               + \"inferring checksum by reading first byte\");\n           ct \u003d DataChecksum.Type.DEFAULT;\n         }\n \n         setOrVerifyChecksumProperties(blockIdx, checksumData.getBytesPerCrc(),\n             checksumData.getCrcPerBlock(), ct);\n         //read md5\n         final MD5Hash md5 \u003d new MD5Hash(checksumData.getMd5().toByteArray());\n         md5.write(md5writer);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"got reply from \" + targetDatanode + \": md5\u003d\" + md5);\n-        }\n+        LOG.debug(\"got reply from datanode:{}, md5\u003d{}\", targetDatanode, md5);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checksumBlock(ExtendedBlock block, int blockIdx,\n                               Token\u003cBlockTokenIdentifier\u003e blockToken,\n                               DatanodeInfo targetDatanode) throws IOException {\n      int timeout \u003d 3000;\n      try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n          timeout, block, blockToken)) {\n\n        LOG.debug(\"write to {}: {}, block\u003d{}\",\n            getDatanode(), Op.BLOCK_CHECKSUM, block);\n\n        // get block MD5\n        createSender(pair).blockChecksum(block, blockToken);\n\n        final DataTransferProtos.BlockOpResponseProto reply \u003d\n            DataTransferProtos.BlockOpResponseProto.parseFrom(\n                PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for block \" + block\n            + \" from datanode \" + targetDatanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n            reply.getChecksumResponse();\n\n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \"\n              + \"inferring checksum by reading first byte\");\n          ct \u003d DataChecksum.Type.DEFAULT;\n        }\n\n        setOrVerifyChecksumProperties(blockIdx, checksumData.getBytesPerCrc(),\n            checksumData.getCrcPerBlock(), ct);\n        //read md5\n        final MD5Hash md5 \u003d new MD5Hash(checksumData.getMd5().toByteArray());\n        md5.write(md5writer);\n        LOG.debug(\"got reply from datanode:{}, md5\u003d{}\", targetDatanode, md5);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockChecksumHelper.java",
      "extendedDetails": {}
    },
    "d749cf65e1ab0e0daf5be86931507183f189e855": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9833. Erasure coding: recomputing block checksum on the fly by reconstructing the missed/corrupt block data. Contributed by Rakesh R.\n",
      "commitDate": "01/06/16 9:56 PM",
      "commitName": "d749cf65e1ab0e0daf5be86931507183f189e855",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "26/03/16 7:58 PM",
      "commitNameOld": "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 67.08,
      "commitsBetweenForRepo": 433,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,44 @@\n     private void checksumBlock(ExtendedBlock block, int blockIdx,\n                                Token\u003cBlockTokenIdentifier\u003e blockToken,\n                                DatanodeInfo targetDatanode) throws IOException {\n       int timeout \u003d 3000;\n       try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n           timeout, block, blockToken)) {\n \n         LOG.debug(\"write to {}: {}, block\u003d{}\",\n             getDatanode(), Op.BLOCK_CHECKSUM, block);\n \n         // get block MD5\n         createSender(pair).blockChecksum(block, blockToken);\n \n         final DataTransferProtos.BlockOpResponseProto reply \u003d\n             DataTransferProtos.BlockOpResponseProto.parseFrom(\n                 PBHelperClient.vintPrefixed(pair.in));\n \n         String logInfo \u003d \"for block \" + block\n             + \" from datanode \" + targetDatanode;\n         DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n \n         DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n             reply.getChecksumResponse();\n \n-        //read byte-per-checksum\n-        final int bpc \u003d checksumData.getBytesPerCrc();\n-        if (blockIdx \u003d\u003d 0) { //first block\n-          setBytesPerCRC(bpc);\n-        } else if (bpc !\u003d getBytesPerCRC()) {\n-          throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n-              + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n-        }\n-\n-        //read crc-per-block\n-        final long cpb \u003d checksumData.getCrcPerBlock();\n-        if (blockIdx \u003d\u003d 0) {\n-          setCrcPerBlock(cpb);\n-        }\n-\n-        //read md5\n-        final MD5Hash md5 \u003d new MD5Hash(\n-            checksumData.getMd5().toByteArray());\n-        md5.write(md5writer);\n-\n         // read crc-type\n         final DataChecksum.Type ct;\n         if (checksumData.hasCrcType()) {\n           ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n         } else {\n-          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n-              \"inferring checksum by reading first byte\");\n+          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \"\n+              + \"inferring checksum by reading first byte\");\n           ct \u003d DataChecksum.Type.DEFAULT;\n         }\n \n-        if (blockIdx \u003d\u003d 0) { // first block\n-          setCrcType(ct);\n-        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n-            getCrcType() !\u003d ct) {\n-          // if crc types are mixed in a file\n-          setCrcType(DataChecksum.Type.MIXED);\n-        }\n-\n+        setOrVerifyChecksumProperties(blockIdx, checksumData.getBytesPerCrc(),\n+            checksumData.getCrcPerBlock(), ct);\n+        //read md5\n+        final MD5Hash md5 \u003d new MD5Hash(checksumData.getMd5().toByteArray());\n+        md5.write(md5writer);\n         if (LOG.isDebugEnabled()) {\n-          if (blockIdx \u003d\u003d 0) {\n-            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n-                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n-          }\n           LOG.debug(\"got reply from \" + targetDatanode + \": md5\u003d\" + md5);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checksumBlock(ExtendedBlock block, int blockIdx,\n                               Token\u003cBlockTokenIdentifier\u003e blockToken,\n                               DatanodeInfo targetDatanode) throws IOException {\n      int timeout \u003d 3000;\n      try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n          timeout, block, blockToken)) {\n\n        LOG.debug(\"write to {}: {}, block\u003d{}\",\n            getDatanode(), Op.BLOCK_CHECKSUM, block);\n\n        // get block MD5\n        createSender(pair).blockChecksum(block, blockToken);\n\n        final DataTransferProtos.BlockOpResponseProto reply \u003d\n            DataTransferProtos.BlockOpResponseProto.parseFrom(\n                PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for block \" + block\n            + \" from datanode \" + targetDatanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n            reply.getChecksumResponse();\n\n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \"\n              + \"inferring checksum by reading first byte\");\n          ct \u003d DataChecksum.Type.DEFAULT;\n        }\n\n        setOrVerifyChecksumProperties(blockIdx, checksumData.getBytesPerCrc(),\n            checksumData.getCrcPerBlock(), ct);\n        //read md5\n        final MD5Hash md5 \u003d new MD5Hash(checksumData.getMd5().toByteArray());\n        md5.write(md5writer);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"got reply from \" + targetDatanode + \": md5\u003d\" + md5);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockChecksumHelper.java",
      "extendedDetails": {}
    },
    "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9694. Make existing DFSClient#getFileChecksum() work for striped blocks. Contributed by Kai Zheng\n",
      "commitDate": "26/03/16 7:58 PM",
      "commitName": "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,71 @@\n+    private void checksumBlock(ExtendedBlock block, int blockIdx,\n+                               Token\u003cBlockTokenIdentifier\u003e blockToken,\n+                               DatanodeInfo targetDatanode) throws IOException {\n+      int timeout \u003d 3000;\n+      try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n+          timeout, block, blockToken)) {\n+\n+        LOG.debug(\"write to {}: {}, block\u003d{}\",\n+            getDatanode(), Op.BLOCK_CHECKSUM, block);\n+\n+        // get block MD5\n+        createSender(pair).blockChecksum(block, blockToken);\n+\n+        final DataTransferProtos.BlockOpResponseProto reply \u003d\n+            DataTransferProtos.BlockOpResponseProto.parseFrom(\n+                PBHelperClient.vintPrefixed(pair.in));\n+\n+        String logInfo \u003d \"for block \" + block\n+            + \" from datanode \" + targetDatanode;\n+        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n+\n+        DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n+            reply.getChecksumResponse();\n+\n+        //read byte-per-checksum\n+        final int bpc \u003d checksumData.getBytesPerCrc();\n+        if (blockIdx \u003d\u003d 0) { //first block\n+          setBytesPerCRC(bpc);\n+        } else if (bpc !\u003d getBytesPerCRC()) {\n+          throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n+              + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n+        }\n+\n+        //read crc-per-block\n+        final long cpb \u003d checksumData.getCrcPerBlock();\n+        if (blockIdx \u003d\u003d 0) {\n+          setCrcPerBlock(cpb);\n+        }\n+\n+        //read md5\n+        final MD5Hash md5 \u003d new MD5Hash(\n+            checksumData.getMd5().toByteArray());\n+        md5.write(md5writer);\n+\n+        // read crc-type\n+        final DataChecksum.Type ct;\n+        if (checksumData.hasCrcType()) {\n+          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n+        } else {\n+          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n+              \"inferring checksum by reading first byte\");\n+          ct \u003d DataChecksum.Type.DEFAULT;\n+        }\n+\n+        if (blockIdx \u003d\u003d 0) { // first block\n+          setCrcType(ct);\n+        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n+            getCrcType() !\u003d ct) {\n+          // if crc types are mixed in a file\n+          setCrcType(DataChecksum.Type.MIXED);\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+          if (blockIdx \u003d\u003d 0) {\n+            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n+                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n+          }\n+          LOG.debug(\"got reply from \" + targetDatanode + \": md5\u003d\" + md5);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void checksumBlock(ExtendedBlock block, int blockIdx,\n                               Token\u003cBlockTokenIdentifier\u003e blockToken,\n                               DatanodeInfo targetDatanode) throws IOException {\n      int timeout \u003d 3000;\n      try (IOStreamPair pair \u003d getDatanode().connectToDN(targetDatanode,\n          timeout, block, blockToken)) {\n\n        LOG.debug(\"write to {}: {}, block\u003d{}\",\n            getDatanode(), Op.BLOCK_CHECKSUM, block);\n\n        // get block MD5\n        createSender(pair).blockChecksum(block, blockToken);\n\n        final DataTransferProtos.BlockOpResponseProto reply \u003d\n            DataTransferProtos.BlockOpResponseProto.parseFrom(\n                PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for block \" + block\n            + \" from datanode \" + targetDatanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        DataTransferProtos.OpBlockChecksumResponseProto checksumData \u003d\n            reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc \u003d checksumData.getBytesPerCrc();\n        if (blockIdx \u003d\u003d 0) { //first block\n          setBytesPerCRC(bpc);\n        } else if (bpc !\u003d getBytesPerCRC()) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n              + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n        }\n\n        //read crc-per-block\n        final long cpb \u003d checksumData.getCrcPerBlock();\n        if (blockIdx \u003d\u003d 0) {\n          setCrcPerBlock(cpb);\n        }\n\n        //read md5\n        final MD5Hash md5 \u003d new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(md5writer);\n\n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n              \"inferring checksum by reading first byte\");\n          ct \u003d DataChecksum.Type.DEFAULT;\n        }\n\n        if (blockIdx \u003d\u003d 0) { // first block\n          setCrcType(ct);\n        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n            getCrcType() !\u003d ct) {\n          // if crc types are mixed in a file\n          setCrcType(DataChecksum.Type.MIXED);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          if (blockIdx \u003d\u003d 0) {\n            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n          }\n          LOG.debug(\"got reply from \" + targetDatanode + \": md5\u003d\" + md5);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockChecksumHelper.java"
    }
  }
}