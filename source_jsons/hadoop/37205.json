{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "IterativePlanner.java",
  "functionName": "computeJobAllocation",
  "functionId": "computeJobAllocation___plan-Plan__reservationId-ReservationId__reservation-ReservationDefinition__user-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
  "functionStartLine": 85,
  "functionEndLine": 167,
  "numCommitsSeen": 11,
  "timeTaken": 5749,
  "changeHistory": [
    "e6e614e380ed1d746973b50f666a9c40d272073e",
    "a3a615eeab8c14ccdc548311097e62a916963dc5",
    "5cf5c41a895f5ab8bf6270089f8cfdea50573a97",
    "742632e346604fd2b263bd42367165638fcf2416",
    "da1016365aba1cee9c06771ab142d077379f27af",
    "156f24ead00436faad5d4aeef327a546392cd265",
    "0e602fa3a1529134214452fba10a90307d9c2072",
    "f66ffcf832235e0da0bb050fff08e248b547c360"
  ],
  "changeHistoryShort": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": "Ybodychange",
    "a3a615eeab8c14ccdc548311097e62a916963dc5": "Ybodychange",
    "5cf5c41a895f5ab8bf6270089f8cfdea50573a97": "Ybodychange",
    "742632e346604fd2b263bd42367165638fcf2416": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "da1016365aba1cee9c06771ab142d077379f27af": "Ybodychange",
    "156f24ead00436faad5d4aeef327a546392cd265": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yrename,Yparameterchange)",
    "0e602fa3a1529134214452fba10a90307d9c2072": "Ybodychange",
    "f66ffcf832235e0da0bb050fff08e248b547c360": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "04/10/17 7:28 PM",
      "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/05/17 4:01 PM",
      "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 156.14,
      "commitsBetweenForRepo": 1057,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,83 @@\n   public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n       ReservationId reservationId, ReservationDefinition reservation,\n       String user) throws PlanningException {\n \n     // Initialize\n     initialize(plan, reservationId, reservation);\n \n     // Create the allocations data structure\n     RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     StageProvider stageProvider \u003d new StageProvider(allocateLeft, reservation);\n \n     // Current stage\n     ReservationRequest currentReservationStage;\n \n+    // initialize periodicity\n+    long period \u003d 0;\n+    if(reservation.getRecurrenceExpression() !\u003d null){\n+      period \u003d Long.parseLong(reservation.getRecurrenceExpression());\n+    }\n+\n     // Iterate the stages in reverse order\n     while (stageProvider.hasNext()) {\n \n       // Get current stage\n       currentReservationStage \u003d stageProvider.next();\n \n       // Validate that the ReservationRequest respects basic constraints\n       validateInputStage(plan, currentReservationStage);\n \n       // Set the stageArrival and stageDeadline\n       ReservationInterval stageInterval \u003d\n           setStageExecutionInterval(plan, reservation, currentReservationStage,\n               allocations);\n       Long stageArrival \u003d stageInterval.getStartTime();\n       Long stageDeadline \u003d stageInterval.getEndTime();\n \n       // Compute stage allocation\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           computeStageAllocation(plan, currentReservationStage, stageArrival,\n-              stageDeadline, user, reservationId);\n+              stageDeadline, period, user, reservationId);\n \n       // If we did not find an allocation, return NULL\n       // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n \n         // If it\u0027s an ANY job, we can move to the next possible request\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n \n         // Otherwise, the job cannot be allocated\n         throw new PlanningException(\"The request cannot be satisfied\");\n \n       }\n \n       // Validate ORDER_NO_GAP\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n         if (!validateOrderNoGap(allocations, curAlloc, allocateLeft)) {\n           throw new PlanningException(\n               \"The allocation found does not respect ORDER_NO_GAP\");\n         }\n       }\n \n       // If we did find an allocation for the stage, add it\n       for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n         allocations.addInterval(entry.getKey(), entry.getValue());\n       }\n \n       // If this is an ANY clause, we have finished\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n         break;\n       }\n     }\n \n     // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n       throw new PlanningException(\"The request cannot be satisfied\");\n     }\n \n     return allocations;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation,\n      String user) throws PlanningException {\n\n    // Initialize\n    initialize(plan, reservationId, reservation);\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    StageProvider stageProvider \u003d new StageProvider(allocateLeft, reservation);\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // initialize periodicity\n    long period \u003d 0;\n    if(reservation.getRecurrenceExpression() !\u003d null){\n      period \u003d Long.parseLong(reservation.getRecurrenceExpression());\n    }\n\n    // Iterate the stages in reverse order\n    while (stageProvider.hasNext()) {\n\n      // Get current stage\n      currentReservationStage \u003d stageProvider.next();\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Set the stageArrival and stageDeadline\n      ReservationInterval stageInterval \u003d\n          setStageExecutionInterval(plan, reservation, currentReservationStage,\n              allocations);\n      Long stageArrival \u003d stageInterval.getStartTime();\n      Long stageDeadline \u003d stageInterval.getEndTime();\n\n      // Compute stage allocation\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage, stageArrival,\n              stageDeadline, period, user, reservationId);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        throw new PlanningException(\"The request cannot be satisfied\");\n\n      }\n\n      // Validate ORDER_NO_GAP\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        if (!validateOrderNoGap(allocations, curAlloc, allocateLeft)) {\n          throw new PlanningException(\n              \"The allocation found does not respect ORDER_NO_GAP\");\n        }\n      }\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The request cannot be satisfied\");\n    }\n\n    return allocations;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
      "extendedDetails": {}
    },
    "a3a615eeab8c14ccdc548311097e62a916963dc5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
      "commitDate": "01/05/17 4:01 PM",
      "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "10/02/16 9:11 AM",
      "commitNameOld": "5cf5c41a895f5ab8bf6270089f8cfdea50573a97",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 446.24,
      "commitsBetweenForRepo": 2940,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,77 @@\n   public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n       ReservationId reservationId, ReservationDefinition reservation,\n       String user) throws PlanningException {\n \n     // Initialize\n     initialize(plan, reservationId, reservation);\n \n     // Create the allocations data structure\n     RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     StageProvider stageProvider \u003d new StageProvider(allocateLeft, reservation);\n \n     // Current stage\n     ReservationRequest currentReservationStage;\n \n-    // Stage deadlines\n-    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n-    long successorStartingTime \u003d -1;\n-    long predecessorEndTime \u003d stepRoundDown(reservation.getArrival(), step);\n-    long stageArrivalTime \u003d -1;\n-\n     // Iterate the stages in reverse order\n     while (stageProvider.hasNext()) {\n \n       // Get current stage\n       currentReservationStage \u003d stageProvider.next();\n \n       // Validate that the ReservationRequest respects basic constraints\n       validateInputStage(plan, currentReservationStage);\n \n-      // Compute an adjusted earliestStart for this resource\n-      // (we need this to provision some space for the ORDER contracts)\n+      // Set the stageArrival and stageDeadline\n+      ReservationInterval stageInterval \u003d\n+          setStageExecutionInterval(plan, reservation, currentReservationStage,\n+              allocations);\n+      Long stageArrival \u003d stageInterval.getStartTime();\n+      Long stageDeadline \u003d stageInterval.getEndTime();\n \n-      if (allocateLeft) {\n-        stageArrivalTime \u003d predecessorEndTime;\n-      } else {\n-        stageArrivalTime \u003d reservation.getArrival();\n-        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          stageArrivalTime \u003d\n-              computeEarliestStartingTime(plan, reservation,\n-                  stageProvider.getCurrentIndex(), currentReservationStage,\n-                  stageDeadline);\n-        }\n-        stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n-        stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n-      }\n-      // Compute the allocation of a single stage\n+      // Compute stage allocation\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          computeStageAllocation(plan, currentReservationStage,\n-              stageArrivalTime, stageDeadline, user, reservationId);\n+          computeStageAllocation(plan, currentReservationStage, stageArrival,\n+              stageDeadline, user, reservationId);\n \n       // If we did not find an allocation, return NULL\n       // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n \n         // If it\u0027s an ANY job, we can move to the next possible request\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n \n         // Otherwise, the job cannot be allocated\n         throw new PlanningException(\"The request cannot be satisfied\");\n \n       }\n \n-      // Get the start \u0026 end time of the current allocation\n-      Long stageStartTime \u003d findEarliestTime(curAlloc);\n-      Long stageEndTime \u003d findLatestTime(curAlloc);\n+      // Validate ORDER_NO_GAP\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        if (!validateOrderNoGap(allocations, curAlloc, allocateLeft)) {\n+          throw new PlanningException(\n+              \"The allocation found does not respect ORDER_NO_GAP\");\n+        }\n+      }\n \n       // If we did find an allocation for the stage, add it\n       for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n         allocations.addInterval(entry.getKey(), entry.getValue());\n       }\n \n       // If this is an ANY clause, we have finished\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n         break;\n       }\n-\n-      // If ORDER job, set the stageDeadline of the next stage to be processed\n-      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-\n-        // CHECK ORDER_NO_GAP\n-        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n-        // note that the test is different left-to-right and right-to-left\n-        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-            \u0026\u0026 successorStartingTime !\u003d -1\n-            \u0026\u0026 ((allocateLeft \u0026\u0026 predecessorEndTime \u003c stageStartTime) ||\n-                (!allocateLeft \u0026\u0026 (stageEndTime \u003c successorStartingTime))\n-               )\n-            || (!isNonPreemptiveAllocation(curAlloc))) {\n-          throw new PlanningException(\n-              \"The allocation found does not respect ORDER_NO_GAP\");\n-        }\n-\n-        if (allocateLeft) {\n-          // Store the stageStartTime and set the new stageDeadline\n-          predecessorEndTime \u003d stageEndTime;\n-        } else {\n-          // Store the stageStartTime and set the new stageDeadline\n-          successorStartingTime \u003d stageStartTime;\n-          stageDeadline \u003d stageStartTime;\n-        }\n-      }\n     }\n \n     // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n       throw new PlanningException(\"The request cannot be satisfied\");\n     }\n \n     return allocations;\n-\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation,\n      String user) throws PlanningException {\n\n    // Initialize\n    initialize(plan, reservationId, reservation);\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    StageProvider stageProvider \u003d new StageProvider(allocateLeft, reservation);\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Iterate the stages in reverse order\n    while (stageProvider.hasNext()) {\n\n      // Get current stage\n      currentReservationStage \u003d stageProvider.next();\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Set the stageArrival and stageDeadline\n      ReservationInterval stageInterval \u003d\n          setStageExecutionInterval(plan, reservation, currentReservationStage,\n              allocations);\n      Long stageArrival \u003d stageInterval.getStartTime();\n      Long stageDeadline \u003d stageInterval.getEndTime();\n\n      // Compute stage allocation\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage, stageArrival,\n              stageDeadline, user, reservationId);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        throw new PlanningException(\"The request cannot be satisfied\");\n\n      }\n\n      // Validate ORDER_NO_GAP\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        if (!validateOrderNoGap(allocations, curAlloc, allocateLeft)) {\n          throw new PlanningException(\n              \"The allocation found does not respect ORDER_NO_GAP\");\n        }\n      }\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The request cannot be satisfied\");\n    }\n\n    return allocations;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
      "extendedDetails": {}
    },
    "5cf5c41a895f5ab8bf6270089f8cfdea50573a97": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4360. Improve GreedyReservationAgent to support \"early\" allocations, and performance improvements (curino via asuresh)\n",
      "commitDate": "10/02/16 9:11 AM",
      "commitName": "5cf5c41a895f5ab8bf6270089f8cfdea50573a97",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "05/12/15 9:26 PM",
      "commitNameOld": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 66.49,
      "commitsBetweenForRepo": 408,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,117 @@\n   public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n       ReservationId reservationId, ReservationDefinition reservation,\n       String user) throws PlanningException {\n \n     // Initialize\n-    initialize(plan, reservation);\n-\n-    // If the job has been previously reserved, logically remove its allocation\n-    ReservationAllocation oldReservation \u003d\n-        plan.getReservationById(reservationId);\n-    if (oldReservation !\u003d null) {\n-      ignoreOldAllocation(oldReservation);\n-    }\n+    initialize(plan, reservationId, reservation);\n \n     // Create the allocations data structure\n     RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n-    // Get a reverse iterator for the set of stages\n-    ListIterator\u003cReservationRequest\u003e li \u003d\n-        reservation\n-            .getReservationRequests()\n-            .getReservationResources()\n-            .listIterator(\n-                reservation.getReservationRequests().getReservationResources()\n-                    .size());\n+    StageProvider stageProvider \u003d new StageProvider(allocateLeft, reservation);\n \n     // Current stage\n     ReservationRequest currentReservationStage;\n \n-    // Index, points on the current node\n-    int index \u003d\n-        reservation.getReservationRequests().getReservationResources().size();\n-\n     // Stage deadlines\n     long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n     long successorStartingTime \u003d -1;\n+    long predecessorEndTime \u003d stepRoundDown(reservation.getArrival(), step);\n+    long stageArrivalTime \u003d -1;\n \n     // Iterate the stages in reverse order\n-    while (li.hasPrevious()) {\n+    while (stageProvider.hasNext()) {\n \n       // Get current stage\n-      currentReservationStage \u003d li.previous();\n-      index -\u003d 1;\n+      currentReservationStage \u003d stageProvider.next();\n \n       // Validate that the ReservationRequest respects basic constraints\n       validateInputStage(plan, currentReservationStage);\n \n       // Compute an adjusted earliestStart for this resource\n       // (we need this to provision some space for the ORDER contracts)\n-      long stageArrivalTime \u003d reservation.getArrival();\n-      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-        stageArrivalTime \u003d\n-            computeEarliestStartingTime(plan, reservation, index,\n-                currentReservationStage, stageDeadline);\n-      }\n-      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n-      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n \n+      if (allocateLeft) {\n+        stageArrivalTime \u003d predecessorEndTime;\n+      } else {\n+        stageArrivalTime \u003d reservation.getArrival();\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+            || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+          stageArrivalTime \u003d\n+              computeEarliestStartingTime(plan, reservation,\n+                  stageProvider.getCurrentIndex(), currentReservationStage,\n+                  stageDeadline);\n+        }\n+        stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+        stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+      }\n       // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           computeStageAllocation(plan, currentReservationStage,\n               stageArrivalTime, stageDeadline, user, reservationId);\n \n       // If we did not find an allocation, return NULL\n       // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n \n         // If it\u0027s an ANY job, we can move to the next possible request\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n \n         // Otherwise, the job cannot be allocated\n-        return null;\n+        throw new PlanningException(\"The request cannot be satisfied\");\n \n       }\n \n       // Get the start \u0026 end time of the current allocation\n       Long stageStartTime \u003d findEarliestTime(curAlloc);\n       Long stageEndTime \u003d findLatestTime(curAlloc);\n \n       // If we did find an allocation for the stage, add it\n       for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n         allocations.addInterval(entry.getKey(), entry.getValue());\n       }\n \n       // If this is an ANY clause, we have finished\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n         break;\n       }\n \n       // If ORDER job, set the stageDeadline of the next stage to be processed\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n \n+        // CHECK ORDER_NO_GAP\n         // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        // note that the test is different left-to-right and right-to-left\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n             \u0026\u0026 successorStartingTime !\u003d -1\n-            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n-\n-          return null;\n-\n+            \u0026\u0026 ((allocateLeft \u0026\u0026 predecessorEndTime \u003c stageStartTime) ||\n+                (!allocateLeft \u0026\u0026 (stageEndTime \u003c successorStartingTime))\n+               )\n+            || (!isNonPreemptiveAllocation(curAlloc))) {\n+          throw new PlanningException(\n+              \"The allocation found does not respect ORDER_NO_GAP\");\n         }\n \n-        // Store the stageStartTime and set the new stageDeadline\n-        successorStartingTime \u003d stageStartTime;\n-        stageDeadline \u003d stageStartTime;\n-\n+        if (allocateLeft) {\n+          // Store the stageStartTime and set the new stageDeadline\n+          predecessorEndTime \u003d stageEndTime;\n+        } else {\n+          // Store the stageStartTime and set the new stageDeadline\n+          successorStartingTime \u003d stageStartTime;\n+          stageDeadline \u003d stageStartTime;\n+        }\n       }\n-\n     }\n \n     // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      return null;\n+      throw new PlanningException(\"The request cannot be satisfied\");\n     }\n \n     return allocations;\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation,\n      String user) throws PlanningException {\n\n    // Initialize\n    initialize(plan, reservationId, reservation);\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    StageProvider stageProvider \u003d new StageProvider(allocateLeft, reservation);\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n    long predecessorEndTime \u003d stepRoundDown(reservation.getArrival(), step);\n    long stageArrivalTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (stageProvider.hasNext()) {\n\n      // Get current stage\n      currentReservationStage \u003d stageProvider.next();\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n\n      if (allocateLeft) {\n        stageArrivalTime \u003d predecessorEndTime;\n      } else {\n        stageArrivalTime \u003d reservation.getArrival();\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n            || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n          stageArrivalTime \u003d\n              computeEarliestStartingTime(plan, reservation,\n                  stageProvider.getCurrentIndex(), currentReservationStage,\n                  stageDeadline);\n        }\n        stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n        stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n      }\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline, user, reservationId);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        throw new PlanningException(\"The request cannot be satisfied\");\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc);\n      Long stageEndTime \u003d findLatestTime(curAlloc);\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // CHECK ORDER_NO_GAP\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        // note that the test is different left-to-right and right-to-left\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 ((allocateLeft \u0026\u0026 predecessorEndTime \u003c stageStartTime) ||\n                (!allocateLeft \u0026\u0026 (stageEndTime \u003c successorStartingTime))\n               )\n            || (!isNonPreemptiveAllocation(curAlloc))) {\n          throw new PlanningException(\n              \"The allocation found does not respect ORDER_NO_GAP\");\n        }\n\n        if (allocateLeft) {\n          // Store the stageStartTime and set the new stageDeadline\n          predecessorEndTime \u003d stageEndTime;\n        } else {\n          // Store the stageStartTime and set the new stageDeadline\n          successorStartingTime \u003d stageStartTime;\n          stageDeadline \u003d stageStartTime;\n        }\n      }\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The request cannot be satisfied\");\n    }\n\n    return allocations;\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
      "extendedDetails": {}
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "21/11/15 9:59 AM",
          "commitNameOld": "da1016365aba1cee9c06771ab142d077379f27af",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 14.48,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,122 @@\n   public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n-      ReservationId reservationId, ReservationDefinition reservation)\n-      throws ContractValidationException {\n+      ReservationId reservationId, ReservationDefinition reservation,\n+      String user) throws PlanningException {\n \n     // Initialize\n     initialize(plan, reservation);\n \n     // If the job has been previously reserved, logically remove its allocation\n     ReservationAllocation oldReservation \u003d\n         plan.getReservationById(reservationId);\n     if (oldReservation !\u003d null) {\n       ignoreOldAllocation(oldReservation);\n     }\n \n     // Create the allocations data structure\n     RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Get a reverse iterator for the set of stages\n     ListIterator\u003cReservationRequest\u003e li \u003d\n         reservation\n             .getReservationRequests()\n             .getReservationResources()\n             .listIterator(\n                 reservation.getReservationRequests().getReservationResources()\n                     .size());\n \n     // Current stage\n     ReservationRequest currentReservationStage;\n \n     // Index, points on the current node\n     int index \u003d\n         reservation.getReservationRequests().getReservationResources().size();\n \n     // Stage deadlines\n     long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n     long successorStartingTime \u003d -1;\n \n     // Iterate the stages in reverse order\n     while (li.hasPrevious()) {\n \n       // Get current stage\n       currentReservationStage \u003d li.previous();\n       index -\u003d 1;\n \n       // Validate that the ReservationRequest respects basic constraints\n       validateInputStage(plan, currentReservationStage);\n \n       // Compute an adjusted earliestStart for this resource\n       // (we need this to provision some space for the ORDER contracts)\n       long stageArrivalTime \u003d reservation.getArrival();\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n         stageArrivalTime \u003d\n             computeEarliestStartingTime(plan, reservation, index,\n                 currentReservationStage, stageDeadline);\n       }\n       stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n       stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n \n       // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           computeStageAllocation(plan, currentReservationStage,\n-              stageArrivalTime, stageDeadline);\n+              stageArrivalTime, stageDeadline, user, reservationId);\n \n       // If we did not find an allocation, return NULL\n       // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n \n         // If it\u0027s an ANY job, we can move to the next possible request\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n \n         // Otherwise, the job cannot be allocated\n         return null;\n \n       }\n \n       // Get the start \u0026 end time of the current allocation\n-      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n-      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+      Long stageStartTime \u003d findEarliestTime(curAlloc);\n+      Long stageEndTime \u003d findLatestTime(curAlloc);\n \n       // If we did find an allocation for the stage, add it\n       for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n         allocations.addInterval(entry.getKey(), entry.getValue());\n       }\n \n       // If this is an ANY clause, we have finished\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n         break;\n       }\n \n       // If ORDER job, set the stageDeadline of the next stage to be processed\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n \n         // Verify that there is no gap, in case the job is ORDER_NO_GAP\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n             \u0026\u0026 successorStartingTime !\u003d -1\n             \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n \n           return null;\n \n         }\n \n         // Store the stageStartTime and set the new stageDeadline\n         successorStartingTime \u003d stageStartTime;\n         stageDeadline \u003d stageStartTime;\n \n       }\n \n     }\n \n     // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n       return null;\n     }\n \n     return allocations;\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation,\n      String user) throws PlanningException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline, user, reservationId);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc);\n      Long stageEndTime \u003d findLatestTime(curAlloc);\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan, reservationId-ReservationId, reservation-ReservationDefinition]",
            "newValue": "[plan-Plan, reservationId-ReservationId, reservation-ReservationDefinition, user-String]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "21/11/15 9:59 AM",
          "commitNameOld": "da1016365aba1cee9c06771ab142d077379f27af",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 14.48,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,122 @@\n   public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n-      ReservationId reservationId, ReservationDefinition reservation)\n-      throws ContractValidationException {\n+      ReservationId reservationId, ReservationDefinition reservation,\n+      String user) throws PlanningException {\n \n     // Initialize\n     initialize(plan, reservation);\n \n     // If the job has been previously reserved, logically remove its allocation\n     ReservationAllocation oldReservation \u003d\n         plan.getReservationById(reservationId);\n     if (oldReservation !\u003d null) {\n       ignoreOldAllocation(oldReservation);\n     }\n \n     // Create the allocations data structure\n     RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Get a reverse iterator for the set of stages\n     ListIterator\u003cReservationRequest\u003e li \u003d\n         reservation\n             .getReservationRequests()\n             .getReservationResources()\n             .listIterator(\n                 reservation.getReservationRequests().getReservationResources()\n                     .size());\n \n     // Current stage\n     ReservationRequest currentReservationStage;\n \n     // Index, points on the current node\n     int index \u003d\n         reservation.getReservationRequests().getReservationResources().size();\n \n     // Stage deadlines\n     long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n     long successorStartingTime \u003d -1;\n \n     // Iterate the stages in reverse order\n     while (li.hasPrevious()) {\n \n       // Get current stage\n       currentReservationStage \u003d li.previous();\n       index -\u003d 1;\n \n       // Validate that the ReservationRequest respects basic constraints\n       validateInputStage(plan, currentReservationStage);\n \n       // Compute an adjusted earliestStart for this resource\n       // (we need this to provision some space for the ORDER contracts)\n       long stageArrivalTime \u003d reservation.getArrival();\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n         stageArrivalTime \u003d\n             computeEarliestStartingTime(plan, reservation, index,\n                 currentReservationStage, stageDeadline);\n       }\n       stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n       stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n \n       // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           computeStageAllocation(plan, currentReservationStage,\n-              stageArrivalTime, stageDeadline);\n+              stageArrivalTime, stageDeadline, user, reservationId);\n \n       // If we did not find an allocation, return NULL\n       // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n \n         // If it\u0027s an ANY job, we can move to the next possible request\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n \n         // Otherwise, the job cannot be allocated\n         return null;\n \n       }\n \n       // Get the start \u0026 end time of the current allocation\n-      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n-      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+      Long stageStartTime \u003d findEarliestTime(curAlloc);\n+      Long stageEndTime \u003d findLatestTime(curAlloc);\n \n       // If we did find an allocation for the stage, add it\n       for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n         allocations.addInterval(entry.getKey(), entry.getValue());\n       }\n \n       // If this is an ANY clause, we have finished\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n         break;\n       }\n \n       // If ORDER job, set the stageDeadline of the next stage to be processed\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n \n         // Verify that there is no gap, in case the job is ORDER_NO_GAP\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n             \u0026\u0026 successorStartingTime !\u003d -1\n             \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n \n           return null;\n \n         }\n \n         // Store the stageStartTime and set the new stageDeadline\n         successorStartingTime \u003d stageStartTime;\n         stageDeadline \u003d stageStartTime;\n \n       }\n \n     }\n \n     // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n       return null;\n     }\n \n     return allocations;\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation,\n      String user) throws PlanningException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline, user, reservationId);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc);\n      Long stageEndTime \u003d findLatestTime(curAlloc);\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldValue": "[ContractValidationException]",
            "newValue": "[PlanningException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "21/11/15 9:59 AM",
          "commitNameOld": "da1016365aba1cee9c06771ab142d077379f27af",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 14.48,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,122 @@\n   public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n-      ReservationId reservationId, ReservationDefinition reservation)\n-      throws ContractValidationException {\n+      ReservationId reservationId, ReservationDefinition reservation,\n+      String user) throws PlanningException {\n \n     // Initialize\n     initialize(plan, reservation);\n \n     // If the job has been previously reserved, logically remove its allocation\n     ReservationAllocation oldReservation \u003d\n         plan.getReservationById(reservationId);\n     if (oldReservation !\u003d null) {\n       ignoreOldAllocation(oldReservation);\n     }\n \n     // Create the allocations data structure\n     RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Get a reverse iterator for the set of stages\n     ListIterator\u003cReservationRequest\u003e li \u003d\n         reservation\n             .getReservationRequests()\n             .getReservationResources()\n             .listIterator(\n                 reservation.getReservationRequests().getReservationResources()\n                     .size());\n \n     // Current stage\n     ReservationRequest currentReservationStage;\n \n     // Index, points on the current node\n     int index \u003d\n         reservation.getReservationRequests().getReservationResources().size();\n \n     // Stage deadlines\n     long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n     long successorStartingTime \u003d -1;\n \n     // Iterate the stages in reverse order\n     while (li.hasPrevious()) {\n \n       // Get current stage\n       currentReservationStage \u003d li.previous();\n       index -\u003d 1;\n \n       // Validate that the ReservationRequest respects basic constraints\n       validateInputStage(plan, currentReservationStage);\n \n       // Compute an adjusted earliestStart for this resource\n       // (we need this to provision some space for the ORDER contracts)\n       long stageArrivalTime \u003d reservation.getArrival();\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n         stageArrivalTime \u003d\n             computeEarliestStartingTime(plan, reservation, index,\n                 currentReservationStage, stageDeadline);\n       }\n       stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n       stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n \n       // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           computeStageAllocation(plan, currentReservationStage,\n-              stageArrivalTime, stageDeadline);\n+              stageArrivalTime, stageDeadline, user, reservationId);\n \n       // If we did not find an allocation, return NULL\n       // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n \n         // If it\u0027s an ANY job, we can move to the next possible request\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n \n         // Otherwise, the job cannot be allocated\n         return null;\n \n       }\n \n       // Get the start \u0026 end time of the current allocation\n-      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n-      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+      Long stageStartTime \u003d findEarliestTime(curAlloc);\n+      Long stageEndTime \u003d findLatestTime(curAlloc);\n \n       // If we did find an allocation for the stage, add it\n       for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n         allocations.addInterval(entry.getKey(), entry.getValue());\n       }\n \n       // If this is an ANY clause, we have finished\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n         break;\n       }\n \n       // If ORDER job, set the stageDeadline of the next stage to be processed\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n \n         // Verify that there is no gap, in case the job is ORDER_NO_GAP\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n             \u0026\u0026 successorStartingTime !\u003d -1\n             \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n \n           return null;\n \n         }\n \n         // Store the stageStartTime and set the new stageDeadline\n         successorStartingTime \u003d stageStartTime;\n         stageDeadline \u003d stageStartTime;\n \n       }\n \n     }\n \n     // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n       return null;\n     }\n \n     return allocations;\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation,\n      String user) throws PlanningException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline, user, reservationId);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc);\n      Long stageEndTime \u003d findLatestTime(curAlloc);\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {}
        }
      ]
    },
    "da1016365aba1cee9c06771ab142d077379f27af": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3454. Add efficient merge operation to RLESparseResourceAllocation (Carlo Curino via asuresh)\n",
      "commitDate": "21/11/15 9:59 AM",
      "commitName": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "25/07/15 7:39 AM",
      "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthorOld": "ccurino",
      "daysBetweenCommits": 119.14,
      "commitsBetweenForRepo": 803,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,122 @@\n   public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n       ReservationId reservationId, ReservationDefinition reservation)\n       throws ContractValidationException {\n \n     // Initialize\n     initialize(plan, reservation);\n \n     // If the job has been previously reserved, logically remove its allocation\n     ReservationAllocation oldReservation \u003d\n         plan.getReservationById(reservationId);\n     if (oldReservation !\u003d null) {\n       ignoreOldAllocation(oldReservation);\n     }\n \n     // Create the allocations data structure\n     RLESparseResourceAllocation allocations \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n+        new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Get a reverse iterator for the set of stages\n     ListIterator\u003cReservationRequest\u003e li \u003d\n         reservation\n             .getReservationRequests()\n             .getReservationResources()\n             .listIterator(\n                 reservation.getReservationRequests().getReservationResources()\n                     .size());\n \n     // Current stage\n     ReservationRequest currentReservationStage;\n \n     // Index, points on the current node\n     int index \u003d\n         reservation.getReservationRequests().getReservationResources().size();\n \n     // Stage deadlines\n     long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n     long successorStartingTime \u003d -1;\n \n     // Iterate the stages in reverse order\n     while (li.hasPrevious()) {\n \n       // Get current stage\n       currentReservationStage \u003d li.previous();\n       index -\u003d 1;\n \n       // Validate that the ReservationRequest respects basic constraints\n       validateInputStage(plan, currentReservationStage);\n \n       // Compute an adjusted earliestStart for this resource\n       // (we need this to provision some space for the ORDER contracts)\n       long stageArrivalTime \u003d reservation.getArrival();\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n         stageArrivalTime \u003d\n             computeEarliestStartingTime(plan, reservation, index,\n                 currentReservationStage, stageDeadline);\n       }\n       stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n       stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n \n       // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           computeStageAllocation(plan, currentReservationStage,\n               stageArrivalTime, stageDeadline);\n \n       // If we did not find an allocation, return NULL\n       // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n \n         // If it\u0027s an ANY job, we can move to the next possible request\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n \n         // Otherwise, the job cannot be allocated\n         return null;\n \n       }\n \n       // Get the start \u0026 end time of the current allocation\n       Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n       Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n \n       // If we did find an allocation for the stage, add it\n       for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n         allocations.addInterval(entry.getKey(), entry.getValue());\n       }\n \n       // If this is an ANY clause, we have finished\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n         break;\n       }\n \n       // If ORDER job, set the stageDeadline of the next stage to be processed\n       if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n           || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n \n         // Verify that there is no gap, in case the job is ORDER_NO_GAP\n         if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n             \u0026\u0026 successorStartingTime !\u003d -1\n             \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n \n           return null;\n \n         }\n \n         // Store the stageStartTime and set the new stageDeadline\n         successorStartingTime \u003d stageStartTime;\n         stageDeadline \u003d stageStartTime;\n \n       }\n \n     }\n \n     // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n       return null;\n     }\n \n     return allocations;\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
      "extendedDetails": {}
    },
    "156f24ead00436faad5d4aeef327a546392cd265": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
      "commitDate": "25/07/15 7:39 AM",
      "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthor": "ccurino",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,123 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n+      ReservationId reservationId, ReservationDefinition reservation)\n+      throws ContractValidationException {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n+    // Initialize\n+    initialize(plan, reservation);\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    // If the job has been previously reserved, logically remove its allocation\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservationId);\n+    if (oldReservation !\u003d null) {\n+      ignoreOldAllocation(oldReservation);\n     }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create the allocations data structure\n+    RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Get a reverse iterator for the set of stages\n+    ListIterator\u003cReservationRequest\u003e li \u003d\n+        reservation\n+            .getReservationRequests()\n+            .getReservationResources()\n+            .listIterator(\n+                reservation.getReservationRequests().getReservationResources()\n+                    .size());\n \n-    boolean hasGang \u003d false;\n+    // Current stage\n+    ReservationRequest currentReservationStage;\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // Index, points on the current node\n+    int index \u003d\n+        reservation.getReservationRequests().getReservationResources().size();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Stage deadlines\n+    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n+    long successorStartingTime \u003d -1;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // Iterate the stages in reverse order\n+    while (li.hasPrevious()) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // Get current stage\n+      currentReservationStage \u003d li.previous();\n+      index -\u003d 1;\n \n-      // run allocation for a single stage\n+      // Validate that the ReservationRequest respects basic constraints\n+      validateInputStage(plan, currentReservationStage);\n+\n+      // Compute an adjusted earliestStart for this resource\n+      // (we need this to provision some space for the ORDER contracts)\n+      long stageArrivalTime \u003d reservation.getArrival();\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        stageArrivalTime \u003d\n+            computeEarliestStartingTime(plan, reservation, index,\n+                currentReservationStage, stageDeadline);\n+      }\n+      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+\n+      // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+          computeStageAllocation(plan, currentReservationStage,\n+              stageArrivalTime, stageDeadline);\n \n+      // If we did not find an allocation, return NULL\n+      // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n+\n+        // If it\u0027s an ANY job, we can move to the next possible request\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n-      } else {\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // Otherwise, the job cannot be allocated\n+        return null;\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n       }\n+\n+      // Get the start \u0026 end time of the current allocation\n+      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n+      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+\n+      // If we did find an allocation for the stage, add it\n+      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n+        allocations.addInterval(entry.getKey(), entry.getValue());\n+      }\n+\n+      // If this is an ANY clause, we have finished\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+        break;\n+      }\n+\n+      // If ORDER job, set the stageDeadline of the next stage to be processed\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+\n+        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+            \u0026\u0026 successorStartingTime !\u003d -1\n+            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n+\n+          return null;\n+\n+        }\n+\n+        // Store the stageStartTime and set the new stageDeadline\n+        successorStartingTime \u003d stageStartTime;\n+        stageDeadline \u003d stageStartTime;\n+\n+      }\n+\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n+    // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+      return null;\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    return allocations;\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n-    } else {\n-      return plan.addReservation(capReservation);\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
            "oldMethodName": "computeAllocation",
            "newMethodName": "computeJobAllocation"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,123 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n+      ReservationId reservationId, ReservationDefinition reservation)\n+      throws ContractValidationException {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n+    // Initialize\n+    initialize(plan, reservation);\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    // If the job has been previously reserved, logically remove its allocation\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservationId);\n+    if (oldReservation !\u003d null) {\n+      ignoreOldAllocation(oldReservation);\n     }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create the allocations data structure\n+    RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Get a reverse iterator for the set of stages\n+    ListIterator\u003cReservationRequest\u003e li \u003d\n+        reservation\n+            .getReservationRequests()\n+            .getReservationResources()\n+            .listIterator(\n+                reservation.getReservationRequests().getReservationResources()\n+                    .size());\n \n-    boolean hasGang \u003d false;\n+    // Current stage\n+    ReservationRequest currentReservationStage;\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // Index, points on the current node\n+    int index \u003d\n+        reservation.getReservationRequests().getReservationResources().size();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Stage deadlines\n+    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n+    long successorStartingTime \u003d -1;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // Iterate the stages in reverse order\n+    while (li.hasPrevious()) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // Get current stage\n+      currentReservationStage \u003d li.previous();\n+      index -\u003d 1;\n \n-      // run allocation for a single stage\n+      // Validate that the ReservationRequest respects basic constraints\n+      validateInputStage(plan, currentReservationStage);\n+\n+      // Compute an adjusted earliestStart for this resource\n+      // (we need this to provision some space for the ORDER contracts)\n+      long stageArrivalTime \u003d reservation.getArrival();\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        stageArrivalTime \u003d\n+            computeEarliestStartingTime(plan, reservation, index,\n+                currentReservationStage, stageDeadline);\n+      }\n+      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+\n+      // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+          computeStageAllocation(plan, currentReservationStage,\n+              stageArrivalTime, stageDeadline);\n \n+      // If we did not find an allocation, return NULL\n+      // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n+\n+        // If it\u0027s an ANY job, we can move to the next possible request\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n-      } else {\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // Otherwise, the job cannot be allocated\n+        return null;\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n       }\n+\n+      // Get the start \u0026 end time of the current allocation\n+      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n+      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+\n+      // If we did find an allocation for the stage, add it\n+      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n+        allocations.addInterval(entry.getKey(), entry.getValue());\n+      }\n+\n+      // If this is an ANY clause, we have finished\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+        break;\n+      }\n+\n+      // If ORDER job, set the stageDeadline of the next stage to be processed\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+\n+        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+            \u0026\u0026 successorStartingTime !\u003d -1\n+            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n+\n+          return null;\n+\n+        }\n+\n+        // Store the stageStartTime and set the new stageDeadline\n+        successorStartingTime \u003d stageStartTime;\n+        stageDeadline \u003d stageStartTime;\n+\n+      }\n+\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n+    // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+      return null;\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    return allocations;\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n-    } else {\n-      return plan.addReservation(capReservation);\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "RLESparseResourceAllocation"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,123 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n+      ReservationId reservationId, ReservationDefinition reservation)\n+      throws ContractValidationException {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n+    // Initialize\n+    initialize(plan, reservation);\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    // If the job has been previously reserved, logically remove its allocation\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservationId);\n+    if (oldReservation !\u003d null) {\n+      ignoreOldAllocation(oldReservation);\n     }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create the allocations data structure\n+    RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Get a reverse iterator for the set of stages\n+    ListIterator\u003cReservationRequest\u003e li \u003d\n+        reservation\n+            .getReservationRequests()\n+            .getReservationResources()\n+            .listIterator(\n+                reservation.getReservationRequests().getReservationResources()\n+                    .size());\n \n-    boolean hasGang \u003d false;\n+    // Current stage\n+    ReservationRequest currentReservationStage;\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // Index, points on the current node\n+    int index \u003d\n+        reservation.getReservationRequests().getReservationResources().size();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Stage deadlines\n+    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n+    long successorStartingTime \u003d -1;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // Iterate the stages in reverse order\n+    while (li.hasPrevious()) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // Get current stage\n+      currentReservationStage \u003d li.previous();\n+      index -\u003d 1;\n \n-      // run allocation for a single stage\n+      // Validate that the ReservationRequest respects basic constraints\n+      validateInputStage(plan, currentReservationStage);\n+\n+      // Compute an adjusted earliestStart for this resource\n+      // (we need this to provision some space for the ORDER contracts)\n+      long stageArrivalTime \u003d reservation.getArrival();\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        stageArrivalTime \u003d\n+            computeEarliestStartingTime(plan, reservation, index,\n+                currentReservationStage, stageDeadline);\n+      }\n+      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+\n+      // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+          computeStageAllocation(plan, currentReservationStage,\n+              stageArrivalTime, stageDeadline);\n \n+      // If we did not find an allocation, return NULL\n+      // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n+\n+        // If it\u0027s an ANY job, we can move to the next possible request\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n-      } else {\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // Otherwise, the job cannot be allocated\n+        return null;\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n       }\n+\n+      // Get the start \u0026 end time of the current allocation\n+      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n+      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+\n+      // If we did find an allocation for the stage, add it\n+      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n+        allocations.addInterval(entry.getKey(), entry.getValue());\n+      }\n+\n+      // If this is an ANY clause, we have finished\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+        break;\n+      }\n+\n+      // If ORDER job, set the stageDeadline of the next stage to be processed\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+\n+        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+            \u0026\u0026 successorStartingTime !\u003d -1\n+            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n+\n+          return null;\n+\n+        }\n+\n+        // Store the stageStartTime and set the new stageDeadline\n+        successorStartingTime \u003d stageStartTime;\n+        stageDeadline \u003d stageStartTime;\n+\n+      }\n+\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n+    // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+      return null;\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    return allocations;\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n-    } else {\n-      return plan.addReservation(capReservation);\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,123 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n+      ReservationId reservationId, ReservationDefinition reservation)\n+      throws ContractValidationException {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n+    // Initialize\n+    initialize(plan, reservation);\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    // If the job has been previously reserved, logically remove its allocation\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservationId);\n+    if (oldReservation !\u003d null) {\n+      ignoreOldAllocation(oldReservation);\n     }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create the allocations data structure\n+    RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Get a reverse iterator for the set of stages\n+    ListIterator\u003cReservationRequest\u003e li \u003d\n+        reservation\n+            .getReservationRequests()\n+            .getReservationResources()\n+            .listIterator(\n+                reservation.getReservationRequests().getReservationResources()\n+                    .size());\n \n-    boolean hasGang \u003d false;\n+    // Current stage\n+    ReservationRequest currentReservationStage;\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // Index, points on the current node\n+    int index \u003d\n+        reservation.getReservationRequests().getReservationResources().size();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Stage deadlines\n+    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n+    long successorStartingTime \u003d -1;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // Iterate the stages in reverse order\n+    while (li.hasPrevious()) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // Get current stage\n+      currentReservationStage \u003d li.previous();\n+      index -\u003d 1;\n \n-      // run allocation for a single stage\n+      // Validate that the ReservationRequest respects basic constraints\n+      validateInputStage(plan, currentReservationStage);\n+\n+      // Compute an adjusted earliestStart for this resource\n+      // (we need this to provision some space for the ORDER contracts)\n+      long stageArrivalTime \u003d reservation.getArrival();\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        stageArrivalTime \u003d\n+            computeEarliestStartingTime(plan, reservation, index,\n+                currentReservationStage, stageDeadline);\n+      }\n+      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+\n+      // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+          computeStageAllocation(plan, currentReservationStage,\n+              stageArrivalTime, stageDeadline);\n \n+      // If we did not find an allocation, return NULL\n+      // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n+\n+        // If it\u0027s an ANY job, we can move to the next possible request\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n-      } else {\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // Otherwise, the job cannot be allocated\n+        return null;\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n       }\n+\n+      // Get the start \u0026 end time of the current allocation\n+      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n+      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+\n+      // If we did find an allocation for the stage, add it\n+      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n+        allocations.addInterval(entry.getKey(), entry.getValue());\n+      }\n+\n+      // If this is an ANY clause, we have finished\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+        break;\n+      }\n+\n+      // If ORDER job, set the stageDeadline of the next stage to be processed\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+\n+        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+            \u0026\u0026 successorStartingTime !\u003d -1\n+            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n+\n+          return null;\n+\n+        }\n+\n+        // Store the stageStartTime and set the new stageDeadline\n+        successorStartingTime \u003d stageStartTime;\n+        stageDeadline \u003d stageStartTime;\n+\n+      }\n+\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n+    // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+      return null;\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    return allocations;\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n-    } else {\n-      return plan.addReservation(capReservation);\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldValue": "[PlanningException, ContractValidationException]",
            "newValue": "[ContractValidationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,123 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n+      ReservationId reservationId, ReservationDefinition reservation)\n+      throws ContractValidationException {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n+    // Initialize\n+    initialize(plan, reservation);\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    // If the job has been previously reserved, logically remove its allocation\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservationId);\n+    if (oldReservation !\u003d null) {\n+      ignoreOldAllocation(oldReservation);\n     }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create the allocations data structure\n+    RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Get a reverse iterator for the set of stages\n+    ListIterator\u003cReservationRequest\u003e li \u003d\n+        reservation\n+            .getReservationRequests()\n+            .getReservationResources()\n+            .listIterator(\n+                reservation.getReservationRequests().getReservationResources()\n+                    .size());\n \n-    boolean hasGang \u003d false;\n+    // Current stage\n+    ReservationRequest currentReservationStage;\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // Index, points on the current node\n+    int index \u003d\n+        reservation.getReservationRequests().getReservationResources().size();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Stage deadlines\n+    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n+    long successorStartingTime \u003d -1;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // Iterate the stages in reverse order\n+    while (li.hasPrevious()) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // Get current stage\n+      currentReservationStage \u003d li.previous();\n+      index -\u003d 1;\n \n-      // run allocation for a single stage\n+      // Validate that the ReservationRequest respects basic constraints\n+      validateInputStage(plan, currentReservationStage);\n+\n+      // Compute an adjusted earliestStart for this resource\n+      // (we need this to provision some space for the ORDER contracts)\n+      long stageArrivalTime \u003d reservation.getArrival();\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        stageArrivalTime \u003d\n+            computeEarliestStartingTime(plan, reservation, index,\n+                currentReservationStage, stageDeadline);\n+      }\n+      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+\n+      // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+          computeStageAllocation(plan, currentReservationStage,\n+              stageArrivalTime, stageDeadline);\n \n+      // If we did not find an allocation, return NULL\n+      // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n+\n+        // If it\u0027s an ANY job, we can move to the next possible request\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n-      } else {\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // Otherwise, the job cannot be allocated\n+        return null;\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n       }\n+\n+      // Get the start \u0026 end time of the current allocation\n+      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n+      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+\n+      // If we did find an allocation for the stage, add it\n+      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n+        allocations.addInterval(entry.getKey(), entry.getValue());\n+      }\n+\n+      // If this is an ANY clause, we have finished\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+        break;\n+      }\n+\n+      // If ORDER job, set the stageDeadline of the next stage to be processed\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+\n+        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+            \u0026\u0026 successorStartingTime !\u003d -1\n+            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n+\n+          return null;\n+\n+        }\n+\n+        // Store the stageStartTime and set the new stageDeadline\n+        successorStartingTime \u003d stageStartTime;\n+        stageDeadline \u003d stageStartTime;\n+\n+      }\n+\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n+    // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+      return null;\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    return allocations;\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n-    } else {\n-      return plan.addReservation(capReservation);\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,123 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n+      ReservationId reservationId, ReservationDefinition reservation)\n+      throws ContractValidationException {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n+    // Initialize\n+    initialize(plan, reservation);\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    // If the job has been previously reserved, logically remove its allocation\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservationId);\n+    if (oldReservation !\u003d null) {\n+      ignoreOldAllocation(oldReservation);\n     }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create the allocations data structure\n+    RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Get a reverse iterator for the set of stages\n+    ListIterator\u003cReservationRequest\u003e li \u003d\n+        reservation\n+            .getReservationRequests()\n+            .getReservationResources()\n+            .listIterator(\n+                reservation.getReservationRequests().getReservationResources()\n+                    .size());\n \n-    boolean hasGang \u003d false;\n+    // Current stage\n+    ReservationRequest currentReservationStage;\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // Index, points on the current node\n+    int index \u003d\n+        reservation.getReservationRequests().getReservationResources().size();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Stage deadlines\n+    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n+    long successorStartingTime \u003d -1;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // Iterate the stages in reverse order\n+    while (li.hasPrevious()) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // Get current stage\n+      currentReservationStage \u003d li.previous();\n+      index -\u003d 1;\n \n-      // run allocation for a single stage\n+      // Validate that the ReservationRequest respects basic constraints\n+      validateInputStage(plan, currentReservationStage);\n+\n+      // Compute an adjusted earliestStart for this resource\n+      // (we need this to provision some space for the ORDER contracts)\n+      long stageArrivalTime \u003d reservation.getArrival();\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        stageArrivalTime \u003d\n+            computeEarliestStartingTime(plan, reservation, index,\n+                currentReservationStage, stageDeadline);\n+      }\n+      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+\n+      // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+          computeStageAllocation(plan, currentReservationStage,\n+              stageArrivalTime, stageDeadline);\n \n+      // If we did not find an allocation, return NULL\n+      // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n+\n+        // If it\u0027s an ANY job, we can move to the next possible request\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n-      } else {\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // Otherwise, the job cannot be allocated\n+        return null;\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n       }\n+\n+      // Get the start \u0026 end time of the current allocation\n+      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n+      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+\n+      // If we did find an allocation for the stage, add it\n+      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n+        allocations.addInterval(entry.getKey(), entry.getValue());\n+      }\n+\n+      // If this is an ANY clause, we have finished\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+        break;\n+      }\n+\n+      // If ORDER job, set the stageDeadline of the next stage to be processed\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+\n+        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+            \u0026\u0026 successorStartingTime !\u003d -1\n+            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n+\n+          return null;\n+\n+        }\n+\n+        // Store the stageStartTime and set the new stageDeadline\n+        successorStartingTime \u003d stageStartTime;\n+        stageDeadline \u003d stageStartTime;\n+\n+      }\n+\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n+    // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+      return null;\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    return allocations;\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n-    } else {\n-      return plan.addReservation(capReservation);\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldValue": "computeAllocation",
            "newValue": "computeJobAllocation"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,123 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n+      ReservationId reservationId, ReservationDefinition reservation)\n+      throws ContractValidationException {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n+    // Initialize\n+    initialize(plan, reservation);\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    // If the job has been previously reserved, logically remove its allocation\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservationId);\n+    if (oldReservation !\u003d null) {\n+      ignoreOldAllocation(oldReservation);\n     }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create the allocations data structure\n+    RLESparseResourceAllocation allocations \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Get a reverse iterator for the set of stages\n+    ListIterator\u003cReservationRequest\u003e li \u003d\n+        reservation\n+            .getReservationRequests()\n+            .getReservationResources()\n+            .listIterator(\n+                reservation.getReservationRequests().getReservationResources()\n+                    .size());\n \n-    boolean hasGang \u003d false;\n+    // Current stage\n+    ReservationRequest currentReservationStage;\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // Index, points on the current node\n+    int index \u003d\n+        reservation.getReservationRequests().getReservationResources().size();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Stage deadlines\n+    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n+    long successorStartingTime \u003d -1;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // Iterate the stages in reverse order\n+    while (li.hasPrevious()) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // Get current stage\n+      currentReservationStage \u003d li.previous();\n+      index -\u003d 1;\n \n-      // run allocation for a single stage\n+      // Validate that the ReservationRequest respects basic constraints\n+      validateInputStage(plan, currentReservationStage);\n+\n+      // Compute an adjusted earliestStart for this resource\n+      // (we need this to provision some space for the ORDER contracts)\n+      long stageArrivalTime \u003d reservation.getArrival();\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+        stageArrivalTime \u003d\n+            computeEarliestStartingTime(plan, reservation, index,\n+                currentReservationStage, stageDeadline);\n+      }\n+      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n+      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n+\n+      // Compute the allocation of a single stage\n       Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+          computeStageAllocation(plan, currentReservationStage,\n+              stageArrivalTime, stageDeadline);\n \n+      // If we did not find an allocation, return NULL\n+      // (unless it\u0027s an ANY job, then we simply continue).\n       if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n+\n+        // If it\u0027s an ANY job, we can move to the next possible request\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           continue;\n         }\n-      } else {\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // Otherwise, the job cannot be allocated\n+        return null;\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n       }\n+\n+      // Get the start \u0026 end time of the current allocation\n+      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n+      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n+\n+      // If we did find an allocation for the stage, add it\n+      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n+        allocations.addInterval(entry.getKey(), entry.getValue());\n+      }\n+\n+      // If this is an ANY clause, we have finished\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+        break;\n+      }\n+\n+      // If ORDER job, set the stageDeadline of the next stage to be processed\n+      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+\n+        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n+        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+            \u0026\u0026 successorStartingTime !\u003d -1\n+            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n+\n+          return null;\n+\n+        }\n+\n+        // Store the stageStartTime and set the new stageDeadline\n+        successorStartingTime \u003d stageStartTime;\n+        stageDeadline \u003d stageStartTime;\n+\n+      }\n+\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n+    // If the allocation is empty, return an error\n     if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+      return null;\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    return allocations;\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n-    } else {\n-      return plan.addReservation(capReservation);\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation computeJobAllocation(Plan plan,\n      ReservationId reservationId, ReservationDefinition reservation)\n      throws ContractValidationException {\n\n    // Initialize\n    initialize(plan, reservation);\n\n    // If the job has been previously reserved, logically remove its allocation\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservationId);\n    if (oldReservation !\u003d null) {\n      ignoreOldAllocation(oldReservation);\n    }\n\n    // Create the allocations data structure\n    RLESparseResourceAllocation allocations \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Get a reverse iterator for the set of stages\n    ListIterator\u003cReservationRequest\u003e li \u003d\n        reservation\n            .getReservationRequests()\n            .getReservationResources()\n            .listIterator(\n                reservation.getReservationRequests().getReservationResources()\n                    .size());\n\n    // Current stage\n    ReservationRequest currentReservationStage;\n\n    // Index, points on the current node\n    int index \u003d\n        reservation.getReservationRequests().getReservationResources().size();\n\n    // Stage deadlines\n    long stageDeadline \u003d stepRoundDown(reservation.getDeadline(), step);\n    long successorStartingTime \u003d -1;\n\n    // Iterate the stages in reverse order\n    while (li.hasPrevious()) {\n\n      // Get current stage\n      currentReservationStage \u003d li.previous();\n      index -\u003d 1;\n\n      // Validate that the ReservationRequest respects basic constraints\n      validateInputStage(plan, currentReservationStage);\n\n      // Compute an adjusted earliestStart for this resource\n      // (we need this to provision some space for the ORDER contracts)\n      long stageArrivalTime \u003d reservation.getArrival();\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n        stageArrivalTime \u003d\n            computeEarliestStartingTime(plan, reservation, index,\n                currentReservationStage, stageDeadline);\n      }\n      stageArrivalTime \u003d stepRoundUp(stageArrivalTime, step);\n      stageArrivalTime \u003d Math.max(stageArrivalTime, reservation.getArrival());\n\n      // Compute the allocation of a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          computeStageAllocation(plan, currentReservationStage,\n              stageArrivalTime, stageDeadline);\n\n      // If we did not find an allocation, return NULL\n      // (unless it\u0027s an ANY job, then we simply continue).\n      if (curAlloc \u003d\u003d null) {\n\n        // If it\u0027s an ANY job, we can move to the next possible request\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          continue;\n        }\n\n        // Otherwise, the job cannot be allocated\n        return null;\n\n      }\n\n      // Get the start \u0026 end time of the current allocation\n      Long stageStartTime \u003d findEarliestTime(curAlloc.keySet());\n      Long stageEndTime \u003d findLatestTime(curAlloc.keySet());\n\n      // If we did find an allocation for the stage, add it\n      for (Entry\u003cReservationInterval, Resource\u003e entry : curAlloc.entrySet()) {\n        allocations.addInterval(entry.getKey(), entry.getValue());\n      }\n\n      // If this is an ANY clause, we have finished\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n        break;\n      }\n\n      // If ORDER job, set the stageDeadline of the next stage to be processed\n      if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER\n          || jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n\n        // Verify that there is no gap, in case the job is ORDER_NO_GAP\n        if (jobType \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n            \u0026\u0026 successorStartingTime !\u003d -1\n            \u0026\u0026 successorStartingTime \u003e stageEndTime) {\n\n          return null;\n\n        }\n\n        // Store the stageStartTime and set the new stageDeadline\n        successorStartingTime \u003d stageStartTime;\n        stageDeadline \u003d stageStartTime;\n\n      }\n\n    }\n\n    // If the allocation is empty, return an error\n    if (allocations.isEmpty()) {\n      return null;\n    }\n\n    return allocations;\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/IterativePlanner.java",
          "extendedDetails": {
            "oldValue": "[reservationId-ReservationId, user-String, plan-Plan, contract-ReservationDefinition, oldReservation-ReservationAllocation]",
            "newValue": "[plan-Plan, reservationId-ReservationId, reservation-ReservationDefinition]"
          }
        }
      ]
    },
    "0e602fa3a1529134214452fba10a90307d9c2072": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
      "commitDate": "09/07/15 4:51 PM",
      "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
      "commitAuthor": "carlo curino",
      "commitDateOld": "03/10/14 3:43 PM",
      "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
      "commitAuthorOld": "subru",
      "daysBetweenCommits": 279.05,
      "commitsBetweenForRepo": 2292,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,139 @@\n   private boolean computeAllocation(ReservationId reservationId, String user,\n       Plan plan, ReservationDefinition contract,\n       ReservationAllocation oldReservation) throws PlanningException,\n       ContractValidationException {\n     LOG.info(\"placing the following ReservationRequest: \" + contract);\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // Here we can addd logic to adjust the ResourceDefinition to account for\n     // system \"imperfections\" (e.g., scheduling delays for large containers).\n \n     // Align with plan step conservatively (i.e., ceil arrival, and floor\n     // deadline)\n     long earliestStart \u003d contract.getArrival();\n     long step \u003d plan.getStep();\n     if (earliestStart % step !\u003d 0) {\n       earliestStart \u003d earliestStart + (step - (earliestStart % step));\n     }\n     long deadline \u003d\n         contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n     // setup temporary variables to handle time-relations between stages and\n     // intermediate answers\n     long curDeadline \u003d deadline;\n     long oldDeadline \u003d -1;\n \n-    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        new HashMap\u003cReservationInterval, Resource\u003e();\n     RLESparseResourceAllocation tempAssigned \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n     List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n         .getReservationResources();\n     ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n         .getInterpreter();\n \n+    boolean hasGang \u003d false;\n+\n     // Iterate the stages in backward from deadline\n     for (ListIterator\u003cReservationRequest\u003e li \u003d \n         stages.listIterator(stages.size()); li.hasPrevious();) {\n \n       ReservationRequest currentReservationStage \u003d li.previous();\n \n       // validate the RR respect basic constraints\n       validateInput(plan, currentReservationStage, totalCapacity);\n \n+      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+\n       // run allocation for a single stage\n-      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n+      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           placeSingleStage(plan, tempAssigned, currentReservationStage,\n               earliestStart, curDeadline, oldReservation, totalCapacity);\n \n       if (curAlloc \u003d\u003d null) {\n         // if we did not find an allocation for the currentReservationStage\n         // return null, unless the ReservationDefinition we are placing is of\n         // type ANY\n         if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n           throw new PlanningException(\"The GreedyAgent\"\n               + \" couldn\u0027t find a valid allocation for your request\");\n         } else {\n           continue;\n         }\n       } else {\n \n         // if we did find an allocation add it to the set of allocations\n         allocations.putAll(curAlloc);\n \n         // if this request is of type ANY we are done searching (greedy)\n         // and can return the current allocation (break-out of the search)\n         if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           break;\n         }\n \n         // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n         // round of allocation to precede the current allocation, by setting\n         // curDeadline\n         if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n             || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n           curDeadline \u003d findEarliestTime(curAlloc.keySet());\n \n           // for ORDER_NO_GAP verify that the allocation found so far has no\n           // gap, return null otherwise (the greedy procedure failed to find a\n           // no-gap\n           // allocation)\n           if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n               \u0026\u0026 oldDeadline \u003e 0) {\n             if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                 .getStep()) {\n               throw new PlanningException(\"The GreedyAgent\"\n                   + \" couldn\u0027t find a valid allocation for your request\");\n             }\n           }\n           // keep the variable oldDeadline pointing to the last deadline we\n           // found\n           oldDeadline \u003d curDeadline;\n         }\n       }\n     }\n \n     // / If we got here is because we failed to find an allocation for the\n     // ReservationDefinition give-up and report failure to the user\n     if (allocations.isEmpty()) {\n       throw new PlanningException(\"The GreedyAgent\"\n           + \" couldn\u0027t find a valid allocation for your request\");\n     }\n \n     // create reservation with above allocations if not null/empty\n \n-    ReservationRequest ZERO_RES \u003d\n-        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n+    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n \n     long firstStartTime \u003d findEarliestTime(allocations.keySet());\n     \n     // add zero-padding from arrival up to the first non-null allocation\n     // to guarantee that the reservation exists starting at arrival\n     if (firstStartTime \u003e earliestStart) {\n       allocations.put(new ReservationInterval(earliestStart,\n           firstStartTime), ZERO_RES);\n       firstStartTime \u003d earliestStart;\n       // consider to add trailing zeros at the end for simmetry\n     }\n \n     // Actually add/update the reservation in the plan.\n     // This is subject to validation as other agents might be placing\n     // in parallel and there might be sharing policies the agent is not\n     // aware off.\n     ReservationAllocation capReservation \u003d\n         new InMemoryReservationAllocation(reservationId, contract, user,\n             plan.getQueueName(), firstStartTime,\n             findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation());\n+            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n     if (oldReservation !\u003d null) {\n       return plan.updateReservation(capReservation);\n     } else {\n       return plan.addReservation(capReservation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean computeAllocation(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n    LOG.info(\"placing the following ReservationRequest: \" + contract);\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // Here we can addd logic to adjust the ResourceDefinition to account for\n    // system \"imperfections\" (e.g., scheduling delays for large containers).\n\n    // Align with plan step conservatively (i.e., ceil arrival, and floor\n    // deadline)\n    long earliestStart \u003d contract.getArrival();\n    long step \u003d plan.getStep();\n    if (earliestStart % step !\u003d 0) {\n      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n    }\n    long deadline \u003d\n        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n\n    // setup temporary variables to handle time-relations between stages and\n    // intermediate answers\n    long curDeadline \u003d deadline;\n    long oldDeadline \u003d -1;\n\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n    RLESparseResourceAllocation tempAssigned \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n        .getReservationResources();\n    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n        .getInterpreter();\n\n    boolean hasGang \u003d false;\n\n    // Iterate the stages in backward from deadline\n    for (ListIterator\u003cReservationRequest\u003e li \u003d \n        stages.listIterator(stages.size()); li.hasPrevious();) {\n\n      ReservationRequest currentReservationStage \u003d li.previous();\n\n      // validate the RR respect basic constraints\n      validateInput(plan, currentReservationStage, totalCapacity);\n\n      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n\n      // run allocation for a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          placeSingleStage(plan, tempAssigned, currentReservationStage,\n              earliestStart, curDeadline, oldReservation, totalCapacity);\n\n      if (curAlloc \u003d\u003d null) {\n        // if we did not find an allocation for the currentReservationStage\n        // return null, unless the ReservationDefinition we are placing is of\n        // type ANY\n        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n          throw new PlanningException(\"The GreedyAgent\"\n              + \" couldn\u0027t find a valid allocation for your request\");\n        } else {\n          continue;\n        }\n      } else {\n\n        // if we did find an allocation add it to the set of allocations\n        allocations.putAll(curAlloc);\n\n        // if this request is of type ANY we are done searching (greedy)\n        // and can return the current allocation (break-out of the search)\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          break;\n        }\n\n        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n        // round of allocation to precede the current allocation, by setting\n        // curDeadline\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n\n          // for ORDER_NO_GAP verify that the allocation found so far has no\n          // gap, return null otherwise (the greedy procedure failed to find a\n          // no-gap\n          // allocation)\n          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n              \u0026\u0026 oldDeadline \u003e 0) {\n            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                .getStep()) {\n              throw new PlanningException(\"The GreedyAgent\"\n                  + \" couldn\u0027t find a valid allocation for your request\");\n            }\n          }\n          // keep the variable oldDeadline pointing to the last deadline we\n          // found\n          oldDeadline \u003d curDeadline;\n        }\n      }\n    }\n\n    // / If we got here is because we failed to find an allocation for the\n    // ReservationDefinition give-up and report failure to the user\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The GreedyAgent\"\n          + \" couldn\u0027t find a valid allocation for your request\");\n    }\n\n    // create reservation with above allocations if not null/empty\n\n    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n\n    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n    \n    // add zero-padding from arrival up to the first non-null allocation\n    // to guarantee that the reservation exists starting at arrival\n    if (firstStartTime \u003e earliestStart) {\n      allocations.put(new ReservationInterval(earliestStart,\n          firstStartTime), ZERO_RES);\n      firstStartTime \u003d earliestStart;\n      // consider to add trailing zeros at the end for simmetry\n    }\n\n    // Actually add/update the reservation in the plan.\n    // This is subject to validation as other agents might be placing\n    // in parallel and there might be sharing policies the agent is not\n    // aware off.\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, contract, user,\n            plan.getQueueName(), firstStartTime,\n            findLatestTime(allocations.keySet()), allocations,\n            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java",
      "extendedDetails": {}
    },
    "f66ffcf832235e0da0bb050fff08e248b547c360": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1710. Logic to find allocations within a Plan that satisfy user ReservationRequest(s). Contributed by Carlo Curino and Subru Krishnan.\n(cherry picked from commit aef7928899b37262773f3dc117157bb746bf8918)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "f66ffcf832235e0da0bb050fff08e248b547c360",
      "commitAuthor": "carlo curino",
      "diff": "@@ -0,0 +1,136 @@\n+  private boolean computeAllocation(ReservationId reservationId, String user,\n+      Plan plan, ReservationDefinition contract,\n+      ReservationAllocation oldReservation) throws PlanningException,\n+      ContractValidationException {\n+    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+\n+    Resource totalCapacity \u003d plan.getTotalCapacity();\n+\n+    // Here we can addd logic to adjust the ResourceDefinition to account for\n+    // system \"imperfections\" (e.g., scheduling delays for large containers).\n+\n+    // Align with plan step conservatively (i.e., ceil arrival, and floor\n+    // deadline)\n+    long earliestStart \u003d contract.getArrival();\n+    long step \u003d plan.getStep();\n+    if (earliestStart % step !\u003d 0) {\n+      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    }\n+    long deadline \u003d\n+        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n+\n+    // setup temporary variables to handle time-relations between stages and\n+    // intermediate answers\n+    long curDeadline \u003d deadline;\n+    long oldDeadline \u003d -1;\n+\n+    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n+        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n+    RLESparseResourceAllocation tempAssigned \u003d\n+        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n+            plan.getMinimumAllocation());\n+\n+    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n+        .getReservationResources();\n+    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n+        .getInterpreter();\n+\n+    // Iterate the stages in backward from deadline\n+    for (ListIterator\u003cReservationRequest\u003e li \u003d \n+        stages.listIterator(stages.size()); li.hasPrevious();) {\n+\n+      ReservationRequest currentReservationStage \u003d li.previous();\n+\n+      // validate the RR respect basic constraints\n+      validateInput(plan, currentReservationStage, totalCapacity);\n+\n+      // run allocation for a single stage\n+      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n+          placeSingleStage(plan, tempAssigned, currentReservationStage,\n+              earliestStart, curDeadline, oldReservation, totalCapacity);\n+\n+      if (curAlloc \u003d\u003d null) {\n+        // if we did not find an allocation for the currentReservationStage\n+        // return null, unless the ReservationDefinition we are placing is of\n+        // type ANY\n+        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n+          throw new PlanningException(\"The GreedyAgent\"\n+              + \" couldn\u0027t find a valid allocation for your request\");\n+        } else {\n+          continue;\n+        }\n+      } else {\n+\n+        // if we did find an allocation add it to the set of allocations\n+        allocations.putAll(curAlloc);\n+\n+        // if this request is of type ANY we are done searching (greedy)\n+        // and can return the current allocation (break-out of the search)\n+        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+          break;\n+        }\n+\n+        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n+        // round of allocation to precede the current allocation, by setting\n+        // curDeadline\n+        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n+\n+          // for ORDER_NO_GAP verify that the allocation found so far has no\n+          // gap, return null otherwise (the greedy procedure failed to find a\n+          // no-gap\n+          // allocation)\n+          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+              \u0026\u0026 oldDeadline \u003e 0) {\n+            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n+                .getStep()) {\n+              throw new PlanningException(\"The GreedyAgent\"\n+                  + \" couldn\u0027t find a valid allocation for your request\");\n+            }\n+          }\n+          // keep the variable oldDeadline pointing to the last deadline we\n+          // found\n+          oldDeadline \u003d curDeadline;\n+        }\n+      }\n+    }\n+\n+    // / If we got here is because we failed to find an allocation for the\n+    // ReservationDefinition give-up and report failure to the user\n+    if (allocations.isEmpty()) {\n+      throw new PlanningException(\"The GreedyAgent\"\n+          + \" couldn\u0027t find a valid allocation for your request\");\n+    }\n+\n+    // create reservation with above allocations if not null/empty\n+\n+    ReservationRequest ZERO_RES \u003d\n+        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n+\n+    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n+    \n+    // add zero-padding from arrival up to the first non-null allocation\n+    // to guarantee that the reservation exists starting at arrival\n+    if (firstStartTime \u003e earliestStart) {\n+      allocations.put(new ReservationInterval(earliestStart,\n+          firstStartTime), ZERO_RES);\n+      firstStartTime \u003d earliestStart;\n+      // consider to add trailing zeros at the end for simmetry\n+    }\n+\n+    // Actually add/update the reservation in the plan.\n+    // This is subject to validation as other agents might be placing\n+    // in parallel and there might be sharing policies the agent is not\n+    // aware off.\n+    ReservationAllocation capReservation \u003d\n+        new InMemoryReservationAllocation(reservationId, contract, user,\n+            plan.getQueueName(), firstStartTime,\n+            findLatestTime(allocations.keySet()), allocations,\n+            plan.getResourceCalculator(), plan.getMinimumAllocation());\n+    if (oldReservation !\u003d null) {\n+      return plan.updateReservation(capReservation);\n+    } else {\n+      return plan.addReservation(capReservation);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean computeAllocation(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n    LOG.info(\"placing the following ReservationRequest: \" + contract);\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // Here we can addd logic to adjust the ResourceDefinition to account for\n    // system \"imperfections\" (e.g., scheduling delays for large containers).\n\n    // Align with plan step conservatively (i.e., ceil arrival, and floor\n    // deadline)\n    long earliestStart \u003d contract.getArrival();\n    long step \u003d plan.getStep();\n    if (earliestStart % step !\u003d 0) {\n      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n    }\n    long deadline \u003d\n        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n\n    // setup temporary variables to handle time-relations between stages and\n    // intermediate answers\n    long curDeadline \u003d deadline;\n    long oldDeadline \u003d -1;\n\n    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n    RLESparseResourceAllocation tempAssigned \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n        .getReservationResources();\n    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n        .getInterpreter();\n\n    // Iterate the stages in backward from deadline\n    for (ListIterator\u003cReservationRequest\u003e li \u003d \n        stages.listIterator(stages.size()); li.hasPrevious();) {\n\n      ReservationRequest currentReservationStage \u003d li.previous();\n\n      // validate the RR respect basic constraints\n      validateInput(plan, currentReservationStage, totalCapacity);\n\n      // run allocation for a single stage\n      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n          placeSingleStage(plan, tempAssigned, currentReservationStage,\n              earliestStart, curDeadline, oldReservation, totalCapacity);\n\n      if (curAlloc \u003d\u003d null) {\n        // if we did not find an allocation for the currentReservationStage\n        // return null, unless the ReservationDefinition we are placing is of\n        // type ANY\n        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n          throw new PlanningException(\"The GreedyAgent\"\n              + \" couldn\u0027t find a valid allocation for your request\");\n        } else {\n          continue;\n        }\n      } else {\n\n        // if we did find an allocation add it to the set of allocations\n        allocations.putAll(curAlloc);\n\n        // if this request is of type ANY we are done searching (greedy)\n        // and can return the current allocation (break-out of the search)\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          break;\n        }\n\n        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n        // round of allocation to precede the current allocation, by setting\n        // curDeadline\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n\n          // for ORDER_NO_GAP verify that the allocation found so far has no\n          // gap, return null otherwise (the greedy procedure failed to find a\n          // no-gap\n          // allocation)\n          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n              \u0026\u0026 oldDeadline \u003e 0) {\n            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                .getStep()) {\n              throw new PlanningException(\"The GreedyAgent\"\n                  + \" couldn\u0027t find a valid allocation for your request\");\n            }\n          }\n          // keep the variable oldDeadline pointing to the last deadline we\n          // found\n          oldDeadline \u003d curDeadline;\n        }\n      }\n    }\n\n    // / If we got here is because we failed to find an allocation for the\n    // ReservationDefinition give-up and report failure to the user\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The GreedyAgent\"\n          + \" couldn\u0027t find a valid allocation for your request\");\n    }\n\n    // create reservation with above allocations if not null/empty\n\n    ReservationRequest ZERO_RES \u003d\n        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n\n    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n    \n    // add zero-padding from arrival up to the first non-null allocation\n    // to guarantee that the reservation exists starting at arrival\n    if (firstStartTime \u003e earliestStart) {\n      allocations.put(new ReservationInterval(earliestStart,\n          firstStartTime), ZERO_RES);\n      firstStartTime \u003d earliestStart;\n      // consider to add trailing zeros at the end for simmetry\n    }\n\n    // Actually add/update the reservation in the plan.\n    // This is subject to validation as other agents might be placing\n    // in parallel and there might be sharing policies the agent is not\n    // aware off.\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, contract, user,\n            plan.getQueueName(), firstStartTime,\n            findLatestTime(allocations.keySet()), allocations,\n            plan.getResourceCalculator(), plan.getMinimumAllocation());\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java"
    }
  }
}