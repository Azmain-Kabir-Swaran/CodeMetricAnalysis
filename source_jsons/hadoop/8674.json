{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirTruncateOp.java",
  "functionName": "prepareFileForTruncate",
  "functionId": "prepareFileForTruncate___fsn-FSNamesystem__iip-INodesInPath__leaseHolder-String__clientMachine-String__lastBlockDelta-long__newBlock-Block",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
  "functionStartLine": 214,
  "functionEndLine": 278,
  "numCommitsSeen": 583,
  "timeTaken": 13202,
  "changeHistory": [
    "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87",
    "2b5ad48762587abbcd8bdb50d0ae98f8080d926c",
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "c304890c8c7782d835896859f5b7f60b96c306c0",
    "164cbe643988f878f0f4100a4de51783e5b6738e",
    "e535e0f05b5fbd087c93238deb888cc985254b4c",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
    "31f117138a00794de4951ee8433e304d72b04094",
    "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557",
    "3841d09765bab332c9ae4803c5981799585b1f41",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "6d5da9484185ca9f585195d6da069b9cd5be4044",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
    "d368d3647a858644b9fcd3be33d9fea2a6962f69",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f"
  ],
  "changeHistoryShort": {
    "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87": "Ybodychange",
    "2b5ad48762587abbcd8bdb50d0ae98f8080d926c": "Ybodychange",
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "c304890c8c7782d835896859f5b7f60b96c306c0": "Ybodychange",
    "164cbe643988f878f0f4100a4de51783e5b6738e": "Ybodychange",
    "e535e0f05b5fbd087c93238deb888cc985254b4c": "Ybodychange",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": "Ybodychange",
    "31f117138a00794de4951ee8433e304d72b04094": "Ybodychange",
    "d3797f9f3cf502b7bfee3b64c641807b276c6faf": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": "Ybodychange",
    "3841d09765bab332c9ae4803c5981799585b1f41": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "6d5da9484185ca9f585195d6da069b9cd5be4044": "Ybodychange",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": "Ybodychange",
    "d368d3647a858644b9fcd3be33d9fea2a6962f69": "Ybodychange",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12884. BlockUnderConstructionFeature.truncateBlock should be of type BlockInfo. Contributed by chencan.",
      "commitDate": "21/03/18 4:46 PM",
      "commitName": "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "25/05/17 3:17 PM",
      "commitNameOld": "2b5ad48762587abbcd8bdb50d0ae98f8080d926c",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 300.06,
      "commitsBetweenForRepo": 2063,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,65 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     assert !file.isStriped();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n \n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ?\n           fsn.createNewBlock(BlockType.CONTIGUOUS)\n           : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n           fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n     final BlockInfo truncatedBlockUC;\n     BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.convertToBlockUnderConstruction(\n           BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC);\n       blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n           truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n-      uc.setTruncateBlock(new Block(oldBlock));\n+      uc.setTruncateBlock(new BlockInfoContiguous(oldBlock,\n+          oldBlock.getReplication()));\n       uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n       truncatedBlockUC \u003d oldBlock;\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n           \"{} Scheduling in-place block truncate to new size {}\",\n           uc, uc.getTruncateBlock().getNumBytes());\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n           truncatedBlockUC, newBlock.getGenerationStamp(), true);\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    assert !file.isStriped();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ?\n          fsn.createNewBlock(BlockType.CONTIGUOUS)\n          : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    final BlockInfo truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.convertToBlockUnderConstruction(\n          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC);\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n      uc.setTruncateBlock(new BlockInfoContiguous(oldBlock,\n          oldBlock.getReplication()));\n      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n      truncatedBlockUC \u003d oldBlock;\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n          \"{} Scheduling in-place block truncate to new size {}\",\n          uc, uc.getTruncateBlock().getNumBytes());\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n          truncatedBlockUC, newBlock.getGenerationStamp(), true);\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "2b5ad48762587abbcd8bdb50d0ae98f8080d926c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11817. A faulty node can cause a lease leak and NPE on accessing data. Contributed by Kihwal Lee.\n",
      "commitDate": "25/05/17 3:17 PM",
      "commitName": "2b5ad48762587abbcd8bdb50d0ae98f8080d926c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "16/05/17 9:28 AM",
      "commitNameOld": "9b90e52f1ec22c18cd535af2a569defcef65b093",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 9.24,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     assert !file.isStriped();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n \n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ?\n           fsn.createNewBlock(BlockType.CONTIGUOUS)\n           : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n           fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n     final BlockInfo truncatedBlockUC;\n     BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.convertToBlockUnderConstruction(\n           BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC);\n       blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n           truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n       uc.setTruncateBlock(new Block(oldBlock));\n       uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n       truncatedBlockUC \u003d oldBlock;\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n           \"{} Scheduling in-place block truncate to new size {}\",\n           uc, uc.getTruncateBlock().getNumBytes());\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n-          truncatedBlockUC, newBlock.getGenerationStamp());\n+          truncatedBlockUC, newBlock.getGenerationStamp(), true);\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    assert !file.isStriped();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ?\n          fsn.createNewBlock(BlockType.CONTIGUOUS)\n          : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    final BlockInfo truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.convertToBlockUnderConstruction(\n          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC);\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n      uc.setTruncateBlock(new Block(oldBlock));\n      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n      truncatedBlockUC \u003d oldBlock;\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n          \"{} Scheduling in-place block truncate to new size {}\",\n          uc, uc.getTruncateBlock().getNumBytes());\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n          truncatedBlockUC, newBlock.getGenerationStamp(), true);\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "05/12/16 10:54 AM",
      "commitNameOld": "1b5cceaffbdde50a87ede81552dc380832db8e79",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 44.11,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,64 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     assert !file.isStriped();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n \n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n-      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock(false)\n+      newBlock \u003d (shouldCopyOnTruncate) ?\n+          fsn.createNewBlock(BlockType.CONTIGUOUS)\n           : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n           fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n     final BlockInfo truncatedBlockUC;\n     BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.convertToBlockUnderConstruction(\n           BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC);\n       blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n           truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n       uc.setTruncateBlock(new Block(oldBlock));\n       uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n       truncatedBlockUC \u003d oldBlock;\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n           \"{} Scheduling in-place block truncate to new size {}\",\n           uc, uc.getTruncateBlock().getNumBytes());\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n           truncatedBlockUC, newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    assert !file.isStriped();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ?\n          fsn.createNewBlock(BlockType.CONTIGUOUS)\n          : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    final BlockInfo truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.convertToBlockUnderConstruction(\n          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC);\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n      uc.setTruncateBlock(new Block(oldBlock));\n      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n      truncatedBlockUC \u003d oldBlock;\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n          \"{} Scheduling in-place block truncate to new size {}\",\n          uc, uc.getTruncateBlock().getNumBytes());\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n          truncatedBlockUC, newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "c304890c8c7782d835896859f5b7f60b96c306c0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9542. Move BlockIdManager from FSNamesystem to BlockManager. Contributed by Jing Zhao.\n",
      "commitDate": "21/01/16 11:13 AM",
      "commitName": "c304890c8c7782d835896859f5b7f60b96c306c0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "01/12/15 4:09 PM",
      "commitNameOld": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 50.79,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     assert !file.isStriped();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n \n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock(false)\n           : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n-          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n+          fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n     final BlockInfo truncatedBlockUC;\n     BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.convertToBlockUnderConstruction(\n           BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC);\n       blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n           truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n       uc.setTruncateBlock(new Block(oldBlock));\n       uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n       truncatedBlockUC \u003d oldBlock;\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n           \"{} Scheduling in-place block truncate to new size {}\",\n           uc, uc.getTruncateBlock().getNumBytes());\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n           truncatedBlockUC, newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    assert !file.isStriped();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock(false)\n          : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    final BlockInfo truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.convertToBlockUnderConstruction(\n          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC);\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n      uc.setTruncateBlock(new Block(oldBlock));\n      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n      truncatedBlockUC \u003d oldBlock;\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n          \"{} Scheduling in-place block truncate to new size {}\",\n          uc, uc.getTruncateBlock().getNumBytes());\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n          truncatedBlockUC, newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "164cbe643988f878f0f4100a4de51783e5b6738e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8909. Erasure coding: update BlockInfoContiguousUC and BlockInfoStripedUC to use BlockUnderConstructionFeature. Contributed by Jing Zhao.\n",
      "commitDate": "27/08/15 1:02 AM",
      "commitName": "164cbe643988f878f0f4100a4de51783e5b6738e",
      "commitAuthor": "Walter Su",
      "commitDateOld": "24/08/15 12:59 PM",
      "commitNameOld": "6b6a63bbbda920315d3d24b61ed3344a78a981b6",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.5,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,63 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     assert !file.isStriped();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n \n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock(false)\n           : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n           fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n-    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n+    final BlockInfo truncatedBlockUC;\n     BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n-      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n+      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n           file.getPreferredBlockReplication());\n+      truncatedBlockUC.convertToBlockUnderConstruction(\n+          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n-      truncatedBlockUC.setTruncateBlock(oldBlock);\n-      file.convertLastBlockToUC(truncatedBlockUC,\n-          blockManager.getStorages(oldBlock));\n+      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n+      file.setLastBlock(truncatedBlockUC);\n       blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n-          truncatedBlockUC.getNumBytes(), newBlock,\n-          truncatedBlockUC.getTruncateBlock());\n+          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n-      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n-      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n-      truncatedBlockUC.getTruncateBlock().setNumBytes(\n-          oldBlock.getNumBytes() - lastBlockDelta);\n-      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n-          newBlock.getGenerationStamp());\n+      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n+      uc.setTruncateBlock(new Block(oldBlock));\n+      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n+      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n+      truncatedBlockUC \u003d oldBlock;\n \n-      NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n-              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n-              .getNumBytes(), truncatedBlockUC);\n+      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n+              \"{} Scheduling in-place block truncate to new size {}\",\n+          uc, uc.getTruncateBlock().getNumBytes());\n     }\n     if (shouldRecoverNow) {\n-      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n+      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n+          truncatedBlockUC, newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    assert !file.isStriped();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock(false)\n          : new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    final BlockInfo truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.convertToBlockUnderConstruction(\n          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC);\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n      uc.setTruncateBlock(new Block(oldBlock));\n      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n      truncatedBlockUC \u003d oldBlock;\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n              \"{} Scheduling in-place block truncate to new size {}\",\n          uc, uc.getTruncateBlock().getNumBytes());\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n          truncatedBlockUC, newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "e535e0f05b5fbd087c93238deb888cc985254b4c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8801. Convert BlockInfoUnderConstruction as a feature. Contributed by Jing Zhao.\n",
      "commitDate": "17/08/15 11:28 AM",
      "commitName": "e535e0f05b5fbd087c93238deb888cc985254b4c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "06/08/15 10:21 AM",
      "commitNameOld": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 11.05,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n           oldBlock.getBlockId(), oldBlock.getNumBytes(),\n           fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n-    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n+    final BlockInfo truncatedBlockUC;\n     BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n-      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n+      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n           file.getPreferredBlockReplication());\n+      truncatedBlockUC.convertToBlockUnderConstruction(\n+          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n-      truncatedBlockUC.setTruncateBlock(oldBlock);\n-      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n+      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n+      file.setLastBlock(truncatedBlockUC);\n       blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n-          truncatedBlockUC.getNumBytes(), newBlock,\n-          truncatedBlockUC.getTruncateBlock());\n+          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n-      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n-      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n-      truncatedBlockUC.getTruncateBlock().setNumBytes(\n-          oldBlock.getNumBytes() - lastBlockDelta);\n-      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n-          newBlock.getGenerationStamp());\n+      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n+      uc.setTruncateBlock(new Block(oldBlock));\n+      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n+      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n+      truncatedBlockUC \u003d oldBlock;\n \n-      NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n-              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n-              .getNumBytes(), truncatedBlockUC);\n+      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n+          \"{} Scheduling in-place block truncate to new size {}\",\n+          uc, uc.getTruncateBlock().getNumBytes());\n     }\n     if (shouldRecoverNow) {\n-      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n+      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n+          truncatedBlockUC, newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    final BlockInfo truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.convertToBlockUnderConstruction(\n          BlockUCState.UNDER_CONSTRUCTION, blockManager.getStorages(oldBlock));\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getUnderConstructionFeature().setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC);\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock, oldBlock);\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      BlockUnderConstructionFeature uc \u003d oldBlock.getUnderConstructionFeature();\n      uc.setTruncateBlock(new Block(oldBlock));\n      uc.getTruncateBlock().setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      uc.getTruncateBlock().setGenerationStamp(newBlock.getGenerationStamp());\n      truncatedBlockUC \u003d oldBlock;\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \" +\n          \"{} Scheduling in-place block truncate to new size {}\",\n          uc, uc.getTruncateBlock().getNumBytes());\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.getUnderConstructionFeature().initializeBlockRecovery(\n          truncatedBlockUC, newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\"\n\nThis reverts commit c17439c2ddd921b63b1635e6f1cba634b8da8557.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/07/15 5:25 PM",
      "commitNameOld": "31f117138a00794de4951ee8433e304d72b04094",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 15.71,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n           oldBlock.getBlockId(), oldBlock.getNumBytes(),\n           fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n-    BlockInfoUnderConstruction truncatedBlockUC;\n+    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n-      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n+      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n           truncatedBlockUC.getNumBytes(), newBlock,\n           truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n-      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n+      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n               + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n               .getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock,\n          truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n              .getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "31f117138a00794de4951ee8433e304d72b04094": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "21/07/15 5:25 PM",
      "commitName": "31f117138a00794de4951ee8433e304d72b04094",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/06/15 4:45 PM",
      "commitNameOld": "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 22.03,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,61 @@\n   static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n       String leaseHolder, String clientMachine, long lastBlockDelta,\n       Block newBlock) throws IOException {\n     assert fsn.hasWriteLock();\n \n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n     if (newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n           oldBlock.getBlockId(), oldBlock.getNumBytes(),\n           fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n               oldBlock)));\n     }\n \n     BlockInfoUnderConstruction truncatedBlockUC;\n+    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n     if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n-      file.setLastBlock(truncatedBlockUC,\n-          fsn.getBlockManager().getStorages(oldBlock));\n-      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n+      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n+      blockManager.addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n               + \" size {}  new block {} old block {}\",\n           truncatedBlockUC.getNumBytes(), newBlock,\n           truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n-      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n-          lastBlockDelta);\n+      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n               + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n               .getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    BlockInfoUnderConstruction truncatedBlockUC;\n    BlockManager blockManager \u003d fsn.getFSDirectory().getBlockManager();\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      blockManager.addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock,\n          truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n              .getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
      "extendedDetails": {}
    },
    "d3797f9f3cf502b7bfee3b64c641807b276c6faf": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-8493. Consolidate truncate() related implementation in a single class. Contributed by Rakesh R.\n",
      "commitDate": "29/06/15 4:45 PM",
      "commitName": "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-8493. Consolidate truncate() related implementation in a single class. Contributed by Rakesh R.\n",
          "commitDate": "29/06/15 4:45 PM",
          "commitName": "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "29/06/15 2:56 PM",
          "commitNameOld": "8e333720e13428a4d0d0f65692102f8f2e5da98d",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,62 @@\n-  Block prepareFileForTruncate(INodesInPath iip,\n-                               String leaseHolder,\n-                               String clientMachine,\n-                               long lastBlockDelta,\n-                               Block newBlock)\n-      throws IOException {\n+  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n+      String leaseHolder, String clientMachine, long lastBlockDelta,\n+      Block newBlock) throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n-    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n-    if(newBlock \u003d\u003d null) {\n-      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n-          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n-              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n+    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n+    if (newBlock \u003d\u003d null) {\n+      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n+          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n+          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n+              oldBlock)));\n     }\n \n     BlockInfoUnderConstruction truncatedBlockUC;\n-    if(shouldCopyOnTruncate) {\n+    if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n-      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n-      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n+      file.setLastBlock(truncatedBlockUC,\n+          fsn.getBlockManager().getStorages(oldBlock));\n+      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n-          \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n-          newBlock, truncatedBlockUC.getTruncateBlock());\n+          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n+              + \" size {}  new block {} old block {}\",\n+          truncatedBlockUC.getNumBytes(), newBlock,\n+          truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n-      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n+      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n+          lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n-          \"truncate to new size {}\",\n-          truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n+          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n+              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n+              .getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    BlockInfoUnderConstruction truncatedBlockUC;\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC,\n          fsn.getBlockManager().getStorages(oldBlock));\n      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock,\n          truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n          lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n              .getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
            "oldMethodName": "prepareFileForTruncate",
            "newMethodName": "prepareFileForTruncate"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-8493. Consolidate truncate() related implementation in a single class. Contributed by Rakesh R.\n",
          "commitDate": "29/06/15 4:45 PM",
          "commitName": "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "29/06/15 2:56 PM",
          "commitNameOld": "8e333720e13428a4d0d0f65692102f8f2e5da98d",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,62 @@\n-  Block prepareFileForTruncate(INodesInPath iip,\n-                               String leaseHolder,\n-                               String clientMachine,\n-                               long lastBlockDelta,\n-                               Block newBlock)\n-      throws IOException {\n+  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n+      String leaseHolder, String clientMachine, long lastBlockDelta,\n+      Block newBlock) throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n-    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n-    if(newBlock \u003d\u003d null) {\n-      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n-          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n-              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n+    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n+    if (newBlock \u003d\u003d null) {\n+      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n+          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n+          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n+              oldBlock)));\n     }\n \n     BlockInfoUnderConstruction truncatedBlockUC;\n-    if(shouldCopyOnTruncate) {\n+    if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n-      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n-      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n+      file.setLastBlock(truncatedBlockUC,\n+          fsn.getBlockManager().getStorages(oldBlock));\n+      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n-          \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n-          newBlock, truncatedBlockUC.getTruncateBlock());\n+          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n+              + \" size {}  new block {} old block {}\",\n+          truncatedBlockUC.getNumBytes(), newBlock,\n+          truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n-      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n+      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n+          lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n-          \"truncate to new size {}\",\n-          truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n+          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n+              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n+              .getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    BlockInfoUnderConstruction truncatedBlockUC;\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC,\n          fsn.getBlockManager().getStorages(oldBlock));\n      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock,\n          truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n          lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n              .getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8493. Consolidate truncate() related implementation in a single class. Contributed by Rakesh R.\n",
          "commitDate": "29/06/15 4:45 PM",
          "commitName": "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "29/06/15 2:56 PM",
          "commitNameOld": "8e333720e13428a4d0d0f65692102f8f2e5da98d",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,62 @@\n-  Block prepareFileForTruncate(INodesInPath iip,\n-                               String leaseHolder,\n-                               String clientMachine,\n-                               long lastBlockDelta,\n-                               Block newBlock)\n-      throws IOException {\n+  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n+      String leaseHolder, String clientMachine, long lastBlockDelta,\n+      Block newBlock) throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n-    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n-    if(newBlock \u003d\u003d null) {\n-      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n-          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n-              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n+    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n+    if (newBlock \u003d\u003d null) {\n+      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n+          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n+          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n+              oldBlock)));\n     }\n \n     BlockInfoUnderConstruction truncatedBlockUC;\n-    if(shouldCopyOnTruncate) {\n+    if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n-      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n-      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n+      file.setLastBlock(truncatedBlockUC,\n+          fsn.getBlockManager().getStorages(oldBlock));\n+      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n-          \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n-          newBlock, truncatedBlockUC.getTruncateBlock());\n+          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n+              + \" size {}  new block {} old block {}\",\n+          truncatedBlockUC.getNumBytes(), newBlock,\n+          truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n-      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n+      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n+          lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n-          \"truncate to new size {}\",\n-          truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n+          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n+              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n+              .getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    BlockInfoUnderConstruction truncatedBlockUC;\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC,\n          fsn.getBlockManager().getStorages(oldBlock));\n      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock,\n          truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n          lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n              .getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8493. Consolidate truncate() related implementation in a single class. Contributed by Rakesh R.\n",
          "commitDate": "29/06/15 4:45 PM",
          "commitName": "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "29/06/15 2:56 PM",
          "commitNameOld": "8e333720e13428a4d0d0f65692102f8f2e5da98d",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,62 @@\n-  Block prepareFileForTruncate(INodesInPath iip,\n-                               String leaseHolder,\n-                               String clientMachine,\n-                               long lastBlockDelta,\n-                               Block newBlock)\n-      throws IOException {\n+  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n+      String leaseHolder, String clientMachine, long lastBlockDelta,\n+      Block newBlock) throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n-    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n-    if(newBlock \u003d\u003d null) {\n-      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n-          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n-              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n+    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n+    if (newBlock \u003d\u003d null) {\n+      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n+          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n+          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n+              oldBlock)));\n     }\n \n     BlockInfoUnderConstruction truncatedBlockUC;\n-    if(shouldCopyOnTruncate) {\n+    if (shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n-      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n-      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n+      file.setLastBlock(truncatedBlockUC,\n+          fsn.getBlockManager().getStorages(oldBlock));\n+      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n-          \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n-          newBlock, truncatedBlockUC.getTruncateBlock());\n+          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n+              + \" size {}  new block {} old block {}\",\n+          truncatedBlockUC.getNumBytes(), newBlock,\n+          truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n-      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n+      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n+          lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\n-          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n-          \"truncate to new size {}\",\n-          truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n+          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n+              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n+              .getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block prepareFileForTruncate(FSNamesystem fsn, INodesInPath iip,\n      String leaseHolder, String clientMachine, long lastBlockDelta,\n      Block newBlock) throws IOException {\n    assert fsn.hasWriteLock();\n\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(fsn, file, oldBlock);\n    if (newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? fsn.createNewBlock() : new Block(\n          oldBlock.getBlockId(), oldBlock.getNumBytes(),\n          fsn.nextGenerationStamp(fsn.getBlockIdManager().isLegacyBlock(\n              oldBlock)));\n    }\n\n    BlockInfoUnderConstruction truncatedBlockUC;\n    if (shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC,\n          fsn.getBlockManager().getStorages(oldBlock));\n      fsn.getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\"\n              + \" size {}  new block {} old block {}\",\n          truncatedBlockUC.getNumBytes(), newBlock,\n          truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      fsn.getBlockManager().convertLastBlockToUnderConstruction(file,\n          lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \"\n              + \"truncate to new size {}\", truncatedBlockUC.getTruncateBlock()\n              .getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirTruncateOp.java",
          "extendedDetails": {
            "oldValue": "[iip-INodesInPath, leaseHolder-String, clientMachine-String, lastBlockDelta-long, newBlock-Block]",
            "newValue": "[fsn-FSNamesystem, iip-INodesInPath, leaseHolder-String, clientMachine-String, lastBlockDelta-long, newBlock-Block]"
          }
        }
      ]
    },
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\n",
      "commitDate": "12/06/15 11:38 AM",
      "commitName": "c17439c2ddd921b63b1635e6f1cba634b8da8557",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "12/06/15 11:17 AM",
      "commitNameOld": "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n-    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n+    BlockInfoUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n-      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n+      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n           \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n           newBlock, truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n-      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n+      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\n           \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n           \"truncate to new size {}\",\n           truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoUnderConstructionContiguous(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n          \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n          newBlock, truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n          \"truncate to new size {}\",\n          truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "3841d09765bab332c9ae4803c5981799585b1f41": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8522. Change heavily recorded NN logs from INFO to DEBUG level. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "05/06/15 3:09 PM",
      "commitName": "3841d09765bab332c9ae4803c5981799585b1f41",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "29/05/15 11:05 AM",
      "commitNameOld": "7817674a3a4d097b647dd77f1345787dd376d5ea",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 7.17,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfo oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n     BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n-      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n-          + \"Scheduling copy-on-truncate to new size \"\n-          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n-          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n+      NameNode.stateChangeLog.debug(\n+          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n+          \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n+          newBlock, truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n-      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n-          + \"Scheduling in-place block truncate to new size \"\n-          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n-          + \" block\u003d\" + truncatedBlockUC);\n+      NameNode.stateChangeLog.debug(\n+          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n+          \"truncate to new size {}\",\n+          truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new\" +\n          \" size {}  new block {} old block {}\", truncatedBlockUC.getNumBytes(),\n          newBlock, truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\n          \"BLOCK* prepareFileForTruncate: {} Scheduling in-place block \" +\n          \"truncate to new size {}\",\n          truncatedBlockUC.getTruncateBlock().getNumBytes(), truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/05/15 8:08 AM",
      "commitNameOld": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n-    BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n+    BlockInfo oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n     BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n           file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling copy-on-truncate to new size \"\n           + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n           + \" old block \" + truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling in-place block truncate to new size \"\n           + truncatedBlockUC.getTruncateBlock().getNumBytes()\n           + \" block\u003d\" + truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling copy-on-truncate to new size \"\n          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling in-place block truncate to new size \"\n          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n          + \" block\u003d\" + truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "6d5da9484185ca9f585195d6da069b9cd5be4044": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8255. Rename getBlockReplication to getPreferredBlockReplication. (Contributed by Zhe Zhang)\n",
      "commitDate": "12/05/15 6:29 AM",
      "commitName": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthor": "yliu",
      "commitDateOld": "08/05/15 11:09 PM",
      "commitNameOld": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.31,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n     BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n-          file.getBlockReplication());\n+          file.getPreferredBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling copy-on-truncate to new size \"\n           + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n           + \" old block \" + truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling in-place block truncate to new size \"\n           + truncatedBlockUC.getTruncateBlock().getNumBytes()\n           + \" block\u003d\" + truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getPreferredBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling copy-on-truncate to new size \"\n          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling in-place block truncate to new size \"\n          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n          + \" block\u003d\" + truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
      "commitDate": "08/05/15 11:04 PM",
      "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/05/15 7:30 AM",
      "commitNameOld": "6f622672b62aa8d719060063ef0e47480cdc8655",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,59 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n-    String src \u003d iip.getPath();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n-        file.getFileUnderConstructionFeature().getClientName(), src);\n+        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n     BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n           file.getBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling copy-on-truncate to new size \"\n           + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n           + \" old block \" + truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling in-place block truncate to new size \"\n           + truncatedBlockUC.getTruncateBlock().getNumBytes()\n           + \" block\u003d\" + truncatedBlockUC);\n     }\n     if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n     }\n \n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling copy-on-truncate to new size \"\n          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling in-place block truncate to new size \"\n          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n          + \" block\u003d\" + truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "d368d3647a858644b9fcd3be33d9fea2a6962f69": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7957. Truncate should verify quota before making changes. Contributed by Jing Zhao.\n",
      "commitDate": "20/03/15 11:50 AM",
      "commitName": "d368d3647a858644b9fcd3be33d9fea2a6962f69",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "20/03/15 10:50 AM",
      "commitNameOld": "a6a5aae472d015d2ea5cd746719485dff93873a8",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,60 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n     String src \u003d iip.getPath();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n     BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n           file.getBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling copy-on-truncate to new size \"\n           + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n           + \" old block \" + truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling in-place block truncate to new size \"\n           + truncatedBlockUC.getTruncateBlock().getNumBytes()\n           + \" block\u003d\" + truncatedBlockUC);\n     }\n-    if(shouldRecoverNow)\n+    if (shouldRecoverNow) {\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n+    }\n \n-    // update the quota: use the preferred block size for UC block\n-    final long diff \u003d\n-        file.getPreferredBlockSize() - truncatedBlockUC.getNumBytes();\n-    dir.updateSpaceConsumed(iip, 0, diff, file.getBlockReplication());\n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    String src \u003d iip.getPath();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling copy-on-truncate to new size \"\n          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling in-place block truncate to new size \"\n          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n          + \" block\u003d\" + truncatedBlockUC);\n    }\n    if (shouldRecoverNow) {\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n    }\n\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/02/15 11:51 AM",
      "commitNameOld": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n     String src \u003d iip.getPath();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n     BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n     BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n       truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n           file.getBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling copy-on-truncate to new size \"\n           + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n           + \" old block \" + truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n       truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling in-place block truncate to new size \"\n           + truncatedBlockUC.getTruncateBlock().getNumBytes()\n           + \" block\u003d\" + truncatedBlockUC);\n     }\n     if(shouldRecoverNow)\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n \n     // update the quota: use the preferred block size for UC block\n     final long diff \u003d\n         file.getPreferredBlockSize() - truncatedBlockUC.getNumBytes();\n-    dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+    dir.updateSpaceConsumed(iip, 0, diff, file.getBlockReplication());\n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    String src \u003d iip.getPath();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling copy-on-truncate to new size \"\n          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling in-place block truncate to new size \"\n          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n          + \" block\u003d\" + truncatedBlockUC);\n    }\n    if(shouldRecoverNow)\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n\n    // update the quota: use the preferred block size for UC block\n    final long diff \u003d\n        file.getPreferredBlockSize() - truncatedBlockUC.getNumBytes();\n    dir.updateSpaceConsumed(iip, 0, diff, file.getBlockReplication());\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/02/15 3:21 PM",
      "commitNameOld": "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   Block prepareFileForTruncate(INodesInPath iip,\n                                String leaseHolder,\n                                String clientMachine,\n                                long lastBlockDelta,\n                                Block newBlock)\n       throws IOException {\n     INodeFile file \u003d iip.getLastINode().asFile();\n     String src \u003d iip.getPath();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n     assert file.isUnderConstruction() : \"inode should be under construction.\";\n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n     boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n-    BlockInfo oldBlock \u003d file.getLastBlock();\n+    BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n     boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n     if(newBlock \u003d\u003d null) {\n       newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n           new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n               nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n     }\n \n-    BlockInfoUnderConstruction truncatedBlockUC;\n+    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n     if(shouldCopyOnTruncate) {\n       // Add new truncateBlock into blocksMap and\n       // use oldBlock as a source for copy-on-truncate recovery\n-      truncatedBlockUC \u003d new BlockInfoUnderConstruction(newBlock,\n+      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n           file.getBlockReplication());\n       truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.setTruncateBlock(oldBlock);\n       file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n       getBlockManager().addBlockCollection(truncatedBlockUC, file);\n \n       NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling copy-on-truncate to new size \"\n           + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n           + \" old block \" + truncatedBlockUC.getTruncateBlock());\n     } else {\n       // Use new generation stamp for in-place truncate recovery\n       blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n       oldBlock \u003d file.getLastBlock();\n       assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n-      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n+      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n       truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n       truncatedBlockUC.getTruncateBlock().setNumBytes(\n           oldBlock.getNumBytes() - lastBlockDelta);\n       truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n           newBlock.getGenerationStamp());\n \n       NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n           + \"Scheduling in-place block truncate to new size \"\n           + truncatedBlockUC.getTruncateBlock().getNumBytes()\n           + \" block\u003d\" + truncatedBlockUC);\n     }\n     if(shouldRecoverNow)\n       truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n \n     // update the quota: use the preferred block size for UC block\n     final long diff \u003d\n         file.getPreferredBlockSize() - truncatedBlockUC.getNumBytes();\n     dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n     return newBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    String src \u003d iip.getPath();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfoContiguous oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoContiguousUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoContiguousUnderConstruction(newBlock,\n          file.getBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling copy-on-truncate to new size \"\n          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoContiguousUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling in-place block truncate to new size \"\n          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n          + \" block\u003d\" + truncatedBlockUC);\n    }\n    if(shouldRecoverNow)\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n\n    // update the quota: use the preferred block size for UC block\n    final long diff \u003d\n        file.getPreferredBlockSize() - truncatedBlockUC.getNumBytes();\n    dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
      "commitDate": "13/01/15 12:24 AM",
      "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthor": "Konstantin V Shvachko",
      "diff": "@@ -0,0 +1,63 @@\n+  Block prepareFileForTruncate(INodesInPath iip,\n+                               String leaseHolder,\n+                               String clientMachine,\n+                               long lastBlockDelta,\n+                               Block newBlock)\n+      throws IOException {\n+    INodeFile file \u003d iip.getLastINode().asFile();\n+    String src \u003d iip.getPath();\n+    file.recordModification(iip.getLatestSnapshotId());\n+    file.toUnderConstruction(leaseHolder, clientMachine);\n+    assert file.isUnderConstruction() : \"inode should be under construction.\";\n+    leaseManager.addLease(\n+        file.getFileUnderConstructionFeature().getClientName(), src);\n+    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n+    BlockInfo oldBlock \u003d file.getLastBlock();\n+    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n+    if(newBlock \u003d\u003d null) {\n+      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n+          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n+              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n+    }\n+\n+    BlockInfoUnderConstruction truncatedBlockUC;\n+    if(shouldCopyOnTruncate) {\n+      // Add new truncateBlock into blocksMap and\n+      // use oldBlock as a source for copy-on-truncate recovery\n+      truncatedBlockUC \u003d new BlockInfoUnderConstruction(newBlock,\n+          file.getBlockReplication());\n+      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n+      truncatedBlockUC.setTruncateBlock(oldBlock);\n+      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n+      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n+\n+      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n+          + \"Scheduling copy-on-truncate to new size \"\n+          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n+          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n+    } else {\n+      // Use new generation stamp for in-place truncate recovery\n+      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n+      oldBlock \u003d file.getLastBlock();\n+      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n+      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n+      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n+      truncatedBlockUC.getTruncateBlock().setNumBytes(\n+          oldBlock.getNumBytes() - lastBlockDelta);\n+      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n+          newBlock.getGenerationStamp());\n+\n+      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n+          + \"Scheduling in-place block truncate to new size \"\n+          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n+          + \" block\u003d\" + truncatedBlockUC);\n+    }\n+    if(shouldRecoverNow)\n+      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n+\n+    // update the quota: use the preferred block size for UC block\n+    final long diff \u003d\n+        file.getPreferredBlockSize() - truncatedBlockUC.getNumBytes();\n+    dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+    return newBlock;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  Block prepareFileForTruncate(INodesInPath iip,\n                               String leaseHolder,\n                               String clientMachine,\n                               long lastBlockDelta,\n                               Block newBlock)\n      throws IOException {\n    INodeFile file \u003d iip.getLastINode().asFile();\n    String src \u003d iip.getPath();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n    assert file.isUnderConstruction() : \"inode should be under construction.\";\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n    boolean shouldRecoverNow \u003d (newBlock \u003d\u003d null);\n    BlockInfo oldBlock \u003d file.getLastBlock();\n    boolean shouldCopyOnTruncate \u003d shouldCopyOnTruncate(file, oldBlock);\n    if(newBlock \u003d\u003d null) {\n      newBlock \u003d (shouldCopyOnTruncate) ? createNewBlock() :\n          new Block(oldBlock.getBlockId(), oldBlock.getNumBytes(),\n              nextGenerationStamp(blockIdManager.isLegacyBlock(oldBlock)));\n    }\n\n    BlockInfoUnderConstruction truncatedBlockUC;\n    if(shouldCopyOnTruncate) {\n      // Add new truncateBlock into blocksMap and\n      // use oldBlock as a source for copy-on-truncate recovery\n      truncatedBlockUC \u003d new BlockInfoUnderConstruction(newBlock,\n          file.getBlockReplication());\n      truncatedBlockUC.setNumBytes(oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.setTruncateBlock(oldBlock);\n      file.setLastBlock(truncatedBlockUC, blockManager.getStorages(oldBlock));\n      getBlockManager().addBlockCollection(truncatedBlockUC, file);\n\n      NameNode.stateChangeLog.info(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling copy-on-truncate to new size \"\n          + truncatedBlockUC.getNumBytes() + \" new block \" + newBlock\n          + \" old block \" + truncatedBlockUC.getTruncateBlock());\n    } else {\n      // Use new generation stamp for in-place truncate recovery\n      blockManager.convertLastBlockToUnderConstruction(file, lastBlockDelta);\n      oldBlock \u003d file.getLastBlock();\n      assert !oldBlock.isComplete() : \"oldBlock should be under construction\";\n      truncatedBlockUC \u003d (BlockInfoUnderConstruction) oldBlock;\n      truncatedBlockUC.setTruncateBlock(new Block(oldBlock));\n      truncatedBlockUC.getTruncateBlock().setNumBytes(\n          oldBlock.getNumBytes() - lastBlockDelta);\n      truncatedBlockUC.getTruncateBlock().setGenerationStamp(\n          newBlock.getGenerationStamp());\n\n      NameNode.stateChangeLog.debug(\"BLOCK* prepareFileForTruncate: \"\n          + \"Scheduling in-place block truncate to new size \"\n          + truncatedBlockUC.getTruncateBlock().getNumBytes()\n          + \" block\u003d\" + truncatedBlockUC);\n    }\n    if(shouldRecoverNow)\n      truncatedBlockUC.initializeBlockRecovery(newBlock.getGenerationStamp());\n\n    // update the quota: use the preferred block size for UC block\n    final long diff \u003d\n        file.getPreferredBlockSize() - truncatedBlockUC.getNumBytes();\n    dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n    return newBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}