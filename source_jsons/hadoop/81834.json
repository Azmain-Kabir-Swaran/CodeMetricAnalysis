{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CleanerUtil.java",
  "functionName": "unmapHackImpl",
  "functionId": "unmapHackImpl",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/CleanerUtil.java",
  "functionStartLine": 89,
  "functionEndLine": 160,
  "numCommitsSeen": 1,
  "timeTaken": 542,
  "changeHistory": [
    "5d084d7eca32cfa647a78ff6ed3c378659f5b186"
  ],
  "changeHistoryShort": {
    "5d084d7eca32cfa647a78ff6ed3c378659f5b186": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5d084d7eca32cfa647a78ff6ed3c378659f5b186": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-12760. sun.misc.Cleaner has moved to a new location in OpenJDK 9. Contributed by Akira Ajisaka.\n",
      "commitDate": "13/09/18 4:42 AM",
      "commitName": "5d084d7eca32cfa647a78ff6ed3c378659f5b186",
      "commitAuthor": "Takanobu Asanuma",
      "diff": "@@ -0,0 +1,72 @@\n+  private static Object unmapHackImpl() {\n+    final MethodHandles.Lookup lookup \u003d MethodHandles.lookup();\n+    try {\n+      try {\n+        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n+        final Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n+        // first check if Unsafe has the right method, otherwise we can\n+        // give up without doing any security critical stuff:\n+        final MethodHandle unmapper \u003d lookup.findVirtual(unsafeClass,\n+            \"invokeCleaner\", methodType(void.class, ByteBuffer.class));\n+        // fetch the unsafe instance and bind it to the virtual MH:\n+        final Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n+        f.setAccessible(true);\n+        final Object theUnsafe \u003d f.get(null);\n+        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n+      } catch (SecurityException se) {\n+        // rethrow to report errors correctly (we need to catch it here,\n+        // as we also catch RuntimeException below!):\n+        throw se;\n+      } catch (ReflectiveOperationException | RuntimeException e) {\n+        // *** sun.misc.Cleaner unmapping (Java 8) ***\n+        final Class\u003c?\u003e directBufferClass \u003d\n+            Class.forName(\"java.nio.DirectByteBuffer\");\n+\n+        final Method m \u003d directBufferClass.getMethod(\"cleaner\");\n+        m.setAccessible(true);\n+        final MethodHandle directBufferCleanerMethod \u003d lookup.unreflect(m);\n+        final Class\u003c?\u003e cleanerClass \u003d\n+            directBufferCleanerMethod.type().returnType();\n+\n+        /*\n+         * \"Compile\" a MethodHandle that basically is equivalent\n+         * to the following code:\n+         *\n+         * void unmapper(ByteBuffer byteBuffer) {\n+         *   sun.misc.Cleaner cleaner \u003d\n+         *       ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n+         *   if (Objects.nonNull(cleaner)) {\n+         *     cleaner.clean();\n+         *   } else {\n+         *     // the noop is needed because MethodHandles#guardWithTest\n+         *     // always needs ELSE\n+         *     noop(cleaner);\n+         *   }\n+         * }\n+         */\n+        final MethodHandle cleanMethod \u003d lookup.findVirtual(\n+            cleanerClass, \"clean\", methodType(void.class));\n+        final MethodHandle nonNullTest \u003d lookup.findStatic(Objects.class,\n+            \"nonNull\", methodType(boolean.class, Object.class))\n+            .asType(methodType(boolean.class, cleanerClass));\n+        final MethodHandle noop \u003d dropArguments(\n+            constant(Void.class, null).asType(methodType(void.class)),\n+            0, cleanerClass);\n+        final MethodHandle unmapper \u003d filterReturnValue(\n+            directBufferCleanerMethod,\n+            guardWithTest(nonNullTest, cleanMethod, noop))\n+            .asType(methodType(void.class, ByteBuffer.class));\n+        return newBufferCleaner(directBufferClass, unmapper);\n+      }\n+    } catch (SecurityException se) {\n+      return \"Unmapping is not supported, because not all required \" +\n+          \"permissions are given to the Hadoop JAR file: \" + se +\n+          \" [Please grant at least the following permissions: \" +\n+          \"RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n+          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n+    } catch (ReflectiveOperationException | RuntimeException e) {\n+      return \"Unmapping is not supported on this platform, \" +\n+          \"because internal Java APIs are not compatible with \" +\n+          \"this Hadoop version: \" + e;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static Object unmapHackImpl() {\n    final MethodHandles.Lookup lookup \u003d MethodHandles.lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can\n        // give up without doing any security critical stuff:\n        final MethodHandle unmapper \u003d lookup.findVirtual(unsafeClass,\n            \"invokeCleaner\", methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe \u003d f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here,\n        // as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class\u003c?\u003e directBufferClass \u003d\n            Class.forName(\"java.nio.DirectByteBuffer\");\n\n        final Method m \u003d directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod \u003d lookup.unreflect(m);\n        final Class\u003c?\u003e cleanerClass \u003d\n            directBufferCleanerMethod.type().returnType();\n\n        /*\n         * \"Compile\" a MethodHandle that basically is equivalent\n         * to the following code:\n         *\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner \u003d\n         *       ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     // the noop is needed because MethodHandles#guardWithTest\n         *     // always needs ELSE\n         *     noop(cleaner);\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod \u003d lookup.findVirtual(\n            cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest \u003d lookup.findStatic(Objects.class,\n            \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop \u003d dropArguments(\n            constant(Void.class, null).asType(methodType(void.class)),\n            0, cleanerClass);\n        final MethodHandle unmapper \u003d filterReturnValue(\n            directBufferCleanerMethod,\n            guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required \" +\n          \"permissions are given to the Hadoop JAR file: \" + se +\n          \" [Please grant at least the following permissions: \" +\n          \"RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, \" +\n          \"because internal Java APIs are not compatible with \" +\n          \"this Hadoop version: \" + e;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/CleanerUtil.java"
    }
  }
}