{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityOverTimePolicy.java",
  "functionName": "validate",
  "functionId": "validate___plan-Plan__reservation-ReservationAllocation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacityOverTimePolicy.java",
  "functionStartLine": 82,
  "functionEndLine": 206,
  "numCommitsSeen": 11,
  "timeTaken": 2029,
  "changeHistory": [
    "fa6137501c1499ae33f6e0e2adc31671a7e782dc",
    "d383bfdcd40c2315197fa5f85c3e5cb3bb83167f",
    "23f937e3b718f607d4fc975610ab3a03265f0f7e",
    "742632e346604fd2b263bd42367165638fcf2416",
    "b6df0dddcdafd7ec67c76ea92aea3ff3e94db247"
  ],
  "changeHistoryShort": {
    "fa6137501c1499ae33f6e0e2adc31671a7e782dc": "Ybodychange",
    "d383bfdcd40c2315197fa5f85c3e5cb3bb83167f": "Ybodychange",
    "23f937e3b718f607d4fc975610ab3a03265f0f7e": "Ybodychange",
    "742632e346604fd2b263bd42367165638fcf2416": "Ybodychange",
    "b6df0dddcdafd7ec67c76ea92aea3ff3e94db247": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fa6137501c1499ae33f6e0e2adc31671a7e782dc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5330. SharingPolicy enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "07/09/17 7:07 PM",
      "commitName": "fa6137501c1499ae33f6e0e2adc31671a7e782dc",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "25/07/16 4:37 PM",
      "commitNameOld": "d383bfdcd40c2315197fa5f85c3e5cb3bb83167f",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 409.1,
      "commitsBetweenForRepo": 2565,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,125 @@\n   public void validate(Plan plan, ReservationAllocation reservation)\n       throws PlanningException {\n \n \n     // rely on NoOverCommitPolicy to check for: 1) user-match, 2) physical\n     // cluster limits, and 3) maxInst (via override of available)\n     try {\n       super.validate(plan, reservation);\n     } catch (PlanningException p) {\n       //wrap it in proper quota exception\n       throw new PlanningQuotaException(p);\n     }\n \n+    long checkStart \u003d reservation.getStartTime() - validWindow;\n+    long checkEnd \u003d reservation.getEndTime() + validWindow;\n+\n     //---- check for integral violations of capacity --------\n \n     // Gather a view of what to check (curr allocation of user, minus old\n     // version of this reservation, plus new version)\n     RLESparseResourceAllocation consumptionForUserOverTime \u003d\n         plan.getConsumptionForUserOverTime(reservation.getUser(),\n-            reservation.getStartTime() - validWindow,\n-            reservation.getEndTime() + validWindow);\n+            checkStart, checkEnd);\n \n     ReservationAllocation old \u003d\n         plan.getReservationById(reservation.getReservationId());\n     if (old !\u003d null) {\n-      consumptionForUserOverTime \u003d RLESparseResourceAllocation\n-          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n-              consumptionForUserOverTime, old.getResourcesOverTime(),\n-              RLEOperator.add, reservation.getStartTime() - validWindow,\n-              reservation.getEndTime() + validWindow);\n+      consumptionForUserOverTime \u003d\n+          RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n+              plan.getTotalCapacity(), consumptionForUserOverTime,\n+              old.getResourcesOverTime(checkStart, checkEnd), RLEOperator.add,\n+              checkStart, checkEnd);\n     }\n \n-    RLESparseResourceAllocation resRLE \u003d reservation.getResourcesOverTime();\n+    RLESparseResourceAllocation resRLE \u003d\n+        reservation.getResourcesOverTime(checkStart, checkEnd);\n \n     RLESparseResourceAllocation toCheck \u003d RLESparseResourceAllocation\n         .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n             consumptionForUserOverTime, resRLE, RLEOperator.add, Long.MIN_VALUE,\n             Long.MAX_VALUE);\n \n     NavigableMap\u003cLong, Resource\u003e integralUp \u003d new TreeMap\u003c\u003e();\n     NavigableMap\u003cLong, Resource\u003e integralDown \u003d new TreeMap\u003c\u003e();\n \n     long prevTime \u003d toCheck.getEarliestStartTime();\n     IntegralResource prevResource \u003d new IntegralResource(0L, 0L);\n     IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n \n     // add intermediate points\n     Map\u003cLong, Resource\u003e temp \u003d new TreeMap\u003c\u003e();\n     for (Map.Entry\u003cLong, Resource\u003e pointToCheck : toCheck.getCumulative()\n         .entrySet()) {\n \n       Long timeToCheck \u003d pointToCheck.getKey();\n       Resource resourceToCheck \u003d pointToCheck.getValue();\n \n       Long nextPoint \u003d toCheck.getCumulative().higherKey(timeToCheck);\n       if (nextPoint \u003d\u003d null || toCheck.getCumulative().get(nextPoint) \u003d\u003d null) {\n         continue;\n       }\n       for (int i \u003d 1; i \u003c\u003d (nextPoint - timeToCheck) / validWindow; i++) {\n         temp.put(timeToCheck + (i * validWindow), resourceToCheck);\n       }\n     }\n     temp.putAll(toCheck.getCumulative());\n \n     // compute point-wise integral for the up-fronts and down-fronts\n     for (Map.Entry\u003cLong, Resource\u003e currPoint : temp.entrySet()) {\n \n       Long currTime \u003d currPoint.getKey();\n       Resource currResource \u003d currPoint.getValue();\n \n       //add to running total current contribution\n       prevResource.multiplyBy(currTime - prevTime);\n       runningTot.add(prevResource);\n       integralUp.put(currTime, normalizeToResource(runningTot, validWindow));\n       integralDown.put(currTime + validWindow,\n           normalizeToResource(runningTot, validWindow));\n \n       if (currResource !\u003d null) {\n         prevResource.memory \u003d currResource.getMemorySize();\n         prevResource.vcores \u003d currResource.getVirtualCores();\n       } else {\n         prevResource.memory \u003d 0L;\n         prevResource.vcores \u003d 0L;\n       }\n       prevTime \u003d currTime;\n     }\n \n     // compute final integral as delta of up minus down transitions\n     RLESparseResourceAllocation intUp \u003d\n         new RLESparseResourceAllocation(integralUp,\n             plan.getResourceCalculator());\n     RLESparseResourceAllocation intDown \u003d\n         new RLESparseResourceAllocation(integralDown,\n             plan.getResourceCalculator());\n \n     RLESparseResourceAllocation integral \u003d RLESparseResourceAllocation\n         .merge(plan.getResourceCalculator(), plan.getTotalCapacity(), intUp,\n             intDown, RLEOperator.subtract, Long.MIN_VALUE, Long.MAX_VALUE);\n \n     // define over-time integral limit\n     // note: this is aligned with the normalization done above\n     NavigableMap\u003cLong, Resource\u003e tlimit \u003d new TreeMap\u003c\u003e();\n     Resource maxAvgRes \u003d Resources.multiply(plan.getTotalCapacity(), maxAvg);\n     tlimit.put(toCheck.getEarliestStartTime() - validWindow, maxAvgRes);\n     RLESparseResourceAllocation targetLimit \u003d\n         new RLESparseResourceAllocation(tlimit, plan.getResourceCalculator());\n \n     // compare using merge() limit with integral\n     try {\n-      RLESparseResourceAllocation\n-          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n-              targetLimit, integral, RLEOperator.subtractTestNonNegative,\n-              reservation.getStartTime() - validWindow,\n-              reservation.getEndTime() + validWindow);\n+\n+      RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n+          plan.getTotalCapacity(), targetLimit, integral,\n+          RLEOperator.subtractTestNonNegative, checkStart, checkEnd);\n+\n     } catch (PlanningException p) {\n       throw new PlanningQuotaException(\n           \"Integral (avg over time) quota capacity \" + maxAvg\n               + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n               + \" would be exceeded by accepting reservation: \" + reservation\n               .getReservationId(), p);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void validate(Plan plan, ReservationAllocation reservation)\n      throws PlanningException {\n\n\n    // rely on NoOverCommitPolicy to check for: 1) user-match, 2) physical\n    // cluster limits, and 3) maxInst (via override of available)\n    try {\n      super.validate(plan, reservation);\n    } catch (PlanningException p) {\n      //wrap it in proper quota exception\n      throw new PlanningQuotaException(p);\n    }\n\n    long checkStart \u003d reservation.getStartTime() - validWindow;\n    long checkEnd \u003d reservation.getEndTime() + validWindow;\n\n    //---- check for integral violations of capacity --------\n\n    // Gather a view of what to check (curr allocation of user, minus old\n    // version of this reservation, plus new version)\n    RLESparseResourceAllocation consumptionForUserOverTime \u003d\n        plan.getConsumptionForUserOverTime(reservation.getUser(),\n            checkStart, checkEnd);\n\n    ReservationAllocation old \u003d\n        plan.getReservationById(reservation.getReservationId());\n    if (old !\u003d null) {\n      consumptionForUserOverTime \u003d\n          RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n              plan.getTotalCapacity(), consumptionForUserOverTime,\n              old.getResourcesOverTime(checkStart, checkEnd), RLEOperator.add,\n              checkStart, checkEnd);\n    }\n\n    RLESparseResourceAllocation resRLE \u003d\n        reservation.getResourcesOverTime(checkStart, checkEnd);\n\n    RLESparseResourceAllocation toCheck \u003d RLESparseResourceAllocation\n        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n            consumptionForUserOverTime, resRLE, RLEOperator.add, Long.MIN_VALUE,\n            Long.MAX_VALUE);\n\n    NavigableMap\u003cLong, Resource\u003e integralUp \u003d new TreeMap\u003c\u003e();\n    NavigableMap\u003cLong, Resource\u003e integralDown \u003d new TreeMap\u003c\u003e();\n\n    long prevTime \u003d toCheck.getEarliestStartTime();\n    IntegralResource prevResource \u003d new IntegralResource(0L, 0L);\n    IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n\n    // add intermediate points\n    Map\u003cLong, Resource\u003e temp \u003d new TreeMap\u003c\u003e();\n    for (Map.Entry\u003cLong, Resource\u003e pointToCheck : toCheck.getCumulative()\n        .entrySet()) {\n\n      Long timeToCheck \u003d pointToCheck.getKey();\n      Resource resourceToCheck \u003d pointToCheck.getValue();\n\n      Long nextPoint \u003d toCheck.getCumulative().higherKey(timeToCheck);\n      if (nextPoint \u003d\u003d null || toCheck.getCumulative().get(nextPoint) \u003d\u003d null) {\n        continue;\n      }\n      for (int i \u003d 1; i \u003c\u003d (nextPoint - timeToCheck) / validWindow; i++) {\n        temp.put(timeToCheck + (i * validWindow), resourceToCheck);\n      }\n    }\n    temp.putAll(toCheck.getCumulative());\n\n    // compute point-wise integral for the up-fronts and down-fronts\n    for (Map.Entry\u003cLong, Resource\u003e currPoint : temp.entrySet()) {\n\n      Long currTime \u003d currPoint.getKey();\n      Resource currResource \u003d currPoint.getValue();\n\n      //add to running total current contribution\n      prevResource.multiplyBy(currTime - prevTime);\n      runningTot.add(prevResource);\n      integralUp.put(currTime, normalizeToResource(runningTot, validWindow));\n      integralDown.put(currTime + validWindow,\n          normalizeToResource(runningTot, validWindow));\n\n      if (currResource !\u003d null) {\n        prevResource.memory \u003d currResource.getMemorySize();\n        prevResource.vcores \u003d currResource.getVirtualCores();\n      } else {\n        prevResource.memory \u003d 0L;\n        prevResource.vcores \u003d 0L;\n      }\n      prevTime \u003d currTime;\n    }\n\n    // compute final integral as delta of up minus down transitions\n    RLESparseResourceAllocation intUp \u003d\n        new RLESparseResourceAllocation(integralUp,\n            plan.getResourceCalculator());\n    RLESparseResourceAllocation intDown \u003d\n        new RLESparseResourceAllocation(integralDown,\n            plan.getResourceCalculator());\n\n    RLESparseResourceAllocation integral \u003d RLESparseResourceAllocation\n        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(), intUp,\n            intDown, RLEOperator.subtract, Long.MIN_VALUE, Long.MAX_VALUE);\n\n    // define over-time integral limit\n    // note: this is aligned with the normalization done above\n    NavigableMap\u003cLong, Resource\u003e tlimit \u003d new TreeMap\u003c\u003e();\n    Resource maxAvgRes \u003d Resources.multiply(plan.getTotalCapacity(), maxAvg);\n    tlimit.put(toCheck.getEarliestStartTime() - validWindow, maxAvgRes);\n    RLESparseResourceAllocation targetLimit \u003d\n        new RLESparseResourceAllocation(tlimit, plan.getResourceCalculator());\n\n    // compare using merge() limit with integral\n    try {\n\n      RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n          plan.getTotalCapacity(), targetLimit, integral,\n          RLEOperator.subtractTestNonNegative, checkStart, checkEnd);\n\n    } catch (PlanningException p) {\n      throw new PlanningQuotaException(\n          \"Integral (avg over time) quota capacity \" + maxAvg\n              + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n              + \" would be exceeded by accepting reservation: \" + reservation\n              .getReservationId(), p);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "d383bfdcd40c2315197fa5f85c3e5cb3bb83167f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5164. Use plan RLE to improve CapacityOverTimePolicy efficiency\n",
      "commitDate": "25/07/16 4:37 PM",
      "commitName": "d383bfdcd40c2315197fa5f85c3e5cb3bb83167f",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 57.32,
      "commitsBetweenForRepo": 487,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,122 @@\n   public void validate(Plan plan, ReservationAllocation reservation)\n       throws PlanningException {\n \n-    // this is entire method invoked under a write-lock on the plan, no need\n-    // to synchronize accesses to the plan further\n \n-    // Try to verify whether there is already a reservation with this ID in\n-    // the system (remove its contribution during validation to simulate a\n-    // try-n-swap\n-    // update).\n-    ReservationAllocation oldReservation \u003d\n+    // rely on NoOverCommitPolicy to check for: 1) user-match, 2) physical\n+    // cluster limits, and 3) maxInst (via override of available)\n+    try {\n+      super.validate(plan, reservation);\n+    } catch (PlanningException p) {\n+      //wrap it in proper quota exception\n+      throw new PlanningQuotaException(p);\n+    }\n+\n+    //---- check for integral violations of capacity --------\n+\n+    // Gather a view of what to check (curr allocation of user, minus old\n+    // version of this reservation, plus new version)\n+    RLESparseResourceAllocation consumptionForUserOverTime \u003d\n+        plan.getConsumptionForUserOverTime(reservation.getUser(),\n+            reservation.getStartTime() - validWindow,\n+            reservation.getEndTime() + validWindow);\n+\n+    ReservationAllocation old \u003d\n         plan.getReservationById(reservation.getReservationId());\n+    if (old !\u003d null) {\n+      consumptionForUserOverTime \u003d RLESparseResourceAllocation\n+          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n+              consumptionForUserOverTime, old.getResourcesOverTime(),\n+              RLEOperator.add, reservation.getStartTime() - validWindow,\n+              reservation.getEndTime() + validWindow);\n+    }\n \n-    long startTime \u003d reservation.getStartTime();\n-    long endTime \u003d reservation.getEndTime();\n-    long step \u003d plan.getStep();\n+    RLESparseResourceAllocation resRLE \u003d reservation.getResourcesOverTime();\n \n-    Resource planTotalCapacity \u003d plan.getTotalCapacity();\n+    RLESparseResourceAllocation toCheck \u003d RLESparseResourceAllocation\n+        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n+            consumptionForUserOverTime, resRLE, RLEOperator.add, Long.MIN_VALUE,\n+            Long.MAX_VALUE);\n \n-    Resource maxAvgRes \u003d Resources.multiply(planTotalCapacity, maxAvg);\n-    Resource maxInsRes \u003d Resources.multiply(planTotalCapacity, maxInst);\n+    NavigableMap\u003cLong, Resource\u003e integralUp \u003d new TreeMap\u003c\u003e();\n+    NavigableMap\u003cLong, Resource\u003e integralDown \u003d new TreeMap\u003c\u003e();\n \n-    // define variable that will store integral of resources (need diff class to\n-    // avoid overflow issues for long/large allocations)\n+    long prevTime \u003d toCheck.getEarliestStartTime();\n+    IntegralResource prevResource \u003d new IntegralResource(0L, 0L);\n     IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n-    IntegralResource maxAllowed \u003d new IntegralResource(maxAvgRes);\n-    maxAllowed.multiplyBy(validWindow / step);\n \n-    RLESparseResourceAllocation userCons \u003d\n-        plan.getConsumptionForUserOverTime(reservation.getUser(), startTime\n-            - validWindow, endTime + validWindow);\n+    // add intermediate points\n+    Map\u003cLong, Resource\u003e temp \u003d new TreeMap\u003c\u003e();\n+    for (Map.Entry\u003cLong, Resource\u003e pointToCheck : toCheck.getCumulative()\n+        .entrySet()) {\n \n-    // check that the resources offered to the user during any window of length\n-    // \"validWindow\" overlapping this allocation are within maxAllowed\n-    // also enforce instantaneous and physical constraints during this pass\n-    for (long t \u003d startTime - validWindow; t \u003c endTime + validWindow; t +\u003d step) {\n+      Long timeToCheck \u003d pointToCheck.getKey();\n+      Resource resourceToCheck \u003d pointToCheck.getValue();\n \n-      Resource currExistingAllocTot \u003d plan.getTotalCommittedResources(t);\n-      Resource currExistingAllocForUser \u003d userCons.getCapacityAtTime(t);\n-      Resource currNewAlloc \u003d reservation.getResourcesAtTime(t);\n-      Resource currOldAlloc \u003d Resources.none();\n-      if (oldReservation !\u003d null) {\n-        currOldAlloc \u003d oldReservation.getResourcesAtTime(t);\n+      Long nextPoint \u003d toCheck.getCumulative().higherKey(timeToCheck);\n+      if (nextPoint \u003d\u003d null || toCheck.getCumulative().get(nextPoint) \u003d\u003d null) {\n+        continue;\n       }\n-\n-      // throw exception if the cluster is overcommitted\n-      // tot_allocated - old + new \u003e capacity\n-      Resource inst \u003d\n-          Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),\n-              currOldAlloc);\n-      if (Resources.greaterThan(plan.getResourceCalculator(),\n-          planTotalCapacity, inst, planTotalCapacity)) {\n-        throw new ResourceOverCommitException(\" Resources at time \" + t\n-            + \" would be overcommitted (\" + inst + \" over \"\n-            + plan.getTotalCapacity() + \") by accepting reservation: \"\n-            + reservation.getReservationId());\n+      for (int i \u003d 1; i \u003c\u003d (nextPoint - timeToCheck) / validWindow; i++) {\n+        temp.put(timeToCheck + (i * validWindow), resourceToCheck);\n       }\n+    }\n+    temp.putAll(toCheck.getCumulative());\n \n-      // throw exception if instantaneous limits are violated\n-      // tot_alloc_to_this_user - old + new \u003e inst_limit\n-      if (Resources.greaterThan(plan.getResourceCalculator(),\n-          planTotalCapacity, Resources.subtract(\n-              Resources.add(currExistingAllocForUser, currNewAlloc),\n-              currOldAlloc), maxInsRes)) {\n-        throw new PlanningQuotaException(\"Instantaneous quota capacity \"\n-            + maxInst + \" would be passed at time \" + t\n-            + \" by accepting reservation: \" + reservation.getReservationId());\n+    // compute point-wise integral for the up-fronts and down-fronts\n+    for (Map.Entry\u003cLong, Resource\u003e currPoint : temp.entrySet()) {\n+\n+      Long currTime \u003d currPoint.getKey();\n+      Resource currResource \u003d currPoint.getValue();\n+\n+      //add to running total current contribution\n+      prevResource.multiplyBy(currTime - prevTime);\n+      runningTot.add(prevResource);\n+      integralUp.put(currTime, normalizeToResource(runningTot, validWindow));\n+      integralDown.put(currTime + validWindow,\n+          normalizeToResource(runningTot, validWindow));\n+\n+      if (currResource !\u003d null) {\n+        prevResource.memory \u003d currResource.getMemorySize();\n+        prevResource.vcores \u003d currResource.getVirtualCores();\n+      } else {\n+        prevResource.memory \u003d 0L;\n+        prevResource.vcores \u003d 0L;\n       }\n+      prevTime \u003d currTime;\n+    }\n \n-      // throw exception if the running integral of utilization over validWindow\n-      // is violated. We perform a delta check, adding/removing instants at the\n-      // boundary of the window from runningTot.\n+    // compute final integral as delta of up minus down transitions\n+    RLESparseResourceAllocation intUp \u003d\n+        new RLESparseResourceAllocation(integralUp,\n+            plan.getResourceCalculator());\n+    RLESparseResourceAllocation intDown \u003d\n+        new RLESparseResourceAllocation(integralDown,\n+            plan.getResourceCalculator());\n \n-      // runningTot \u003d previous_runningTot + currExistingAllocForUser +\n-      // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;\n+    RLESparseResourceAllocation integral \u003d RLESparseResourceAllocation\n+        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(), intUp,\n+            intDown, RLEOperator.subtract, Long.MIN_VALUE, Long.MAX_VALUE);\n \n-      // Where:\n-      // 1) currNewAlloc, currExistingAllocForUser represent the contribution of\n-      // the instant in time added in this pass.\n-      // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time\n-      // instants that are being retired from the the window\n-      // 3) currOldAlloc is the contribution (if any) of the previous version of\n-      // this reservation (the one we are updating)\n+    // define over-time integral limit\n+    // note: this is aligned with the normalization done above\n+    NavigableMap\u003cLong, Resource\u003e tlimit \u003d new TreeMap\u003c\u003e();\n+    Resource maxAvgRes \u003d Resources.multiply(plan.getTotalCapacity(), maxAvg);\n+    tlimit.put(toCheck.getEarliestStartTime() - validWindow, maxAvgRes);\n+    RLESparseResourceAllocation targetLimit \u003d\n+        new RLESparseResourceAllocation(tlimit, plan.getResourceCalculator());\n \n-      runningTot.add(currExistingAllocForUser);\n-      runningTot.add(currNewAlloc);\n-      runningTot.subtract(currOldAlloc);\n-\n-      // expire contributions from instant in time before (t - validWindow)\n-      if (t \u003e startTime) {\n-        Resource pastOldAlloc \u003d userCons.getCapacityAtTime(t - validWindow);\n-        Resource pastNewAlloc \u003d reservation.getResourcesAtTime(t - validWindow);\n-\n-        // runningTot \u003d runningTot - pastExistingAlloc - pastNewAlloc;\n-        runningTot.subtract(pastOldAlloc);\n-        runningTot.subtract(pastNewAlloc);\n-      }\n-\n-      // check integral\n-      // runningTot \u003e maxAvg * validWindow\n-      // NOTE: we need to use comparator of IntegralResource directly, as\n-      // Resource and ResourceCalculator assume \"int\" amount of resources,\n-      // which is not sufficient when comparing integrals (out-of-bound)\n-      if (maxAllowed.compareTo(runningTot) \u003c 0) {\n-        throw new PlanningQuotaException(\n-            \"Integral (avg over time) quota capacity \" + maxAvg\n-                + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n-                + \" would be passed at time \" + t + \"(\" + new Date(t)\n-                + \") by accepting reservation: \"\n-                + reservation.getReservationId());\n-      }\n+    // compare using merge() limit with integral\n+    try {\n+      RLESparseResourceAllocation\n+          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n+              targetLimit, integral, RLEOperator.subtractTestNonNegative,\n+              reservation.getStartTime() - validWindow,\n+              reservation.getEndTime() + validWindow);\n+    } catch (PlanningException p) {\n+      throw new PlanningQuotaException(\n+          \"Integral (avg over time) quota capacity \" + maxAvg\n+              + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n+              + \" would be exceeded by accepting reservation: \" + reservation\n+              .getReservationId(), p);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void validate(Plan plan, ReservationAllocation reservation)\n      throws PlanningException {\n\n\n    // rely on NoOverCommitPolicy to check for: 1) user-match, 2) physical\n    // cluster limits, and 3) maxInst (via override of available)\n    try {\n      super.validate(plan, reservation);\n    } catch (PlanningException p) {\n      //wrap it in proper quota exception\n      throw new PlanningQuotaException(p);\n    }\n\n    //---- check for integral violations of capacity --------\n\n    // Gather a view of what to check (curr allocation of user, minus old\n    // version of this reservation, plus new version)\n    RLESparseResourceAllocation consumptionForUserOverTime \u003d\n        plan.getConsumptionForUserOverTime(reservation.getUser(),\n            reservation.getStartTime() - validWindow,\n            reservation.getEndTime() + validWindow);\n\n    ReservationAllocation old \u003d\n        plan.getReservationById(reservation.getReservationId());\n    if (old !\u003d null) {\n      consumptionForUserOverTime \u003d RLESparseResourceAllocation\n          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n              consumptionForUserOverTime, old.getResourcesOverTime(),\n              RLEOperator.add, reservation.getStartTime() - validWindow,\n              reservation.getEndTime() + validWindow);\n    }\n\n    RLESparseResourceAllocation resRLE \u003d reservation.getResourcesOverTime();\n\n    RLESparseResourceAllocation toCheck \u003d RLESparseResourceAllocation\n        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n            consumptionForUserOverTime, resRLE, RLEOperator.add, Long.MIN_VALUE,\n            Long.MAX_VALUE);\n\n    NavigableMap\u003cLong, Resource\u003e integralUp \u003d new TreeMap\u003c\u003e();\n    NavigableMap\u003cLong, Resource\u003e integralDown \u003d new TreeMap\u003c\u003e();\n\n    long prevTime \u003d toCheck.getEarliestStartTime();\n    IntegralResource prevResource \u003d new IntegralResource(0L, 0L);\n    IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n\n    // add intermediate points\n    Map\u003cLong, Resource\u003e temp \u003d new TreeMap\u003c\u003e();\n    for (Map.Entry\u003cLong, Resource\u003e pointToCheck : toCheck.getCumulative()\n        .entrySet()) {\n\n      Long timeToCheck \u003d pointToCheck.getKey();\n      Resource resourceToCheck \u003d pointToCheck.getValue();\n\n      Long nextPoint \u003d toCheck.getCumulative().higherKey(timeToCheck);\n      if (nextPoint \u003d\u003d null || toCheck.getCumulative().get(nextPoint) \u003d\u003d null) {\n        continue;\n      }\n      for (int i \u003d 1; i \u003c\u003d (nextPoint - timeToCheck) / validWindow; i++) {\n        temp.put(timeToCheck + (i * validWindow), resourceToCheck);\n      }\n    }\n    temp.putAll(toCheck.getCumulative());\n\n    // compute point-wise integral for the up-fronts and down-fronts\n    for (Map.Entry\u003cLong, Resource\u003e currPoint : temp.entrySet()) {\n\n      Long currTime \u003d currPoint.getKey();\n      Resource currResource \u003d currPoint.getValue();\n\n      //add to running total current contribution\n      prevResource.multiplyBy(currTime - prevTime);\n      runningTot.add(prevResource);\n      integralUp.put(currTime, normalizeToResource(runningTot, validWindow));\n      integralDown.put(currTime + validWindow,\n          normalizeToResource(runningTot, validWindow));\n\n      if (currResource !\u003d null) {\n        prevResource.memory \u003d currResource.getMemorySize();\n        prevResource.vcores \u003d currResource.getVirtualCores();\n      } else {\n        prevResource.memory \u003d 0L;\n        prevResource.vcores \u003d 0L;\n      }\n      prevTime \u003d currTime;\n    }\n\n    // compute final integral as delta of up minus down transitions\n    RLESparseResourceAllocation intUp \u003d\n        new RLESparseResourceAllocation(integralUp,\n            plan.getResourceCalculator());\n    RLESparseResourceAllocation intDown \u003d\n        new RLESparseResourceAllocation(integralDown,\n            plan.getResourceCalculator());\n\n    RLESparseResourceAllocation integral \u003d RLESparseResourceAllocation\n        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(), intUp,\n            intDown, RLEOperator.subtract, Long.MIN_VALUE, Long.MAX_VALUE);\n\n    // define over-time integral limit\n    // note: this is aligned with the normalization done above\n    NavigableMap\u003cLong, Resource\u003e tlimit \u003d new TreeMap\u003c\u003e();\n    Resource maxAvgRes \u003d Resources.multiply(plan.getTotalCapacity(), maxAvg);\n    tlimit.put(toCheck.getEarliestStartTime() - validWindow, maxAvgRes);\n    RLESparseResourceAllocation targetLimit \u003d\n        new RLESparseResourceAllocation(tlimit, plan.getResourceCalculator());\n\n    // compare using merge() limit with integral\n    try {\n      RLESparseResourceAllocation\n          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),\n              targetLimit, integral, RLEOperator.subtractTestNonNegative,\n              reservation.getStartTime() - validWindow,\n              reservation.getEndTime() + validWindow);\n    } catch (PlanningException p) {\n      throw new PlanningQuotaException(\n          \"Integral (avg over time) quota capacity \" + maxAvg\n              + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n              + \" would be exceeded by accepting reservation: \" + reservation\n              .getReservationId(), p);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "23f937e3b718f607d4fc975610ab3a03265f0f7e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2575. Create separate ACLs for Reservation create/update/delete/list ops (Sean Po via asuresh)\n",
      "commitDate": "11/02/16 10:47 AM",
      "commitName": "23f937e3b718f607d4fc975610ab3a03265f0f7e",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "10/02/16 9:11 AM",
      "commitNameOld": "5cf5c41a895f5ab8bf6270089f8cfdea50573a97",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 1.07,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,113 @@\n   public void validate(Plan plan, ReservationAllocation reservation)\n       throws PlanningException {\n \n     // this is entire method invoked under a write-lock on the plan, no need\n     // to synchronize accesses to the plan further\n \n     // Try to verify whether there is already a reservation with this ID in\n     // the system (remove its contribution during validation to simulate a\n     // try-n-swap\n     // update).\n     ReservationAllocation oldReservation \u003d\n         plan.getReservationById(reservation.getReservationId());\n \n-    // sanity check that the update of a reservation is not changing username\n-    if (oldReservation !\u003d null\n-        \u0026\u0026 !oldReservation.getUser().equals(reservation.getUser())) {\n-      throw new MismatchedUserException(\n-          \"Updating an existing reservation with mismatched user:\"\n-              + oldReservation.getUser() + \" !\u003d \" + reservation.getUser());\n-    }\n-\n     long startTime \u003d reservation.getStartTime();\n     long endTime \u003d reservation.getEndTime();\n     long step \u003d plan.getStep();\n \n     Resource planTotalCapacity \u003d plan.getTotalCapacity();\n \n     Resource maxAvgRes \u003d Resources.multiply(planTotalCapacity, maxAvg);\n     Resource maxInsRes \u003d Resources.multiply(planTotalCapacity, maxInst);\n \n     // define variable that will store integral of resources (need diff class to\n     // avoid overflow issues for long/large allocations)\n     IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n     IntegralResource maxAllowed \u003d new IntegralResource(maxAvgRes);\n     maxAllowed.multiplyBy(validWindow / step);\n \n     RLESparseResourceAllocation userCons \u003d\n         plan.getConsumptionForUserOverTime(reservation.getUser(), startTime\n             - validWindow, endTime + validWindow);\n \n     // check that the resources offered to the user during any window of length\n     // \"validWindow\" overlapping this allocation are within maxAllowed\n     // also enforce instantaneous and physical constraints during this pass\n     for (long t \u003d startTime - validWindow; t \u003c endTime + validWindow; t +\u003d step) {\n \n       Resource currExistingAllocTot \u003d plan.getTotalCommittedResources(t);\n       Resource currExistingAllocForUser \u003d userCons.getCapacityAtTime(t);\n       Resource currNewAlloc \u003d reservation.getResourcesAtTime(t);\n       Resource currOldAlloc \u003d Resources.none();\n       if (oldReservation !\u003d null) {\n         currOldAlloc \u003d oldReservation.getResourcesAtTime(t);\n       }\n \n       // throw exception if the cluster is overcommitted\n       // tot_allocated - old + new \u003e capacity\n       Resource inst \u003d\n           Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),\n               currOldAlloc);\n       if (Resources.greaterThan(plan.getResourceCalculator(),\n           planTotalCapacity, inst, planTotalCapacity)) {\n         throw new ResourceOverCommitException(\" Resources at time \" + t\n             + \" would be overcommitted (\" + inst + \" over \"\n             + plan.getTotalCapacity() + \") by accepting reservation: \"\n             + reservation.getReservationId());\n       }\n \n       // throw exception if instantaneous limits are violated\n       // tot_alloc_to_this_user - old + new \u003e inst_limit\n       if (Resources.greaterThan(plan.getResourceCalculator(),\n           planTotalCapacity, Resources.subtract(\n               Resources.add(currExistingAllocForUser, currNewAlloc),\n               currOldAlloc), maxInsRes)) {\n         throw new PlanningQuotaException(\"Instantaneous quota capacity \"\n             + maxInst + \" would be passed at time \" + t\n             + \" by accepting reservation: \" + reservation.getReservationId());\n       }\n \n       // throw exception if the running integral of utilization over validWindow\n       // is violated. We perform a delta check, adding/removing instants at the\n       // boundary of the window from runningTot.\n \n       // runningTot \u003d previous_runningTot + currExistingAllocForUser +\n       // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;\n \n       // Where:\n       // 1) currNewAlloc, currExistingAllocForUser represent the contribution of\n       // the instant in time added in this pass.\n       // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time\n       // instants that are being retired from the the window\n       // 3) currOldAlloc is the contribution (if any) of the previous version of\n       // this reservation (the one we are updating)\n \n       runningTot.add(currExistingAllocForUser);\n       runningTot.add(currNewAlloc);\n       runningTot.subtract(currOldAlloc);\n \n       // expire contributions from instant in time before (t - validWindow)\n       if (t \u003e startTime) {\n         Resource pastOldAlloc \u003d userCons.getCapacityAtTime(t - validWindow);\n         Resource pastNewAlloc \u003d reservation.getResourcesAtTime(t - validWindow);\n \n         // runningTot \u003d runningTot - pastExistingAlloc - pastNewAlloc;\n         runningTot.subtract(pastOldAlloc);\n         runningTot.subtract(pastNewAlloc);\n       }\n \n       // check integral\n       // runningTot \u003e maxAvg * validWindow\n       // NOTE: we need to use comparator of IntegralResource directly, as\n       // Resource and ResourceCalculator assume \"int\" amount of resources,\n       // which is not sufficient when comparing integrals (out-of-bound)\n       if (maxAllowed.compareTo(runningTot) \u003c 0) {\n         throw new PlanningQuotaException(\n             \"Integral (avg over time) quota capacity \" + maxAvg\n                 + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n                 + \" would be passed at time \" + t + \"(\" + new Date(t)\n                 + \") by accepting reservation: \"\n                 + reservation.getReservationId());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void validate(Plan plan, ReservationAllocation reservation)\n      throws PlanningException {\n\n    // this is entire method invoked under a write-lock on the plan, no need\n    // to synchronize accesses to the plan further\n\n    // Try to verify whether there is already a reservation with this ID in\n    // the system (remove its contribution during validation to simulate a\n    // try-n-swap\n    // update).\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservation.getReservationId());\n\n    long startTime \u003d reservation.getStartTime();\n    long endTime \u003d reservation.getEndTime();\n    long step \u003d plan.getStep();\n\n    Resource planTotalCapacity \u003d plan.getTotalCapacity();\n\n    Resource maxAvgRes \u003d Resources.multiply(planTotalCapacity, maxAvg);\n    Resource maxInsRes \u003d Resources.multiply(planTotalCapacity, maxInst);\n\n    // define variable that will store integral of resources (need diff class to\n    // avoid overflow issues for long/large allocations)\n    IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n    IntegralResource maxAllowed \u003d new IntegralResource(maxAvgRes);\n    maxAllowed.multiplyBy(validWindow / step);\n\n    RLESparseResourceAllocation userCons \u003d\n        plan.getConsumptionForUserOverTime(reservation.getUser(), startTime\n            - validWindow, endTime + validWindow);\n\n    // check that the resources offered to the user during any window of length\n    // \"validWindow\" overlapping this allocation are within maxAllowed\n    // also enforce instantaneous and physical constraints during this pass\n    for (long t \u003d startTime - validWindow; t \u003c endTime + validWindow; t +\u003d step) {\n\n      Resource currExistingAllocTot \u003d plan.getTotalCommittedResources(t);\n      Resource currExistingAllocForUser \u003d userCons.getCapacityAtTime(t);\n      Resource currNewAlloc \u003d reservation.getResourcesAtTime(t);\n      Resource currOldAlloc \u003d Resources.none();\n      if (oldReservation !\u003d null) {\n        currOldAlloc \u003d oldReservation.getResourcesAtTime(t);\n      }\n\n      // throw exception if the cluster is overcommitted\n      // tot_allocated - old + new \u003e capacity\n      Resource inst \u003d\n          Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),\n              currOldAlloc);\n      if (Resources.greaterThan(plan.getResourceCalculator(),\n          planTotalCapacity, inst, planTotalCapacity)) {\n        throw new ResourceOverCommitException(\" Resources at time \" + t\n            + \" would be overcommitted (\" + inst + \" over \"\n            + plan.getTotalCapacity() + \") by accepting reservation: \"\n            + reservation.getReservationId());\n      }\n\n      // throw exception if instantaneous limits are violated\n      // tot_alloc_to_this_user - old + new \u003e inst_limit\n      if (Resources.greaterThan(plan.getResourceCalculator(),\n          planTotalCapacity, Resources.subtract(\n              Resources.add(currExistingAllocForUser, currNewAlloc),\n              currOldAlloc), maxInsRes)) {\n        throw new PlanningQuotaException(\"Instantaneous quota capacity \"\n            + maxInst + \" would be passed at time \" + t\n            + \" by accepting reservation: \" + reservation.getReservationId());\n      }\n\n      // throw exception if the running integral of utilization over validWindow\n      // is violated. We perform a delta check, adding/removing instants at the\n      // boundary of the window from runningTot.\n\n      // runningTot \u003d previous_runningTot + currExistingAllocForUser +\n      // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;\n\n      // Where:\n      // 1) currNewAlloc, currExistingAllocForUser represent the contribution of\n      // the instant in time added in this pass.\n      // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time\n      // instants that are being retired from the the window\n      // 3) currOldAlloc is the contribution (if any) of the previous version of\n      // this reservation (the one we are updating)\n\n      runningTot.add(currExistingAllocForUser);\n      runningTot.add(currNewAlloc);\n      runningTot.subtract(currOldAlloc);\n\n      // expire contributions from instant in time before (t - validWindow)\n      if (t \u003e startTime) {\n        Resource pastOldAlloc \u003d userCons.getCapacityAtTime(t - validWindow);\n        Resource pastNewAlloc \u003d reservation.getResourcesAtTime(t - validWindow);\n\n        // runningTot \u003d runningTot - pastExistingAlloc - pastNewAlloc;\n        runningTot.subtract(pastOldAlloc);\n        runningTot.subtract(pastNewAlloc);\n      }\n\n      // check integral\n      // runningTot \u003e maxAvg * validWindow\n      // NOTE: we need to use comparator of IntegralResource directly, as\n      // Resource and ResourceCalculator assume \"int\" amount of resources,\n      // which is not sufficient when comparing integrals (out-of-bound)\n      if (maxAllowed.compareTo(runningTot) \u003c 0) {\n        throw new PlanningQuotaException(\n            \"Integral (avg over time) quota capacity \" + maxAvg\n                + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n                + \" would be passed at time \" + t + \"(\" + new Date(t)\n                + \") by accepting reservation: \"\n                + reservation.getReservationId());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "17/11/14 4:45 PM",
      "commitNameOld": "2fce6d61412843f0447f60cfe02326f769edae25",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 383.19,
      "commitsBetweenForRepo": 3085,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,121 @@\n   public void validate(Plan plan, ReservationAllocation reservation)\n       throws PlanningException {\n \n     // this is entire method invoked under a write-lock on the plan, no need\n     // to synchronize accesses to the plan further\n \n     // Try to verify whether there is already a reservation with this ID in\n     // the system (remove its contribution during validation to simulate a\n     // try-n-swap\n     // update).\n     ReservationAllocation oldReservation \u003d\n         plan.getReservationById(reservation.getReservationId());\n \n     // sanity check that the update of a reservation is not changing username\n     if (oldReservation !\u003d null\n         \u0026\u0026 !oldReservation.getUser().equals(reservation.getUser())) {\n       throw new MismatchedUserException(\n           \"Updating an existing reservation with mismatched user:\"\n               + oldReservation.getUser() + \" !\u003d \" + reservation.getUser());\n     }\n \n     long startTime \u003d reservation.getStartTime();\n     long endTime \u003d reservation.getEndTime();\n     long step \u003d plan.getStep();\n \n     Resource planTotalCapacity \u003d plan.getTotalCapacity();\n \n     Resource maxAvgRes \u003d Resources.multiply(planTotalCapacity, maxAvg);\n     Resource maxInsRes \u003d Resources.multiply(planTotalCapacity, maxInst);\n \n     // define variable that will store integral of resources (need diff class to\n     // avoid overflow issues for long/large allocations)\n     IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n     IntegralResource maxAllowed \u003d new IntegralResource(maxAvgRes);\n     maxAllowed.multiplyBy(validWindow / step);\n \n+    RLESparseResourceAllocation userCons \u003d\n+        plan.getConsumptionForUserOverTime(reservation.getUser(), startTime\n+            - validWindow, endTime + validWindow);\n+\n     // check that the resources offered to the user during any window of length\n     // \"validWindow\" overlapping this allocation are within maxAllowed\n     // also enforce instantaneous and physical constraints during this pass\n     for (long t \u003d startTime - validWindow; t \u003c endTime + validWindow; t +\u003d step) {\n \n       Resource currExistingAllocTot \u003d plan.getTotalCommittedResources(t);\n-      Resource currExistingAllocForUser \u003d\n-          plan.getConsumptionForUser(reservation.getUser(), t);\n+      Resource currExistingAllocForUser \u003d userCons.getCapacityAtTime(t);\n       Resource currNewAlloc \u003d reservation.getResourcesAtTime(t);\n       Resource currOldAlloc \u003d Resources.none();\n       if (oldReservation !\u003d null) {\n         currOldAlloc \u003d oldReservation.getResourcesAtTime(t);\n       }\n \n       // throw exception if the cluster is overcommitted\n       // tot_allocated - old + new \u003e capacity\n       Resource inst \u003d\n           Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),\n               currOldAlloc);\n       if (Resources.greaterThan(plan.getResourceCalculator(),\n           planTotalCapacity, inst, planTotalCapacity)) {\n         throw new ResourceOverCommitException(\" Resources at time \" + t\n             + \" would be overcommitted (\" + inst + \" over \"\n             + plan.getTotalCapacity() + \") by accepting reservation: \"\n             + reservation.getReservationId());\n       }\n \n       // throw exception if instantaneous limits are violated\n       // tot_alloc_to_this_user - old + new \u003e inst_limit\n       if (Resources.greaterThan(plan.getResourceCalculator(),\n           planTotalCapacity, Resources.subtract(\n               Resources.add(currExistingAllocForUser, currNewAlloc),\n               currOldAlloc), maxInsRes)) {\n         throw new PlanningQuotaException(\"Instantaneous quota capacity \"\n             + maxInst + \" would be passed at time \" + t\n             + \" by accepting reservation: \" + reservation.getReservationId());\n       }\n \n       // throw exception if the running integral of utilization over validWindow\n       // is violated. We perform a delta check, adding/removing instants at the\n       // boundary of the window from runningTot.\n \n       // runningTot \u003d previous_runningTot + currExistingAllocForUser +\n       // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;\n \n       // Where:\n       // 1) currNewAlloc, currExistingAllocForUser represent the contribution of\n       // the instant in time added in this pass.\n       // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time\n       // instants that are being retired from the the window\n       // 3) currOldAlloc is the contribution (if any) of the previous version of\n       // this reservation (the one we are updating)\n \n       runningTot.add(currExistingAllocForUser);\n       runningTot.add(currNewAlloc);\n       runningTot.subtract(currOldAlloc);\n \n       // expire contributions from instant in time before (t - validWindow)\n       if (t \u003e startTime) {\n-        Resource pastOldAlloc \u003d\n-            plan.getConsumptionForUser(reservation.getUser(), t - validWindow);\n+        Resource pastOldAlloc \u003d userCons.getCapacityAtTime(t - validWindow);\n         Resource pastNewAlloc \u003d reservation.getResourcesAtTime(t - validWindow);\n \n         // runningTot \u003d runningTot - pastExistingAlloc - pastNewAlloc;\n         runningTot.subtract(pastOldAlloc);\n         runningTot.subtract(pastNewAlloc);\n       }\n \n       // check integral\n       // runningTot \u003e maxAvg * validWindow\n       // NOTE: we need to use comparator of IntegralResource directly, as\n       // Resource and ResourceCalculator assume \"int\" amount of resources,\n       // which is not sufficient when comparing integrals (out-of-bound)\n       if (maxAllowed.compareTo(runningTot) \u003c 0) {\n         throw new PlanningQuotaException(\n             \"Integral (avg over time) quota capacity \" + maxAvg\n                 + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n                 + \" would be passed at time \" + t + \"(\" + new Date(t)\n                 + \") by accepting reservation: \"\n                 + reservation.getReservationId());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void validate(Plan plan, ReservationAllocation reservation)\n      throws PlanningException {\n\n    // this is entire method invoked under a write-lock on the plan, no need\n    // to synchronize accesses to the plan further\n\n    // Try to verify whether there is already a reservation with this ID in\n    // the system (remove its contribution during validation to simulate a\n    // try-n-swap\n    // update).\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservation.getReservationId());\n\n    // sanity check that the update of a reservation is not changing username\n    if (oldReservation !\u003d null\n        \u0026\u0026 !oldReservation.getUser().equals(reservation.getUser())) {\n      throw new MismatchedUserException(\n          \"Updating an existing reservation with mismatched user:\"\n              + oldReservation.getUser() + \" !\u003d \" + reservation.getUser());\n    }\n\n    long startTime \u003d reservation.getStartTime();\n    long endTime \u003d reservation.getEndTime();\n    long step \u003d plan.getStep();\n\n    Resource planTotalCapacity \u003d plan.getTotalCapacity();\n\n    Resource maxAvgRes \u003d Resources.multiply(planTotalCapacity, maxAvg);\n    Resource maxInsRes \u003d Resources.multiply(planTotalCapacity, maxInst);\n\n    // define variable that will store integral of resources (need diff class to\n    // avoid overflow issues for long/large allocations)\n    IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n    IntegralResource maxAllowed \u003d new IntegralResource(maxAvgRes);\n    maxAllowed.multiplyBy(validWindow / step);\n\n    RLESparseResourceAllocation userCons \u003d\n        plan.getConsumptionForUserOverTime(reservation.getUser(), startTime\n            - validWindow, endTime + validWindow);\n\n    // check that the resources offered to the user during any window of length\n    // \"validWindow\" overlapping this allocation are within maxAllowed\n    // also enforce instantaneous and physical constraints during this pass\n    for (long t \u003d startTime - validWindow; t \u003c endTime + validWindow; t +\u003d step) {\n\n      Resource currExistingAllocTot \u003d plan.getTotalCommittedResources(t);\n      Resource currExistingAllocForUser \u003d userCons.getCapacityAtTime(t);\n      Resource currNewAlloc \u003d reservation.getResourcesAtTime(t);\n      Resource currOldAlloc \u003d Resources.none();\n      if (oldReservation !\u003d null) {\n        currOldAlloc \u003d oldReservation.getResourcesAtTime(t);\n      }\n\n      // throw exception if the cluster is overcommitted\n      // tot_allocated - old + new \u003e capacity\n      Resource inst \u003d\n          Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),\n              currOldAlloc);\n      if (Resources.greaterThan(plan.getResourceCalculator(),\n          planTotalCapacity, inst, planTotalCapacity)) {\n        throw new ResourceOverCommitException(\" Resources at time \" + t\n            + \" would be overcommitted (\" + inst + \" over \"\n            + plan.getTotalCapacity() + \") by accepting reservation: \"\n            + reservation.getReservationId());\n      }\n\n      // throw exception if instantaneous limits are violated\n      // tot_alloc_to_this_user - old + new \u003e inst_limit\n      if (Resources.greaterThan(plan.getResourceCalculator(),\n          planTotalCapacity, Resources.subtract(\n              Resources.add(currExistingAllocForUser, currNewAlloc),\n              currOldAlloc), maxInsRes)) {\n        throw new PlanningQuotaException(\"Instantaneous quota capacity \"\n            + maxInst + \" would be passed at time \" + t\n            + \" by accepting reservation: \" + reservation.getReservationId());\n      }\n\n      // throw exception if the running integral of utilization over validWindow\n      // is violated. We perform a delta check, adding/removing instants at the\n      // boundary of the window from runningTot.\n\n      // runningTot \u003d previous_runningTot + currExistingAllocForUser +\n      // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;\n\n      // Where:\n      // 1) currNewAlloc, currExistingAllocForUser represent the contribution of\n      // the instant in time added in this pass.\n      // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time\n      // instants that are being retired from the the window\n      // 3) currOldAlloc is the contribution (if any) of the previous version of\n      // this reservation (the one we are updating)\n\n      runningTot.add(currExistingAllocForUser);\n      runningTot.add(currNewAlloc);\n      runningTot.subtract(currOldAlloc);\n\n      // expire contributions from instant in time before (t - validWindow)\n      if (t \u003e startTime) {\n        Resource pastOldAlloc \u003d userCons.getCapacityAtTime(t - validWindow);\n        Resource pastNewAlloc \u003d reservation.getResourcesAtTime(t - validWindow);\n\n        // runningTot \u003d runningTot - pastExistingAlloc - pastNewAlloc;\n        runningTot.subtract(pastOldAlloc);\n        runningTot.subtract(pastNewAlloc);\n      }\n\n      // check integral\n      // runningTot \u003e maxAvg * validWindow\n      // NOTE: we need to use comparator of IntegralResource directly, as\n      // Resource and ResourceCalculator assume \"int\" amount of resources,\n      // which is not sufficient when comparing integrals (out-of-bound)\n      if (maxAllowed.compareTo(runningTot) \u003c 0) {\n        throw new PlanningQuotaException(\n            \"Integral (avg over time) quota capacity \" + maxAvg\n                + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n                + \" would be passed at time \" + t + \"(\" + new Date(t)\n                + \") by accepting reservation: \"\n                + reservation.getReservationId());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "b6df0dddcdafd7ec67c76ea92aea3ff3e94db247": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1711. Policy to enforce instantaneous and over-time quotas on user reservation. Contributed by Carlo Curino and Subru Krishnan.\n(cherry picked from commit c4918cb4cb5a267a8cfd6eace28fcfe7ad6174e8)\n",
      "commitDate": "03/10/14 3:42 PM",
      "commitName": "b6df0dddcdafd7ec67c76ea92aea3ff3e94db247",
      "commitAuthor": "carlo curino",
      "diff": "@@ -0,0 +1,119 @@\n+  public void validate(Plan plan, ReservationAllocation reservation)\n+      throws PlanningException {\n+\n+    // this is entire method invoked under a write-lock on the plan, no need\n+    // to synchronize accesses to the plan further\n+\n+    // Try to verify whether there is already a reservation with this ID in\n+    // the system (remove its contribution during validation to simulate a\n+    // try-n-swap\n+    // update).\n+    ReservationAllocation oldReservation \u003d\n+        plan.getReservationById(reservation.getReservationId());\n+\n+    // sanity check that the update of a reservation is not changing username\n+    if (oldReservation !\u003d null\n+        \u0026\u0026 !oldReservation.getUser().equals(reservation.getUser())) {\n+      throw new MismatchedUserException(\n+          \"Updating an existing reservation with mismatched user:\"\n+              + oldReservation.getUser() + \" !\u003d \" + reservation.getUser());\n+    }\n+\n+    long startTime \u003d reservation.getStartTime();\n+    long endTime \u003d reservation.getEndTime();\n+    long step \u003d plan.getStep();\n+\n+    Resource planTotalCapacity \u003d plan.getTotalCapacity();\n+\n+    Resource maxAvgRes \u003d Resources.multiply(planTotalCapacity, maxAvg);\n+    Resource maxInsRes \u003d Resources.multiply(planTotalCapacity, maxInst);\n+\n+    // define variable that will store integral of resources (need diff class to\n+    // avoid overflow issues for long/large allocations)\n+    IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n+    IntegralResource maxAllowed \u003d new IntegralResource(maxAvgRes);\n+    maxAllowed.multiplyBy(validWindow / step);\n+\n+    // check that the resources offered to the user during any window of length\n+    // \"validWindow\" overlapping this allocation are within maxAllowed\n+    // also enforce instantaneous and physical constraints during this pass\n+    for (long t \u003d startTime - validWindow; t \u003c endTime + validWindow; t +\u003d step) {\n+\n+      Resource currExistingAllocTot \u003d plan.getTotalCommittedResources(t);\n+      Resource currExistingAllocForUser \u003d\n+          plan.getConsumptionForUser(reservation.getUser(), t);\n+      Resource currNewAlloc \u003d reservation.getResourcesAtTime(t);\n+      Resource currOldAlloc \u003d Resources.none();\n+      if (oldReservation !\u003d null) {\n+        currOldAlloc \u003d oldReservation.getResourcesAtTime(t);\n+      }\n+\n+      // throw exception if the cluster is overcommitted\n+      // tot_allocated - old + new \u003e capacity\n+      Resource inst \u003d\n+          Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),\n+              currOldAlloc);\n+      if (Resources.greaterThan(plan.getResourceCalculator(),\n+          planTotalCapacity, inst, planTotalCapacity)) {\n+        throw new ResourceOverCommitException(\" Resources at time \" + t\n+            + \" would be overcommitted (\" + inst + \" over \"\n+            + plan.getTotalCapacity() + \") by accepting reservation: \"\n+            + reservation.getReservationId());\n+      }\n+\n+      // throw exception if instantaneous limits are violated\n+      // tot_alloc_to_this_user - old + new \u003e inst_limit\n+      if (Resources.greaterThan(plan.getResourceCalculator(),\n+          planTotalCapacity, Resources.subtract(\n+              Resources.add(currExistingAllocForUser, currNewAlloc),\n+              currOldAlloc), maxInsRes)) {\n+        throw new PlanningQuotaException(\"Instantaneous quota capacity \"\n+            + maxInst + \" would be passed at time \" + t\n+            + \" by accepting reservation: \" + reservation.getReservationId());\n+      }\n+\n+      // throw exception if the running integral of utilization over validWindow\n+      // is violated. We perform a delta check, adding/removing instants at the\n+      // boundary of the window from runningTot.\n+\n+      // runningTot \u003d previous_runningTot + currExistingAllocForUser +\n+      // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;\n+\n+      // Where:\n+      // 1) currNewAlloc, currExistingAllocForUser represent the contribution of\n+      // the instant in time added in this pass.\n+      // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time\n+      // instants that are being retired from the the window\n+      // 3) currOldAlloc is the contribution (if any) of the previous version of\n+      // this reservation (the one we are updating)\n+\n+      runningTot.add(currExistingAllocForUser);\n+      runningTot.add(currNewAlloc);\n+      runningTot.subtract(currOldAlloc);\n+\n+      // expire contributions from instant in time before (t - validWindow)\n+      if (t \u003e startTime) {\n+        Resource pastOldAlloc \u003d\n+            plan.getConsumptionForUser(reservation.getUser(), t - validWindow);\n+        Resource pastNewAlloc \u003d reservation.getResourcesAtTime(t - validWindow);\n+\n+        // runningTot \u003d runningTot - pastExistingAlloc - pastNewAlloc;\n+        runningTot.subtract(pastOldAlloc);\n+        runningTot.subtract(pastNewAlloc);\n+      }\n+\n+      // check integral\n+      // runningTot \u003e maxAvg * validWindow\n+      // NOTE: we need to use comparator of IntegralResource directly, as\n+      // Resource and ResourceCalculator assume \"int\" amount of resources,\n+      // which is not sufficient when comparing integrals (out-of-bound)\n+      if (maxAllowed.compareTo(runningTot) \u003c 0) {\n+        throw new PlanningQuotaException(\n+            \"Integral (avg over time) quota capacity \" + maxAvg\n+                + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n+                + \" would be passed at time \" + t + \"(\" + new Date(t)\n+                + \") by accepting reservation: \"\n+                + reservation.getReservationId());\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void validate(Plan plan, ReservationAllocation reservation)\n      throws PlanningException {\n\n    // this is entire method invoked under a write-lock on the plan, no need\n    // to synchronize accesses to the plan further\n\n    // Try to verify whether there is already a reservation with this ID in\n    // the system (remove its contribution during validation to simulate a\n    // try-n-swap\n    // update).\n    ReservationAllocation oldReservation \u003d\n        plan.getReservationById(reservation.getReservationId());\n\n    // sanity check that the update of a reservation is not changing username\n    if (oldReservation !\u003d null\n        \u0026\u0026 !oldReservation.getUser().equals(reservation.getUser())) {\n      throw new MismatchedUserException(\n          \"Updating an existing reservation with mismatched user:\"\n              + oldReservation.getUser() + \" !\u003d \" + reservation.getUser());\n    }\n\n    long startTime \u003d reservation.getStartTime();\n    long endTime \u003d reservation.getEndTime();\n    long step \u003d plan.getStep();\n\n    Resource planTotalCapacity \u003d plan.getTotalCapacity();\n\n    Resource maxAvgRes \u003d Resources.multiply(planTotalCapacity, maxAvg);\n    Resource maxInsRes \u003d Resources.multiply(planTotalCapacity, maxInst);\n\n    // define variable that will store integral of resources (need diff class to\n    // avoid overflow issues for long/large allocations)\n    IntegralResource runningTot \u003d new IntegralResource(0L, 0L);\n    IntegralResource maxAllowed \u003d new IntegralResource(maxAvgRes);\n    maxAllowed.multiplyBy(validWindow / step);\n\n    // check that the resources offered to the user during any window of length\n    // \"validWindow\" overlapping this allocation are within maxAllowed\n    // also enforce instantaneous and physical constraints during this pass\n    for (long t \u003d startTime - validWindow; t \u003c endTime + validWindow; t +\u003d step) {\n\n      Resource currExistingAllocTot \u003d plan.getTotalCommittedResources(t);\n      Resource currExistingAllocForUser \u003d\n          plan.getConsumptionForUser(reservation.getUser(), t);\n      Resource currNewAlloc \u003d reservation.getResourcesAtTime(t);\n      Resource currOldAlloc \u003d Resources.none();\n      if (oldReservation !\u003d null) {\n        currOldAlloc \u003d oldReservation.getResourcesAtTime(t);\n      }\n\n      // throw exception if the cluster is overcommitted\n      // tot_allocated - old + new \u003e capacity\n      Resource inst \u003d\n          Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),\n              currOldAlloc);\n      if (Resources.greaterThan(plan.getResourceCalculator(),\n          planTotalCapacity, inst, planTotalCapacity)) {\n        throw new ResourceOverCommitException(\" Resources at time \" + t\n            + \" would be overcommitted (\" + inst + \" over \"\n            + plan.getTotalCapacity() + \") by accepting reservation: \"\n            + reservation.getReservationId());\n      }\n\n      // throw exception if instantaneous limits are violated\n      // tot_alloc_to_this_user - old + new \u003e inst_limit\n      if (Resources.greaterThan(plan.getResourceCalculator(),\n          planTotalCapacity, Resources.subtract(\n              Resources.add(currExistingAllocForUser, currNewAlloc),\n              currOldAlloc), maxInsRes)) {\n        throw new PlanningQuotaException(\"Instantaneous quota capacity \"\n            + maxInst + \" would be passed at time \" + t\n            + \" by accepting reservation: \" + reservation.getReservationId());\n      }\n\n      // throw exception if the running integral of utilization over validWindow\n      // is violated. We perform a delta check, adding/removing instants at the\n      // boundary of the window from runningTot.\n\n      // runningTot \u003d previous_runningTot + currExistingAllocForUser +\n      // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;\n\n      // Where:\n      // 1) currNewAlloc, currExistingAllocForUser represent the contribution of\n      // the instant in time added in this pass.\n      // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time\n      // instants that are being retired from the the window\n      // 3) currOldAlloc is the contribution (if any) of the previous version of\n      // this reservation (the one we are updating)\n\n      runningTot.add(currExistingAllocForUser);\n      runningTot.add(currNewAlloc);\n      runningTot.subtract(currOldAlloc);\n\n      // expire contributions from instant in time before (t - validWindow)\n      if (t \u003e startTime) {\n        Resource pastOldAlloc \u003d\n            plan.getConsumptionForUser(reservation.getUser(), t - validWindow);\n        Resource pastNewAlloc \u003d reservation.getResourcesAtTime(t - validWindow);\n\n        // runningTot \u003d runningTot - pastExistingAlloc - pastNewAlloc;\n        runningTot.subtract(pastOldAlloc);\n        runningTot.subtract(pastNewAlloc);\n      }\n\n      // check integral\n      // runningTot \u003e maxAvg * validWindow\n      // NOTE: we need to use comparator of IntegralResource directly, as\n      // Resource and ResourceCalculator assume \"int\" amount of resources,\n      // which is not sufficient when comparing integrals (out-of-bound)\n      if (maxAllowed.compareTo(runningTot) \u003c 0) {\n        throw new PlanningQuotaException(\n            \"Integral (avg over time) quota capacity \" + maxAvg\n                + \" over a window of \" + validWindow / 1000 + \" seconds, \"\n                + \" would be passed at time \" + t + \"(\" + new Date(t)\n                + \") by accepting reservation: \"\n                + reservation.getReservationId());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacityOverTimePolicy.java"
    }
  }
}