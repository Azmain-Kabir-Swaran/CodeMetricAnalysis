{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RetryPolicies.java",
  "functionName": "shouldRetry",
  "functionId": "shouldRetry___e-Exception__retries-int__failovers-int__isIdempotentOrAtMostOnce-boolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
  "functionStartLine": 186,
  "functionEndLine": 190,
  "numCommitsSeen": 42,
  "timeTaken": 5310,
  "changeHistory": [
    "26a969ec734dbdbf1d544f486dfa33f15c291789",
    "3d249301f42130de80ab3ecf8c783bb51b0fa8a3",
    "c79a5f2d9930f58ad95864c59cd0a6164cd53280",
    "f2efaf013f7577948061abbb49c6d17c375e92cc",
    "289bc50e663b882956878eeaefe0eaa1ef4ed39e",
    "35f255b03b1bb5c94063ec1818af1d253ceee991",
    "5360da8bd9f720384860f411bee081aef13b4bd4",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
    "84ba1a75b6bcd696dfc20aeabb6f19cb4eff6011",
    "0aa09f6d5a97f523e9ee6f30bb44f206433ead0a",
    "a4bc1a62185af6e626f2e6b0292f31e957fb945e",
    "1fe1942328856dd832e9f94fb56a40ab3d810870",
    "3be4036abebb46d2f8c76b6929c201844fcbcb65",
    "5a0b74663951475f668c7c68b9902c2bb54dc861",
    "cdc8146bd46ae8bf3395498c529513730d446824",
    "116bf57bd673b55f91d8dde7a83fc43e11522ebd",
    "9818091a66b9c8e337de9d4e18655cf4b157056b",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "637cdaefc294814febb27cbef2f35026053114c7",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "26a969ec734dbdbf1d544f486dfa33f15c291789": "Ybodychange",
    "3d249301f42130de80ab3ecf8c783bb51b0fa8a3": "Ybodychange",
    "c79a5f2d9930f58ad95864c59cd0a6164cd53280": "Ybodychange",
    "f2efaf013f7577948061abbb49c6d17c375e92cc": "Ybodychange",
    "289bc50e663b882956878eeaefe0eaa1ef4ed39e": "Ybodychange",
    "35f255b03b1bb5c94063ec1818af1d253ceee991": "Ybodychange",
    "5360da8bd9f720384860f411bee081aef13b4bd4": "Ybodychange",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": "Ybodychange",
    "84ba1a75b6bcd696dfc20aeabb6f19cb4eff6011": "Ybodychange",
    "0aa09f6d5a97f523e9ee6f30bb44f206433ead0a": "Ybodychange",
    "a4bc1a62185af6e626f2e6b0292f31e957fb945e": "Ybodychange",
    "1fe1942328856dd832e9f94fb56a40ab3d810870": "Ybodychange",
    "3be4036abebb46d2f8c76b6929c201844fcbcb65": "Ymultichange(Yparameterchange,Ybodychange)",
    "5a0b74663951475f668c7c68b9902c2bb54dc861": "Ybodychange",
    "cdc8146bd46ae8bf3395498c529513730d446824": "Ybodychange",
    "116bf57bd673b55f91d8dde7a83fc43e11522ebd": "Ybodychange",
    "9818091a66b9c8e337de9d4e18655cf4b157056b": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "637cdaefc294814febb27cbef2f35026053114c7": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "26a969ec734dbdbf1d544f486dfa33f15c291789": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15099. [SBN Read] checkOperation(WRITE) should throw ObserverRetryOnActiveException for ObserverNode. Contributed by Chen Liang.",
      "commitDate": "10/01/20 5:06 PM",
      "commitName": "26a969ec734dbdbf1d544f486dfa33f15c291789",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "09/11/19 6:43 AM",
      "commitNameOld": "3d249301f42130de80ab3ecf8c783bb51b0fa8a3",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 62.43,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n \n       if (isSaslFailure(e)) {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n                   \"SASL failure\");\n       }\n \n       if (e instanceof ConnectException ||\n           e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n-          isWrappedStandbyException(e)) {\n+          shouldFailoverOnException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n       } else if (e instanceof AccessControlException ||\n               hasWrappedAccessControlException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Access denied\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n               getFailoverOrRetrySleepTime(retries));\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n\n      if (isSaslFailure(e)) {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n                  \"SASL failure\");\n      }\n\n      if (e instanceof ConnectException ||\n          e instanceof EOFException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          shouldFailoverOnException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof AccessControlException ||\n              hasWrappedAccessControlException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Access denied\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n              getFailoverOrRetrySleepTime(retries));\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "3d249301f42130de80ab3ecf8c783bb51b0fa8a3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16683. Disable retry of FailoverOnNetworkExceptionRetry in case of wrapped AccessControlException. Contributed by Adam Antal\n",
      "commitDate": "09/11/19 6:43 AM",
      "commitName": "3d249301f42130de80ab3ecf8c783bb51b0fa8a3",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "16/10/19 4:29 AM",
      "commitNameOld": "c79a5f2d9930f58ad95864c59cd0a6164cd53280",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 24.14,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n \n       if (isSaslFailure(e)) {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n                   \"SASL failure\");\n       }\n \n       if (e instanceof ConnectException ||\n           e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n-      } else if (e instanceof AccessControlException) {\n+      } else if (e instanceof AccessControlException ||\n+              hasWrappedAccessControlException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Access denied\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n               getFailoverOrRetrySleepTime(retries));\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n\n      if (isSaslFailure(e)) {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n                  \"SASL failure\");\n      }\n\n      if (e instanceof ConnectException ||\n          e instanceof EOFException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof AccessControlException ||\n              hasWrappedAccessControlException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Access denied\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n              getFailoverOrRetrySleepTime(retries));\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "c79a5f2d9930f58ad95864c59cd0a6164cd53280": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16580. Disable retry of FailoverOnNetworkExceptionRetry in case of AccessControlException. Contributed by Adam Antal\n",
      "commitDate": "16/10/19 4:29 AM",
      "commitName": "c79a5f2d9930f58ad95864c59cd0a6164cd53280",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "16/11/17 11:11 AM",
      "commitNameOld": "f2efaf013f7577948061abbb49c6d17c375e92cc",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 698.68,
      "commitsBetweenForRepo": 5777,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,52 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n \n       if (isSaslFailure(e)) {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n                   \"SASL failure\");\n       }\n \n       if (e instanceof ConnectException ||\n           e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n+      } else if (e instanceof AccessControlException) {\n+        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n+            \"Access denied\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n               getFailoverOrRetrySleepTime(retries));\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n\n      if (isSaslFailure(e)) {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n                  \"SASL failure\");\n      }\n\n      if (e instanceof ConnectException ||\n          e instanceof EOFException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof AccessControlException) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Access denied\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n              getFailoverOrRetrySleepTime(retries));\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "f2efaf013f7577948061abbb49c6d17c375e92cc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14982. Clients using FailoverOnNetworkExceptionRetry can go into a loop if they\u0027re used without authenticating with kerberos in HA env (pbacsko via rkanter)\n",
      "commitDate": "16/11/17 11:11 AM",
      "commitName": "f2efaf013f7577948061abbb49c6d17c375e92cc",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 121.61,
      "commitsBetweenForRepo": 1079,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,49 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n \n+      if (isSaslFailure(e)) {\n+          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n+                  \"SASL failure\");\n+      }\n+\n       if (e instanceof ConnectException ||\n           e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n               getFailoverOrRetrySleepTime(retries));\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n\n      if (isSaslFailure(e)) {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n                  \"SASL failure\");\n      }\n\n      if (e instanceof ConnectException ||\n          e instanceof EOFException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n              getFailoverOrRetrySleepTime(retries));\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "289bc50e663b882956878eeaefe0eaa1ef4ed39e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14116:FailoverOnNetworkExceptionRetry does not wait when failover\non certain exception. Contributed by Jian He\n",
      "commitDate": "24/02/17 11:42 AM",
      "commitName": "289bc50e663b882956878eeaefe0eaa1ef4ed39e",
      "commitAuthor": "Xuan",
      "commitDateOld": "13/09/16 11:12 AM",
      "commitNameOld": "08d8e0ba259f01465a83d8db09466dfd46b7ec81",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 164.06,
      "commitsBetweenForRepo": 1032,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n \n       if (e instanceof ConnectException ||\n           e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n-          return RetryAction.FAILOVER_AND_RETRY;\n+          return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+              getFailoverOrRetrySleepTime(retries));\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n\n      if (e instanceof ConnectException ||\n          e instanceof EOFException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n              getFailoverOrRetrySleepTime(retries));\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "35f255b03b1bb5c94063ec1818af1d253ceee991": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HADOOP-13226 Support async call retry and failover.\"\"\n\nThis reverts commit 5360da8bd9f720384860f411bee081aef13b4bd4.\n",
      "commitDate": "06/06/16 1:31 AM",
      "commitName": "35f255b03b1bb5c94063ec1818af1d253ceee991",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "03/06/16 6:09 PM",
      "commitNameOld": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.31,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n-      \n+\n       if (e instanceof ConnectException ||\n+          e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n\n      if (e instanceof ConnectException ||\n          e instanceof EOFException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "5360da8bd9f720384860f411bee081aef13b4bd4": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13226 Support async call retry and failover.\"\n\nThis reverts commit 83f2f78c118a7e52aba5104bd97b0acedc96be7b.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "31/05/16 4:30 PM",
      "commitNameOld": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 3.07,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,42 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n-\n+      \n       if (e instanceof ConnectException ||\n-          e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13226 Support async call retry and failover.\n",
      "commitDate": "31/05/16 4:30 PM",
      "commitName": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "29/02/16 4:24 PM",
      "commitNameOld": "d8f390d015510950ccf78174af8891cd613d4438",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 91.96,
      "commitsBetweenForRepo": 568,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n-      \n+\n       if (e instanceof ConnectException ||\n+          e instanceof EOFException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof InvalidToken) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"Invalid or Cancelled Token\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n\n      if (e instanceof ConnectException ||\n          e instanceof EOFException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "84ba1a75b6bcd696dfc20aeabb6f19cb4eff6011": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12054. RPC client should not retry for InvalidToken exceptions. (Contributed by Varun Saxena)\n",
      "commitDate": "08/06/15 3:45 PM",
      "commitName": "84ba1a75b6bcd696dfc20aeabb6f19cb4eff6011",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "19/05/15 10:50 AM",
      "commitNameOld": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 20.2,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,42 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       if (retries - failovers \u003e maxRetries) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n             + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n+      } else if (e instanceof InvalidToken) {\n+        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n+            \"Invalid or Cancelled Token\");\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof InvalidToken) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"Invalid or Cancelled Token\");\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "0aa09f6d5a97f523e9ee6f30bb44f206433ead0a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5399. Revisit SafeModeException and corresponding retry policies. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564629 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/02/14 8:18 PM",
      "commitName": "0aa09f6d5a97f523e9ee6f30bb44f206433ead0a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "21/12/13 8:29 AM",
      "commitNameOld": "624703ed7b6d80855d3e0567bee5c1b7659bc635",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 45.49,
      "commitsBetweenForRepo": 220,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,39 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n+      if (retries - failovers \u003e maxRetries) {\n+        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n+            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n+      }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof RetriableException\n           || getWrappedRetriableException(e) !\u003d null) {\n         // RetriableException or RetriableException wrapped \n         return new RetryAction(RetryAction.RetryDecision.RETRY,\n               getFailoverOrRetrySleepTime(retries));\n       } else if (e instanceof SocketException\n           || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \"\n                   + \"whether it was invoked\");\n         }\n       } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      if (retries - failovers \u003e maxRetries) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0, \"retries (\"\n            + retries + \") exceeded maximum allowed (\" + maxRetries + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "a4bc1a62185af6e626f2e6b0292f31e957fb945e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5371. Let client retry the same NN when dfs.client.test.drop.namenode.response.number is enabled. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1540197 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/11/13 1:39 PM",
      "commitName": "a4bc1a62185af6e626f2e6b0292f31e957fb945e",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/10/13 4:58 PM",
      "commitNameOld": "1fe1942328856dd832e9f94fb56a40ab3d810870",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 31.9,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,35 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             getFailoverOrRetrySleepTime(failovers));\n-      } else if (e instanceof SocketException ||\n-                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n+      } else if (e instanceof RetriableException\n+          || getWrappedRetriableException(e) !\u003d null) {\n+        // RetriableException or RetriableException wrapped \n+        return new RetryAction(RetryAction.RetryDecision.RETRY,\n+              getFailoverOrRetrySleepTime(retries));\n+      } else if (e instanceof SocketException\n+          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n-              \"the invoked method is not idempotent, and unable to determine \" +\n-              \"whether it was invoked\");\n+              \"the invoked method is not idempotent, and unable to determine \"\n+                  + \"whether it was invoked\");\n         }\n       } else {\n-        RetriableException re \u003d getWrappedRetriableException(e);\n-        if (re !\u003d null) {\n-          return new RetryAction(RetryAction.RetryDecision.RETRY,\n-              getFailoverOrRetrySleepTime(retries));\n-        } else {\n           return fallbackPolicy.shouldRetry(e, retries, failovers,\n               isIdempotentOrAtMostOnce);\n-        }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof RetriableException\n          || getWrappedRetriableException(e) !\u003d null) {\n        // RetriableException or RetriableException wrapped \n        return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n      } else if (e instanceof SocketException\n          || (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \"\n                  + \"whether it was invoked\");\n        }\n      } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "1fe1942328856dd832e9f94fb56a40ab3d810870": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5291. Standby namenode after transition to active goes into safemode. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530112 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/10/13 4:58 PM",
      "commitName": "1fe1942328856dd832e9f94fb56a40ab3d810870",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "29/07/13 11:19 PM",
      "commitNameOld": "3be4036abebb46d2f8c76b6929c201844fcbcb65",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 69.74,
      "commitsBetweenForRepo": 419,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,36 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n-        return new RetryAction(\n-            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n-            // retry immediately if this is our first failover, sleep otherwise\n-            failovers \u003d\u003d 0 ? 0 :\n-                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n+        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+            getFailoverOrRetrySleepTime(failovers));\n       } else if (e instanceof SocketException ||\n                  (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \" +\n               \"whether it was invoked\");\n         }\n       } else {\n-        return fallbackPolicy.shouldRetry(e, retries, failovers,\n-            isIdempotentOrAtMostOnce);\n+        RetriableException re \u003d getWrappedRetriableException(e);\n+        if (re !\u003d null) {\n+          return new RetryAction(RetryAction.RetryDecision.RETRY,\n+              getFailoverOrRetrySleepTime(retries));\n+        } else {\n+          return fallbackPolicy.shouldRetry(e, retries, failovers,\n+              isIdempotentOrAtMostOnce);\n+        }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            getFailoverOrRetrySleepTime(failovers));\n      } else if (e instanceof SocketException ||\n                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \" +\n              \"whether it was invoked\");\n        }\n      } else {\n        RetriableException re \u003d getWrappedRetriableException(e);\n        if (re !\u003d null) {\n          return new RetryAction(RetryAction.RetryDecision.RETRY,\n              getFailoverOrRetrySleepTime(retries));\n        } else {\n          return fallbackPolicy.shouldRetry(e, retries, failovers,\n              isIdempotentOrAtMostOnce);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "3be4036abebb46d2f8c76b6929c201844fcbcb65": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-9792. Retry the methods that are tagged @AtMostOnce along with @Idempotent. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508312 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 11:19 PM",
      "commitName": "3be4036abebb46d2f8c76b6929c201844fcbcb65",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-9792. Retry the methods that are tagged @AtMostOnce along with @Idempotent. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508312 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/13 11:19 PM",
          "commitName": "3be4036abebb46d2f8c76b6929c201844fcbcb65",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "04/02/13 7:18 PM",
          "commitNameOld": "5a0b74663951475f668c7c68b9902c2bb54dc861",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 175.13,
          "commitsBetweenForRepo": 1041,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,33 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n-        int failovers, boolean isMethodIdempotent) throws Exception {\n+        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(\n             RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             // retry immediately if this is our first failover, sleep otherwise\n             failovers \u003d\u003d 0 ? 0 :\n                 calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n       } else if (e instanceof SocketException ||\n                  (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n-        if (isMethodIdempotent) {\n+        if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \" +\n               \"whether it was invoked\");\n         }\n       } else {\n         return fallbackPolicy.shouldRetry(e, retries, failovers,\n-            isMethodIdempotent);\n+            isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(\n            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            // retry immediately if this is our first failover, sleep otherwise\n            failovers \u003d\u003d 0 ? 0 :\n                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n      } else if (e instanceof SocketException ||\n                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \" +\n              \"whether it was invoked\");\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isIdempotentOrAtMostOnce);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
          "extendedDetails": {
            "oldValue": "[e-Exception, retries-int, failovers-int, isMethodIdempotent-boolean]",
            "newValue": "[e-Exception, retries-int, failovers-int, isIdempotentOrAtMostOnce-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9792. Retry the methods that are tagged @AtMostOnce along with @Idempotent. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508312 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/13 11:19 PM",
          "commitName": "3be4036abebb46d2f8c76b6929c201844fcbcb65",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "04/02/13 7:18 PM",
          "commitNameOld": "5a0b74663951475f668c7c68b9902c2bb54dc861",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 175.13,
          "commitsBetweenForRepo": 1041,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,33 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n-        int failovers, boolean isMethodIdempotent) throws Exception {\n+        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(\n             RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             // retry immediately if this is our first failover, sleep otherwise\n             failovers \u003d\u003d 0 ? 0 :\n                 calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n       } else if (e instanceof SocketException ||\n                  (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n-        if (isMethodIdempotent) {\n+        if (isIdempotentOrAtMostOnce) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \" +\n               \"whether it was invoked\");\n         }\n       } else {\n         return fallbackPolicy.shouldRetry(e, retries, failovers,\n-            isMethodIdempotent);\n+            isIdempotentOrAtMostOnce);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isIdempotentOrAtMostOnce) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(\n            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            // retry immediately if this is our first failover, sleep otherwise\n            failovers \u003d\u003d 0 ? 0 :\n                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n      } else if (e instanceof SocketException ||\n                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isIdempotentOrAtMostOnce) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \" +\n              \"whether it was invoked\");\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isIdempotentOrAtMostOnce);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
          "extendedDetails": {}
        }
      ]
    },
    "5a0b74663951475f668c7c68b9902c2bb54dc861": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4404. Create file failure when the machine of first attempted NameNode is down. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1442461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/02/13 7:18 PM",
      "commitName": "5a0b74663951475f668c7c68b9902c2bb54dc861",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 164.09,
      "commitsBetweenForRepo": 832,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isMethodIdempotent) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n             \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n+          e instanceof ConnectTimeoutException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(\n             RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             // retry immediately if this is our first failover, sleep otherwise\n             failovers \u003d\u003d 0 ? 0 :\n                 calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n       } else if (e instanceof SocketException ||\n                  (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isMethodIdempotent) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n               \"the invoked method is not idempotent, and unable to determine \" +\n               \"whether it was invoked\");\n         }\n       } else {\n         return fallbackPolicy.shouldRetry(e, retries, failovers,\n             isMethodIdempotent);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          e instanceof ConnectTimeoutException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(\n            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            // retry immediately if this is our first failover, sleep otherwise\n            failovers \u003d\u003d 0 ? 0 :\n                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n      } else if (e instanceof SocketException ||\n                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \" +\n              \"whether it was invoked\");\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "cdc8146bd46ae8bf3395498c529513730d446824": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8068. void methods can swallow exceptions when going through failover path. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1244628 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/02/12 10:20 AM",
      "commitName": "cdc8146bd46ae8bf3395498c529513730d446824",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "15/12/11 5:54 PM",
      "commitNameOld": "116bf57bd673b55f91d8dde7a83fc43e11522ebd",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 61.68,
      "commitsBetweenForRepo": 415,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,32 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isMethodIdempotent) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n-        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n+        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n+            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n-        return RetryAction.FAIL;\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(\n             RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             // retry immediately if this is our first failover, sleep otherwise\n             failovers \u003d\u003d 0 ? 0 :\n                 calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n       } else if (e instanceof SocketException ||\n                  (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isMethodIdempotent) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n-          return RetryAction.FAIL;\n+          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n+              \"the invoked method is not idempotent, and unable to determine \" +\n+              \"whether it was invoked\");\n         }\n       } else {\n         return fallbackPolicy.shouldRetry(e, retries, failovers,\n             isMethodIdempotent);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n            \"failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(\n            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            // retry immediately if this is our first failover, sleep otherwise\n            failovers \u003d\u003d 0 ? 0 :\n                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n      } else if (e instanceof SocketException ||\n                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return new RetryAction(RetryAction.RetryDecision.FAIL, 0,\n              \"the invoked method is not idempotent, and unable to determine \" +\n              \"whether it was invoked\");\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "116bf57bd673b55f91d8dde7a83fc43e11522ebd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7928. HA: Client failover policy is incorrectly trying to fail over all IOExceptions. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1215019 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/12/11 5:54 PM",
      "commitName": "116bf57bd673b55f91d8dde7a83fc43e11522ebd",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "13/12/11 11:24 PM",
      "commitNameOld": "9818091a66b9c8e337de9d4e18655cf4b157056b",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 1.77,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isMethodIdempotent) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n         return RetryAction.FAIL;\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n           e instanceof StandbyException ||\n           isWrappedStandbyException(e)) {\n         return new RetryAction(\n             RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n             // retry immediately if this is our first failover, sleep otherwise\n             failovers \u003d\u003d 0 ? 0 :\n                 calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n       } else if (e instanceof SocketException ||\n-                 e instanceof IOException) {\n+                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n         if (isMethodIdempotent) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return RetryAction.FAIL;\n         }\n       } else {\n         return fallbackPolicy.shouldRetry(e, retries, failovers,\n             isMethodIdempotent);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n        return RetryAction.FAIL;\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(\n            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            // retry immediately if this is our first failover, sleep otherwise\n            failovers \u003d\u003d 0 ? 0 :\n                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n      } else if (e instanceof SocketException ||\n                 (e instanceof IOException \u0026\u0026 !(e instanceof RemoteException))) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return RetryAction.FAIL;\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "9818091a66b9c8e337de9d4e18655cf4b157056b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7896. HA: if both NNs are in Standby mode, client needs to try failing back and forth several times with sleeps. Contributed by Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1214076 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 11:24 PM",
      "commitName": "9818091a66b9c8e337de9d4e18655cf4b157056b",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 111.3,
      "commitsBetweenForRepo": 780,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,30 @@\n     public RetryAction shouldRetry(Exception e, int retries,\n         int failovers, boolean isMethodIdempotent) throws Exception {\n       if (failovers \u003e\u003d maxFailovers) {\n         LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n             + maxFailovers + \")\");\n         return RetryAction.FAIL;\n       }\n       \n       if (e instanceof ConnectException ||\n           e instanceof NoRouteToHostException ||\n           e instanceof UnknownHostException ||\n-          e instanceof StandbyException) {\n-        return RetryAction.FAILOVER_AND_RETRY;\n+          e instanceof StandbyException ||\n+          isWrappedStandbyException(e)) {\n+        return new RetryAction(\n+            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+            // retry immediately if this is our first failover, sleep otherwise\n+            failovers \u003d\u003d 0 ? 0 :\n+                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n       } else if (e instanceof SocketException ||\n                  e instanceof IOException) {\n         if (isMethodIdempotent) {\n           return RetryAction.FAILOVER_AND_RETRY;\n         } else {\n           return RetryAction.FAIL;\n         }\n       } else {\n         return fallbackPolicy.shouldRetry(e, retries, failovers,\n             isMethodIdempotent);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n        return RetryAction.FAIL;\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException ||\n          isWrappedStandbyException(e)) {\n        return new RetryAction(\n            RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n            // retry immediately if this is our first failover, sleep otherwise\n            failovers \u003d\u003d 0 ? 0 :\n                calculateExponentialTime(delayMillis, failovers, maxDelayBase));\n      } else if (e instanceof SocketException ||\n                 e instanceof IOException) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return RetryAction.FAIL;\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n        return RetryAction.FAIL;\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException) {\n        return RetryAction.FAILOVER_AND_RETRY;\n      } else if (e instanceof SocketException ||\n                 e instanceof IOException) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return RetryAction.FAIL;\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n        return RetryAction.FAIL;\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException) {\n        return RetryAction.FAILOVER_AND_RETRY;\n      } else if (e instanceof SocketException ||\n                 e instanceof IOException) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return RetryAction.FAIL;\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/io/retry/RetryPolicies.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryPolicies.java"
      }
    },
    "637cdaefc294814febb27cbef2f35026053114c7": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-7380. Add client failover functionality to o.a.h.io.(ipc|retry). Contributed by Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1144043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/11 2:16 PM",
      "commitName": "637cdaefc294814febb27cbef2f35026053114c7",
      "commitAuthor": "Eli Collins",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-7380. Add client failover functionality to o.a.h.io.(ipc|retry). Contributed by Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1144043 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/07/11 2:16 PM",
          "commitName": "637cdaefc294814febb27cbef2f35026053114c7",
          "commitAuthor": "Eli Collins",
          "commitDateOld": "12/06/11 3:00 PM",
          "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 24.97,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,11 +1,25 @@\n-    public boolean shouldRetry(Exception e, int retries) throws Exception {\n-      RetryPolicy policy \u003d null;\n-      if (e instanceof RemoteException) {\n-        policy \u003d exceptionNameToPolicyMap.get(\n-            ((RemoteException) e).getClassName());\n+    public RetryAction shouldRetry(Exception e, int retries,\n+        int failovers, boolean isMethodIdempotent) throws Exception {\n+      if (failovers \u003e\u003d maxFailovers) {\n+        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n+            + maxFailovers + \")\");\n+        return RetryAction.FAIL;\n       }\n-      if (policy \u003d\u003d null) {\n-        policy \u003d defaultPolicy;\n+      \n+      if (e instanceof ConnectException ||\n+          e instanceof NoRouteToHostException ||\n+          e instanceof UnknownHostException ||\n+          e instanceof StandbyException) {\n+        return RetryAction.FAILOVER_AND_RETRY;\n+      } else if (e instanceof SocketException ||\n+                 e instanceof IOException) {\n+        if (isMethodIdempotent) {\n+          return RetryAction.FAILOVER_AND_RETRY;\n+        } else {\n+          return RetryAction.FAIL;\n+        }\n+      } else {\n+        return fallbackPolicy.shouldRetry(e, retries, failovers,\n+            isMethodIdempotent);\n       }\n-      return policy.shouldRetry(e, retries);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n        return RetryAction.FAIL;\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException) {\n        return RetryAction.FAILOVER_AND_RETRY;\n      } else if (e instanceof SocketException ||\n                 e instanceof IOException) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return RetryAction.FAIL;\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
          "path": "common/src/java/org/apache/hadoop/io/retry/RetryPolicies.java",
          "extendedDetails": {
            "oldValue": "[e-Exception, retries-int]",
            "newValue": "[e-Exception, retries-int, failovers-int, isMethodIdempotent-boolean]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-7380. Add client failover functionality to o.a.h.io.(ipc|retry). Contributed by Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1144043 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/07/11 2:16 PM",
          "commitName": "637cdaefc294814febb27cbef2f35026053114c7",
          "commitAuthor": "Eli Collins",
          "commitDateOld": "12/06/11 3:00 PM",
          "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 24.97,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,11 +1,25 @@\n-    public boolean shouldRetry(Exception e, int retries) throws Exception {\n-      RetryPolicy policy \u003d null;\n-      if (e instanceof RemoteException) {\n-        policy \u003d exceptionNameToPolicyMap.get(\n-            ((RemoteException) e).getClassName());\n+    public RetryAction shouldRetry(Exception e, int retries,\n+        int failovers, boolean isMethodIdempotent) throws Exception {\n+      if (failovers \u003e\u003d maxFailovers) {\n+        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n+            + maxFailovers + \")\");\n+        return RetryAction.FAIL;\n       }\n-      if (policy \u003d\u003d null) {\n-        policy \u003d defaultPolicy;\n+      \n+      if (e instanceof ConnectException ||\n+          e instanceof NoRouteToHostException ||\n+          e instanceof UnknownHostException ||\n+          e instanceof StandbyException) {\n+        return RetryAction.FAILOVER_AND_RETRY;\n+      } else if (e instanceof SocketException ||\n+                 e instanceof IOException) {\n+        if (isMethodIdempotent) {\n+          return RetryAction.FAILOVER_AND_RETRY;\n+        } else {\n+          return RetryAction.FAIL;\n+        }\n+      } else {\n+        return fallbackPolicy.shouldRetry(e, retries, failovers,\n+            isMethodIdempotent);\n       }\n-      return policy.shouldRetry(e, retries);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n        return RetryAction.FAIL;\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException) {\n        return RetryAction.FAILOVER_AND_RETRY;\n      } else if (e instanceof SocketException ||\n                 e instanceof IOException) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return RetryAction.FAIL;\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
          "path": "common/src/java/org/apache/hadoop/io/retry/RetryPolicies.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "RetryAction"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-7380. Add client failover functionality to o.a.h.io.(ipc|retry). Contributed by Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1144043 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/07/11 2:16 PM",
          "commitName": "637cdaefc294814febb27cbef2f35026053114c7",
          "commitAuthor": "Eli Collins",
          "commitDateOld": "12/06/11 3:00 PM",
          "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 24.97,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,11 +1,25 @@\n-    public boolean shouldRetry(Exception e, int retries) throws Exception {\n-      RetryPolicy policy \u003d null;\n-      if (e instanceof RemoteException) {\n-        policy \u003d exceptionNameToPolicyMap.get(\n-            ((RemoteException) e).getClassName());\n+    public RetryAction shouldRetry(Exception e, int retries,\n+        int failovers, boolean isMethodIdempotent) throws Exception {\n+      if (failovers \u003e\u003d maxFailovers) {\n+        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n+            + maxFailovers + \")\");\n+        return RetryAction.FAIL;\n       }\n-      if (policy \u003d\u003d null) {\n-        policy \u003d defaultPolicy;\n+      \n+      if (e instanceof ConnectException ||\n+          e instanceof NoRouteToHostException ||\n+          e instanceof UnknownHostException ||\n+          e instanceof StandbyException) {\n+        return RetryAction.FAILOVER_AND_RETRY;\n+      } else if (e instanceof SocketException ||\n+                 e instanceof IOException) {\n+        if (isMethodIdempotent) {\n+          return RetryAction.FAILOVER_AND_RETRY;\n+        } else {\n+          return RetryAction.FAIL;\n+        }\n+      } else {\n+        return fallbackPolicy.shouldRetry(e, retries, failovers,\n+            isMethodIdempotent);\n       }\n-      return policy.shouldRetry(e, retries);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public RetryAction shouldRetry(Exception e, int retries,\n        int failovers, boolean isMethodIdempotent) throws Exception {\n      if (failovers \u003e\u003d maxFailovers) {\n        LOG.info(\"Failovers (\" + failovers + \") exceeded maximum allowed (\"\n            + maxFailovers + \")\");\n        return RetryAction.FAIL;\n      }\n      \n      if (e instanceof ConnectException ||\n          e instanceof NoRouteToHostException ||\n          e instanceof UnknownHostException ||\n          e instanceof StandbyException) {\n        return RetryAction.FAILOVER_AND_RETRY;\n      } else if (e instanceof SocketException ||\n                 e instanceof IOException) {\n        if (isMethodIdempotent) {\n          return RetryAction.FAILOVER_AND_RETRY;\n        } else {\n          return RetryAction.FAIL;\n        }\n      } else {\n        return fallbackPolicy.shouldRetry(e, retries, failovers,\n            isMethodIdempotent);\n      }\n    }",
          "path": "common/src/java/org/apache/hadoop/io/retry/RetryPolicies.java",
          "extendedDetails": {}
        }
      ]
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public boolean shouldRetry(Exception e, int retries) throws Exception {\n      RetryPolicy policy \u003d null;\n      if (e instanceof RemoteException) {\n        policy \u003d exceptionNameToPolicyMap.get(\n            ((RemoteException) e).getClassName());\n      }\n      if (policy \u003d\u003d null) {\n        policy \u003d defaultPolicy;\n      }\n      return policy.shouldRetry(e, retries);\n    }",
      "path": "common/src/java/org/apache/hadoop/io/retry/RetryPolicies.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/io/retry/RetryPolicies.java",
        "newPath": "common/src/java/org/apache/hadoop/io/retry/RetryPolicies.java"
      }
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,11 @@\n+    public boolean shouldRetry(Exception e, int retries) throws Exception {\n+      RetryPolicy policy \u003d null;\n+      if (e instanceof RemoteException) {\n+        policy \u003d exceptionNameToPolicyMap.get(\n+            ((RemoteException) e).getClassName());\n+      }\n+      if (policy \u003d\u003d null) {\n+        policy \u003d defaultPolicy;\n+      }\n+      return policy.shouldRetry(e, retries);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public boolean shouldRetry(Exception e, int retries) throws Exception {\n      RetryPolicy policy \u003d null;\n      if (e instanceof RemoteException) {\n        policy \u003d exceptionNameToPolicyMap.get(\n            ((RemoteException) e).getClassName());\n      }\n      if (policy \u003d\u003d null) {\n        policy \u003d defaultPolicy;\n      }\n      return policy.shouldRetry(e, retries);\n    }",
      "path": "src/java/org/apache/hadoop/io/retry/RetryPolicies.java"
    }
  }
}