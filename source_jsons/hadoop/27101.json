{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "WebAppProxyServlet.java",
  "functionName": "doGet",
  "functionId": "doGet___req-HttpServletRequest__resp-HttpServletResponse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
  "functionStartLine": 349,
  "functionEndLine": 352,
  "numCommitsSeen": 36,
  "timeTaken": 3146,
  "changeHistory": [
    "d18f10ad1b3e497fa1aaaeb85ba055f87d9849f7",
    "a583a40693f5c56c40b39fd12cfa0bb7174fc526",
    "1a68fc43464d3948418f453bb2f80df7ce773097",
    "83be450acc7fc9bb9f7bbd006e7b0804bf10279c",
    "1c49cfbeb7df7ad5466578bd470819bcedc612cf",
    "990cffdcfa9349fff0cee144b1d0e5267c40f63d",
    "13420d01f2fb28a0e445dc87ad9ee9b607804d53",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "92b7165a71656468f17ce8b760ce11e648932f0e",
    "320f7bdcb878d1dbf88edf660e9949f9897fa807",
    "64e4fb983e022d8d3375a3e1b8facbf95f7ba403",
    "4b9f0443cb0e35747e0c4ec5f416175b42164a60",
    "5a408bdeac0c40cef39c9c0eb1630698f7b77c19",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7b387f55c3f30c32e3fe672268d6d4ae6c120f70",
    "d41cb76b56e19f6eb411b3dacaf28a490d079c68",
    "defa1c5babdcb40eb2b868ee2564826a8fb68f3b",
    "8aabd3d4e67cad8dc7e46f5339981135badc7421"
  ],
  "changeHistoryShort": {
    "d18f10ad1b3e497fa1aaaeb85ba055f87d9849f7": "Ymultichange(Yexceptionschange,Ybodychange)",
    "a583a40693f5c56c40b39fd12cfa0bb7174fc526": "Ybodychange",
    "1a68fc43464d3948418f453bb2f80df7ce773097": "Ybodychange",
    "83be450acc7fc9bb9f7bbd006e7b0804bf10279c": "Ybodychange",
    "1c49cfbeb7df7ad5466578bd470819bcedc612cf": "Ybodychange",
    "990cffdcfa9349fff0cee144b1d0e5267c40f63d": "Ybodychange",
    "13420d01f2fb28a0e445dc87ad9ee9b607804d53": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "92b7165a71656468f17ce8b760ce11e648932f0e": "Ybodychange",
    "320f7bdcb878d1dbf88edf660e9949f9897fa807": "Ybodychange",
    "64e4fb983e022d8d3375a3e1b8facbf95f7ba403": "Ybodychange",
    "4b9f0443cb0e35747e0c4ec5f416175b42164a60": "Ybodychange",
    "5a408bdeac0c40cef39c9c0eb1630698f7b77c19": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7b387f55c3f30c32e3fe672268d6d4ae6c120f70": "Ybodychange",
    "d41cb76b56e19f6eb411b3dacaf28a490d079c68": "Ybodychange",
    "defa1c5babdcb40eb2b868ee2564826a8fb68f3b": "Ybodychange",
    "8aabd3d4e67cad8dc7e46f5339981135badc7421": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d18f10ad1b3e497fa1aaaeb85ba055f87d9849f7": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "MAPREDUCE-6284. Add Task Attempt State API to MapReduce Application Master REST API. Contributed by Ryu Kobayashi.\n",
      "commitDate": "07/05/15 11:59 PM",
      "commitName": "d18f10ad1b3e497fa1aaaeb85ba055f87d9849f7",
      "commitAuthor": "Tsuyoshi Ozawa",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "MAPREDUCE-6284. Add Task Attempt State API to MapReduce Application Master REST API. Contributed by Ryu Kobayashi.\n",
          "commitDate": "07/05/15 11:59 PM",
          "commitName": "d18f10ad1b3e497fa1aaaeb85ba055f87d9849f7",
          "commitAuthor": "Tsuyoshi Ozawa",
          "commitDateOld": "05/05/15 9:42 PM",
          "commitNameOld": "a583a40693f5c56c40b39fd12cfa0bb7174fc526",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 2.1,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,4 @@\n-  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n-  throws IOException{\n-    try {\n-      String userApprovedParamS \u003d \n-        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n-      boolean userWasWarned \u003d false;\n-      boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n-      boolean securityEnabled \u003d isSecurityEnabled();\n-      final String remoteUser \u003d req.getRemoteUser();\n-      final String pathInfo \u003d req.getPathInfo();\n-\n-      String[] parts \u003d null;\n-      if (pathInfo !\u003d null) {\n-        parts \u003d pathInfo.split(\"/\", 3);\n-      }\n-      if(parts \u003d\u003d null || parts.length \u003c 2) {\n-        LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n-        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n-        return;\n-      }\n-      //parts[0] is empty because path info always starts with a /\n-      String appId \u003d parts[1];\n-      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n-      ApplicationId id \u003d Apps.toAppID(appId);\n-      if(id \u003d\u003d null) {\n-        LOG.warn(\"{} attempting to access {} that is invalid\",\n-            remoteUser, appId);\n-        notFound(resp, appId + \" appears to be formatted incorrectly.\");\n-        return;\n-      }\n-      \n-      if(securityEnabled) {\n-        String cookieName \u003d getCheckCookieName(id); \n-        Cookie[] cookies \u003d req.getCookies();\n-        if (cookies !\u003d null) {\n-          for (Cookie c : cookies) {\n-            if (cookieName.equals(c.getName())) {\n-              userWasWarned \u003d true;\n-              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n-              break;\n-            }\n-          }\n-        }\n-      }\n-      \n-      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n-\n-      ApplicationReport applicationReport;\n-      try {\n-        applicationReport \u003d getApplicationReport(id);\n-      } catch (ApplicationNotFoundException e) {\n-        applicationReport \u003d null;\n-      }\n-      if(applicationReport \u003d\u003d null) {\n-        LOG.warn(\"{} attempting to access {} that was not found\",\n-            remoteUser, id);\n-\n-        URI toFetch \u003d\n-            ProxyUriUtils\n-                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n-        if (toFetch !\u003d null) {\n-          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n-          return;\n-        }\n-\n-        notFound(resp, \"Application \" + appId + \" could not be found, \" +\n-                       \"please try the history server\");\n-        return;\n-      }\n-      String original \u003d applicationReport.getOriginalTrackingUrl();\n-      URI trackingUri;\n-      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n-      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n-        ProxyUtils.sendRedirect(req, resp, \n-            StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n-        return;\n-      } else {\n-        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n-          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n-              WebAppUtils.getHttpSchemePrefix(conf), original);\n-        } else {\n-          trackingUri \u003d new URI(original);\n-        }\n-      }\n-\n-      String runningUser \u003d applicationReport.getUser();\n-      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n-        LOG.info(\"Asking {} if they want to connect to the \"\n-            + \"app master GUI of {} owned by {}\",\n-            remoteUser, appId, runningUser);\n-        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n-            req.getQueryString(), true), runningUser, id);\n-        return;\n-      }\n-\n-      // Append the user-provided path and query parameter to the original\n-      // tracking url.\n-      List\u003cNameValuePair\u003e queryPairs \u003d\n-          URLEncodedUtils.parse(req.getQueryString(), null);\n-      UriBuilder builder \u003d UriBuilder.fromUri(trackingUri);\n-      for (NameValuePair pair : queryPairs) {\n-        builder.queryParam(pair.getName(), pair.getValue());\n-      }\n-      URI toFetch \u003d builder.path(rest).build();\n-\n-      LOG.info(\"{} is accessing unchecked {}\"\n-          + \" which is the app master GUI of {} owned by {}\",\n-          remoteUser, toFetch, appId, runningUser);\n-\n-      switch (applicationReport.getYarnApplicationState()) {\n-        case KILLED:\n-        case FINISHED:\n-        case FAILED:\n-          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n-          return;\n-        default:\n-          // fall out of the switch\n-      }\n-      Cookie c \u003d null;\n-      if (userWasWarned \u0026\u0026 userApproved) {\n-        c \u003d makeCheckCookie(id, true);\n-      }\n-      proxyLink(req, resp, toFetch, c, getProxyHost());\n-\n-    } catch(URISyntaxException | YarnException e) {\n-      throw new IOException(e); \n-    }\n+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+      throws ServletException, IOException {\n+    methodAction(req, resp, HTTP.GET);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n      throws ServletException, IOException {\n    methodAction(req, resp, HTTP.GET);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[ServletException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-6284. Add Task Attempt State API to MapReduce Application Master REST API. Contributed by Ryu Kobayashi.\n",
          "commitDate": "07/05/15 11:59 PM",
          "commitName": "d18f10ad1b3e497fa1aaaeb85ba055f87d9849f7",
          "commitAuthor": "Tsuyoshi Ozawa",
          "commitDateOld": "05/05/15 9:42 PM",
          "commitNameOld": "a583a40693f5c56c40b39fd12cfa0bb7174fc526",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 2.1,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,4 @@\n-  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n-  throws IOException{\n-    try {\n-      String userApprovedParamS \u003d \n-        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n-      boolean userWasWarned \u003d false;\n-      boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n-      boolean securityEnabled \u003d isSecurityEnabled();\n-      final String remoteUser \u003d req.getRemoteUser();\n-      final String pathInfo \u003d req.getPathInfo();\n-\n-      String[] parts \u003d null;\n-      if (pathInfo !\u003d null) {\n-        parts \u003d pathInfo.split(\"/\", 3);\n-      }\n-      if(parts \u003d\u003d null || parts.length \u003c 2) {\n-        LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n-        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n-        return;\n-      }\n-      //parts[0] is empty because path info always starts with a /\n-      String appId \u003d parts[1];\n-      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n-      ApplicationId id \u003d Apps.toAppID(appId);\n-      if(id \u003d\u003d null) {\n-        LOG.warn(\"{} attempting to access {} that is invalid\",\n-            remoteUser, appId);\n-        notFound(resp, appId + \" appears to be formatted incorrectly.\");\n-        return;\n-      }\n-      \n-      if(securityEnabled) {\n-        String cookieName \u003d getCheckCookieName(id); \n-        Cookie[] cookies \u003d req.getCookies();\n-        if (cookies !\u003d null) {\n-          for (Cookie c : cookies) {\n-            if (cookieName.equals(c.getName())) {\n-              userWasWarned \u003d true;\n-              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n-              break;\n-            }\n-          }\n-        }\n-      }\n-      \n-      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n-\n-      ApplicationReport applicationReport;\n-      try {\n-        applicationReport \u003d getApplicationReport(id);\n-      } catch (ApplicationNotFoundException e) {\n-        applicationReport \u003d null;\n-      }\n-      if(applicationReport \u003d\u003d null) {\n-        LOG.warn(\"{} attempting to access {} that was not found\",\n-            remoteUser, id);\n-\n-        URI toFetch \u003d\n-            ProxyUriUtils\n-                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n-        if (toFetch !\u003d null) {\n-          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n-          return;\n-        }\n-\n-        notFound(resp, \"Application \" + appId + \" could not be found, \" +\n-                       \"please try the history server\");\n-        return;\n-      }\n-      String original \u003d applicationReport.getOriginalTrackingUrl();\n-      URI trackingUri;\n-      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n-      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n-        ProxyUtils.sendRedirect(req, resp, \n-            StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n-        return;\n-      } else {\n-        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n-          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n-              WebAppUtils.getHttpSchemePrefix(conf), original);\n-        } else {\n-          trackingUri \u003d new URI(original);\n-        }\n-      }\n-\n-      String runningUser \u003d applicationReport.getUser();\n-      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n-        LOG.info(\"Asking {} if they want to connect to the \"\n-            + \"app master GUI of {} owned by {}\",\n-            remoteUser, appId, runningUser);\n-        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n-            req.getQueryString(), true), runningUser, id);\n-        return;\n-      }\n-\n-      // Append the user-provided path and query parameter to the original\n-      // tracking url.\n-      List\u003cNameValuePair\u003e queryPairs \u003d\n-          URLEncodedUtils.parse(req.getQueryString(), null);\n-      UriBuilder builder \u003d UriBuilder.fromUri(trackingUri);\n-      for (NameValuePair pair : queryPairs) {\n-        builder.queryParam(pair.getName(), pair.getValue());\n-      }\n-      URI toFetch \u003d builder.path(rest).build();\n-\n-      LOG.info(\"{} is accessing unchecked {}\"\n-          + \" which is the app master GUI of {} owned by {}\",\n-          remoteUser, toFetch, appId, runningUser);\n-\n-      switch (applicationReport.getYarnApplicationState()) {\n-        case KILLED:\n-        case FINISHED:\n-        case FAILED:\n-          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n-          return;\n-        default:\n-          // fall out of the switch\n-      }\n-      Cookie c \u003d null;\n-      if (userWasWarned \u0026\u0026 userApproved) {\n-        c \u003d makeCheckCookie(id, true);\n-      }\n-      proxyLink(req, resp, toFetch, c, getProxyHost());\n-\n-    } catch(URISyntaxException | YarnException e) {\n-      throw new IOException(e); \n-    }\n+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+      throws ServletException, IOException {\n+    methodAction(req, resp, HTTP.GET);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n      throws ServletException, IOException {\n    methodAction(req, resp, HTTP.GET);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
          "extendedDetails": {}
        }
      ]
    },
    "a583a40693f5c56c40b39fd12cfa0bb7174fc526": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3582. NPE in WebAppProxyServlet. Contributed by Jian He\n",
      "commitDate": "05/05/15 9:42 PM",
      "commitName": "a583a40693f5c56c40b39fd12cfa0bb7174fc526",
      "commitAuthor": "Xuan",
      "commitDateOld": "26/02/15 7:24 AM",
      "commitNameOld": "773b6515ac51af3484824bd6f57685a9726a1e70",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 68.55,
      "commitsBetweenForRepo": 602,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,128 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n-      String[] parts \u003d pathInfo.split(\"/\", 3);\n-      if(parts.length \u003c 2) {\n+      String[] parts \u003d null;\n+      if (pathInfo !\u003d null) {\n+        parts \u003d pathInfo.split(\"/\", 3);\n+      }\n+      if(parts \u003d\u003d null || parts.length \u003c 2) {\n         LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(\"{} attempting to access {} that is invalid\",\n             remoteUser, appId);\n         notFound(resp, appId + \" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport;\n       try {\n         applicationReport \u003d getApplicationReport(id);\n       } catch (ApplicationNotFoundException e) {\n         applicationReport \u003d null;\n       }\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(\"{} attempting to access {} that was not found\",\n             remoteUser, id);\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null) {\n           ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n           return;\n         }\n \n         notFound(resp, \"Application \" + appId + \" could not be found, \" +\n                        \"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri;\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         ProxyUtils.sendRedirect(req, resp, \n             StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n         return;\n       } else {\n         if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n           trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n               WebAppUtils.getHttpSchemePrefix(conf), original);\n         } else {\n           trackingUri \u003d new URI(original);\n         }\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking {} if they want to connect to the \"\n             + \"app master GUI of {} owned by {}\",\n             remoteUser, appId, runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n \n       // Append the user-provided path and query parameter to the original\n       // tracking url.\n       List\u003cNameValuePair\u003e queryPairs \u003d\n           URLEncodedUtils.parse(req.getQueryString(), null);\n       UriBuilder builder \u003d UriBuilder.fromUri(trackingUri);\n       for (NameValuePair pair : queryPairs) {\n         builder.queryParam(pair.getName(), pair.getValue());\n       }\n       URI toFetch \u003d builder.path(rest).build();\n \n       LOG.info(\"{} is accessing unchecked {}\"\n           + \" which is the app master GUI of {} owned by {}\",\n           remoteUser, toFetch, appId, runningUser);\n \n       switch (applicationReport.getYarnApplicationState()) {\n         case KILLED:\n         case FINISHED:\n         case FAILED:\n           ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n           return;\n         default:\n           // fall out of the switch\n       }\n       Cookie c \u003d null;\n       if (userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException | YarnException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String[] parts \u003d null;\n      if (pathInfo !\u003d null) {\n        parts \u003d pathInfo.split(\"/\", 3);\n      }\n      if(parts \u003d\u003d null || parts.length \u003c 2) {\n        LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(\"{} attempting to access {} that is invalid\",\n            remoteUser, appId);\n        notFound(resp, appId + \" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport;\n      try {\n        applicationReport \u003d getApplicationReport(id);\n      } catch (ApplicationNotFoundException e) {\n        applicationReport \u003d null;\n      }\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(\"{} attempting to access {} that was not found\",\n            remoteUser, id);\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null) {\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        }\n\n        notFound(resp, \"Application \" + appId + \" could not be found, \" +\n                       \"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri;\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        ProxyUtils.sendRedirect(req, resp, \n            StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n              WebAppUtils.getHttpSchemePrefix(conf), original);\n        } else {\n          trackingUri \u003d new URI(original);\n        }\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking {} if they want to connect to the \"\n            + \"app master GUI of {} owned by {}\",\n            remoteUser, appId, runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n\n      // Append the user-provided path and query parameter to the original\n      // tracking url.\n      List\u003cNameValuePair\u003e queryPairs \u003d\n          URLEncodedUtils.parse(req.getQueryString(), null);\n      UriBuilder builder \u003d UriBuilder.fromUri(trackingUri);\n      for (NameValuePair pair : queryPairs) {\n        builder.queryParam(pair.getName(), pair.getValue());\n      }\n      URI toFetch \u003d builder.path(rest).build();\n\n      LOG.info(\"{} is accessing unchecked {}\"\n          + \" which is the app master GUI of {} owned by {}\",\n          remoteUser, toFetch, appId, runningUser);\n\n      switch (applicationReport.getYarnApplicationState()) {\n        case KILLED:\n        case FINISHED:\n        case FAILED:\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        default:\n          // fall out of the switch\n      }\n      Cookie c \u003d null;\n      if (userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException | YarnException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "1a68fc43464d3948418f453bb2f80df7ce773097": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3239. WebAppProxy does not support a final tracking url which has query fragments and params. Contributed by Jian He\n",
      "commitDate": "25/02/15 8:14 AM",
      "commitName": "1a68fc43464d3948418f453bb2f80df7ce773097",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/02/15 10:57 AM",
      "commitNameOld": "83be450acc7fc9bb9f7bbd006e7b0804bf10279c",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 12.89,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,125 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String[] parts \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(\"{} attempting to access {} that is invalid\",\n             remoteUser, appId);\n         notFound(resp, appId + \" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport;\n       try {\n         applicationReport \u003d getApplicationReport(id);\n       } catch (ApplicationNotFoundException e) {\n         applicationReport \u003d null;\n       }\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(\"{} attempting to access {} that was not found\",\n             remoteUser, id);\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null) {\n           ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n           return;\n         }\n \n         notFound(resp, \"Application \" + appId + \" could not be found, \" +\n                        \"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri;\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         ProxyUtils.sendRedirect(req, resp, \n             StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n         return;\n       } else {\n         if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n           trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n               WebAppUtils.getHttpSchemePrefix(conf), original);\n         } else {\n           trackingUri \u003d new URI(original);\n         }\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking {} if they want to connect to the \"\n             + \"app master GUI of {} owned by {}\",\n             remoteUser, appId, runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n-      URI toFetch \u003d new URI(trackingUri.getScheme(), \n-          trackingUri.getAuthority(),\n-          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n-          null);\n-      \n+\n+      // Append the user-provided path and query parameter to the original\n+      // tracking url.\n+      List\u003cNameValuePair\u003e queryPairs \u003d\n+          URLEncodedUtils.parse(req.getQueryString(), null);\n+      UriBuilder builder \u003d UriBuilder.fromUri(trackingUri);\n+      for (NameValuePair pair : queryPairs) {\n+        builder.queryParam(pair.getName(), pair.getValue());\n+      }\n+      URI toFetch \u003d builder.path(rest).build();\n+\n       LOG.info(\"{} is accessing unchecked {}\"\n           + \" which is the app master GUI of {} owned by {}\",\n           remoteUser, toFetch, appId, runningUser);\n \n       switch (applicationReport.getYarnApplicationState()) {\n         case KILLED:\n         case FINISHED:\n         case FAILED:\n           ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n           return;\n         default:\n           // fall out of the switch\n       }\n       Cookie c \u003d null;\n       if (userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException | YarnException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String[] parts \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(\"{} attempting to access {} that is invalid\",\n            remoteUser, appId);\n        notFound(resp, appId + \" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport;\n      try {\n        applicationReport \u003d getApplicationReport(id);\n      } catch (ApplicationNotFoundException e) {\n        applicationReport \u003d null;\n      }\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(\"{} attempting to access {} that was not found\",\n            remoteUser, id);\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null) {\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        }\n\n        notFound(resp, \"Application \" + appId + \" could not be found, \" +\n                       \"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri;\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        ProxyUtils.sendRedirect(req, resp, \n            StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n              WebAppUtils.getHttpSchemePrefix(conf), original);\n        } else {\n          trackingUri \u003d new URI(original);\n        }\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking {} if they want to connect to the \"\n            + \"app master GUI of {} owned by {}\",\n            remoteUser, appId, runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n\n      // Append the user-provided path and query parameter to the original\n      // tracking url.\n      List\u003cNameValuePair\u003e queryPairs \u003d\n          URLEncodedUtils.parse(req.getQueryString(), null);\n      UriBuilder builder \u003d UriBuilder.fromUri(trackingUri);\n      for (NameValuePair pair : queryPairs) {\n        builder.queryParam(pair.getName(), pair.getValue());\n      }\n      URI toFetch \u003d builder.path(rest).build();\n\n      LOG.info(\"{} is accessing unchecked {}\"\n          + \" which is the app master GUI of {} owned by {}\",\n          remoteUser, toFetch, appId, runningUser);\n\n      switch (applicationReport.getYarnApplicationState()) {\n        case KILLED:\n        case FINISHED:\n        case FAILED:\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        default:\n          // fall out of the switch\n      }\n      Cookie c \u003d null;\n      if (userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException | YarnException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "83be450acc7fc9bb9f7bbd006e7b0804bf10279c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3147. Clean up RM web proxy code. Contributed by Steve Loughran\n",
      "commitDate": "12/02/15 10:57 AM",
      "commitName": "83be450acc7fc9bb9f7bbd006e7b0804bf10279c",
      "commitAuthor": "Xuan",
      "commitDateOld": "23/12/14 8:04 PM",
      "commitNameOld": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 50.62,
      "commitsBetweenForRepo": 356,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,119 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n-      boolean userApproved \u003d \n-        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n+      boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n-      String parts[] \u003d pathInfo.split(\"/\", 3);\n+      String[] parts \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n-        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n+        LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n-        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n-        \" that is invalid\");\n-        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n+        LOG.warn(\"{} attempting to access {} that is invalid\",\n+            remoteUser, appId);\n+        notFound(resp, appId + \" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n-      ApplicationReport applicationReport \u003d null;\n+      ApplicationReport applicationReport;\n       try {\n         applicationReport \u003d getApplicationReport(id);\n       } catch (ApplicationNotFoundException e) {\n         applicationReport \u003d null;\n       }\n       if(applicationReport \u003d\u003d null) {\n-        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n-            \" that was not found\");\n+        LOG.warn(\"{} attempting to access {} that was not found\",\n+            remoteUser, id);\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n-        if (toFetch !\u003d null)\n-        {\n-          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n+        if (toFetch !\u003d null) {\n+          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n           return;\n         }\n \n-        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n-        \t\t\"please try the history server\");\n+        notFound(resp, \"Application \" + appId + \" could not be found, \" +\n+                       \"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n-      URI trackingUri \u003d null;\n+      URI trackingUri;\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n-        resp.sendRedirect(resp.encodeRedirectURL(\n-            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n+        ProxyUtils.sendRedirect(req, resp, \n+            StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n         return;\n       } else {\n         if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n           trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n               WebAppUtils.getHttpSchemePrefix(conf), original);\n         } else {\n           trackingUri \u003d new URI(original);\n         }\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n-        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n-            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n+        LOG.info(\"Asking {} if they want to connect to the \"\n+            + \"app master GUI of {} owned by {}\",\n+            remoteUser, appId, runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       URI toFetch \u003d new URI(trackingUri.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n-      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n-          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n+      LOG.info(\"{} is accessing unchecked {}\"\n+          + \" which is the app master GUI of {} owned by {}\",\n+          remoteUser, toFetch, appId, runningUser);\n \n-      switch(applicationReport.getYarnApplicationState()) {\n-      case KILLED:\n-      case FINISHED:\n-      case FAILED:\n-        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n-        return;\n+      switch (applicationReport.getYarnApplicationState()) {\n+        case KILLED:\n+        case FINISHED:\n+        case FAILED:\n+          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n+          return;\n+        default:\n+          // fall out of the switch\n       }\n       Cookie c \u003d null;\n-      if(userWasWarned \u0026\u0026 userApproved) {\n+      if (userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n-    } catch(URISyntaxException e) {\n+    } catch(URISyntaxException | YarnException e) {\n       throw new IOException(e); \n-    } catch (YarnException e) {\n-      throw new IOException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d Boolean.valueOf(userApprovedParamS);\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String[] parts \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(\"{} attempting to access {} that is invalid\",\n            remoteUser, appId);\n        notFound(resp, appId + \" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport;\n      try {\n        applicationReport \u003d getApplicationReport(id);\n      } catch (ApplicationNotFoundException e) {\n        applicationReport \u003d null;\n      }\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(\"{} attempting to access {} that was not found\",\n            remoteUser, id);\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null) {\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        }\n\n        notFound(resp, \"Application \" + appId + \" could not be found, \" +\n                       \"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri;\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        ProxyUtils.sendRedirect(req, resp, \n            StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n              WebAppUtils.getHttpSchemePrefix(conf), original);\n        } else {\n          trackingUri \u003d new URI(original);\n        }\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking {} if they want to connect to the \"\n            + \"app master GUI of {} owned by {}\",\n            remoteUser, appId, runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      URI toFetch \u003d new URI(trackingUri.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(\"{} is accessing unchecked {}\"\n          + \" which is the app master GUI of {} owned by {}\",\n          remoteUser, toFetch, appId, runningUser);\n\n      switch (applicationReport.getYarnApplicationState()) {\n        case KILLED:\n        case FINISHED:\n        case FAILED:\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        default:\n          // fall out of the switch\n      }\n      Cookie c \u003d null;\n      if (userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException | YarnException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "1c49cfbeb7df7ad5466578bd470819bcedc612cf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1859. Fixed WebAppProxyServlet to correctly handle applications absent on the ResourceManager. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579866 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/14 7:02 PM",
      "commitName": "1c49cfbeb7df7ad5466578bd470819bcedc612cf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/02/14 12:01 PM",
      "commitNameOld": "990cffdcfa9349fff0cee144b1d0e5267c40f63d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 34.25,
      "commitsBetweenForRepo": 311,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,119 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n-      ApplicationReport applicationReport \u003d getApplicationReport(id);\n+      ApplicationReport applicationReport \u003d null;\n+      try {\n+        applicationReport \u003d getApplicationReport(id);\n+      } catch (ApplicationNotFoundException e) {\n+        applicationReport \u003d null;\n+      }\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri \u003d null;\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         resp.sendRedirect(resp.encodeRedirectURL(\n             StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n         return;\n       } else {\n         if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n           trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n               WebAppUtils.getHttpSchemePrefix(conf), original);\n         } else {\n           trackingUri \u003d new URI(original);\n         }\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       URI toFetch \u003d new URI(trackingUri.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     } catch (YarnException e) {\n       throw new IOException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d null;\n      try {\n        applicationReport \u003d getApplicationReport(id);\n      } catch (ApplicationNotFoundException e) {\n        applicationReport \u003d null;\n      }\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri \u003d null;\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        resp.sendRedirect(resp.encodeRedirectURL(\n            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n              WebAppUtils.getHttpSchemePrefix(conf), original);\n        } else {\n          trackingUri \u003d new URI(original);\n        }\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      URI toFetch \u003d new URI(trackingUri.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    } catch (YarnException e) {\n      throw new IOException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "990cffdcfa9349fff0cee144b1d0e5267c40f63d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1553. Modified YARN and MR to stop using HttpConfig.isSecure() and\ninstead rely on the http policy framework. And also fix some bugs related\nto https handling in YARN web-apps. Contributed by Haohui Mai.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1568501 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/02/14 12:01 PM",
      "commitName": "990cffdcfa9349fff0cee144b1d0e5267c40f63d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/09/13 10:20 AM",
      "commitNameOld": "78e995a37d44cfcf511dcaf7e149a6fd47ba3434",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 143.11,
      "commitsBetweenForRepo": 898,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,114 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri \u003d null;\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         resp.sendRedirect(resp.encodeRedirectURL(\n             StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n         return;\n       } else {\n         if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n-          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\"http\", original);\n+          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n+              WebAppUtils.getHttpSchemePrefix(conf), original);\n         } else {\n           trackingUri \u003d new URI(original);\n         }\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       URI toFetch \u003d new URI(trackingUri.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     } catch (YarnException e) {\n       throw new IOException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri \u003d null;\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        resp.sendRedirect(resp.encodeRedirectURL(\n            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n              WebAppUtils.getHttpSchemePrefix(conf), original);\n        } else {\n          trackingUri \u003d new URI(original);\n        }\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      URI toFetch \u003d new URI(trackingUri.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    } catch (YarnException e) {\n      throw new IOException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "13420d01f2fb28a0e445dc87ad9ee9b607804d53": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1203. Changed YARN web-app proxy to handle http and https URLs from AM registration and finish correctly. Contributed by Omkar Vinit Joshi.\nMAPREDUCE-5515. Fixed MR AM\u0027s webapp to depend on a new config mapreduce.ssl.enabled to enable https and disabling it by default as MR AM needs\nto set up its own certificates etc and not depend on clusters\u0027. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1524864 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/09/13 4:35 PM",
      "commitName": "13420d01f2fb28a0e445dc87ad9ee9b607804d53",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 9:05 PM",
      "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 107.81,
      "commitsBetweenForRepo": 641,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,113 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri \u003d null;\n-      if (original !\u003d null) {\n-        trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n-      }\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         resp.sendRedirect(resp.encodeRedirectURL(\n             StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n         return;\n+      } else {\n+        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n+          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\"http\", original);\n+        } else {\n+          trackingUri \u003d new URI(original);\n+        }\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n-      \n-      URI toFetch \u003d new URI(req.getScheme(), \n+      URI toFetch \u003d new URI(trackingUri.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     } catch (YarnException e) {\n       throw new IOException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri \u003d null;\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        resp.sendRedirect(resp.encodeRedirectURL(\n            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\"http\", original);\n        } else {\n          trackingUri \u003d new URI(original);\n        }\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      URI toFetch \u003d new URI(trackingUri.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    } catch (YarnException e) {\n      throw new IOException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 12:04 PM",
      "commitNameOld": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 28.38,
      "commitsBetweenForRepo": 170,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,111 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri \u003d null;\n       if (original !\u003d null) {\n         trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n       }\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         resp.sendRedirect(resp.encodeRedirectURL(\n             StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n-    } catch (YarnRemoteException e) {\n+    } catch (YarnException e) {\n       throw new IOException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri \u003d null;\n      if (original !\u003d null) {\n        trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n      }\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        resp.sendRedirect(resp.encodeRedirectURL(\n            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    } catch (YarnException e) {\n      throw new IOException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "92b7165a71656468f17ce8b760ce11e648932f0e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-629. Make YarnRemoteException not be rooted at IOException. Contributed by Xuan Gong.\nMAPREDUCE-5204. Handling YarnRemoteException separately from IOException in MR app after YARN-629. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479680 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/05/13 12:04 PM",
      "commitName": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/02/13 12:57 PM",
      "commitNameOld": "320f7bdcb878d1dbf88edf660e9949f9897fa807",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 74.92,
      "commitsBetweenForRepo": 399,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,111 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri \u003d null;\n       if (original !\u003d null) {\n         trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n       }\n       // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         resp.sendRedirect(resp.encodeRedirectURL(\n             StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n+    } catch (YarnRemoteException e) {\n+      throw new IOException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri \u003d null;\n      if (original !\u003d null) {\n        trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n      }\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        resp.sendRedirect(resp.encodeRedirectURL(\n            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    } catch (YarnRemoteException e) {\n      throw new IOException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "320f7bdcb878d1dbf88edf660e9949f9897fa807": {
      "type": "Ybodychange",
      "commitMessage": "YARN-236. RM should point tracking URL to RM web page when app fails to start (Jason Lowe via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1448406 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/02/13 12:57 PM",
      "commitName": "320f7bdcb878d1dbf88edf660e9949f9897fa807",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "04/01/13 12:35 PM",
      "commitNameOld": "64e4fb983e022d8d3375a3e1b8facbf95f7ba403",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 47.01,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,109 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       String original \u003d applicationReport.getOriginalTrackingUrl();\n       URI trackingUri \u003d null;\n       if (original !\u003d null) {\n         trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n       }\n+      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n       if(original \u003d\u003d null || original.equals(\"N/A\")) {\n-        String message;\n-        switch(applicationReport.getFinalApplicationStatus()) {\n-          case FAILED:\n-          case KILLED:\n-          case SUCCEEDED:\n-            message \u003d\n-              \"The requested application exited before setting a tracking URL.\";\n-            break;\n-          case UNDEFINED:\n-            message \u003d \"The requested application does not appear to be running \"\n-              +\"yet, and has not set a tracking URL.\";\n-            break;\n-          default:\n-            //This should never happen, but just to be safe\n-            message \u003d \"The requested application has not set a tracking URL.\";\n-            break;\n-        }\n-        notFound(resp, message);\n+        resp.sendRedirect(resp.encodeRedirectURL(\n+            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri \u003d null;\n      if (original !\u003d null) {\n        trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n      }\n      // fallback to ResourceManager\u0027s app page if no tracking URI provided\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        resp.sendRedirect(resp.encodeRedirectURL(\n            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "64e4fb983e022d8d3375a3e1b8facbf95f7ba403": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4819. AM can rerun job after reporting final job status to the client (bobby and Bikas Saha via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1429114 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/13 12:35 PM",
      "commitName": "64e4fb983e022d8d3375a3e1b8facbf95f7ba403",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "28/12/12 6:21 AM",
      "commitNameOld": "4b9f0443cb0e35747e0c4ec5f416175b42164a60",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 7.26,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,124 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         Cookie[] cookies \u003d req.getCookies();\n         if (cookies !\u003d null) {\n           for (Cookie c : cookies) {\n             if (cookieName.equals(c.getName())) {\n               userWasWarned \u003d true;\n               userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n               break;\n             }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n-      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n-          applicationReport.getOriginalTrackingUrl());\n-      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n+      String original \u003d applicationReport.getOriginalTrackingUrl();\n+      URI trackingUri \u003d null;\n+      if (original !\u003d null) {\n+        trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n+      }\n+      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n         String message;\n         switch(applicationReport.getFinalApplicationStatus()) {\n           case FAILED:\n           case KILLED:\n           case SUCCEEDED:\n             message \u003d\n               \"The requested application exited before setting a tracking URL.\";\n             break;\n           case UNDEFINED:\n             message \u003d \"The requested application does not appear to be running \"\n               +\"yet, and has not set a tracking URL.\";\n             break;\n           default:\n             //This should never happen, but just to be safe\n             message \u003d \"The requested application has not set a tracking URL.\";\n             break;\n         }\n         notFound(resp, message);\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original \u003d applicationReport.getOriginalTrackingUrl();\n      URI trackingUri \u003d null;\n      if (original !\u003d null) {\n        trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(original);\n      }\n      if(original \u003d\u003d null || original.equals(\"N/A\")) {\n        String message;\n        switch(applicationReport.getFinalApplicationStatus()) {\n          case FAILED:\n          case KILLED:\n          case SUCCEEDED:\n            message \u003d\n              \"The requested application exited before setting a tracking URL.\";\n            break;\n          case UNDEFINED:\n            message \u003d \"The requested application does not appear to be running \"\n              +\"yet, and has not set a tracking URL.\";\n            break;\n          default:\n            //This should never happen, but just to be safe\n            message \u003d \"The requested application has not set a tracking URL.\";\n            break;\n        }\n        notFound(resp, message);\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "4b9f0443cb0e35747e0c4ec5f416175b42164a60": {
      "type": "Ybodychange",
      "commitMessage": "YARN-225. Proxy Link in RM UI thows NPE in Secure mode (Devaraj K via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1426515 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/12/12 6:21 AM",
      "commitName": "4b9f0443cb0e35747e0c4ec5f416175b42164a60",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "21/12/12 4:26 PM",
      "commitNameOld": "5a408bdeac0c40cef39c9c0eb1630698f7b77c19",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.58,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,121 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n-        for(Cookie c: req.getCookies()) {\n-          if(cookieName.equals(c.getName())) {\n-            userWasWarned \u003d true;\n-            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n-            break;\n+        Cookie[] cookies \u003d req.getCookies();\n+        if (cookies !\u003d null) {\n+          for (Cookie c : cookies) {\n+            if (cookieName.equals(c.getName())) {\n+              userWasWarned \u003d true;\n+              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n+              break;\n+            }\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n \n         URI toFetch \u003d\n             ProxyUriUtils\n                 .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n         if (toFetch !\u003d null)\n         {\n           resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n           return;\n         }\n \n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n           applicationReport.getOriginalTrackingUrl());\n       if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n         String message;\n         switch(applicationReport.getFinalApplicationStatus()) {\n           case FAILED:\n           case KILLED:\n           case SUCCEEDED:\n             message \u003d\n               \"The requested application exited before setting a tracking URL.\";\n             break;\n           case UNDEFINED:\n             message \u003d \"The requested application does not appear to be running \"\n               +\"yet, and has not set a tracking URL.\";\n             break;\n           default:\n             //This should never happen, but just to be safe\n             message \u003d \"The requested application has not set a tracking URL.\";\n             break;\n         }\n         notFound(resp, message);\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        Cookie[] cookies \u003d req.getCookies();\n        if (cookies !\u003d null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned \u003d true;\n              userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        String message;\n        switch(applicationReport.getFinalApplicationStatus()) {\n          case FAILED:\n          case KILLED:\n          case SUCCEEDED:\n            message \u003d\n              \"The requested application exited before setting a tracking URL.\";\n            break;\n          case UNDEFINED:\n            message \u003d \"The requested application does not appear to be running \"\n              +\"yet, and has not set a tracking URL.\";\n            break;\n          default:\n            //This should never happen, but just to be safe\n            message \u003d \"The requested application has not set a tracking URL.\";\n            break;\n        }\n        notFound(resp, message);\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "5a408bdeac0c40cef39c9c0eb1630698f7b77c19": {
      "type": "Ybodychange",
      "commitMessage": "YARN-285. Added a temporary plugin interface for RM to be able to redirect to JobHistory server for apps that it no longer tracks. Contributed by Derek Dagit.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1425210 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/12/12 4:26 PM",
      "commitName": "5a408bdeac0c40cef39c9c0eb1630698f7b77c19",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 135.79,
      "commitsBetweenForRepo": 758,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,118 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         for(Cookie c: req.getCookies()) {\n           if(cookieName.equals(c.getName())) {\n             userWasWarned \u003d true;\n             userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n             break;\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n+\n+        URI toFetch \u003d\n+            ProxyUriUtils\n+                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n+        if (toFetch !\u003d null)\n+        {\n+          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n+          return;\n+        }\n+\n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n           applicationReport.getOriginalTrackingUrl());\n       if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n         String message;\n         switch(applicationReport.getFinalApplicationStatus()) {\n           case FAILED:\n           case KILLED:\n           case SUCCEEDED:\n             message \u003d\n               \"The requested application exited before setting a tracking URL.\";\n             break;\n           case UNDEFINED:\n             message \u003d \"The requested application does not appear to be running \"\n               +\"yet, and has not set a tracking URL.\";\n             break;\n           default:\n             //This should never happen, but just to be safe\n             message \u003d \"The requested application has not set a tracking URL.\";\n             break;\n         }\n         notFound(resp, message);\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        for(Cookie c: req.getCookies()) {\n          if(cookieName.equals(c.getName())) {\n            userWasWarned \u003d true;\n            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n            break;\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch \u003d\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch !\u003d null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        String message;\n        switch(applicationReport.getFinalApplicationStatus()) {\n          case FAILED:\n          case KILLED:\n          case SUCCEEDED:\n            message \u003d\n              \"The requested application exited before setting a tracking URL.\";\n            break;\n          case UNDEFINED:\n            message \u003d \"The requested application does not appear to be running \"\n              +\"yet, and has not set a tracking URL.\";\n            break;\n          default:\n            //This should never happen, but just to be safe\n            message \u003d \"The requested application has not set a tracking URL.\";\n            break;\n        }\n        notFound(resp, message);\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        for(Cookie c: req.getCookies()) {\n          if(cookieName.equals(c.getName())) {\n            userWasWarned \u003d true;\n            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n            break;\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        String message;\n        switch(applicationReport.getFinalApplicationStatus()) {\n          case FAILED:\n          case KILLED:\n          case SUCCEEDED:\n            message \u003d\n              \"The requested application exited before setting a tracking URL.\";\n            break;\n          case UNDEFINED:\n            message \u003d \"The requested application does not appear to be running \"\n              +\"yet, and has not set a tracking URL.\";\n            break;\n          default:\n            //This should never happen, but just to be safe\n            message \u003d \"The requested application has not set a tracking URL.\";\n            break;\n        }\n        notFound(resp, message);\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java"
      }
    },
    "7b387f55c3f30c32e3fe672268d6d4ae6c120f70": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3999. Tracking link gives an error if the AppMaster hasn\u0027t started yet (Ravi Prakash via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1309108 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/12 12:37 PM",
      "commitName": "7b387f55c3f30c32e3fe672268d6d4ae6c120f70",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "04/03/12 1:14 PM",
      "commitNameOld": "d41cb76b56e19f6eb411b3dacaf28a490d079c68",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 29.93,
      "commitsBetweenForRepo": 192,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,108 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         for(Cookie c: req.getCookies()) {\n           if(cookieName.equals(c.getName())) {\n             userWasWarned \u003d true;\n             userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n             break;\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n           applicationReport.getOriginalTrackingUrl());\n       if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n-        notFound(resp, \"The MRAppMaster died before writing anything.\");\n+        String message;\n+        switch(applicationReport.getFinalApplicationStatus()) {\n+          case FAILED:\n+          case KILLED:\n+          case SUCCEEDED:\n+            message \u003d\n+              \"The requested application exited before setting a tracking URL.\";\n+            break;\n+          case UNDEFINED:\n+            message \u003d \"The requested application does not appear to be running \"\n+              +\"yet, and has not set a tracking URL.\";\n+            break;\n+          default:\n+            //This should never happen, but just to be safe\n+            message \u003d \"The requested application has not set a tracking URL.\";\n+            break;\n+        }\n+        notFound(resp, message);\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        for(Cookie c: req.getCookies()) {\n          if(cookieName.equals(c.getName())) {\n            userWasWarned \u003d true;\n            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n            break;\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        String message;\n        switch(applicationReport.getFinalApplicationStatus()) {\n          case FAILED:\n          case KILLED:\n          case SUCCEEDED:\n            message \u003d\n              \"The requested application exited before setting a tracking URL.\";\n            break;\n          case UNDEFINED:\n            message \u003d \"The requested application does not appear to be running \"\n              +\"yet, and has not set a tracking URL.\";\n            break;\n          default:\n            //This should never happen, but just to be safe\n            message \u003d \"The requested application has not set a tracking URL.\";\n            break;\n        }\n        notFound(resp, message);\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "d41cb76b56e19f6eb411b3dacaf28a490d079c68": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3960. Fix web-proxy to forward request to AM with configured hostname or IP. Contributed by Thomas Graves. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296878 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/12 1:14 PM",
      "commitName": "d41cb76b56e19f6eb411b3dacaf28a490d079c68",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "29/02/12 2:14 PM",
      "commitNameOld": "7bf2f9559f884827f2ea09412e4c20a456e972df",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 3.96,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         for(Cookie c: req.getCookies()) {\n           if(cookieName.equals(c.getName())) {\n             userWasWarned \u003d true;\n             userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n             break;\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n           applicationReport.getOriginalTrackingUrl());\n       if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n         notFound(resp, \"The MRAppMaster died before writing anything.\");\n         return;\n       }\n \n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n-      proxyLink(req, resp, toFetch, c);\n+      proxyLink(req, resp, toFetch, c, getProxyHost());\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        for(Cookie c: req.getCookies()) {\n          if(cookieName.equals(c.getName())) {\n            userWasWarned \u003d true;\n            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n            break;\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        notFound(resp, \"The MRAppMaster died before writing anything.\");\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "defa1c5babdcb40eb2b868ee2564826a8fb68f3b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3687.  If AM dies before it returns new tracking URL, proxy redirects to http://N/A/ and doesn\u0027t return error code (Ravi Prakash via bobby)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1295147 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/02/12 7:19 AM",
      "commitName": "defa1c5babdcb40eb2b868ee2564826a8fb68f3b",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "25/10/11 11:29 PM",
      "commitNameOld": "8aabd3d4e67cad8dc7e46f5339981135badc7421",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 126.37,
      "commitsBetweenForRepo": 755,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,91 @@\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n   throws IOException{\n     try {\n       String userApprovedParamS \u003d \n         req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n       boolean userWasWarned \u003d false;\n       boolean userApproved \u003d \n         (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n       boolean securityEnabled \u003d isSecurityEnabled();\n       final String remoteUser \u003d req.getRemoteUser();\n       final String pathInfo \u003d req.getPathInfo();\n \n       String parts[] \u003d pathInfo.split(\"/\", 3);\n       if(parts.length \u003c 2) {\n         LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n         notFound(resp, \"Your path appears to be formatted incorrectly.\");\n         return;\n       }\n       //parts[0] is empty because path info always starts with a /\n       String appId \u003d parts[1];\n       String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n       ApplicationId id \u003d Apps.toAppID(appId);\n       if(id \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n         \" that is invalid\");\n         notFound(resp, appId+\" appears to be formatted incorrectly.\");\n         return;\n       }\n       \n       if(securityEnabled) {\n         String cookieName \u003d getCheckCookieName(id); \n         for(Cookie c: req.getCookies()) {\n           if(cookieName.equals(c.getName())) {\n             userWasWarned \u003d true;\n             userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n             break;\n           }\n         }\n       }\n       \n       boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n \n       ApplicationReport applicationReport \u003d getApplicationReport(id);\n       if(applicationReport \u003d\u003d null) {\n         LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n             \" that was not found\");\n         notFound(resp, \"Application \"+appId+\" could not be found, \" +\n         \t\t\"please try the history server\");\n         return;\n       }\n       URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n           applicationReport.getOriginalTrackingUrl());\n-      \n+      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n+        notFound(resp, \"The MRAppMaster died before writing anything.\");\n+        return;\n+      }\n+\n       String runningUser \u003d applicationReport.getUser();\n       if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n         LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n             \"app master GUI of \"+appId+\" owned by \"+runningUser);\n         warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n             req.getQueryString(), true), runningUser, id);\n         return;\n       }\n       \n       URI toFetch \u003d new URI(req.getScheme(), \n           trackingUri.getAuthority(),\n           StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n           null);\n       \n       LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n           \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n \n       switch(applicationReport.getYarnApplicationState()) {\n       case KILLED:\n       case FINISHED:\n       case FAILED:\n         resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n         return;\n       }\n       Cookie c \u003d null;\n       if(userWasWarned \u0026\u0026 userApproved) {\n         c \u003d makeCheckCookie(id, true);\n       }\n       proxyLink(req, resp, toFetch, c);\n \n     } catch(URISyntaxException e) {\n       throw new IOException(e); \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        for(Cookie c: req.getCookies()) {\n          if(cookieName.equals(c.getName())) {\n            userWasWarned \u003d true;\n            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n            break;\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        notFound(resp, \"The MRAppMaster died before writing anything.\");\n        return;\n      }\n\n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c);\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java",
      "extendedDetails": {}
    },
    "8aabd3d4e67cad8dc7e46f5339981135badc7421": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2858. Added a WebApp Proxy for applications. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189036 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/11 11:29 PM",
      "commitName": "8aabd3d4e67cad8dc7e46f5339981135badc7421",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,87 @@\n+  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n+  throws IOException{\n+    try {\n+      String userApprovedParamS \u003d \n+        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n+      boolean userWasWarned \u003d false;\n+      boolean userApproved \u003d \n+        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n+      boolean securityEnabled \u003d isSecurityEnabled();\n+      final String remoteUser \u003d req.getRemoteUser();\n+      final String pathInfo \u003d req.getPathInfo();\n+\n+      String parts[] \u003d pathInfo.split(\"/\", 3);\n+      if(parts.length \u003c 2) {\n+        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n+        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n+        return;\n+      }\n+      //parts[0] is empty because path info always starts with a /\n+      String appId \u003d parts[1];\n+      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n+      ApplicationId id \u003d Apps.toAppID(appId);\n+      if(id \u003d\u003d null) {\n+        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n+        \" that is invalid\");\n+        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n+        return;\n+      }\n+      \n+      if(securityEnabled) {\n+        String cookieName \u003d getCheckCookieName(id); \n+        for(Cookie c: req.getCookies()) {\n+          if(cookieName.equals(c.getName())) {\n+            userWasWarned \u003d true;\n+            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n+            break;\n+          }\n+        }\n+      }\n+      \n+      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n+\n+      ApplicationReport applicationReport \u003d getApplicationReport(id);\n+      if(applicationReport \u003d\u003d null) {\n+        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n+            \" that was not found\");\n+        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n+        \t\t\"please try the history server\");\n+        return;\n+      }\n+      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n+          applicationReport.getOriginalTrackingUrl());\n+      \n+      String runningUser \u003d applicationReport.getUser();\n+      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n+        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n+            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n+        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n+            req.getQueryString(), true), runningUser, id);\n+        return;\n+      }\n+      \n+      URI toFetch \u003d new URI(req.getScheme(), \n+          trackingUri.getAuthority(),\n+          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n+          null);\n+      \n+      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n+          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n+\n+      switch(applicationReport.getYarnApplicationState()) {\n+      case KILLED:\n+      case FINISHED:\n+      case FAILED:\n+        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n+        return;\n+      }\n+      Cookie c \u003d null;\n+      if(userWasWarned \u0026\u0026 userApproved) {\n+        c \u003d makeCheckCookie(id, true);\n+      }\n+      proxyLink(req, resp, toFetch, c);\n+\n+    } catch(URISyntaxException e) {\n+      throw new IOException(e); \n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS \u003d \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned \u003d false;\n      boolean userApproved \u003d \n        (userApprovedParamS !\u003d null \u0026\u0026 Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled \u003d isSecurityEnabled();\n      final String remoteUser \u003d req.getRemoteUser();\n      final String pathInfo \u003d req.getPathInfo();\n\n      String parts[] \u003d pathInfo.split(\"/\", 3);\n      if(parts.length \u003c 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId \u003d parts[1];\n      String rest \u003d parts.length \u003e 2 ? parts[2] : \"\";\n      ApplicationId id \u003d Apps.toAppID(appId);\n      if(id \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName \u003d getCheckCookieName(id); \n        for(Cookie c: req.getCookies()) {\n          if(cookieName.equals(c.getName())) {\n            userWasWarned \u003d true;\n            userApproved \u003d userApproved || Boolean.valueOf(c.getValue());\n            break;\n          }\n        }\n      }\n      \n      boolean checkUser \u003d securityEnabled \u0026\u0026 (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport \u003d getApplicationReport(id);\n      if(applicationReport \u003d\u003d null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri \u003d ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      \n      String runningUser \u003d applicationReport.getUser();\n      if(checkUser \u0026\u0026 !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch \u003d new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c \u003d null;\n      if(userWasWarned \u0026\u0026 userApproved) {\n        c \u003d makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c);\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-web-proxy/src/main/java/org/apache/hadoop/yarn/server/webproxy/WebAppProxyServlet.java"
    }
  }
}