{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StateStoreFileBaseImpl.java",
  "functionName": "putAll",
  "functionId": "putAll___records-List__T____allowUpdate-boolean__errorIfExists-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/driver/impl/StateStoreFileBaseImpl.java",
  "functionStartLine": 306,
  "functionEndLine": 384,
  "numCommitsSeen": 5,
  "timeTaken": 2195,
  "changeHistory": [
    "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "76be6cbf6c33f866794f27ca2560ca7c7b2fa0e7",
    "4bf877b03f0e01c4bcedc689c66689701e62b560"
  ],
  "changeHistoryShort": {
    "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1": "Ybodychange",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Yfilerename",
    "76be6cbf6c33f866794f27ca2560ca7c7b2fa0e7": "Ybodychange",
    "4bf877b03f0e01c4bcedc689c66689701e62b560": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13435. RBF: Improve the error loggings for printing the stack trace.\n",
      "commitDate": "16/04/18 8:23 PM",
      "commitName": "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "19/03/18 10:13 PM",
      "commitNameOld": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthorOld": "weiy",
      "daysBetweenCommits": 27.92,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public \u003cT extends BaseRecord\u003e boolean putAll(\n       List\u003cT\u003e records, boolean allowUpdate, boolean errorIfExists)\n           throws StateStoreUnavailableException {\n     verifyDriverReady();\n     if (records.isEmpty()) {\n       return true;\n     }\n \n     long start \u003d monotonicNow();\n     StateStoreMetrics metrics \u003d getMetrics();\n \n     // Check if any record exists\n     Map\u003cString, T\u003e toWrite \u003d new HashMap\u003c\u003e();\n     for (T record : records) {\n       Class\u003c? extends BaseRecord\u003e recordClass \u003d record.getClass();\n       String path \u003d getPathForClass(recordClass);\n       String primaryKey \u003d getPrimaryKey(record);\n       String recordPath \u003d path + \"/\" + primaryKey;\n \n       if (exists(recordPath)) {\n         if (allowUpdate) {\n           // Update the mod time stamp. Many backends will use their\n           // own timestamp for the mod time.\n           record.setDateModified(this.getTime());\n           toWrite.put(recordPath, record);\n         } else if (errorIfExists) {\n           LOG.error(\"Attempt to insert record {} that already exists\",\n               recordPath);\n           if (metrics !\u003d null) {\n             metrics.addFailure(monotonicNow() - start);\n           }\n           return false;\n         } else  {\n           LOG.debug(\"Not updating {}\", record);\n         }\n       } else {\n         toWrite.put(recordPath, record);\n       }\n     }\n \n     // Write the records\n     boolean success \u003d true;\n     for (Entry\u003cString, T\u003e entry : toWrite.entrySet()) {\n       String recordPath \u003d entry.getKey();\n       String recordPathTemp \u003d recordPath + \".\" + now() + TMP_MARK;\n       BufferedWriter writer \u003d getWriter(recordPathTemp);\n       try {\n         T record \u003d entry.getValue();\n         String line \u003d serializeString(record);\n         writer.write(line);\n       } catch (IOException e) {\n         LOG.error(\"Cannot write {}\", recordPathTemp, e);\n         success \u003d false;\n       } finally {\n         if (writer !\u003d null) {\n           try {\n             writer.close();\n           } catch (IOException e) {\n-            LOG.error(\"Cannot close the writer for {}\", recordPathTemp);\n+            LOG.error(\"Cannot close the writer for {}\", recordPathTemp, e);\n           }\n         }\n       }\n       // Commit\n       if (!rename(recordPathTemp, recordPath)) {\n         LOG.error(\"Failed committing record into {}\", recordPath);\n         success \u003d false;\n       }\n     }\n \n     long end \u003d monotonicNow();\n     if (metrics !\u003d null) {\n       if (success) {\n         metrics.addWrite(end - start);\n       } else {\n         metrics.addFailure(end - start);\n       }\n     }\n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends BaseRecord\u003e boolean putAll(\n      List\u003cT\u003e records, boolean allowUpdate, boolean errorIfExists)\n          throws StateStoreUnavailableException {\n    verifyDriverReady();\n    if (records.isEmpty()) {\n      return true;\n    }\n\n    long start \u003d monotonicNow();\n    StateStoreMetrics metrics \u003d getMetrics();\n\n    // Check if any record exists\n    Map\u003cString, T\u003e toWrite \u003d new HashMap\u003c\u003e();\n    for (T record : records) {\n      Class\u003c? extends BaseRecord\u003e recordClass \u003d record.getClass();\n      String path \u003d getPathForClass(recordClass);\n      String primaryKey \u003d getPrimaryKey(record);\n      String recordPath \u003d path + \"/\" + primaryKey;\n\n      if (exists(recordPath)) {\n        if (allowUpdate) {\n          // Update the mod time stamp. Many backends will use their\n          // own timestamp for the mod time.\n          record.setDateModified(this.getTime());\n          toWrite.put(recordPath, record);\n        } else if (errorIfExists) {\n          LOG.error(\"Attempt to insert record {} that already exists\",\n              recordPath);\n          if (metrics !\u003d null) {\n            metrics.addFailure(monotonicNow() - start);\n          }\n          return false;\n        } else  {\n          LOG.debug(\"Not updating {}\", record);\n        }\n      } else {\n        toWrite.put(recordPath, record);\n      }\n    }\n\n    // Write the records\n    boolean success \u003d true;\n    for (Entry\u003cString, T\u003e entry : toWrite.entrySet()) {\n      String recordPath \u003d entry.getKey();\n      String recordPathTemp \u003d recordPath + \".\" + now() + TMP_MARK;\n      BufferedWriter writer \u003d getWriter(recordPathTemp);\n      try {\n        T record \u003d entry.getValue();\n        String line \u003d serializeString(record);\n        writer.write(line);\n      } catch (IOException e) {\n        LOG.error(\"Cannot write {}\", recordPathTemp, e);\n        success \u003d false;\n      } finally {\n        if (writer !\u003d null) {\n          try {\n            writer.close();\n          } catch (IOException e) {\n            LOG.error(\"Cannot close the writer for {}\", recordPathTemp, e);\n          }\n        }\n      }\n      // Commit\n      if (!rename(recordPathTemp, recordPath)) {\n        LOG.error(\"Failed committing record into {}\", recordPath);\n        success \u003d false;\n      }\n    }\n\n    long end \u003d monotonicNow();\n    if (metrics !\u003d null) {\n      if (success) {\n        metrics.addWrite(end - start);\n      } else {\n        metrics.addFailure(end - start);\n      }\n    }\n    return success;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/driver/impl/StateStoreFileBaseImpl.java",
      "extendedDetails": {}
    },
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "commitDateOld": "19/03/18 5:19 PM",
      "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public \u003cT extends BaseRecord\u003e boolean putAll(\n      List\u003cT\u003e records, boolean allowUpdate, boolean errorIfExists)\n          throws StateStoreUnavailableException {\n    verifyDriverReady();\n    if (records.isEmpty()) {\n      return true;\n    }\n\n    long start \u003d monotonicNow();\n    StateStoreMetrics metrics \u003d getMetrics();\n\n    // Check if any record exists\n    Map\u003cString, T\u003e toWrite \u003d new HashMap\u003c\u003e();\n    for (T record : records) {\n      Class\u003c? extends BaseRecord\u003e recordClass \u003d record.getClass();\n      String path \u003d getPathForClass(recordClass);\n      String primaryKey \u003d getPrimaryKey(record);\n      String recordPath \u003d path + \"/\" + primaryKey;\n\n      if (exists(recordPath)) {\n        if (allowUpdate) {\n          // Update the mod time stamp. Many backends will use their\n          // own timestamp for the mod time.\n          record.setDateModified(this.getTime());\n          toWrite.put(recordPath, record);\n        } else if (errorIfExists) {\n          LOG.error(\"Attempt to insert record {} that already exists\",\n              recordPath);\n          if (metrics !\u003d null) {\n            metrics.addFailure(monotonicNow() - start);\n          }\n          return false;\n        } else  {\n          LOG.debug(\"Not updating {}\", record);\n        }\n      } else {\n        toWrite.put(recordPath, record);\n      }\n    }\n\n    // Write the records\n    boolean success \u003d true;\n    for (Entry\u003cString, T\u003e entry : toWrite.entrySet()) {\n      String recordPath \u003d entry.getKey();\n      String recordPathTemp \u003d recordPath + \".\" + now() + TMP_MARK;\n      BufferedWriter writer \u003d getWriter(recordPathTemp);\n      try {\n        T record \u003d entry.getValue();\n        String line \u003d serializeString(record);\n        writer.write(line);\n      } catch (IOException e) {\n        LOG.error(\"Cannot write {}\", recordPathTemp, e);\n        success \u003d false;\n      } finally {\n        if (writer !\u003d null) {\n          try {\n            writer.close();\n          } catch (IOException e) {\n            LOG.error(\"Cannot close the writer for {}\", recordPathTemp);\n          }\n        }\n      }\n      // Commit\n      if (!rename(recordPathTemp, recordPath)) {\n        LOG.error(\"Failed committing record into {}\", recordPath);\n        success \u003d false;\n      }\n    }\n\n    long end \u003d monotonicNow();\n    if (metrics !\u003d null) {\n      if (success) {\n        metrics.addWrite(end - start);\n      } else {\n        metrics.addFailure(end - start);\n      }\n    }\n    return success;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/driver/impl/StateStoreFileBaseImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/driver/impl/StateStoreFileBaseImpl.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/driver/impl/StateStoreFileBaseImpl.java"
      }
    },
    "76be6cbf6c33f866794f27ca2560ca7c7b2fa0e7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12773. RBF: Improve State Store FS implementation. Contributed by Inigo Goiri.\n",
      "commitDate": "13/03/18 8:20 PM",
      "commitName": "76be6cbf6c33f866794f27ca2560ca7c7b2fa0e7",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "29/11/17 9:43 AM",
      "commitNameOld": "301641811d93ac22dc6fe1a05f18c1f266cc5e54",
      "commitAuthorOld": "Wei Yan",
      "daysBetweenCommits": 104.4,
      "commitsBetweenForRepo": 654,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,79 @@\n   public \u003cT extends BaseRecord\u003e boolean putAll(\n       List\u003cT\u003e records, boolean allowUpdate, boolean errorIfExists)\n           throws StateStoreUnavailableException {\n     verifyDriverReady();\n-\n     if (records.isEmpty()) {\n       return true;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    Class\u003cT\u003e clazz \u003d (Class\u003cT\u003e) getRecordClass(records.get(0).getClass());\n-    QueryResult\u003cT\u003e result;\n-    try {\n-      result \u003d get(clazz);\n-    } catch (IOException e) {\n-      return false;\n-    }\n-    Map\u003cObject, T\u003e writeList \u003d new HashMap\u003c\u003e();\n+    long start \u003d monotonicNow();\n+    StateStoreMetrics metrics \u003d getMetrics();\n \n-    // Write all of the existing records\n-    for (T existingRecord : result.getRecords()) {\n-      String key \u003d existingRecord.getPrimaryKey();\n-      writeList.put(key, existingRecord);\n-    }\n+    // Check if any record exists\n+    Map\u003cString, T\u003e toWrite \u003d new HashMap\u003c\u003e();\n+    for (T record : records) {\n+      Class\u003c? extends BaseRecord\u003e recordClass \u003d record.getClass();\n+      String path \u003d getPathForClass(recordClass);\n+      String primaryKey \u003d getPrimaryKey(record);\n+      String recordPath \u003d path + \"/\" + primaryKey;\n \n-    // Add inserts and updates, overwrite any existing values\n-    for (T updatedRecord : records) {\n-      try {\n-        updatedRecord.validate();\n-        String key \u003d updatedRecord.getPrimaryKey();\n-        if (writeList.containsKey(key) \u0026\u0026 allowUpdate) {\n-          // Update\n-          writeList.put(key, updatedRecord);\n+      if (exists(recordPath)) {\n+        if (allowUpdate) {\n           // Update the mod time stamp. Many backends will use their\n           // own timestamp for the mod time.\n-          updatedRecord.setDateModified(this.getTime());\n-        } else if (!writeList.containsKey(key)) {\n-          // Insert\n-          // Create/Mod timestamps are already initialized\n-          writeList.put(key, updatedRecord);\n+          record.setDateModified(this.getTime());\n+          toWrite.put(recordPath, record);\n         } else if (errorIfExists) {\n           LOG.error(\"Attempt to insert record {} that already exists\",\n-              updatedRecord);\n+              recordPath);\n+          if (metrics !\u003d null) {\n+            metrics.addFailure(monotonicNow() - start);\n+          }\n           return false;\n+        } else  {\n+          LOG.debug(\"Not updating {}\", record);\n         }\n-      } catch (IllegalArgumentException ex) {\n-        LOG.error(\"Cannot write invalid record to State Store\", ex);\n-        return false;\n+      } else {\n+        toWrite.put(recordPath, record);\n       }\n     }\n \n-    // Write all\n-    boolean status \u003d writeAll(writeList.values(), clazz);\n-    return status;\n+    // Write the records\n+    boolean success \u003d true;\n+    for (Entry\u003cString, T\u003e entry : toWrite.entrySet()) {\n+      String recordPath \u003d entry.getKey();\n+      String recordPathTemp \u003d recordPath + \".\" + now() + TMP_MARK;\n+      BufferedWriter writer \u003d getWriter(recordPathTemp);\n+      try {\n+        T record \u003d entry.getValue();\n+        String line \u003d serializeString(record);\n+        writer.write(line);\n+      } catch (IOException e) {\n+        LOG.error(\"Cannot write {}\", recordPathTemp, e);\n+        success \u003d false;\n+      } finally {\n+        if (writer !\u003d null) {\n+          try {\n+            writer.close();\n+          } catch (IOException e) {\n+            LOG.error(\"Cannot close the writer for {}\", recordPathTemp);\n+          }\n+        }\n+      }\n+      // Commit\n+      if (!rename(recordPathTemp, recordPath)) {\n+        LOG.error(\"Failed committing record into {}\", recordPath);\n+        success \u003d false;\n+      }\n+    }\n+\n+    long end \u003d monotonicNow();\n+    if (metrics !\u003d null) {\n+      if (success) {\n+        metrics.addWrite(end - start);\n+      } else {\n+        metrics.addFailure(end - start);\n+      }\n+    }\n+    return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends BaseRecord\u003e boolean putAll(\n      List\u003cT\u003e records, boolean allowUpdate, boolean errorIfExists)\n          throws StateStoreUnavailableException {\n    verifyDriverReady();\n    if (records.isEmpty()) {\n      return true;\n    }\n\n    long start \u003d monotonicNow();\n    StateStoreMetrics metrics \u003d getMetrics();\n\n    // Check if any record exists\n    Map\u003cString, T\u003e toWrite \u003d new HashMap\u003c\u003e();\n    for (T record : records) {\n      Class\u003c? extends BaseRecord\u003e recordClass \u003d record.getClass();\n      String path \u003d getPathForClass(recordClass);\n      String primaryKey \u003d getPrimaryKey(record);\n      String recordPath \u003d path + \"/\" + primaryKey;\n\n      if (exists(recordPath)) {\n        if (allowUpdate) {\n          // Update the mod time stamp. Many backends will use their\n          // own timestamp for the mod time.\n          record.setDateModified(this.getTime());\n          toWrite.put(recordPath, record);\n        } else if (errorIfExists) {\n          LOG.error(\"Attempt to insert record {} that already exists\",\n              recordPath);\n          if (metrics !\u003d null) {\n            metrics.addFailure(monotonicNow() - start);\n          }\n          return false;\n        } else  {\n          LOG.debug(\"Not updating {}\", record);\n        }\n      } else {\n        toWrite.put(recordPath, record);\n      }\n    }\n\n    // Write the records\n    boolean success \u003d true;\n    for (Entry\u003cString, T\u003e entry : toWrite.entrySet()) {\n      String recordPath \u003d entry.getKey();\n      String recordPathTemp \u003d recordPath + \".\" + now() + TMP_MARK;\n      BufferedWriter writer \u003d getWriter(recordPathTemp);\n      try {\n        T record \u003d entry.getValue();\n        String line \u003d serializeString(record);\n        writer.write(line);\n      } catch (IOException e) {\n        LOG.error(\"Cannot write {}\", recordPathTemp, e);\n        success \u003d false;\n      } finally {\n        if (writer !\u003d null) {\n          try {\n            writer.close();\n          } catch (IOException e) {\n            LOG.error(\"Cannot close the writer for {}\", recordPathTemp);\n          }\n        }\n      }\n      // Commit\n      if (!rename(recordPathTemp, recordPath)) {\n        LOG.error(\"Failed committing record into {}\", recordPath);\n        success \u003d false;\n      }\n    }\n\n    long end \u003d monotonicNow();\n    if (metrics !\u003d null) {\n      if (success) {\n        metrics.addWrite(end - start);\n      } else {\n        metrics.addFailure(end - start);\n      }\n    }\n    return success;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/driver/impl/StateStoreFileBaseImpl.java",
      "extendedDetails": {}
    },
    "4bf877b03f0e01c4bcedc689c66689701e62b560": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10630. Federation State Store FS Implementation. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit c6e0bd640cdaf83a660fa050809cad6f1d4c6f4d)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "4bf877b03f0e01c4bcedc689c66689701e62b560",
      "commitAuthor": "Inigo Goiri",
      "diff": "@@ -0,0 +1,55 @@\n+  public \u003cT extends BaseRecord\u003e boolean putAll(\n+      List\u003cT\u003e records, boolean allowUpdate, boolean errorIfExists)\n+          throws StateStoreUnavailableException {\n+    verifyDriverReady();\n+\n+    if (records.isEmpty()) {\n+      return true;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    Class\u003cT\u003e clazz \u003d (Class\u003cT\u003e) getRecordClass(records.get(0).getClass());\n+    QueryResult\u003cT\u003e result;\n+    try {\n+      result \u003d get(clazz);\n+    } catch (IOException e) {\n+      return false;\n+    }\n+    Map\u003cObject, T\u003e writeList \u003d new HashMap\u003c\u003e();\n+\n+    // Write all of the existing records\n+    for (T existingRecord : result.getRecords()) {\n+      String key \u003d existingRecord.getPrimaryKey();\n+      writeList.put(key, existingRecord);\n+    }\n+\n+    // Add inserts and updates, overwrite any existing values\n+    for (T updatedRecord : records) {\n+      try {\n+        updatedRecord.validate();\n+        String key \u003d updatedRecord.getPrimaryKey();\n+        if (writeList.containsKey(key) \u0026\u0026 allowUpdate) {\n+          // Update\n+          writeList.put(key, updatedRecord);\n+          // Update the mod time stamp. Many backends will use their\n+          // own timestamp for the mod time.\n+          updatedRecord.setDateModified(this.getTime());\n+        } else if (!writeList.containsKey(key)) {\n+          // Insert\n+          // Create/Mod timestamps are already initialized\n+          writeList.put(key, updatedRecord);\n+        } else if (errorIfExists) {\n+          LOG.error(\"Attempt to insert record {} that already exists\",\n+              updatedRecord);\n+          return false;\n+        }\n+      } catch (IllegalArgumentException ex) {\n+        LOG.error(\"Cannot write invalid record to State Store\", ex);\n+        return false;\n+      }\n+    }\n+\n+    // Write all\n+    boolean status \u003d writeAll(writeList.values(), clazz);\n+    return status;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends BaseRecord\u003e boolean putAll(\n      List\u003cT\u003e records, boolean allowUpdate, boolean errorIfExists)\n          throws StateStoreUnavailableException {\n    verifyDriverReady();\n\n    if (records.isEmpty()) {\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    Class\u003cT\u003e clazz \u003d (Class\u003cT\u003e) getRecordClass(records.get(0).getClass());\n    QueryResult\u003cT\u003e result;\n    try {\n      result \u003d get(clazz);\n    } catch (IOException e) {\n      return false;\n    }\n    Map\u003cObject, T\u003e writeList \u003d new HashMap\u003c\u003e();\n\n    // Write all of the existing records\n    for (T existingRecord : result.getRecords()) {\n      String key \u003d existingRecord.getPrimaryKey();\n      writeList.put(key, existingRecord);\n    }\n\n    // Add inserts and updates, overwrite any existing values\n    for (T updatedRecord : records) {\n      try {\n        updatedRecord.validate();\n        String key \u003d updatedRecord.getPrimaryKey();\n        if (writeList.containsKey(key) \u0026\u0026 allowUpdate) {\n          // Update\n          writeList.put(key, updatedRecord);\n          // Update the mod time stamp. Many backends will use their\n          // own timestamp for the mod time.\n          updatedRecord.setDateModified(this.getTime());\n        } else if (!writeList.containsKey(key)) {\n          // Insert\n          // Create/Mod timestamps are already initialized\n          writeList.put(key, updatedRecord);\n        } else if (errorIfExists) {\n          LOG.error(\"Attempt to insert record {} that already exists\",\n              updatedRecord);\n          return false;\n        }\n      } catch (IllegalArgumentException ex) {\n        LOG.error(\"Cannot write invalid record to State Store\", ex);\n        return false;\n      }\n    }\n\n    // Write all\n    boolean status \u003d writeAll(writeList.values(), clazz);\n    return status;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/driver/impl/StateStoreFileBaseImpl.java"
    }
  }
}