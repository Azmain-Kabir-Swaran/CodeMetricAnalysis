{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "IPCLoggerChannel.java",
  "functionName": "sendEdits",
  "functionId": "sendEdits___segmentTxId-long(modifiers-final)__firstTxnId-long(modifiers-final)__numTxns-int(modifiers-final)__data-byte[](modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
  "functionStartLine": 382,
  "functionEndLine": 461,
  "numCommitsSeen": 48,
  "timeTaken": 3042,
  "changeHistory": [
    "d7979079ea8c6514858b77a78f0119cffc178086",
    "faa4455be512e070fa420084be8d1be5c72f3b08",
    "81192e4e415d359ca832eff50d6f64c3da7acb73",
    "729ec86907c91f6f72df5313e4ed0c9ebdbde407",
    "959afc0fd3bdd4fa366fbec97ffa6b96d4528e53",
    "cae8116a146cb27d40e4e41cece9a17945bc7f9c",
    "72485f3112832a6a32f912d59ecf303a0c7e919a",
    "42cdc1b0835abb4a331d40f30f2c210143b747bc",
    "74d4573a23db5586c6e47ff2277aa7c35237da34"
  ],
  "changeHistoryShort": {
    "d7979079ea8c6514858b77a78f0119cffc178086": "Ybodychange",
    "faa4455be512e070fa420084be8d1be5c72f3b08": "Ybodychange",
    "81192e4e415d359ca832eff50d6f64c3da7acb73": "Ybodychange",
    "729ec86907c91f6f72df5313e4ed0c9ebdbde407": "Ybodychange",
    "959afc0fd3bdd4fa366fbec97ffa6b96d4528e53": "Ybodychange",
    "cae8116a146cb27d40e4e41cece9a17945bc7f9c": "Ybodychange",
    "72485f3112832a6a32f912d59ecf303a0c7e919a": "Ybodychange",
    "42cdc1b0835abb4a331d40f30f2c210143b747bc": "Ymultichange(Yparameterchange,Ybodychange)",
    "74d4573a23db5586c6e47ff2277aa7c35237da34": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d7979079ea8c6514858b77a78f0119cffc178086": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16210. Update guava to 27.0-jre in hadoop-project trunk. Contributed by Gabor Bota.\n",
      "commitDate": "03/04/19 11:59 AM",
      "commitName": "d7979079ea8c6514858b77a78f0119cffc178086",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "00e99c65943e64fd696ec715cf21e851b93115f1",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 100.06,
      "commitsBetweenForRepo": 758,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n       final long segmentTxId, final long firstTxnId,\n       final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     \n     // When this batch is acked, we use its submission time in order\n     // to calculate how far we are lagging.\n     final long submitNanos \u003d System.nanoTime();\n     \n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d singleThreadExecutor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n           throwIfOutOfSync();\n \n           long rpcSendTimeNanos \u003d System.nanoTime();\n           try {\n             getProxy().journal(createReqInfo(),\n                 segmentTxId, firstTxnId, numTxns, data);\n           } catch (IOException e) {\n             QuorumJournalManager.LOG.warn(\n                 \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                 \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                 \". Will try to write to this JN again after the next \" +\n                 \"log roll.\", e); \n             synchronized (IPCLoggerChannel.this) {\n               outOfSync \u003d true;\n             }\n             throw e;\n           } finally {\n             long now \u003d System.nanoTime();\n             long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n                 now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n             long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n                 now - submitNanos, TimeUnit.NANOSECONDS);\n             metrics.addWriteEndToEndLatency(endToEndTime);\n             metrics.addWriteRpcLatency(rpcTime);\n             if (rpcTime / 1000 \u003e WARN_JOURNAL_MILLIS_THRESHOLD) {\n               QuorumJournalManager.LOG.warn(\n                   \"Took \" + (rpcTime / 1000) + \"ms to send a batch of \" +\n                   numTxns + \" edits (\" + data.length + \" bytes) to \" +\n                   \"remote journal \" + IPCLoggerChannel.this);\n             }\n           }\n           synchronized (IPCLoggerChannel.this) {\n             highestAckedTxId \u003d firstTxnId + numTxns - 1;\n             lastAckNanos \u003d submitNanos;\n           }\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n-        });\n+        }, MoreExecutors.directExecutor());\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    \n    // When this batch is acked, we use its submission time in order\n    // to calculate how far we are lagging.\n    final long submitNanos \u003d System.nanoTime();\n    \n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d singleThreadExecutor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          throwIfOutOfSync();\n\n          long rpcSendTimeNanos \u003d System.nanoTime();\n          try {\n            getProxy().journal(createReqInfo(),\n                segmentTxId, firstTxnId, numTxns, data);\n          } catch (IOException e) {\n            QuorumJournalManager.LOG.warn(\n                \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                \". Will try to write to this JN again after the next \" +\n                \"log roll.\", e); \n            synchronized (IPCLoggerChannel.this) {\n              outOfSync \u003d true;\n            }\n            throw e;\n          } finally {\n            long now \u003d System.nanoTime();\n            long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n            long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - submitNanos, TimeUnit.NANOSECONDS);\n            metrics.addWriteEndToEndLatency(endToEndTime);\n            metrics.addWriteRpcLatency(rpcTime);\n            if (rpcTime / 1000 \u003e WARN_JOURNAL_MILLIS_THRESHOLD) {\n              QuorumJournalManager.LOG.warn(\n                  \"Took \" + (rpcTime / 1000) + \"ms to send a batch of \" +\n                  numTxns + \" edits (\" + data.length + \" bytes) to \" +\n                  \"remote journal \" + IPCLoggerChannel.this);\n            }\n          }\n          synchronized (IPCLoggerChannel.this) {\n            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n            lastAckNanos \u003d submitNanos;\n          }\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        }, MoreExecutors.directExecutor());\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
      "extendedDetails": {}
    },
    "faa4455be512e070fa420084be8d1be5c72f3b08": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6634. inotify in HDFS. Contributed by James Thomas.\n",
      "commitDate": "02/09/14 2:02 PM",
      "commitName": "faa4455be512e070fa420084be8d1be5c72f3b08",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 161.9,
      "commitsBetweenForRepo": 1116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n       final long segmentTxId, final long firstTxnId,\n       final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     \n     // When this batch is acked, we use its submission time in order\n     // to calculate how far we are lagging.\n     final long submitNanos \u003d System.nanoTime();\n     \n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n-      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n+      ret \u003d singleThreadExecutor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n           throwIfOutOfSync();\n \n           long rpcSendTimeNanos \u003d System.nanoTime();\n           try {\n             getProxy().journal(createReqInfo(),\n                 segmentTxId, firstTxnId, numTxns, data);\n           } catch (IOException e) {\n             QuorumJournalManager.LOG.warn(\n                 \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                 \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                 \". Will try to write to this JN again after the next \" +\n                 \"log roll.\", e); \n             synchronized (IPCLoggerChannel.this) {\n               outOfSync \u003d true;\n             }\n             throw e;\n           } finally {\n             long now \u003d System.nanoTime();\n             long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n                 now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n             long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n                 now - submitNanos, TimeUnit.NANOSECONDS);\n             metrics.addWriteEndToEndLatency(endToEndTime);\n             metrics.addWriteRpcLatency(rpcTime);\n             if (rpcTime / 1000 \u003e WARN_JOURNAL_MILLIS_THRESHOLD) {\n               QuorumJournalManager.LOG.warn(\n                   \"Took \" + (rpcTime / 1000) + \"ms to send a batch of \" +\n                   numTxns + \" edits (\" + data.length + \" bytes) to \" +\n                   \"remote journal \" + IPCLoggerChannel.this);\n             }\n           }\n           synchronized (IPCLoggerChannel.this) {\n             highestAckedTxId \u003d firstTxnId + numTxns - 1;\n             lastAckNanos \u003d submitNanos;\n           }\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    \n    // When this batch is acked, we use its submission time in order\n    // to calculate how far we are lagging.\n    final long submitNanos \u003d System.nanoTime();\n    \n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d singleThreadExecutor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          throwIfOutOfSync();\n\n          long rpcSendTimeNanos \u003d System.nanoTime();\n          try {\n            getProxy().journal(createReqInfo(),\n                segmentTxId, firstTxnId, numTxns, data);\n          } catch (IOException e) {\n            QuorumJournalManager.LOG.warn(\n                \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                \". Will try to write to this JN again after the next \" +\n                \"log roll.\", e); \n            synchronized (IPCLoggerChannel.this) {\n              outOfSync \u003d true;\n            }\n            throw e;\n          } finally {\n            long now \u003d System.nanoTime();\n            long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n            long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - submitNanos, TimeUnit.NANOSECONDS);\n            metrics.addWriteEndToEndLatency(endToEndTime);\n            metrics.addWriteRpcLatency(rpcTime);\n            if (rpcTime / 1000 \u003e WARN_JOURNAL_MILLIS_THRESHOLD) {\n              QuorumJournalManager.LOG.warn(\n                  \"Took \" + (rpcTime / 1000) + \"ms to send a batch of \" +\n                  numTxns + \" edits (\" + data.length + \" bytes) to \" +\n                  \"remote journal \" + IPCLoggerChannel.this);\n            }\n          }\n          synchronized (IPCLoggerChannel.this) {\n            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n            lastAckNanos \u003d submitNanos;\n          }\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
      "extendedDetails": {}
    },
    "81192e4e415d359ca832eff50d6f64c3da7acb73": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4621. Additional logging to help diagnose slow QJM syncs. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461777 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/03/13 11:42 AM",
      "commitName": "81192e4e415d359ca832eff50d6f64c3da7acb73",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "19/09/12 11:52 AM",
      "commitNameOld": "663e7484c04c197eed53f10a7808140f1c955277",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 188.99,
      "commitsBetweenForRepo": 912,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,80 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n       final long segmentTxId, final long firstTxnId,\n       final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     \n     // When this batch is acked, we use its submission time in order\n     // to calculate how far we are lagging.\n     final long submitNanos \u003d System.nanoTime();\n     \n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n           throwIfOutOfSync();\n \n           long rpcSendTimeNanos \u003d System.nanoTime();\n           try {\n             getProxy().journal(createReqInfo(),\n                 segmentTxId, firstTxnId, numTxns, data);\n           } catch (IOException e) {\n             QuorumJournalManager.LOG.warn(\n                 \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                 \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                 \". Will try to write to this JN again after the next \" +\n                 \"log roll.\", e); \n             synchronized (IPCLoggerChannel.this) {\n               outOfSync \u003d true;\n             }\n             throw e;\n           } finally {\n             long now \u003d System.nanoTime();\n             long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n                 now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n             long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n                 now - submitNanos, TimeUnit.NANOSECONDS);\n             metrics.addWriteEndToEndLatency(endToEndTime);\n             metrics.addWriteRpcLatency(rpcTime);\n+            if (rpcTime / 1000 \u003e WARN_JOURNAL_MILLIS_THRESHOLD) {\n+              QuorumJournalManager.LOG.warn(\n+                  \"Took \" + (rpcTime / 1000) + \"ms to send a batch of \" +\n+                  numTxns + \" edits (\" + data.length + \" bytes) to \" +\n+                  \"remote journal \" + IPCLoggerChannel.this);\n+            }\n           }\n           synchronized (IPCLoggerChannel.this) {\n             highestAckedTxId \u003d firstTxnId + numTxns - 1;\n             lastAckNanos \u003d submitNanos;\n           }\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    \n    // When this batch is acked, we use its submission time in order\n    // to calculate how far we are lagging.\n    final long submitNanos \u003d System.nanoTime();\n    \n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          throwIfOutOfSync();\n\n          long rpcSendTimeNanos \u003d System.nanoTime();\n          try {\n            getProxy().journal(createReqInfo(),\n                segmentTxId, firstTxnId, numTxns, data);\n          } catch (IOException e) {\n            QuorumJournalManager.LOG.warn(\n                \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                \". Will try to write to this JN again after the next \" +\n                \"log roll.\", e); \n            synchronized (IPCLoggerChannel.this) {\n              outOfSync \u003d true;\n            }\n            throw e;\n          } finally {\n            long now \u003d System.nanoTime();\n            long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n            long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - submitNanos, TimeUnit.NANOSECONDS);\n            metrics.addWriteEndToEndLatency(endToEndTime);\n            metrics.addWriteRpcLatency(rpcTime);\n            if (rpcTime / 1000 \u003e WARN_JOURNAL_MILLIS_THRESHOLD) {\n              QuorumJournalManager.LOG.warn(\n                  \"Took \" + (rpcTime / 1000) + \"ms to send a batch of \" +\n                  numTxns + \" edits (\" + data.length + \" bytes) to \" +\n                  \"remote journal \" + IPCLoggerChannel.this);\n            }\n          }\n          synchronized (IPCLoggerChannel.this) {\n            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n            lastAckNanos \u003d submitNanos;\n          }\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
      "extendedDetails": {}
    },
    "729ec86907c91f6f72df5313e4ed0c9ebdbde407": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3899. Add client side metrics for QJM. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1383139 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/12 3:39 PM",
      "commitName": "729ec86907c91f6f72df5313e4ed0c9ebdbde407",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "10/09/12 3:30 PM",
      "commitNameOld": "959afc0fd3bdd4fa366fbec97ffa6b96d4528e53",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,74 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n       final long segmentTxId, final long firstTxnId,\n       final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     \n     // When this batch is acked, we use its submission time in order\n     // to calculate how far we are lagging.\n     final long submitNanos \u003d System.nanoTime();\n     \n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n           throwIfOutOfSync();\n \n+          long rpcSendTimeNanos \u003d System.nanoTime();\n           try {\n             getProxy().journal(createReqInfo(),\n                 segmentTxId, firstTxnId, numTxns, data);\n           } catch (IOException e) {\n             QuorumJournalManager.LOG.warn(\n                 \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                 \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                 \". Will try to write to this JN again after the next \" +\n                 \"log roll.\", e); \n             synchronized (IPCLoggerChannel.this) {\n               outOfSync \u003d true;\n             }\n             throw e;\n+          } finally {\n+            long now \u003d System.nanoTime();\n+            long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n+                now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n+            long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n+                now - submitNanos, TimeUnit.NANOSECONDS);\n+            metrics.addWriteEndToEndLatency(endToEndTime);\n+            metrics.addWriteRpcLatency(rpcTime);\n           }\n           synchronized (IPCLoggerChannel.this) {\n             highestAckedTxId \u003d firstTxnId + numTxns - 1;\n             lastAckNanos \u003d submitNanos;\n           }\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    \n    // When this batch is acked, we use its submission time in order\n    // to calculate how far we are lagging.\n    final long submitNanos \u003d System.nanoTime();\n    \n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          throwIfOutOfSync();\n\n          long rpcSendTimeNanos \u003d System.nanoTime();\n          try {\n            getProxy().journal(createReqInfo(),\n                segmentTxId, firstTxnId, numTxns, data);\n          } catch (IOException e) {\n            QuorumJournalManager.LOG.warn(\n                \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                \". Will try to write to this JN again after the next \" +\n                \"log roll.\", e); \n            synchronized (IPCLoggerChannel.this) {\n              outOfSync \u003d true;\n            }\n            throw e;\n          } finally {\n            long now \u003d System.nanoTime();\n            long rpcTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - rpcSendTimeNanos, TimeUnit.NANOSECONDS);\n            long endToEndTime \u003d TimeUnit.MICROSECONDS.convert(\n                now - submitNanos, TimeUnit.NANOSECONDS);\n            metrics.addWriteEndToEndLatency(endToEndTime);\n            metrics.addWriteRpcLatency(rpcTime);\n          }\n          synchronized (IPCLoggerChannel.this) {\n            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n            lastAckNanos \u003d submitNanos;\n          }\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
      "extendedDetails": {}
    },
    "959afc0fd3bdd4fa366fbec97ffa6b96d4528e53": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3901. QJM: send \u0027heartbeat\u0027 messages to JNs even when they are out-of-sync. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1383137 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/12 3:30 PM",
      "commitName": "959afc0fd3bdd4fa366fbec97ffa6b96d4528e53",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "10/09/12 11:46 AM",
      "commitNameOld": "aa65777ef0480b74e99e0fa2f1077690cb3f3eda",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,65 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n       final long segmentTxId, final long firstTxnId,\n       final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n+    \n+    // When this batch is acked, we use its submission time in order\n+    // to calculate how far we are lagging.\n+    final long submitNanos \u003d System.nanoTime();\n+    \n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n           throwIfOutOfSync();\n \n           try {\n             getProxy().journal(createReqInfo(),\n                 segmentTxId, firstTxnId, numTxns, data);\n           } catch (IOException e) {\n             QuorumJournalManager.LOG.warn(\n                 \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                 \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                 \". Will try to write to this JN again after the next \" +\n                 \"log roll.\", e); \n             synchronized (IPCLoggerChannel.this) {\n               outOfSync \u003d true;\n             }\n             throw e;\n           }\n           synchronized (IPCLoggerChannel.this) {\n             highestAckedTxId \u003d firstTxnId + numTxns - 1;\n+            lastAckNanos \u003d submitNanos;\n           }\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    \n    // When this batch is acked, we use its submission time in order\n    // to calculate how far we are lagging.\n    final long submitNanos \u003d System.nanoTime();\n    \n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          throwIfOutOfSync();\n\n          try {\n            getProxy().journal(createReqInfo(),\n                segmentTxId, firstTxnId, numTxns, data);\n          } catch (IOException e) {\n            QuorumJournalManager.LOG.warn(\n                \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                \". Will try to write to this JN again after the next \" +\n                \"log roll.\", e); \n            synchronized (IPCLoggerChannel.this) {\n              outOfSync \u003d true;\n            }\n            throw e;\n          }\n          synchronized (IPCLoggerChannel.this) {\n            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n            lastAckNanos \u003d submitNanos;\n          }\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
      "extendedDetails": {}
    },
    "cae8116a146cb27d40e4e41cece9a17945bc7f9c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3726. If a logger misses an RPC, don\u0027t retry that logger until next segment. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1381482 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/12 12:03 AM",
      "commitName": "cae8116a146cb27d40e4e41cece9a17945bc7f9c",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/09/12 9:16 PM",
      "commitNameOld": "72485f3112832a6a32f912d59ecf303a0c7e919a",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,59 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n       final long segmentTxId, final long firstTxnId,\n       final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n-          getProxy().journal(createReqInfo(),\n-              segmentTxId, firstTxnId, numTxns, data);\n+          throwIfOutOfSync();\n+\n+          try {\n+            getProxy().journal(createReqInfo(),\n+                segmentTxId, firstTxnId, numTxns, data);\n+          } catch (IOException e) {\n+            QuorumJournalManager.LOG.warn(\n+                \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n+                \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n+                \". Will try to write to this JN again after the next \" +\n+                \"log roll.\", e); \n+            synchronized (IPCLoggerChannel.this) {\n+              outOfSync \u003d true;\n+            }\n+            throw e;\n+          }\n           synchronized (IPCLoggerChannel.this) {\n             highestAckedTxId \u003d firstTxnId + numTxns - 1;\n           }\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          throwIfOutOfSync();\n\n          try {\n            getProxy().journal(createReqInfo(),\n                segmentTxId, firstTxnId, numTxns, data);\n          } catch (IOException e) {\n            QuorumJournalManager.LOG.warn(\n                \"Remote journal \" + IPCLoggerChannel.this + \" failed to \" +\n                \"write txns \" + firstTxnId + \"-\" + (firstTxnId + numTxns - 1) +\n                \". Will try to write to this JN again after the next \" +\n                \"log roll.\", e); \n            synchronized (IPCLoggerChannel.this) {\n              outOfSync \u003d true;\n            }\n            throw e;\n          }\n          synchronized (IPCLoggerChannel.this) {\n            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n          }\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
      "extendedDetails": {}
    },
    "72485f3112832a6a32f912d59ecf303a0c7e919a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3869. Expose non-file journal manager details in web UI. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1380978 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/12 9:16 PM",
      "commitName": "72485f3112832a6a32f912d59ecf303a0c7e919a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/09/12 9:13 PM",
      "commitNameOld": "8021d9199f278345aca6211f318145342ad036f4",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,45 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n       final long segmentTxId, final long firstTxnId,\n       final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n           getProxy().journal(createReqInfo(),\n               segmentTxId, firstTxnId, numTxns, data);\n+          synchronized (IPCLoggerChannel.this) {\n+            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n+          }\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          getProxy().journal(createReqInfo(),\n              segmentTxId, firstTxnId, numTxns, data);\n          synchronized (IPCLoggerChannel.this) {\n            highestAckedTxId \u003d firstTxnId + numTxns - 1;\n          }\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
      "extendedDetails": {}
    },
    "42cdc1b0835abb4a331d40f30f2c210143b747bc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3797. QJM: add segment txid as a parameter to journal() RPC. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1373571 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/08/12 11:58 AM",
      "commitName": "42cdc1b0835abb4a331d40f30f2c210143b747bc",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3797. QJM: add segment txid as a parameter to journal() RPC. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1373571 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/08/12 11:58 AM",
          "commitName": "42cdc1b0835abb4a331d40f30f2c210143b747bc",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "14/08/12 5:57 PM",
          "commitNameOld": "c95a1674b61ef2a6963dc64604986ef90a8c636d",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.75,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,42 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n-      final long firstTxnId, final int numTxns, final byte[] data) {\n+      final long segmentTxId, final long firstTxnId,\n+      final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n-          getProxy().journal(createReqInfo(), firstTxnId, numTxns, data);\n+          getProxy().journal(createReqInfo(),\n+              segmentTxId, firstTxnId, numTxns, data);\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          getProxy().journal(createReqInfo(),\n              segmentTxId, firstTxnId, numTxns, data);\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
          "extendedDetails": {
            "oldValue": "[firstTxnId-long(modifiers-final), numTxns-int(modifiers-final), data-byte[](modifiers-final)]",
            "newValue": "[segmentTxId-long(modifiers-final), firstTxnId-long(modifiers-final), numTxns-int(modifiers-final), data-byte[](modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3797. QJM: add segment txid as a parameter to journal() RPC. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1373571 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/08/12 11:58 AM",
          "commitName": "42cdc1b0835abb4a331d40f30f2c210143b747bc",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "14/08/12 5:57 PM",
          "commitNameOld": "c95a1674b61ef2a6963dc64604986ef90a8c636d",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.75,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,42 @@\n   public ListenableFuture\u003cVoid\u003e sendEdits(\n-      final long firstTxnId, final int numTxns, final byte[] data) {\n+      final long segmentTxId, final long firstTxnId,\n+      final int numTxns, final byte[] data) {\n     try {\n       reserveQueueSpace(data.length);\n     } catch (LoggerTooFarBehindException e) {\n       return Futures.immediateFailedFuture(e);\n     }\n     ListenableFuture\u003cVoid\u003e ret \u003d null;\n     try {\n       ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n         @Override\n         public Void call() throws IOException {\n-          getProxy().journal(createReqInfo(), firstTxnId, numTxns, data);\n+          getProxy().journal(createReqInfo(),\n+              segmentTxId, firstTxnId, numTxns, data);\n           return null;\n         }\n       });\n     } finally {\n       if (ret \u003d\u003d null) {\n         // it didn\u0027t successfully get submitted,\n         // so adjust the queue size back down.\n         unreserveQueueSpace(data.length);\n       } else {\n         // It was submitted to the queue, so adjust the length\n         // once the call completes, regardless of whether it\n         // succeeds or fails.\n         Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n           @Override\n           public void onFailure(Throwable t) {\n             unreserveQueueSpace(data.length);\n           }\n \n           @Override\n           public void onSuccess(Void t) {\n             unreserveQueueSpace(data.length);\n           }\n         });\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long segmentTxId, final long firstTxnId,\n      final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          getProxy().journal(createReqInfo(),\n              segmentTxId, firstTxnId, numTxns, data);\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java",
          "extendedDetails": {}
        }
      ]
    },
    "74d4573a23db5586c6e47ff2277aa7c35237da34": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/12 5:25 PM",
      "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,40 @@\n+  public ListenableFuture\u003cVoid\u003e sendEdits(\n+      final long firstTxnId, final int numTxns, final byte[] data) {\n+    try {\n+      reserveQueueSpace(data.length);\n+    } catch (LoggerTooFarBehindException e) {\n+      return Futures.immediateFailedFuture(e);\n+    }\n+    ListenableFuture\u003cVoid\u003e ret \u003d null;\n+    try {\n+      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n+        @Override\n+        public Void call() throws IOException {\n+          getProxy().journal(createReqInfo(), firstTxnId, numTxns, data);\n+          return null;\n+        }\n+      });\n+    } finally {\n+      if (ret \u003d\u003d null) {\n+        // it didn\u0027t successfully get submitted,\n+        // so adjust the queue size back down.\n+        unreserveQueueSpace(data.length);\n+      } else {\n+        // It was submitted to the queue, so adjust the length\n+        // once the call completes, regardless of whether it\n+        // succeeds or fails.\n+        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n+          @Override\n+          public void onFailure(Throwable t) {\n+            unreserveQueueSpace(data.length);\n+          }\n+\n+          @Override\n+          public void onSuccess(Void t) {\n+            unreserveQueueSpace(data.length);\n+          }\n+        });\n+      }\n+    }\n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ListenableFuture\u003cVoid\u003e sendEdits(\n      final long firstTxnId, final int numTxns, final byte[] data) {\n    try {\n      reserveQueueSpace(data.length);\n    } catch (LoggerTooFarBehindException e) {\n      return Futures.immediateFailedFuture(e);\n    }\n    ListenableFuture\u003cVoid\u003e ret \u003d null;\n    try {\n      ret \u003d executor.submit(new Callable\u003cVoid\u003e() {\n        @Override\n        public Void call() throws IOException {\n          getProxy().journal(createReqInfo(), firstTxnId, numTxns, data);\n          return null;\n        }\n      });\n    } finally {\n      if (ret \u003d\u003d null) {\n        // it didn\u0027t successfully get submitted,\n        // so adjust the queue size back down.\n        unreserveQueueSpace(data.length);\n      } else {\n        // It was submitted to the queue, so adjust the length\n        // once the call completes, regardless of whether it\n        // succeeds or fails.\n        Futures.addCallback(ret, new FutureCallback\u003cVoid\u003e() {\n          @Override\n          public void onFailure(Throwable t) {\n            unreserveQueueSpace(data.length);\n          }\n\n          @Override\n          public void onSuccess(Void t) {\n            unreserveQueueSpace(data.length);\n          }\n        });\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/IPCLoggerChannel.java"
    }
  }
}