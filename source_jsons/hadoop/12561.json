{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Balancer.java",
  "functionName": "doBalance",
  "functionId": "doBalance___namenodes-Collection__URI____nsIds-Collection__String____p-BalancerParameters(modifiers-final)__conf-Configuration",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
  "functionStartLine": 691,
  "functionEndLine": 751,
  "numCommitsSeen": 375,
  "timeTaken": 16967,
  "changeHistory": [
    "a3f44dacc1fa19acc4eefd1e2505e54f8629e603",
    "dcf55838ae41aecfa8a7b37d9b95478ce6acf0a7",
    "1f26cc8705b5af12eefedda019e7ab5c261d9bfb",
    "66357574ae1da09ced735da36bf7d80a40c3fa1b",
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
    "de4894936a5b581572f35fa5b8979d9f23da0891",
    "d37dc5d1b8e022a7085118a2e7066623483c293f",
    "ccff6035f50769eb69701128ae61efc69e82609d",
    "c6497949e866594050153b953a85c0a1db59d2f8",
    "083b44c136ea5aba660fcd1dddbb2d21513b4456",
    "d31a41c35927f02f2fb40d19380b5df4bb2b6d57",
    "7ecbfd44aa57f5f54c214b7fdedda2500be76f51",
    "b94c1117a28e996adee68fe0e181eb6f536289f4",
    "ae71a671a3b4b454aa393c2974b6f1f16dd61405",
    "2749fc677c295e4ac5f4b1ebd5dbd6092370a857",
    "5d5aae0694bc27df5b9fa50819854cd3050a8658",
    "e60673697d5046c29c52bbabdfe80506f99773e4",
    "83b9933db3349e6a6faf23bce35c9d4ce3f7bcf2",
    "eae2a304624ee6caaa8591999752be2bba2b89e0",
    "1634e980af422c0af2f7c9c7280a77f2fbddc9c0",
    "0d7de507a5d6e9292aeabe357fab6976f81f5be4",
    "9318ff425019b9f88e154a80f3aeb23e6c69cb69",
    "01b17c40cf20df576fb18315c2019645d5050ddf",
    "9146ad23f3f1af7c5547fba08e2a867cee49e015",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "a3f44dacc1fa19acc4eefd1e2505e54f8629e603": "Ymultichange(Yparameterchange,Ybodychange)",
    "dcf55838ae41aecfa8a7b37d9b95478ce6acf0a7": "Ybodychange",
    "1f26cc8705b5af12eefedda019e7ab5c261d9bfb": "Ymultichange(Yrename,Ymodifierchange)",
    "66357574ae1da09ced735da36bf7d80a40c3fa1b": "Ybodychange",
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": "Ybodychange",
    "de4894936a5b581572f35fa5b8979d9f23da0891": "Ybodychange",
    "d37dc5d1b8e022a7085118a2e7066623483c293f": "Ybodychange",
    "ccff6035f50769eb69701128ae61efc69e82609d": "Ybodychange",
    "c6497949e866594050153b953a85c0a1db59d2f8": "Ybodychange",
    "083b44c136ea5aba660fcd1dddbb2d21513b4456": "Ymultichange(Yparameterchange,Ybodychange)",
    "d31a41c35927f02f2fb40d19380b5df4bb2b6d57": "Ybodychange",
    "7ecbfd44aa57f5f54c214b7fdedda2500be76f51": "Ybodychange",
    "b94c1117a28e996adee68fe0e181eb6f536289f4": "Ybodychange",
    "ae71a671a3b4b454aa393c2974b6f1f16dd61405": "Ybodychange",
    "2749fc677c295e4ac5f4b1ebd5dbd6092370a857": "Ybodychange",
    "5d5aae0694bc27df5b9fa50819854cd3050a8658": "Ybodychange",
    "e60673697d5046c29c52bbabdfe80506f99773e4": "Ybodychange",
    "83b9933db3349e6a6faf23bce35c9d4ce3f7bcf2": "Ybodychange",
    "eae2a304624ee6caaa8591999752be2bba2b89e0": "Ybodychange",
    "1634e980af422c0af2f7c9c7280a77f2fbddc9c0": "Ybodychange",
    "0d7de507a5d6e9292aeabe357fab6976f81f5be4": "Ymultichange(Yparameterchange,Ybodychange)",
    "9318ff425019b9f88e154a80f3aeb23e6c69cb69": "Ymultichange(Yparameterchange,Ybodychange)",
    "01b17c40cf20df576fb18315c2019645d5050ddf": "Ymultichange(Yparameterchange,Ybodychange)",
    "9146ad23f3f1af7c5547fba08e2a867cee49e015": "Ymultichange(Yparameterchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a3f44dacc1fa19acc4eefd1e2505e54f8629e603": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13183. Standby NameNode process getBlocks request to reduce Active load. Contributed by Xiaoqiao He.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "18/05/20 7:09 AM",
      "commitName": "a3f44dacc1fa19acc4eefd1e2505e54f8629e603",
      "commitAuthor": "He Xiaoqiao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13183. Standby NameNode process getBlocks request to reduce Active load. Contributed by Xiaoqiao He.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
          "commitDate": "18/05/20 7:09 AM",
          "commitName": "a3f44dacc1fa19acc4eefd1e2505e54f8629e603",
          "commitAuthor": "He Xiaoqiao",
          "commitDateOld": "06/11/19 8:15 AM",
          "commitNameOld": "dcf55838ae41aecfa8a7b37d9b95478ce6acf0a7",
          "commitAuthorOld": "Ayush Saxena",
          "daysBetweenCommits": 193.91,
          "commitsBetweenForRepo": 665,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,61 @@\n   static private int doBalance(Collection\u003cURI\u003e namenodes,\n-      final BalancerParameters p, Configuration conf)\n+      Collection\u003cString\u003e nsIds, final BalancerParameters p, Configuration conf)\n       throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n         conf.getTimeDuration(\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n-    try {\n-      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n-              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n-              p.getMaxIdleIteration());\n-\n-      boolean done \u003d false;\n-      for(int iteration \u003d 0; !done; iteration++) {\n+    boolean done \u003d false;\n+    for(int iteration \u003d 0; !done; iteration++) {\n+      try {\n+        connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, nsIds,\n+            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n+            p.getMaxIdleIteration());\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n           if (done) {\n             System.out.println(\"The cluster is balanced. Exiting...\");\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n-      }\n-    } finally {\n-      for(NameNodeConnector nnc : connectors) {\n-        IOUtils.cleanupWithLogger(LOG, nnc);\n+      } finally {\n+        for(NameNodeConnector nnc : connectors) {\n+          IOUtils.cleanupWithLogger(LOG, nnc);\n+        }\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static private int doBalance(Collection\u003cURI\u003e namenodes,\n      Collection\u003cString\u003e nsIds, final BalancerParameters p, Configuration conf)\n      throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    boolean done \u003d false;\n    for(int iteration \u003d 0; !done; iteration++) {\n      try {\n        connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, nsIds,\n            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n            p.getMaxIdleIteration());\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n          if (done) {\n            System.out.println(\"The cluster is balanced. Exiting...\");\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      } finally {\n        for(NameNodeConnector nnc : connectors) {\n          IOUtils.cleanupWithLogger(LOG, nnc);\n        }\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "[namenodes-Collection\u003cURI\u003e, p-BalancerParameters(modifiers-final), conf-Configuration]",
            "newValue": "[namenodes-Collection\u003cURI\u003e, nsIds-Collection\u003cString\u003e, p-BalancerParameters(modifiers-final), conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13183. Standby NameNode process getBlocks request to reduce Active load. Contributed by Xiaoqiao He.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
          "commitDate": "18/05/20 7:09 AM",
          "commitName": "a3f44dacc1fa19acc4eefd1e2505e54f8629e603",
          "commitAuthor": "He Xiaoqiao",
          "commitDateOld": "06/11/19 8:15 AM",
          "commitNameOld": "dcf55838ae41aecfa8a7b37d9b95478ce6acf0a7",
          "commitAuthorOld": "Ayush Saxena",
          "daysBetweenCommits": 193.91,
          "commitsBetweenForRepo": 665,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,61 @@\n   static private int doBalance(Collection\u003cURI\u003e namenodes,\n-      final BalancerParameters p, Configuration conf)\n+      Collection\u003cString\u003e nsIds, final BalancerParameters p, Configuration conf)\n       throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n         conf.getTimeDuration(\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n-    try {\n-      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n-              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n-              p.getMaxIdleIteration());\n-\n-      boolean done \u003d false;\n-      for(int iteration \u003d 0; !done; iteration++) {\n+    boolean done \u003d false;\n+    for(int iteration \u003d 0; !done; iteration++) {\n+      try {\n+        connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, nsIds,\n+            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n+            p.getMaxIdleIteration());\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n           if (done) {\n             System.out.println(\"The cluster is balanced. Exiting...\");\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n-      }\n-    } finally {\n-      for(NameNodeConnector nnc : connectors) {\n-        IOUtils.cleanupWithLogger(LOG, nnc);\n+      } finally {\n+        for(NameNodeConnector nnc : connectors) {\n+          IOUtils.cleanupWithLogger(LOG, nnc);\n+        }\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static private int doBalance(Collection\u003cURI\u003e namenodes,\n      Collection\u003cString\u003e nsIds, final BalancerParameters p, Configuration conf)\n      throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    boolean done \u003d false;\n    for(int iteration \u003d 0; !done; iteration++) {\n      try {\n        connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, nsIds,\n            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n            p.getMaxIdleIteration());\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n          if (done) {\n            System.out.println(\"The cluster is balanced. Exiting...\");\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      } finally {\n        for(NameNodeConnector nnc : connectors) {\n          IOUtils.cleanupWithLogger(LOG, nnc);\n        }\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {}
        }
      ]
    },
    "dcf55838ae41aecfa8a7b37d9b95478ce6acf0a7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14880. Correct the sequence of statistics \u0026 exit message in balencer. Contributed by Renukaprasad C.\n",
      "commitDate": "06/11/19 8:15 AM",
      "commitName": "dcf55838ae41aecfa8a7b37d9b95478ce6acf0a7",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "30/07/19 3:42 PM",
      "commitNameOld": "1f26cc8705b5af12eefedda019e7ab5c261d9bfb",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 98.73,
      "commitsBetweenForRepo": 757,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,62 @@\n   static private int doBalance(Collection\u003cURI\u003e namenodes,\n       final BalancerParameters p, Configuration conf)\n       throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n         conf.getTimeDuration(\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n+          if (done) {\n+            System.out.println(\"The cluster is balanced. Exiting...\");\n+          }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanupWithLogger(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static private int doBalance(Collection\u003cURI\u003e namenodes,\n      final BalancerParameters p, Configuration conf)\n      throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n          if (done) {\n            System.out.println(\"The cluster is balanced. Exiting...\");\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanupWithLogger(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "1f26cc8705b5af12eefedda019e7ab5c261d9bfb": {
      "type": "Ymultichange(Yrename,Ymodifierchange)",
      "commitMessage": "HDFS-13783. Add an option to the Balancer to make it run as a long-running service. Contributed by Chen Zhang.\n",
      "commitDate": "30/07/19 3:42 PM",
      "commitName": "1f26cc8705b5af12eefedda019e7ab5c261d9bfb",
      "commitAuthor": "Erik Krogen",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-13783. Add an option to the Balancer to make it run as a long-running service. Contributed by Chen Zhang.\n",
          "commitDate": "30/07/19 3:42 PM",
          "commitName": "1f26cc8705b5af12eefedda019e7ab5c261d9bfb",
          "commitAuthor": "Erik Krogen",
          "commitDateOld": "13/03/19 1:15 PM",
          "commitNameOld": "66357574ae1da09ced735da36bf7d80a40c3fa1b",
          "commitAuthorOld": "Erik Krogen",
          "daysBetweenCommits": 139.1,
          "commitsBetweenForRepo": 973,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,59 @@\n-  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n-      Configuration conf) throws IOException, InterruptedException {\n+  static private int doBalance(Collection\u003cURI\u003e namenodes,\n+      final BalancerParameters p, Configuration conf)\n+      throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n         conf.getTimeDuration(\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanupWithLogger(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static private int doBalance(Collection\u003cURI\u003e namenodes,\n      final BalancerParameters p, Configuration conf)\n      throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanupWithLogger(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "run",
            "newValue": "doBalance"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-13783. Add an option to the Balancer to make it run as a long-running service. Contributed by Chen Zhang.\n",
          "commitDate": "30/07/19 3:42 PM",
          "commitName": "1f26cc8705b5af12eefedda019e7ab5c261d9bfb",
          "commitAuthor": "Erik Krogen",
          "commitDateOld": "13/03/19 1:15 PM",
          "commitNameOld": "66357574ae1da09ced735da36bf7d80a40c3fa1b",
          "commitAuthorOld": "Erik Krogen",
          "daysBetweenCommits": 139.1,
          "commitsBetweenForRepo": 973,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,59 @@\n-  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n-      Configuration conf) throws IOException, InterruptedException {\n+  static private int doBalance(Collection\u003cURI\u003e namenodes,\n+      final BalancerParameters p, Configuration conf)\n+      throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n         conf.getTimeDuration(\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n             TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanupWithLogger(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static private int doBalance(Collection\u003cURI\u003e namenodes,\n      final BalancerParameters p, Configuration conf)\n      throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanupWithLogger(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "[static]",
            "newValue": "[private, static]"
          }
        }
      ]
    },
    "66357574ae1da09ced735da36bf7d80a40c3fa1b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14346. Add better time precision to Configuration#getTimeDuration, allowing return unit and default unit to be specified independently. Contributed by Chao Sun.\n",
      "commitDate": "13/03/19 1:15 PM",
      "commitName": "66357574ae1da09ced735da36bf7d80a40c3fa1b",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "30/10/18 10:43 PM",
      "commitNameOld": "fac9f91b2944cee641049fffcafa6b65e0cf68f2",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 133.61,
      "commitsBetweenForRepo": 963,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n-            TimeUnit.SECONDS) * 2000 +\n+            TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n         conf.getTimeDuration(\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n-            TimeUnit.SECONDS) * 1000;\n+            TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanupWithLogger(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS) * 2 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS, TimeUnit.MILLISECONDS);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanupWithLogger(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13695. Move logging to slf4j in HDFS package. Contributed by Ian Pickering.\n",
      "commitDate": "06/09/18 2:48 PM",
      "commitName": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "15/06/18 1:36 PM",
      "commitNameOld": "c966a3837af1c1a1c4a441f491b0d76d5c9e5d78",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 83.05,
      "commitsBetweenForRepo": 562,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n             TimeUnit.SECONDS) * 2000 +\n         conf.getTimeDuration(\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n             TimeUnit.SECONDS) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n-        IOUtils.cleanup(LOG, nnc);\n+        IOUtils.cleanupWithLogger(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS) * 2000 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanupWithLogger(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "de4894936a5b581572f35fa5b8979d9f23da0891": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11368. Erasure Coding: Deprecate replication-related config keys. Contributed by Rakesh R.\n",
      "commitDate": "23/11/16 4:42 PM",
      "commitName": "de4894936a5b581572f35fa5b8979d9f23da0891",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/11/16 8:13 AM",
      "commitNameOld": "49a09179e3fadae090126261be0a7fe0aa48798e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.35,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n             TimeUnit.SECONDS) * 2000 +\n         conf.getTimeDuration(\n-            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n-            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT,\n+            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n+            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n             TimeUnit.SECONDS) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS) * 2000 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT,\n            TimeUnit.SECONDS) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "d37dc5d1b8e022a7085118a2e7066623483c293f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9847. HDFS configuration should accept time units. Contributed by Yiqun Lin\n",
      "commitDate": "06/09/16 10:38 AM",
      "commitName": "d37dc5d1b8e022a7085118a2e7066623483c293f",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "15/07/16 11:42 AM",
      "commitNameOld": "c48e9d608c1daf7826f2e738c0a67d8eab79d8de",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 52.96,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,58 @@\n   static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n-        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n-            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n-        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n-            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n+        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n+            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n+            TimeUnit.SECONDS) * 2000 +\n+        conf.getTimeDuration(\n+            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n+            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT,\n+            TimeUnit.SECONDS) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n     checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS) * 2000 +\n        conf.getTimeDuration(\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT,\n            TimeUnit.SECONDS) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "ccff6035f50769eb69701128ae61efc69e82609d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9804. Allow long-running Balancer to login with keytab. Contributed by Xiao Chen.\n\nChange-Id: I54b82e0b11929082057b4d21bfcf285222c94cdb\n",
      "commitDate": "25/02/16 9:24 AM",
      "commitName": "ccff6035f50769eb69701128ae61efc69e82609d",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "18/02/16 6:18 PM",
      "commitNameOld": "46f77902368e5d8cc2d3e24de735b98a83ad46e1",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 6.63,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n-\n+    checkKeytabAndInit(conf);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n    checkKeytabAndInit(conf);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "c6497949e866594050153b953a85c0a1db59d2f8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9761. Rebalancer sleeps too long between iterations. Contributed by Mingliang Liu.\n",
      "commitDate": "05/02/16 3:07 PM",
      "commitName": "c6497949e866594050153b953a85c0a1db59d2f8",
      "commitAuthor": "cnauroth",
      "commitDateOld": "22/09/15 1:27 PM",
      "commitNameOld": "1080c3730068177ddd10dc313890ac1f5dc58f1a",
      "commitAuthorOld": "",
      "daysBetweenCommits": 136.11,
      "commitsBetweenForRepo": 953,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,55 @@\n   static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n     LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n     LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n \n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n               Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n               p.getMaxIdleIteration());\n \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           if (p.getBlockPools().size() \u003d\u003d 0\n               || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n-\n-            if (!done) {\n-              Thread.sleep(sleeptime);\n-            }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n+        if (!done) {\n+          Thread.sleep(sleeptime);\n+        }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "083b44c136ea5aba660fcd1dddbb2d21513b4456": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9008. Balancer#Parameters class could use a builder pattern. (Chris Trezzo via mingma)\n",
      "commitDate": "15/09/15 10:16 AM",
      "commitName": "083b44c136ea5aba660fcd1dddbb2d21513b4456",
      "commitAuthor": "Ming Ma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9008. Balancer#Parameters class could use a builder pattern. (Chris Trezzo via mingma)\n",
          "commitDate": "15/09/15 10:16 AM",
          "commitName": "083b44c136ea5aba660fcd1dddbb2d21513b4456",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "02/09/15 3:55 PM",
          "commitNameOld": "d31a41c35927f02f2fb40d19380b5df4bb2b6d57",
          "commitAuthorOld": "Ming Ma",
          "daysBetweenCommits": 12.76,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,56 @@\n-  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n+  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n-    LOG.info(\"included nodes \u003d \" + p.includedNodes);\n-    LOG.info(\"excluded nodes \u003d \" + p.excludedNodes);\n-    LOG.info(\"source nodes \u003d \" + p.sourceNodes);\n-    \n+    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n+    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n+    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n+\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n-            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n-    \n+              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n+              p.getMaxIdleIteration());\n+\n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n-          if (p.blockpools.size() \u003d\u003d 0\n-              || p.blockpools.contains(nnc.getBlockpoolID())) {\n+          if (p.getBlockPools().size() \u003d\u003d 0\n+              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n \n             if (!done) {\n               Thread.sleep(sleeptime);\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n\n            if (!done) {\n              Thread.sleep(sleeptime);\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "[namenodes-Collection\u003cURI\u003e, p-Parameters(modifiers-final), conf-Configuration]",
            "newValue": "[namenodes-Collection\u003cURI\u003e, p-BalancerParameters(modifiers-final), conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9008. Balancer#Parameters class could use a builder pattern. (Chris Trezzo via mingma)\n",
          "commitDate": "15/09/15 10:16 AM",
          "commitName": "083b44c136ea5aba660fcd1dddbb2d21513b4456",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "02/09/15 3:55 PM",
          "commitNameOld": "d31a41c35927f02f2fb40d19380b5df4bb2b6d57",
          "commitAuthorOld": "Ming Ma",
          "daysBetweenCommits": 12.76,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,56 @@\n-  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n+  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n-    LOG.info(\"included nodes \u003d \" + p.includedNodes);\n-    LOG.info(\"excluded nodes \u003d \" + p.excludedNodes);\n-    LOG.info(\"source nodes \u003d \" + p.sourceNodes);\n-    \n+    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n+    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n+    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n+\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n-            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n-    \n+              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n+              p.getMaxIdleIteration());\n+\n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n-          if (p.blockpools.size() \u003d\u003d 0\n-              || p.blockpools.contains(nnc.getBlockpoolID())) {\n+          if (p.getBlockPools().size() \u003d\u003d 0\n+              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n             final Balancer b \u003d new Balancer(nnc, p, conf);\n             final Result r \u003d b.runOneIteration();\n             r.print(iteration, System.out);\n \n             // clean all lists\n             b.resetData(conf);\n             if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n               done \u003d false;\n             } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n               // must be an error statue, return.\n               return r.exitStatus.getExitCode();\n             }\n \n             if (!done) {\n               Thread.sleep(sleeptime);\n             }\n           } else {\n             LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final BalancerParameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.getIncludedNodes());\n    LOG.info(\"excluded nodes \u003d \" + p.getExcludedNodes());\n    LOG.info(\"source nodes \u003d \" + p.getSourceNodes());\n\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n              Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf,\n              p.getMaxIdleIteration());\n\n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.getBlockPools().size() \u003d\u003d 0\n              || p.getBlockPools().contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n\n            if (!done) {\n              Thread.sleep(sleeptime);\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {}
        }
      ]
    },
    "d31a41c35927f02f2fb40d19380b5df4bb2b6d57": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8890. Allow admin to specify which blockpools the balancer should run on. (Chris Trezzo via mingma)\n",
      "commitDate": "02/09/15 3:55 PM",
      "commitName": "d31a41c35927f02f2fb40d19380b5df4bb2b6d57",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "18/08/15 7:25 PM",
      "commitNameOld": "7ecbfd44aa57f5f54c214b7fdedda2500be76f51",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 14.85,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,55 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     LOG.info(\"included nodes \u003d \" + p.includedNodes);\n     LOG.info(\"excluded nodes \u003d \" + p.excludedNodes);\n     LOG.info(\"source nodes \u003d \" + p.sourceNodes);\n     \n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n             Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n-          final Balancer b \u003d new Balancer(nnc, p, conf);\n-          final Result r \u003d b.runOneIteration();\n-          r.print(iteration, System.out);\n+          if (p.blockpools.size() \u003d\u003d 0\n+              || p.blockpools.contains(nnc.getBlockpoolID())) {\n+            final Balancer b \u003d new Balancer(nnc, p, conf);\n+            final Result r \u003d b.runOneIteration();\n+            r.print(iteration, System.out);\n \n-          // clean all lists\n-          b.resetData(conf);\n-          if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n-            done \u003d false;\n-          } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n-            //must be an error statue, return.\n-            return r.exitStatus.getExitCode();\n+            // clean all lists\n+            b.resetData(conf);\n+            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n+              done \u003d false;\n+            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n+              // must be an error statue, return.\n+              return r.exitStatus.getExitCode();\n+            }\n+\n+            if (!done) {\n+              Thread.sleep(sleeptime);\n+            }\n+          } else {\n+            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n           }\n         }\n-\n-        if (!done) {\n-          Thread.sleep(sleeptime);\n-        }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.includedNodes);\n    LOG.info(\"excluded nodes \u003d \" + p.excludedNodes);\n    LOG.info(\"source nodes \u003d \" + p.sourceNodes);\n    \n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          if (p.blockpools.size() \u003d\u003d 0\n              || p.blockpools.contains(nnc.getBlockpoolID())) {\n            final Balancer b \u003d new Balancer(nnc, p, conf);\n            final Result r \u003d b.runOneIteration();\n            r.print(iteration, System.out);\n\n            // clean all lists\n            b.resetData(conf);\n            if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n              done \u003d false;\n            } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n              // must be an error statue, return.\n              return r.exitStatus.getExitCode();\n            }\n\n            if (!done) {\n              Thread.sleep(sleeptime);\n            }\n          } else {\n            LOG.info(\"Skipping blockpool \" + nnc.getBlockpoolID());\n          }\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "7ecbfd44aa57f5f54c214b7fdedda2500be76f51": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8826. In Balancer, add an option to specify the source node list so that balancer only selects blocks to move from those nodes.\n",
      "commitDate": "18/08/15 7:25 PM",
      "commitName": "7ecbfd44aa57f5f54c214b7fdedda2500be76f51",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "17/08/15 5:55 PM",
      "commitNameOld": "51a00964da0e399718d1cec25ff692a32d7642b7",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 1.06,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,50 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n+    LOG.info(\"included nodes \u003d \" + p.includedNodes);\n+    LOG.info(\"excluded nodes \u003d \" + p.excludedNodes);\n+    LOG.info(\"source nodes \u003d \" + p.sourceNodes);\n     \n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n             Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final Result r \u003d b.runOneIteration();\n           r.print(iteration, System.out);\n \n           // clean all lists\n           b.resetData(conf);\n           if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.exitStatus.getExitCode();\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    LOG.info(\"included nodes \u003d \" + p.includedNodes);\n    LOG.info(\"excluded nodes \u003d \" + p.excludedNodes);\n    LOG.info(\"source nodes \u003d \" + p.sourceNodes);\n    \n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final Result r \u003d b.runOneIteration();\n          r.print(iteration, System.out);\n\n          // clean all lists\n          b.resetData(conf);\n          if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.exitStatus.getExitCode();\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "b94c1117a28e996adee68fe0e181eb6f536289f4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-316. Balancer should run for a configurable # of iterations (Xiaoyu Yao via aw)\n",
      "commitDate": "11/02/15 8:10 AM",
      "commitName": "b94c1117a28e996adee68fe0e181eb6f536289f4",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "06/11/14 5:48 PM",
      "commitNameOld": "ae71a671a3b4b454aa393c2974b6f1f16dd61405",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 96.6,
      "commitsBetweenForRepo": 668,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     \n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n-            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf);\n+            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final Result r \u003d b.runOneIteration();\n           r.print(iteration, System.out);\n \n           // clean all lists\n           b.resetData(conf);\n           if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.exitStatus.getExitCode();\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    \n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf, p.maxIdleIteration);\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final Result r \u003d b.runOneIteration();\n          r.print(iteration, System.out);\n\n          // clean all lists\n          b.resetData(conf);\n          if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.exitStatus.getExitCode();\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "ae71a671a3b4b454aa393c2974b6f1f16dd61405": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7364. Balancer always shows zero Bytes Already Moved. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "06/11/14 5:48 PM",
      "commitName": "ae71a671a3b4b454aa393c2974b6f1f16dd61405",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/09/14 9:08 PM",
      "commitNameOld": "e8e7fbe81abc64a9ae3d2f3f62c088426073b2bf",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 42.9,
      "commitsBetweenForRepo": 426,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,47 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d\n         conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n             DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n         conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n             DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     \n-    final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n       connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n             Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf);\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n-          final ExitStatus r \u003d b.run(iteration, formatter, conf);\n+          final Result r \u003d b.runOneIteration();\n+          r.print(iteration, System.out);\n+\n           // clean all lists\n           b.resetData(conf);\n-          if (r \u003d\u003d ExitStatus.IN_PROGRESS) {\n+          if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n             done \u003d false;\n-          } else if (r !\u003d ExitStatus.SUCCESS) {\n+          } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n             //must be an error statue, return.\n-            return r.getExitCode();\n+            return r.exitStatus.getExitCode();\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    \n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf);\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final Result r \u003d b.runOneIteration();\n          r.print(iteration, System.out);\n\n          // clean all lists\n          b.resetData(conf);\n          if (r.exitStatus \u003d\u003d ExitStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r.exitStatus !\u003d ExitStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.exitStatus.getExitCode();\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "2749fc677c295e4ac5f4b1ebd5dbd6092370a857": {
      "type": "Ybodychange",
      "commitMessage": "Newly moved block replica been invalidated and deleted in TestBalancer. Contributed by Binglin Chang.\n",
      "commitDate": "09/09/14 11:32 AM",
      "commitName": "2749fc677c295e4ac5f4b1ebd5dbd6092370a857",
      "commitAuthor": "cnauroth",
      "commitDateOld": "11/08/14 11:01 AM",
      "commitNameOld": "e60673697d5046c29c52bbabdfe80506f99773e4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 29.02,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,51 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n-    final long sleeptime \u003d 2000*conf.getLong(\n-        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n-        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n+    final long sleeptime \u003d\n+        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n+            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n+        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n+            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n       for (URI uri : namenodes) {\n         final NameNodeConnector nnc \u003d new NameNodeConnector(\n             Balancer.class.getSimpleName(), uri, BALANCER_ID_PATH, conf);\n         nnc.getKeyManager().startBlockKeyUpdater();\n         connectors.add(nnc);\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ExitStatus r \u003d b.run(iteration, formatter, conf);\n           // clean all lists\n           b.resetData(conf);\n           if (r \u003d\u003d ExitStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ExitStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.getExitCode();\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d\n        conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n            DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 +\n        conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,\n            DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        final NameNodeConnector nnc \u003d new NameNodeConnector(\n            Balancer.class.getSimpleName(), uri, BALANCER_ID_PATH, conf);\n        nnc.getKeyManager().startBlockKeyUpdater();\n        connectors.add(nnc);\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ExitStatus r \u003d b.run(iteration, formatter, conf);\n          // clean all lists\n          b.resetData(conf);\n          if (r \u003d\u003d ExitStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ExitStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.getExitCode();\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "5d5aae0694bc27df5b9fa50819854cd3050a8658": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6801. Archival Storage: Add a new data migration tool. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1618675 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/14 10:51 AM",
      "commitName": "5d5aae0694bc27df5b9fa50819854cd3050a8658",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "11/08/14 11:01 AM",
      "commitNameOld": "e60673697d5046c29c52bbabdfe80506f99773e4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 6.99,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,44 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n-    final List\u003cNameNodeConnector\u003e connectors\n-        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n+    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n     try {\n-      for (URI uri : namenodes) {\n-        final NameNodeConnector nnc \u003d new NameNodeConnector(\n-            Balancer.class.getSimpleName(), uri, BALANCER_ID_PATH, conf);\n-        nnc.getKeyManager().startBlockKeyUpdater();\n-        connectors.add(nnc);\n-      }\n+      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n+            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf);\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ExitStatus r \u003d b.run(iteration, formatter, conf);\n           // clean all lists\n           b.resetData(conf);\n           if (r \u003d\u003d ExitStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ExitStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.getExitCode();\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n-        nnc.close();\n+        IOUtils.cleanup(LOG, nnc);\n       }\n     }\n     return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    List\u003cNameNodeConnector\u003e connectors \u003d Collections.emptyList();\n    try {\n      connectors \u003d NameNodeConnector.newNameNodeConnectors(namenodes, \n            Balancer.class.getSimpleName(), BALANCER_ID_PATH, conf);\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ExitStatus r \u003d b.run(iteration, formatter, conf);\n          // clean all lists\n          b.resetData(conf);\n          if (r \u003d\u003d ExitStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ExitStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.getExitCode();\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        IOUtils.cleanup(LOG, nnc);\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "e60673697d5046c29c52bbabdfe80506f99773e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6837. Code cleanup for Balancer and Dispatcher. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617337 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 11:01 AM",
      "commitName": "e60673697d5046c29c52bbabdfe80506f99773e4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "08/08/14 2:33 PM",
      "commitNameOld": "c3cf331dc91e2beef2afeed11105084843b02858",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.85,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes  \u003d \" + namenodes);\n     LOG.info(\"parameters \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n       for (URI uri : namenodes) {\n         final NameNodeConnector nnc \u003d new NameNodeConnector(\n             Balancer.class.getSimpleName(), uri, BALANCER_ID_PATH, conf);\n         nnc.getKeyManager().startBlockKeyUpdater();\n         connectors.add(nnc);\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n-          final ReturnStatus r \u003d b.run(iteration, formatter, conf);\n+          final ExitStatus r \u003d b.run(iteration, formatter, conf);\n           // clean all lists\n           b.resetData(conf);\n-          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n+          if (r \u003d\u003d ExitStatus.IN_PROGRESS) {\n             done \u003d false;\n-          } else if (r !\u003d ReturnStatus.SUCCESS) {\n+          } else if (r !\u003d ExitStatus.SUCCESS) {\n             //must be an error statue, return.\n-            return r.code;\n+            return r.getExitCode();\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n-    return ReturnStatus.SUCCESS.code;\n+    return ExitStatus.SUCCESS.getExitCode();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        final NameNodeConnector nnc \u003d new NameNodeConnector(\n            Balancer.class.getSimpleName(), uri, BALANCER_ID_PATH, conf);\n        nnc.getKeyManager().startBlockKeyUpdater();\n        connectors.add(nnc);\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ExitStatus r \u003d b.run(iteration, formatter, conf);\n          // clean all lists\n          b.resetData(conf);\n          if (r \u003d\u003d ExitStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ExitStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.getExitCode();\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ExitStatus.SUCCESS.getExitCode();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "83b9933db3349e6a6faf23bce35c9d4ce3f7bcf2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6809. Move Balancer\u0027s inner classes MovedBlocks and Matcher as to standalone classes and separates KeyManager from NameNodeConnector.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616422 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/14 12:18 AM",
      "commitName": "83b9933db3349e6a6faf23bce35c9d4ce3f7bcf2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/08/14 7:12 AM",
      "commitNameOld": "7e12b1912f8cdbe6d88ac0b8eb71d7c4dc1bf78e",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 5.71,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,49 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n-    LOG.info(\"namenodes \u003d \" + namenodes);\n-    LOG.info(\"p         \u003d \" + p);\n+    LOG.info(\"namenodes  \u003d \" + namenodes);\n+    LOG.info(\"parameters \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n       for (URI uri : namenodes) {\n-        connectors.add(new NameNodeConnector(uri, conf));\n+        final NameNodeConnector nnc \u003d new NameNodeConnector(\n+            Balancer.class.getSimpleName(), uri, BALANCER_ID_PATH, conf);\n+        nnc.getKeyManager().startBlockKeyUpdater();\n+        connectors.add(nnc);\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter, conf);\n           // clean all lists\n           b.resetData(conf);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes  \u003d \" + namenodes);\n    LOG.info(\"parameters \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        final NameNodeConnector nnc \u003d new NameNodeConnector(\n            Balancer.class.getSimpleName(), uri, BALANCER_ID_PATH, conf);\n        nnc.getKeyManager().startBlockKeyUpdater();\n        connectors.add(nnc);\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter, conf);\n          // clean all lists\n          b.resetData(conf);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "eae2a304624ee6caaa8591999752be2bba2b89e0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4261. Fix bugs in Balaner causing infinite loop and TestBalancerWithNodeGroup timeing out.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 7:55 AM",
      "commitName": "eae2a304624ee6caaa8591999752be2bba2b89e0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/01/13 1:05 PM",
      "commitNameOld": "5cdb7e5ce7f0c3129749be8f29e2f11c0e0f2269",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,46 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n       for (URI uri : namenodes) {\n         connectors.add(new NameNodeConnector(uri, conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter, conf);\n+          // clean all lists\n+          b.resetData(conf);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        connectors.add(new NameNodeConnector(uri, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter, conf);\n          // clean all lists\n          b.resetData(conf);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "1634e980af422c0af2f7c9c7280a77f2fbddc9c0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3495. Update Balancer to support new NetworkTopology with NodeGroup.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1414874 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/11/12 11:19 AM",
      "commitName": "1634e980af422c0af2f7c9c7280a77f2fbddc9c0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "14/08/12 5:28 PM",
      "commitNameOld": "28e87740c5797e87a9038d7f151c8b21a5b04592",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 105.79,
      "commitsBetweenForRepo": 628,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n       for (URI uri : namenodes) {\n         connectors.add(new NameNodeConnector(uri, conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n-          final ReturnStatus r \u003d b.run(iteration, formatter);\n+          final ReturnStatus r \u003d b.run(iteration, formatter, conf);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        connectors.add(new NameNodeConnector(uri, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter, conf);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "0d7de507a5d6e9292aeabe357fab6976f81f5be4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2979. Balancer should use logical uri for creating failover proxy with HA enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295473 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/03/12 12:50 AM",
      "commitName": "0d7de507a5d6e9292aeabe357fab6976f81f5be4",
      "commitAuthor": "Aaron Myers",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2979. Balancer should use logical uri for creating failover proxy with HA enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295473 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/03/12 12:50 AM",
          "commitName": "0d7de507a5d6e9292aeabe357fab6976f81f5be4",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "29/02/12 11:03 PM",
          "commitNameOld": "9318ff425019b9f88e154a80f3aeb23e6c69cb69",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,44 @@\n-  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n-      final Parameters p,\n+  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n-          namenodes.entrySet()) {\n-        connectors.add(\n-            new NameNodeConnector(entry.getValue().values(), conf));\n+      for (URI uri : namenodes) {\n+        connectors.add(new NameNodeConnector(uri, conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        connectors.add(new NameNodeConnector(uri, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "[namenodes-Map\u003cString,Map\u003cString,InetSocketAddress\u003e\u003e, p-Parameters(modifiers-final), conf-Configuration]",
            "newValue": "[namenodes-Collection\u003cURI\u003e, p-Parameters(modifiers-final), conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2979. Balancer should use logical uri for creating failover proxy with HA enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295473 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/03/12 12:50 AM",
          "commitName": "0d7de507a5d6e9292aeabe357fab6976f81f5be4",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "29/02/12 11:03 PM",
          "commitNameOld": "9318ff425019b9f88e154a80f3aeb23e6c69cb69",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,44 @@\n-  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n-      final Parameters p,\n+  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n-          namenodes.entrySet()) {\n-        connectors.add(\n-            new NameNodeConnector(entry.getValue().values(), conf));\n+      for (URI uri : namenodes) {\n+        connectors.add(new NameNodeConnector(uri, conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        connectors.add(new NameNodeConnector(uri, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {}
        }
      ]
    },
    "9318ff425019b9f88e154a80f3aeb23e6c69cb69": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert commit of HDFS-2979.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295435 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/02/12 11:03 PM",
      "commitName": "9318ff425019b9f88e154a80f3aeb23e6c69cb69",
      "commitAuthor": "Aaron Myers",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert commit of HDFS-2979.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295435 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/02/12 11:03 PM",
          "commitName": "9318ff425019b9f88e154a80f3aeb23e6c69cb69",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "29/02/12 3:42 PM",
          "commitNameOld": "01b17c40cf20df576fb18315c2019645d5050ddf",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.31,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,47 @@\n-  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n+  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n+      final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for (URI uri : namenodes) {\n-        connectors.add(new NameNodeConnector(uri, conf));\n+      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n+          namenodes.entrySet()) {\n+        connectors.add(\n+            new NameNodeConnector(entry.getValue().values(), conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n      final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n          namenodes.entrySet()) {\n        connectors.add(\n            new NameNodeConnector(entry.getValue().values(), conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "[namenodes-Collection\u003cURI\u003e, p-Parameters(modifiers-final), conf-Configuration]",
            "newValue": "[namenodes-Map\u003cString,Map\u003cString,InetSocketAddress\u003e\u003e, p-Parameters(modifiers-final), conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert commit of HDFS-2979.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295435 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/02/12 11:03 PM",
          "commitName": "9318ff425019b9f88e154a80f3aeb23e6c69cb69",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "29/02/12 3:42 PM",
          "commitNameOld": "01b17c40cf20df576fb18315c2019645d5050ddf",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.31,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,47 @@\n-  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n+  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n+      final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for (URI uri : namenodes) {\n-        connectors.add(new NameNodeConnector(uri, conf));\n+      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n+          namenodes.entrySet()) {\n+        connectors.add(\n+            new NameNodeConnector(entry.getValue().values(), conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n      final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n          namenodes.entrySet()) {\n        connectors.add(\n            new NameNodeConnector(entry.getValue().values(), conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {}
        }
      ]
    },
    "01b17c40cf20df576fb18315c2019645d5050ddf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2979. Balancer should use logical uri for creating failover proxy with HA enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295340 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/02/12 3:42 PM",
      "commitName": "01b17c40cf20df576fb18315c2019645d5050ddf",
      "commitAuthor": "Aaron Myers",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2979. Balancer should use logical uri for creating failover proxy with HA enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295340 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/02/12 3:42 PM",
          "commitName": "01b17c40cf20df576fb18315c2019645d5050ddf",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "28/11/11 6:27 PM",
          "commitNameOld": "9146ad23f3f1af7c5547fba08e2a867cee49e015",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 92.89,
          "commitsBetweenForRepo": 661,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,44 @@\n-  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n-      final Parameters p,\n+  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n-          namenodes.entrySet()) {\n-        connectors.add(\n-            new NameNodeConnector(entry.getValue().values(), conf));\n+      for (URI uri : namenodes) {\n+        connectors.add(new NameNodeConnector(uri, conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        connectors.add(new NameNodeConnector(uri, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "[namenodes-Map\u003cString,Map\u003cString,InetSocketAddress\u003e\u003e, p-Parameters(modifiers-final), conf-Configuration]",
            "newValue": "[namenodes-Collection\u003cURI\u003e, p-Parameters(modifiers-final), conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2979. Balancer should use logical uri for creating failover proxy with HA enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295340 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/02/12 3:42 PM",
          "commitName": "01b17c40cf20df576fb18315c2019645d5050ddf",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "28/11/11 6:27 PM",
          "commitNameOld": "9146ad23f3f1af7c5547fba08e2a867cee49e015",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 92.89,
          "commitsBetweenForRepo": 661,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,44 @@\n-  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n-      final Parameters p,\n+  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n-          namenodes.entrySet()) {\n-        connectors.add(\n-            new NameNodeConnector(entry.getValue().values(), conf));\n+      for (URI uri : namenodes) {\n+        connectors.add(new NameNodeConnector(uri, conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Collection\u003cURI\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for (URI uri : namenodes) {\n        connectors.add(new NameNodeConnector(uri, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {}
        }
      ]
    },
    "9146ad23f3f1af7c5547fba08e2a867cee49e015": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2582. Scope dfs.ha.namenodes config by nameservice. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1207738 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/11/11 6:27 PM",
      "commitName": "9146ad23f3f1af7c5547fba08e2a867cee49e015",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2582. Scope dfs.ha.namenodes config by nameservice. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1207738 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "28/11/11 6:27 PM",
          "commitName": "9146ad23f3f1af7c5547fba08e2a867cee49e015",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "19/11/11 7:58 PM",
          "commitNameOld": "b2313021fd03d9803a04b120d97bfd91fcbd4d36",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,47 @@\n-  static int run(List\u003cInetSocketAddress\u003e namenodes, final Parameters p,\n+  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n+      final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for(InetSocketAddress isa : namenodes) {\n-        connectors.add(new NameNodeConnector(isa, conf));\n+      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n+          namenodes.entrySet()) {\n+        connectors.add(\n+            new NameNodeConnector(entry.getValue().values(), conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n      final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n          namenodes.entrySet()) {\n        connectors.add(\n            new NameNodeConnector(entry.getValue().values(), conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {
            "oldValue": "[namenodes-List\u003cInetSocketAddress\u003e, p-Parameters(modifiers-final), conf-Configuration]",
            "newValue": "[namenodes-Map\u003cString,Map\u003cString,InetSocketAddress\u003e\u003e, p-Parameters(modifiers-final), conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2582. Scope dfs.ha.namenodes config by nameservice. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1207738 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "28/11/11 6:27 PM",
          "commitName": "9146ad23f3f1af7c5547fba08e2a867cee49e015",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "19/11/11 7:58 PM",
          "commitNameOld": "b2313021fd03d9803a04b120d97bfd91fcbd4d36",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,47 @@\n-  static int run(List\u003cInetSocketAddress\u003e namenodes, final Parameters p,\n+  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n+      final Parameters p,\n       Configuration conf) throws IOException, InterruptedException {\n     final long sleeptime \u003d 2000*conf.getLong(\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n         DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n     LOG.info(\"namenodes \u003d \" + namenodes);\n     LOG.info(\"p         \u003d \" + p);\n     \n     final Formatter formatter \u003d new Formatter(System.out);\n     System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n     \n     final List\u003cNameNodeConnector\u003e connectors\n         \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n     try {\n-      for(InetSocketAddress isa : namenodes) {\n-        connectors.add(new NameNodeConnector(isa, conf));\n+      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n+          namenodes.entrySet()) {\n+        connectors.add(\n+            new NameNodeConnector(entry.getValue().values(), conf));\n       }\n     \n       boolean done \u003d false;\n       for(int iteration \u003d 0; !done; iteration++) {\n         done \u003d true;\n         Collections.shuffle(connectors);\n         for(NameNodeConnector nnc : connectors) {\n           final Balancer b \u003d new Balancer(nnc, p, conf);\n           final ReturnStatus r \u003d b.run(iteration, formatter);\n           if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n             done \u003d false;\n           } else if (r !\u003d ReturnStatus.SUCCESS) {\n             //must be an error statue, return.\n             return r.code;\n           }\n         }\n \n         if (!done) {\n           Thread.sleep(sleeptime);\n         }\n       }\n     } finally {\n       for(NameNodeConnector nnc : connectors) {\n         nnc.close();\n       }\n     }\n     return ReturnStatus.SUCCESS.code;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static int run(Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e namenodes,\n      final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for(Entry\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e entry :\n          namenodes.entrySet()) {\n        connectors.add(\n            new NameNodeConnector(entry.getValue().values(), conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  static int run(List\u003cInetSocketAddress\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for(InetSocketAddress isa : namenodes) {\n        connectors.add(new NameNodeConnector(isa, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  static int run(List\u003cInetSocketAddress\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for(InetSocketAddress isa : namenodes) {\n        connectors.add(new NameNodeConnector(isa, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,44 @@\n+  static int run(List\u003cInetSocketAddress\u003e namenodes, final Parameters p,\n+      Configuration conf) throws IOException, InterruptedException {\n+    final long sleeptime \u003d 2000*conf.getLong(\n+        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n+        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n+    LOG.info(\"namenodes \u003d \" + namenodes);\n+    LOG.info(\"p         \u003d \" + p);\n+    \n+    final Formatter formatter \u003d new Formatter(System.out);\n+    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n+    \n+    final List\u003cNameNodeConnector\u003e connectors\n+        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n+    try {\n+      for(InetSocketAddress isa : namenodes) {\n+        connectors.add(new NameNodeConnector(isa, conf));\n+      }\n+    \n+      boolean done \u003d false;\n+      for(int iteration \u003d 0; !done; iteration++) {\n+        done \u003d true;\n+        Collections.shuffle(connectors);\n+        for(NameNodeConnector nnc : connectors) {\n+          final Balancer b \u003d new Balancer(nnc, p, conf);\n+          final ReturnStatus r \u003d b.run(iteration, formatter);\n+          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n+            done \u003d false;\n+          } else if (r !\u003d ReturnStatus.SUCCESS) {\n+            //must be an error statue, return.\n+            return r.code;\n+          }\n+        }\n+\n+        if (!done) {\n+          Thread.sleep(sleeptime);\n+        }\n+      }\n+    } finally {\n+      for(NameNodeConnector nnc : connectors) {\n+        nnc.close();\n+      }\n+    }\n+    return ReturnStatus.SUCCESS.code;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static int run(List\u003cInetSocketAddress\u003e namenodes, final Parameters p,\n      Configuration conf) throws IOException, InterruptedException {\n    final long sleeptime \u003d 2000*conf.getLong(\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,\n        DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT);\n    LOG.info(\"namenodes \u003d \" + namenodes);\n    LOG.info(\"p         \u003d \" + p);\n    \n    final Formatter formatter \u003d new Formatter(System.out);\n    System.out.println(\"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved\");\n    \n    final List\u003cNameNodeConnector\u003e connectors\n        \u003d new ArrayList\u003cNameNodeConnector\u003e(namenodes.size());\n    try {\n      for(InetSocketAddress isa : namenodes) {\n        connectors.add(new NameNodeConnector(isa, conf));\n      }\n    \n      boolean done \u003d false;\n      for(int iteration \u003d 0; !done; iteration++) {\n        done \u003d true;\n        Collections.shuffle(connectors);\n        for(NameNodeConnector nnc : connectors) {\n          final Balancer b \u003d new Balancer(nnc, p, conf);\n          final ReturnStatus r \u003d b.run(iteration, formatter);\n          if (r \u003d\u003d ReturnStatus.IN_PROGRESS) {\n            done \u003d false;\n          } else if (r !\u003d ReturnStatus.SUCCESS) {\n            //must be an error statue, return.\n            return r.code;\n          }\n        }\n\n        if (!done) {\n          Thread.sleep(sleeptime);\n        }\n      }\n    } finally {\n      for(NameNodeConnector nnc : connectors) {\n        nnc.close();\n      }\n    }\n    return ReturnStatus.SUCCESS.code;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
    }
  }
}