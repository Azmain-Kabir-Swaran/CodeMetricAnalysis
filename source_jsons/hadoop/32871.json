{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerLaunch.java",
  "functionName": "sanitizeEnv",
  "functionId": "sanitizeEnv___environment-Map__String,String____pwd-Path__appDirs-List__Path____userLocalDirs-List__String____containerLogDirs-List__String____resources-Map__Path,List__String______nmPrivateClasspathJarDir-Path__nmVars-Set__String__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
  "functionStartLine": 1564,
  "functionEndLine": 1650,
  "numCommitsSeen": 416,
  "timeTaken": 13190,
  "changeHistory": [
    "be539690477f7fee8f836bf3612cbe7ff6a3506e",
    "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0",
    "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
    "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf",
    "8013475d447a8377b5aed858208bf8b91dd32366",
    "682ea21f2bbc587e1b727b3c895c2f513a908432",
    "12eaae383ad06de8f9959241b2451dec82cf9ceb",
    "7eb8499996869cdb63743f1c9eca2ba91d57ad08",
    "3860be7961580ac20dd505d665b580f0a04ac4f8",
    "a3c44195bed724c02bb76859fe2690d6a9e8f2e9",
    "729d05f5293acf63e7e4aa3bfbf29b999c9a2906",
    "74a61438ca01e2191b54000af73b654a2d0b8253",
    "58e18508018081b5b5aa7c12cc5af386146cd26b",
    "1ff27f9d12e8124c1b9a722708264c5b07fd0fde",
    "4102e5882e17b75507ae5cf8b8979485b3e24cbc",
    "0f95921447ea547bdf9caf18f7fde46bc66031f8",
    "06b797947c980d7d21864eb8b700cf565756aac1",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769",
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
    "49afc64cd469bc3a775c18e0458661e39270b7a5",
    "4047ad72cffa03ba8383f4448a0f921a3d4fcdf2",
    "29a370872435ee558fbeb9f64bf70da87f8cd27a",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
    "92fb7cdcdeedf2a68b127667ced2633dae22f970",
    "638801cce16fc1dc3259c541dc30a599faaddda1",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "c1d90772b6e38bb4e4be7ed75cb5d34f3048ad7b",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940"
  ],
  "changeHistoryShort": {
    "be539690477f7fee8f836bf3612cbe7ff6a3506e": "Ybodychange",
    "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0": "Ybodychange",
    "d69b31f7f70f296ddd180e004fa0f827c2f737f2": "Ymultichange(Yparameterchange,Ybodychange)",
    "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf": "Ymultichange(Yparameterchange,Ybodychange)",
    "8013475d447a8377b5aed858208bf8b91dd32366": "Ymultichange(Yparameterchange,Ybodychange)",
    "682ea21f2bbc587e1b727b3c895c2f513a908432": "Ybodychange",
    "12eaae383ad06de8f9959241b2451dec82cf9ceb": "Ybodychange",
    "7eb8499996869cdb63743f1c9eca2ba91d57ad08": "Ybodychange",
    "3860be7961580ac20dd505d665b580f0a04ac4f8": "Ybodychange",
    "a3c44195bed724c02bb76859fe2690d6a9e8f2e9": "Ybodychange",
    "729d05f5293acf63e7e4aa3bfbf29b999c9a2906": "Ybodychange",
    "74a61438ca01e2191b54000af73b654a2d0b8253": "Ybodychange",
    "58e18508018081b5b5aa7c12cc5af386146cd26b": "Ymultichange(Yparameterchange,Ybodychange)",
    "1ff27f9d12e8124c1b9a722708264c5b07fd0fde": "Ybodychange",
    "4102e5882e17b75507ae5cf8b8979485b3e24cbc": "Ybodychange",
    "0f95921447ea547bdf9caf18f7fde46bc66031f8": "Ybodychange",
    "06b797947c980d7d21864eb8b700cf565756aac1": "Ybodychange",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": "Ymultichange(Yparameterchange,Ybodychange)",
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5": "Ybodychange",
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769": "Ybodychange",
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb": "Ybodychange",
    "49afc64cd469bc3a775c18e0458661e39270b7a5": "Ybodychange",
    "4047ad72cffa03ba8383f4448a0f921a3d4fcdf2": "Ybodychange",
    "29a370872435ee558fbeb9f64bf70da87f8cd27a": "Ymultichange(Yparameterchange,Ybodychange)",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "edcfd4527ca93acdf54403aafaa070b17aff5dd0": "Ymultichange(Yparameterchange,Ybodychange)",
    "92fb7cdcdeedf2a68b127667ced2633dae22f970": "Ybodychange",
    "638801cce16fc1dc3259c541dc30a599faaddda1": "Ymultichange(Yexceptionschange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "c1d90772b6e38bb4e4be7ed75cb5d34f3048ad7b": "Ybodychange",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": "Yintroduced"
  },
  "changeHistoryDetails": {
    "be539690477f7fee8f836bf3612cbe7ff6a3506e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8071. Add ability to specify nodemanager environment variables individually. Contributed by Jim Brennan\n",
      "commitDate": "16/05/18 2:17 PM",
      "commitName": "be539690477f7fee8f836bf3612cbe7ff6a3506e",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "11/05/18 4:56 PM",
      "commitNameOld": "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 4.89,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,87 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir,\n       Set\u003cString\u003e nmVars) throws IOException {\n     // Based on discussion in YARN-7654, for ENTRY_POINT enabled\n     // docker container, we forward user defined environment variables\n     // without node manager environment variables.  This is the reason\n     // that we skip sanitizeEnv method.\n     boolean overrideDisable \u003d Boolean.parseBoolean(\n         environment.get(\n             Environment.\n                 YARN_CONTAINER_RUNTIME_DOCKER_RUN_OVERRIDE_DISABLE.\n                     name()));\n     if (overrideDisable) {\n       environment.remove(\"WORK_DIR\");\n       return;\n     }\n \n     /**\n      * Non-modifiable environment variables\n      */\n \n     addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n         container.getContainerId().toString());\n \n     addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n         this.context.getNodeId().getHost());\n \n     addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n         StringUtils.join(\",\", userLocalDirs));\n \n     addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     addToEnvMap(environment, nmVars, Environment.USER.name(),\n         container.getUser());\n \n     addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n         container.getUser());\n \n     addToEnvMap(environment, nmVars, Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n \n     addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n \n     if (!Shell.WINDOWS) {\n       addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n     }\n \n-    // variables here will be forced in, even if the container has specified them.\n-    String nmAdminUserEnv \u003d conf.get(\n-        YarnConfiguration.NM_ADMIN_USER_ENV,\n-        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n-    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n-    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n-        File.pathSeparator));\n+    // variables here will be forced in, even if the container has\n+    // specified them.\n+    String defEnvStr \u003d conf.get(YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n+    Apps.setEnvFromInputProperty(environment,\n+        YarnConfiguration.NM_ADMIN_USER_ENV, defEnvStr, conf,\n+        File.pathSeparator);\n+    nmVars.addAll(Apps.getEnvVarsFromInputProperty(\n+        YarnConfiguration.NM_ADMIN_USER_ENV, defEnvStr, conf));\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n       nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir,\n      Set\u003cString\u003e nmVars) throws IOException {\n    // Based on discussion in YARN-7654, for ENTRY_POINT enabled\n    // docker container, we forward user defined environment variables\n    // without node manager environment variables.  This is the reason\n    // that we skip sanitizeEnv method.\n    boolean overrideDisable \u003d Boolean.parseBoolean(\n        environment.get(\n            Environment.\n                YARN_CONTAINER_RUNTIME_DOCKER_RUN_OVERRIDE_DISABLE.\n                    name()));\n    if (overrideDisable) {\n      environment.remove(\"WORK_DIR\");\n      return;\n    }\n\n    /**\n     * Non-modifiable environment variables\n     */\n\n    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n        container.getContainerId().toString());\n\n    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n        this.context.getNodeId().getHost());\n\n    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n        StringUtils.join(\",\", userLocalDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    addToEnvMap(environment, nmVars, Environment.USER.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n\n    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n\n    if (!Shell.WINDOWS) {\n      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has\n    // specified them.\n    String defEnvStr \u003d conf.get(YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n    Apps.setEnvFromInputProperty(environment,\n        YarnConfiguration.NM_ADMIN_USER_ENV, defEnvStr, conf,\n        File.pathSeparator);\n    nmVars.addAll(Apps.getEnvVarsFromInputProperty(\n        YarnConfiguration.NM_ADMIN_USER_ENV, defEnvStr, conf));\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7654. Support ENTRY_POINT for docker container. Contributed by Eric Yang\n",
      "commitDate": "11/05/18 4:56 PM",
      "commitName": "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "02/05/18 5:07 PM",
      "commitNameOld": "f4d280f02b557885cd5e5cf36abc36eb579ccfb4",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.99,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,86 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir,\n       Set\u003cString\u003e nmVars) throws IOException {\n+    // Based on discussion in YARN-7654, for ENTRY_POINT enabled\n+    // docker container, we forward user defined environment variables\n+    // without node manager environment variables.  This is the reason\n+    // that we skip sanitizeEnv method.\n+    boolean overrideDisable \u003d Boolean.parseBoolean(\n+        environment.get(\n+            Environment.\n+                YARN_CONTAINER_RUNTIME_DOCKER_RUN_OVERRIDE_DISABLE.\n+                    name()));\n+    if (overrideDisable) {\n+      environment.remove(\"WORK_DIR\");\n+      return;\n+    }\n+\n     /**\n      * Non-modifiable environment variables\n      */\n \n     addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n         container.getContainerId().toString());\n \n     addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n         this.context.getNodeId().getHost());\n \n     addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n         StringUtils.join(\",\", userLocalDirs));\n \n     addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     addToEnvMap(environment, nmVars, Environment.USER.name(),\n         container.getUser());\n \n     addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n         container.getUser());\n \n     addToEnvMap(environment, nmVars, Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n \n     addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n \n     if (!Shell.WINDOWS) {\n       addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     String nmAdminUserEnv \u003d conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n     Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n     nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n         File.pathSeparator));\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n       nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir,\n      Set\u003cString\u003e nmVars) throws IOException {\n    // Based on discussion in YARN-7654, for ENTRY_POINT enabled\n    // docker container, we forward user defined environment variables\n    // without node manager environment variables.  This is the reason\n    // that we skip sanitizeEnv method.\n    boolean overrideDisable \u003d Boolean.parseBoolean(\n        environment.get(\n            Environment.\n                YARN_CONTAINER_RUNTIME_DOCKER_RUN_OVERRIDE_DISABLE.\n                    name()));\n    if (overrideDisable) {\n      environment.remove(\"WORK_DIR\");\n      return;\n    }\n\n    /**\n     * Non-modifiable environment variables\n     */\n\n    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n        container.getContainerId().toString());\n\n    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n        this.context.getNodeId().getHost());\n\n    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n        StringUtils.join(\",\", userLocalDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    addToEnvMap(environment, nmVars, Environment.USER.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n\n    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n\n    if (!Shell.WINDOWS) {\n      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    String nmAdminUserEnv \u003d conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n        File.pathSeparator));\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "d69b31f7f70f296ddd180e004fa0f827c2f737f2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
      "commitDate": "07/03/18 7:20 AM",
      "commitName": "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
          "commitDate": "07/03/18 7:20 AM",
          "commitName": "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "23/02/18 1:46 PM",
          "commitNameOld": "8e728f39c961f034369b43e087d68d01aa4a0e7d",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 11.73,
          "commitsBetweenForRepo": 80,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,72 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n-      containerLogDirs,\n-      Map\u003cPath, List\u003cString\u003e\u003e resources,\n-      Path nmPrivateClasspathJarDir) throws IOException {\n+      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir,\n+      Set\u003cString\u003e nmVars) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n-    environment.put(Environment.CONTAINER_ID.name(), container\n-        .getContainerId().toString());\n+    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n+        container.getContainerId().toString());\n \n-    environment.put(Environment.NM_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n-    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n-      .getHost());\n+    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n+        this.context.getNodeId().getHost());\n \n-    environment.put(Environment.NM_HTTP_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n-    environment.put(Environment.LOCAL_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n-    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n-        userLocalDirs));\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n+        StringUtils.join(\",\", userLocalDirs));\n \n-    environment.put(Environment.LOG_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n-    environment.put(Environment.USER.name(), container.getUser());\n-    \n-    environment.put(Environment.LOGNAME.name(), container.getUser());\n+    addToEnvMap(environment, nmVars, Environment.USER.name(),\n+        container.getUser());\n \n-    environment.put(Environment.HOME.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n+        container.getUser());\n+\n+    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n-    \n-    environment.put(Environment.PWD.name(), pwd.toString());\n-    \n-    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n+\n+    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n \n     if (!Shell.WINDOWS) {\n-      environment.put(\"JVM_PID\", \"$$\");\n+      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n-    Apps.setEnvFromInputString(environment, conf.get(\n-      YarnConfiguration.NM_ADMIN_USER_ENV,\n-      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n+    String nmAdminUserEnv \u003d conf.get(\n+        YarnConfiguration.NM_ADMIN_USER_ENV,\n+        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n+    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n+    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n+        File.pathSeparator));\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n+      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir,\n      Set\u003cString\u003e nmVars) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n        container.getContainerId().toString());\n\n    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n        this.context.getNodeId().getHost());\n\n    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n        StringUtils.join(\",\", userLocalDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    addToEnvMap(environment, nmVars, Environment.USER.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n\n    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n\n    if (!Shell.WINDOWS) {\n      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    String nmAdminUserEnv \u003d conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n        File.pathSeparator));\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, userLocalDirs-List\u003cString\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path]",
            "newValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, userLocalDirs-List\u003cString\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path, nmVars-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
          "commitDate": "07/03/18 7:20 AM",
          "commitName": "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "23/02/18 1:46 PM",
          "commitNameOld": "8e728f39c961f034369b43e087d68d01aa4a0e7d",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 11.73,
          "commitsBetweenForRepo": 80,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,72 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n-      containerLogDirs,\n-      Map\u003cPath, List\u003cString\u003e\u003e resources,\n-      Path nmPrivateClasspathJarDir) throws IOException {\n+      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir,\n+      Set\u003cString\u003e nmVars) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n-    environment.put(Environment.CONTAINER_ID.name(), container\n-        .getContainerId().toString());\n+    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n+        container.getContainerId().toString());\n \n-    environment.put(Environment.NM_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n-    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n-      .getHost());\n+    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n+        this.context.getNodeId().getHost());\n \n-    environment.put(Environment.NM_HTTP_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n-    environment.put(Environment.LOCAL_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n-    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n-        userLocalDirs));\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n+        StringUtils.join(\",\", userLocalDirs));\n \n-    environment.put(Environment.LOG_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n-    environment.put(Environment.USER.name(), container.getUser());\n-    \n-    environment.put(Environment.LOGNAME.name(), container.getUser());\n+    addToEnvMap(environment, nmVars, Environment.USER.name(),\n+        container.getUser());\n \n-    environment.put(Environment.HOME.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n+        container.getUser());\n+\n+    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n-    \n-    environment.put(Environment.PWD.name(), pwd.toString());\n-    \n-    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n+\n+    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n \n     if (!Shell.WINDOWS) {\n-      environment.put(\"JVM_PID\", \"$$\");\n+      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n-    Apps.setEnvFromInputString(environment, conf.get(\n-      YarnConfiguration.NM_ADMIN_USER_ENV,\n-      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n+    String nmAdminUserEnv \u003d conf.get(\n+        YarnConfiguration.NM_ADMIN_USER_ENV,\n+        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n+    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n+    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n+        File.pathSeparator));\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n+      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir,\n      Set\u003cString\u003e nmVars) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n        container.getContainerId().toString());\n\n    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n        this.context.getNodeId().getHost());\n\n    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n        StringUtils.join(\",\", userLocalDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    addToEnvMap(environment, nmVars, Environment.USER.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n\n    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n\n    if (!Shell.WINDOWS) {\n      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    String nmAdminUserEnv \u003d conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n        File.pathSeparator));\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert \"YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\"\n\nThis reverts commit 8013475d447a8377b5aed858208bf8b91dd32366.\n",
      "commitDate": "19/02/18 6:16 AM",
      "commitName": "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert \"YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\"\n\nThis reverts commit 8013475d447a8377b5aed858208bf8b91dd32366.\n",
          "commitDate": "19/02/18 6:16 AM",
          "commitName": "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "15/02/18 3:09 PM",
          "commitNameOld": "8013475d447a8377b5aed858208bf8b91dd32366",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 3.63,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,68 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n-      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n-      Path nmPrivateClasspathJarDir,\n-      Set\u003cString\u003e nmVars) throws IOException {\n+      containerLogDirs,\n+      Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n-    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n-        container.getContainerId().toString());\n+    environment.put(Environment.CONTAINER_ID.name(), container\n+        .getContainerId().toString());\n \n-    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n+    environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n-    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n-        this.context.getNodeId().getHost());\n+    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n+      .getHost());\n \n-    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n+    environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n-    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n+    environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n-    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n-        StringUtils.join(\",\", userLocalDirs));\n+    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n+        userLocalDirs));\n \n-    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n+    environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n-    addToEnvMap(environment, nmVars, Environment.USER.name(),\n-        container.getUser());\n+    environment.put(Environment.USER.name(), container.getUser());\n+    \n+    environment.put(Environment.LOGNAME.name(), container.getUser());\n \n-    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n-        container.getUser());\n-\n-    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n+    environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n-\n-    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n+    \n+    environment.put(Environment.PWD.name(), pwd.toString());\n+    \n+    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n \n     if (!Shell.WINDOWS) {\n-      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n+      environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n-    String nmAdminUserEnv \u003d conf.get(\n-        YarnConfiguration.NM_ADMIN_USER_ENV,\n-        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n-    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n-    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n-        File.pathSeparator));\n+    Apps.setEnvFromInputString(environment, conf.get(\n+      YarnConfiguration.NM_ADMIN_USER_ENV,\n+      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n-      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, userLocalDirs-List\u003cString\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path, nmVars-Set\u003cString\u003e]",
            "newValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, userLocalDirs-List\u003cString\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\"\n\nThis reverts commit 8013475d447a8377b5aed858208bf8b91dd32366.\n",
          "commitDate": "19/02/18 6:16 AM",
          "commitName": "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "15/02/18 3:09 PM",
          "commitNameOld": "8013475d447a8377b5aed858208bf8b91dd32366",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 3.63,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,68 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n-      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n-      Path nmPrivateClasspathJarDir,\n-      Set\u003cString\u003e nmVars) throws IOException {\n+      containerLogDirs,\n+      Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n-    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n-        container.getContainerId().toString());\n+    environment.put(Environment.CONTAINER_ID.name(), container\n+        .getContainerId().toString());\n \n-    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n+    environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n-    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n-        this.context.getNodeId().getHost());\n+    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n+      .getHost());\n \n-    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n+    environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n-    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n+    environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n-    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n-        StringUtils.join(\",\", userLocalDirs));\n+    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n+        userLocalDirs));\n \n-    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n+    environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n-    addToEnvMap(environment, nmVars, Environment.USER.name(),\n-        container.getUser());\n+    environment.put(Environment.USER.name(), container.getUser());\n+    \n+    environment.put(Environment.LOGNAME.name(), container.getUser());\n \n-    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n-        container.getUser());\n-\n-    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n+    environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n-\n-    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n+    \n+    environment.put(Environment.PWD.name(), pwd.toString());\n+    \n+    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n \n     if (!Shell.WINDOWS) {\n-      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n+      environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n-    String nmAdminUserEnv \u003d conf.get(\n-        YarnConfiguration.NM_ADMIN_USER_ENV,\n-        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n-    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n-    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n-        File.pathSeparator));\n+    Apps.setEnvFromInputString(environment, conf.get(\n+      YarnConfiguration.NM_ADMIN_USER_ENV,\n+      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n-      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "8013475d447a8377b5aed858208bf8b91dd32366": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
      "commitDate": "15/02/18 3:09 PM",
      "commitName": "8013475d447a8377b5aed858208bf8b91dd32366",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
          "commitDate": "15/02/18 3:09 PM",
          "commitName": "8013475d447a8377b5aed858208bf8b91dd32366",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "07/02/18 11:09 AM",
          "commitNameOld": "456705a07c8b80658950acc99f23086244c6b20f",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 8.17,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,72 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n-      containerLogDirs,\n-      Map\u003cPath, List\u003cString\u003e\u003e resources,\n-      Path nmPrivateClasspathJarDir) throws IOException {\n+      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir,\n+      Set\u003cString\u003e nmVars) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n-    environment.put(Environment.CONTAINER_ID.name(), container\n-        .getContainerId().toString());\n+    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n+        container.getContainerId().toString());\n \n-    environment.put(Environment.NM_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n-    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n-      .getHost());\n+    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n+        this.context.getNodeId().getHost());\n \n-    environment.put(Environment.NM_HTTP_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n-    environment.put(Environment.LOCAL_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n-    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n-        userLocalDirs));\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n+        StringUtils.join(\",\", userLocalDirs));\n \n-    environment.put(Environment.LOG_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n-    environment.put(Environment.USER.name(), container.getUser());\n-    \n-    environment.put(Environment.LOGNAME.name(), container.getUser());\n+    addToEnvMap(environment, nmVars, Environment.USER.name(),\n+        container.getUser());\n \n-    environment.put(Environment.HOME.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n+        container.getUser());\n+\n+    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n-    \n-    environment.put(Environment.PWD.name(), pwd.toString());\n-    \n-    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n+\n+    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n \n     if (!Shell.WINDOWS) {\n-      environment.put(\"JVM_PID\", \"$$\");\n+      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n-    Apps.setEnvFromInputString(environment, conf.get(\n-      YarnConfiguration.NM_ADMIN_USER_ENV,\n-      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n+    String nmAdminUserEnv \u003d conf.get(\n+        YarnConfiguration.NM_ADMIN_USER_ENV,\n+        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n+    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n+    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n+        File.pathSeparator));\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n+      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir,\n      Set\u003cString\u003e nmVars) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n        container.getContainerId().toString());\n\n    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n        this.context.getNodeId().getHost());\n\n    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n        StringUtils.join(\",\", userLocalDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    addToEnvMap(environment, nmVars, Environment.USER.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n\n    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n\n    if (!Shell.WINDOWS) {\n      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    String nmAdminUserEnv \u003d conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n        File.pathSeparator));\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, userLocalDirs-List\u003cString\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path]",
            "newValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, userLocalDirs-List\u003cString\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path, nmVars-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
          "commitDate": "15/02/18 3:09 PM",
          "commitName": "8013475d447a8377b5aed858208bf8b91dd32366",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "07/02/18 11:09 AM",
          "commitNameOld": "456705a07c8b80658950acc99f23086244c6b20f",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 8.17,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,72 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n-      containerLogDirs,\n-      Map\u003cPath, List\u003cString\u003e\u003e resources,\n-      Path nmPrivateClasspathJarDir) throws IOException {\n+      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir,\n+      Set\u003cString\u003e nmVars) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n-    environment.put(Environment.CONTAINER_ID.name(), container\n-        .getContainerId().toString());\n+    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n+        container.getContainerId().toString());\n \n-    environment.put(Environment.NM_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n-    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n-      .getHost());\n+    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n+        this.context.getNodeId().getHost());\n \n-    environment.put(Environment.NM_HTTP_PORT.name(),\n+    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n-    environment.put(Environment.LOCAL_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n-    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n-        userLocalDirs));\n+    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n+        StringUtils.join(\",\", userLocalDirs));\n \n-    environment.put(Environment.LOG_DIRS.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n-    environment.put(Environment.USER.name(), container.getUser());\n-    \n-    environment.put(Environment.LOGNAME.name(), container.getUser());\n+    addToEnvMap(environment, nmVars, Environment.USER.name(),\n+        container.getUser());\n \n-    environment.put(Environment.HOME.name(),\n+    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n+        container.getUser());\n+\n+    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n-    \n-    environment.put(Environment.PWD.name(), pwd.toString());\n-    \n-    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n+\n+    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n \n     if (!Shell.WINDOWS) {\n-      environment.put(\"JVM_PID\", \"$$\");\n+      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n-    Apps.setEnvFromInputString(environment, conf.get(\n-      YarnConfiguration.NM_ADMIN_USER_ENV,\n-      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n+    String nmAdminUserEnv \u003d conf.get(\n+        YarnConfiguration.NM_ADMIN_USER_ENV,\n+        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n+    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n+    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n+        File.pathSeparator));\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n+      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs, Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir,\n      Set\u003cString\u003e nmVars) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    addToEnvMap(environment, nmVars, Environment.CONTAINER_ID.name(),\n        container.getContainerId().toString());\n\n    addToEnvMap(environment, nmVars, Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    addToEnvMap(environment, nmVars, Environment.NM_HOST.name(),\n        this.context.getNodeId().getHost());\n\n    addToEnvMap(environment, nmVars, Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOCAL_USER_DIRS.name(),\n        StringUtils.join(\",\", userLocalDirs));\n\n    addToEnvMap(environment, nmVars, Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    addToEnvMap(environment, nmVars, Environment.USER.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.LOGNAME.name(),\n        container.getUser());\n\n    addToEnvMap(environment, nmVars, Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n\n    addToEnvMap(environment, nmVars, Environment.PWD.name(), pwd.toString());\n\n    if (!Shell.WINDOWS) {\n      addToEnvMap(environment, nmVars, \"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    String nmAdminUserEnv \u003d conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV);\n    Apps.setEnvFromInputString(environment, nmAdminUserEnv, File.pathSeparator);\n    nmVars.addAll(Apps.getEnvVarsFromInputString(nmAdminUserEnv,\n        File.pathSeparator));\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n      nmVars.add(AuxiliaryServiceHelper.getPrefixServiceName(meta.getKey()));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "682ea21f2bbc587e1b727b3c895c2f513a908432": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\"\n\nThis reverts commit 12eaae383ad06de8f9959241b2451dec82cf9ceb.\n",
      "commitDate": "01/02/18 10:14 AM",
      "commitName": "682ea21f2bbc587e1b727b3c895c2f513a908432",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "31/01/18 9:37 AM",
      "commitNameOld": "12eaae383ad06de8f9959241b2451dec82cf9ceb",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.03,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n         userLocalDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n+    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n+\n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "12eaae383ad06de8f9959241b2451dec82cf9ceb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
      "commitDate": "31/01/18 9:37 AM",
      "commitName": "12eaae383ad06de8f9959241b2451dec82cf9ceb",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "24/01/18 12:54 PM",
      "commitNameOld": "fa8cf4d1b4896a602dc383d5e266768392a9790c",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 6.86,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,66 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n         userLocalDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n-    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n-\n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "7eb8499996869cdb63743f1c9eca2ba91d57ad08": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7226. Whitelisted variables do not support delayed variable expansion. Contributed by Jason Lowe\n",
      "commitDate": "02/10/17 7:04 PM",
      "commitName": "7eb8499996869cdb63743f1c9eca2ba91d57ad08",
      "commitAuthor": "Sidharta S",
      "commitDateOld": "29/09/17 4:39 PM",
      "commitNameOld": "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,68 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n         userLocalDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n-    /**\n-     * Modifiable environment variables\n-     */\n-    \n-    // allow containers to override these variables\n-    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n-    \n-    for(String whitelistEnvVariable : whitelist) {\n-      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n-    }\n-\n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "3860be7961580ac20dd505d665b580f0a04ac4f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4727. Unable to override the $HADOOP_CONF_DIR env variable for container. Contributed by Jason Lowe.\n",
      "commitDate": "13/09/17 12:41 PM",
      "commitName": "3860be7961580ac20dd505d665b580f0a04ac4f8",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "13/09/17 12:38 PM",
      "commitNameOld": "a3c44195bed724c02bb76859fe2690d6a9e8f2e9",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,79 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n         userLocalDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n-    putEnvIfNotNull(environment, \n-        Environment.HADOOP_CONF_DIR.name(), \n-        System.getenv(Environment.HADOOP_CONF_DIR.name())\n-        );\n+    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "a3c44195bed724c02bb76859fe2690d6a9e8f2e9": {
      "type": "Ybodychange",
      "commitMessage": "Revert \u0027YARN-4727. Unable to override the $HADOOP_CONF_DIR env variable for container. Contributed by Jason Lowe.\u0027\n\nThis reverts commit 729d05f5293acf63e7e4aa3bfbf29b999c9a2906.\n",
      "commitDate": "13/09/17 12:38 PM",
      "commitName": "a3c44195bed724c02bb76859fe2690d6a9e8f2e9",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "13/09/17 12:29 PM",
      "commitNameOld": "729d05f5293acf63e7e4aa3bfbf29b999c9a2906",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,82 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n         userLocalDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n-    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n+    putEnvIfNotNull(environment, \n+        Environment.HADOOP_CONF_DIR.name(), \n+        System.getenv(Environment.HADOOP_CONF_DIR.name())\n+        );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "729d05f5293acf63e7e4aa3bfbf29b999c9a2906": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4727. Unable to override the /home/ericp/run/conf/ env variable for container. Contributed by Jason Lowe.\n",
      "commitDate": "13/09/17 12:29 PM",
      "commitName": "729d05f5293acf63e7e4aa3bfbf29b999c9a2906",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "29/08/17 3:29 PM",
      "commitNameOld": "f59332b97b9a57e3cf1dcdeb47d7838d287100eb",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 14.87,
      "commitsBetweenForRepo": 209,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,79 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n         userLocalDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n-    putEnvIfNotNull(environment, \n-        Environment.HADOOP_CONF_DIR.name(), \n-        System.getenv(Environment.HADOOP_CONF_DIR.name())\n-        );\n+    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n \n       sanitizeWindowsEnv(environment, pwd,\n           resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfAbsent(environment, Environment.HADOOP_CONF_DIR.name());\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "74a61438ca01e2191b54000af73b654a2d0b8253": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6475. Fix some long function checkstyle issues\n(Contributed by Soumabrata Chakraborty via Daniel Templeton)\n",
      "commitDate": "10/05/17 10:46 AM",
      "commitName": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "19/04/17 12:23 PM",
      "commitNameOld": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 20.93,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,82 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n       containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n         userLocalDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n-      \n-      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n \n-      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n-\n-        //On non-windows, localized resources\n-        //from distcache are available via the classpath as they were placed\n-        //there but on windows they are not available when the classpath\n-        //jar is created and so they \"are lost\" and have to be explicitly\n-        //added to the classpath instead.  This also means that their position\n-        //is lost relative to other non-distcache classpath entries which will\n-        //break things like mapreduce.job.user.classpath.first.  An environment\n-        //variable can be set to indicate that distcache entries should come\n-        //first\n-\n-        boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n-          environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n-          );\n-\n-        boolean needsSeparator \u003d false;\n-        StringBuilder newClassPath \u003d new StringBuilder();\n-        if (!preferLocalizedJars) {\n-          newClassPath.append(inputClassPath);\n-          needsSeparator \u003d true;\n-        }\n-\n-        // Localized resources do not exist at the desired paths yet, because the\n-        // container launch script has not run to create symlinks yet.  This\n-        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n-        // wildcards to separate classpath entries for each file in the manifest.\n-        // To resolve this, append classpath entries explicitly for each\n-        // resource.\n-        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n-          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n-            .isDirectory();\n-\n-          for (String linkName : entry.getValue()) {\n-            // Append resource.\n-            if (needsSeparator) {\n-              newClassPath.append(File.pathSeparator);\n-            } else {\n-              needsSeparator \u003d true;\n-            }\n-            newClassPath.append(pwd.toString())\n-              .append(Path.SEPARATOR).append(linkName);\n-\n-            // FileUtil.createJarWithClassPath must use File.toURI to convert\n-            // each file to a URI to write into the manifest\u0027s classpath.  For\n-            // directories, the classpath must have a trailing \u0027/\u0027, but\n-            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n-            // already exists.  To resolve this, add the classpath entries with\n-            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n-            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n-            // that the resulting entry in the manifest\u0027s classpath will have a\n-            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n-            if (targetIsDirectory) {\n-              newClassPath.append(Path.SEPARATOR);\n-            }\n-          }\n-        }\n-        if (preferLocalizedJars) {\n-          if (needsSeparator) {\n-            newClassPath.append(File.pathSeparator);\n-          }\n-          newClassPath.append(inputClassPath);\n-        }\n-\n-        // When the container launches, it takes the parent process\u0027s environment\n-        // and then adds/overwrites with the entries from the container launch\n-        // context.  Do the same thing here for correct substitution of\n-        // environment variables in the classpath jar manifest.\n-        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n-          System.getenv());\n-        mergedEnv.putAll(environment);\n-        \n-        // this is hacky and temporary - it\u0027s to preserve the windows secure\n-        // behavior but enable non-secure windows to properly build the class\n-        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n-        Path jarDir;\n-        if (exec instanceof WindowsSecureContainerExecutor) {\n-          jarDir \u003d nmPrivateClasspathJarDir;\n-        } else {\n-          jarDir \u003d pwd; \n-        }\n-        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n-          newClassPath.toString(), jarDir, pwd, mergedEnv);\n-        // In a secure cluster the classpath jar must be localized to grant access\n-        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n-            new Path(jarCp[0]), pwd, container.getUser());\n-        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n-        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n-      }\n+      sanitizeWindowsEnv(environment, pwd,\n+          resources, nmPrivateClasspathJarDir);\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n\n      sanitizeWindowsEnv(environment, pwd,\n          resources, nmPrivateClasspathJarDir);\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "58e18508018081b5b5aa7c12cc5af386146cd26b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5298. Mount usercache and NM filecache directories into Docker container. Contributed by  Sidharta Seethana.\n",
      "commitDate": "14/07/16 3:41 AM",
      "commitName": "58e18508018081b5b5aa7c12cc5af386146cd26b",
      "commitAuthor": "Varun Vasudev",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5298. Mount usercache and NM filecache directories into Docker container. Contributed by  Sidharta Seethana.\n",
          "commitDate": "14/07/16 3:41 AM",
          "commitName": "58e18508018081b5b5aa7c12cc5af386146cd26b",
          "commitAuthor": "Varun Vasudev",
          "commitDateOld": "14/06/16 3:06 PM",
          "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 29.52,
          "commitsBetweenForRepo": 329,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,167 +1,171 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n-      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n+      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n+      containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n+    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n+        userLocalDirs));\n+\n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n \n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n \n         //On non-windows, localized resources\n         //from distcache are available via the classpath as they were placed\n         //there but on windows they are not available when the classpath\n         //jar is created and so they \"are lost\" and have to be explicitly\n         //added to the classpath instead.  This also means that their position\n         //is lost relative to other non-distcache classpath entries which will\n         //break things like mapreduce.job.user.classpath.first.  An environment\n         //variable can be set to indicate that distcache entries should come\n         //first\n \n         boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n           environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n           );\n \n         boolean needsSeparator \u003d false;\n         StringBuilder newClassPath \u003d new StringBuilder();\n         if (!preferLocalizedJars) {\n           newClassPath.append(inputClassPath);\n           needsSeparator \u003d true;\n         }\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             if (needsSeparator) {\n               newClassPath.append(File.pathSeparator);\n             } else {\n               needsSeparator \u003d true;\n             }\n             newClassPath.append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n         if (preferLocalizedJars) {\n           if (needsSeparator) {\n             newClassPath.append(File.pathSeparator);\n           }\n           newClassPath.append(inputClassPath);\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n         \n         // this is hacky and temporary - it\u0027s to preserve the windows secure\n         // behavior but enable non-secure windows to properly build the class\n         // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n         Path jarDir;\n         if (exec instanceof WindowsSecureContainerExecutor) {\n           jarDir \u003d nmPrivateClasspathJarDir;\n         } else {\n           jarDir \u003d pwd; \n         }\n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), jarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n         Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n             new Path(jarCp[0]), pwd, container.getUser());\n         String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n\n        //On non-windows, localized resources\n        //from distcache are available via the classpath as they were placed\n        //there but on windows they are not available when the classpath\n        //jar is created and so they \"are lost\" and have to be explicitly\n        //added to the classpath instead.  This also means that their position\n        //is lost relative to other non-distcache classpath entries which will\n        //break things like mapreduce.job.user.classpath.first.  An environment\n        //variable can be set to indicate that distcache entries should come\n        //first\n\n        boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n          environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n          );\n\n        boolean needsSeparator \u003d false;\n        StringBuilder newClassPath \u003d new StringBuilder();\n        if (!preferLocalizedJars) {\n          newClassPath.append(inputClassPath);\n          needsSeparator \u003d true;\n        }\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            if (needsSeparator) {\n              newClassPath.append(File.pathSeparator);\n            } else {\n              needsSeparator \u003d true;\n            }\n            newClassPath.append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n        if (preferLocalizedJars) {\n          if (needsSeparator) {\n            newClassPath.append(File.pathSeparator);\n          }\n          newClassPath.append(inputClassPath);\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        // this is hacky and temporary - it\u0027s to preserve the windows secure\n        // behavior but enable non-secure windows to properly build the class\n        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n        Path jarDir;\n        if (exec instanceof WindowsSecureContainerExecutor) {\n          jarDir \u003d nmPrivateClasspathJarDir;\n        } else {\n          jarDir \u003d pwd; \n        }\n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), jarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path]",
            "newValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, userLocalDirs-List\u003cString\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5298. Mount usercache and NM filecache directories into Docker container. Contributed by  Sidharta Seethana.\n",
          "commitDate": "14/07/16 3:41 AM",
          "commitName": "58e18508018081b5b5aa7c12cc5af386146cd26b",
          "commitAuthor": "Varun Vasudev",
          "commitDateOld": "14/06/16 3:06 PM",
          "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 29.52,
          "commitsBetweenForRepo": 329,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,167 +1,171 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n-      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n+      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n+      containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n+    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n+        userLocalDirs));\n+\n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n \n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n \n         //On non-windows, localized resources\n         //from distcache are available via the classpath as they were placed\n         //there but on windows they are not available when the classpath\n         //jar is created and so they \"are lost\" and have to be explicitly\n         //added to the classpath instead.  This also means that their position\n         //is lost relative to other non-distcache classpath entries which will\n         //break things like mapreduce.job.user.classpath.first.  An environment\n         //variable can be set to indicate that distcache entries should come\n         //first\n \n         boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n           environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n           );\n \n         boolean needsSeparator \u003d false;\n         StringBuilder newClassPath \u003d new StringBuilder();\n         if (!preferLocalizedJars) {\n           newClassPath.append(inputClassPath);\n           needsSeparator \u003d true;\n         }\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             if (needsSeparator) {\n               newClassPath.append(File.pathSeparator);\n             } else {\n               needsSeparator \u003d true;\n             }\n             newClassPath.append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n         if (preferLocalizedJars) {\n           if (needsSeparator) {\n             newClassPath.append(File.pathSeparator);\n           }\n           newClassPath.append(inputClassPath);\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n         \n         // this is hacky and temporary - it\u0027s to preserve the windows secure\n         // behavior but enable non-secure windows to properly build the class\n         // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n         Path jarDir;\n         if (exec instanceof WindowsSecureContainerExecutor) {\n           jarDir \u003d nmPrivateClasspathJarDir;\n         } else {\n           jarDir \u003d pwd; \n         }\n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), jarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n         Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n             new Path(jarCp[0]), pwd, container.getUser());\n         String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e userLocalDirs, List\u003cString\u003e\n      containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOCAL_USER_DIRS.name(), StringUtils.join(\",\",\n        userLocalDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n\n        //On non-windows, localized resources\n        //from distcache are available via the classpath as they were placed\n        //there but on windows they are not available when the classpath\n        //jar is created and so they \"are lost\" and have to be explicitly\n        //added to the classpath instead.  This also means that their position\n        //is lost relative to other non-distcache classpath entries which will\n        //break things like mapreduce.job.user.classpath.first.  An environment\n        //variable can be set to indicate that distcache entries should come\n        //first\n\n        boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n          environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n          );\n\n        boolean needsSeparator \u003d false;\n        StringBuilder newClassPath \u003d new StringBuilder();\n        if (!preferLocalizedJars) {\n          newClassPath.append(inputClassPath);\n          needsSeparator \u003d true;\n        }\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            if (needsSeparator) {\n              newClassPath.append(File.pathSeparator);\n            } else {\n              needsSeparator \u003d true;\n            }\n            newClassPath.append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n        if (preferLocalizedJars) {\n          if (needsSeparator) {\n            newClassPath.append(File.pathSeparator);\n          }\n          newClassPath.append(inputClassPath);\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        // this is hacky and temporary - it\u0027s to preserve the windows secure\n        // behavior but enable non-secure windows to properly build the class\n        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n        Path jarDir;\n        if (exec instanceof WindowsSecureContainerExecutor) {\n          jarDir \u003d nmPrivateClasspathJarDir;\n        } else {\n          jarDir \u003d pwd; \n        }\n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), jarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "1ff27f9d12e8124c1b9a722708264c5b07fd0fde": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4630. Remove useless boxing/unboxing code. Contributed by Kousuke Saruta.\n",
      "commitDate": "10/04/16 10:55 PM",
      "commitName": "1ff27f9d12e8124c1b9a722708264c5b07fd0fde",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "22/01/16 1:13 AM",
      "commitNameOld": "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 79.86,
      "commitsBetweenForRepo": 507,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,167 +1,167 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n \n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n \n         //On non-windows, localized resources\n         //from distcache are available via the classpath as they were placed\n         //there but on windows they are not available when the classpath\n         //jar is created and so they \"are lost\" and have to be explicitly\n         //added to the classpath instead.  This also means that their position\n         //is lost relative to other non-distcache classpath entries which will\n         //break things like mapreduce.job.user.classpath.first.  An environment\n         //variable can be set to indicate that distcache entries should come\n         //first\n \n-        boolean preferLocalizedJars \u003d Boolean.valueOf(\n+        boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n           environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n           );\n \n         boolean needsSeparator \u003d false;\n         StringBuilder newClassPath \u003d new StringBuilder();\n         if (!preferLocalizedJars) {\n           newClassPath.append(inputClassPath);\n           needsSeparator \u003d true;\n         }\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             if (needsSeparator) {\n               newClassPath.append(File.pathSeparator);\n             } else {\n               needsSeparator \u003d true;\n             }\n             newClassPath.append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n         if (preferLocalizedJars) {\n           if (needsSeparator) {\n             newClassPath.append(File.pathSeparator);\n           }\n           newClassPath.append(inputClassPath);\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n         \n         // this is hacky and temporary - it\u0027s to preserve the windows secure\n         // behavior but enable non-secure windows to properly build the class\n         // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n         Path jarDir;\n         if (exec instanceof WindowsSecureContainerExecutor) {\n           jarDir \u003d nmPrivateClasspathJarDir;\n         } else {\n           jarDir \u003d pwd; \n         }\n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), jarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n         Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n             new Path(jarCp[0]), pwd, container.getUser());\n         String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n\n        //On non-windows, localized resources\n        //from distcache are available via the classpath as they were placed\n        //there but on windows they are not available when the classpath\n        //jar is created and so they \"are lost\" and have to be explicitly\n        //added to the classpath instead.  This also means that their position\n        //is lost relative to other non-distcache classpath entries which will\n        //break things like mapreduce.job.user.classpath.first.  An environment\n        //variable can be set to indicate that distcache entries should come\n        //first\n\n        boolean preferLocalizedJars \u003d Boolean.parseBoolean(\n          environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n          );\n\n        boolean needsSeparator \u003d false;\n        StringBuilder newClassPath \u003d new StringBuilder();\n        if (!preferLocalizedJars) {\n          newClassPath.append(inputClassPath);\n          needsSeparator \u003d true;\n        }\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            if (needsSeparator) {\n              newClassPath.append(File.pathSeparator);\n            } else {\n              needsSeparator \u003d true;\n            }\n            newClassPath.append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n        if (preferLocalizedJars) {\n          if (needsSeparator) {\n            newClassPath.append(File.pathSeparator);\n          }\n          newClassPath.append(inputClassPath);\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        // this is hacky and temporary - it\u0027s to preserve the windows secure\n        // behavior but enable non-secure windows to properly build the class\n        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n        Path jarDir;\n        if (exec instanceof WindowsSecureContainerExecutor) {\n          jarDir \u003d nmPrivateClasspathJarDir;\n        } else {\n          jarDir \u003d pwd; \n        }\n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), jarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "4102e5882e17b75507ae5cf8b8979485b3e24cbc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3626. On Windows localized resources are not moved to the front of the classpath when they should be. Contributed by Craig Welch.\n",
      "commitDate": "27/05/15 2:31 PM",
      "commitName": "4102e5882e17b75507ae5cf8b8979485b3e24cbc",
      "commitAuthor": "cnauroth",
      "commitDateOld": "21/05/15 3:50 PM",
      "commitNameOld": "53fafcf061616516c24e2e2007a66a93d23d3e25",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.95,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,166 +1,167 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n \n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n \n         //On non-windows, localized resources\n         //from distcache are available via the classpath as they were placed\n         //there but on windows they are not available when the classpath\n         //jar is created and so they \"are lost\" and have to be explicitly\n         //added to the classpath instead.  This also means that their position\n         //is lost relative to other non-distcache classpath entries which will\n-        //break things like mapreduce.job.user.classpath.first.\n+        //break things like mapreduce.job.user.classpath.first.  An environment\n+        //variable can be set to indicate that distcache entries should come\n+        //first\n \n-        boolean preferLocalizedJars \u003d conf.getBoolean(\n-          YarnConfiguration.YARN_APPLICATION_CLASSPATH_PREPEND_DISTCACHE,\n-          YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH_PREPEND_DISTCACHE\n+        boolean preferLocalizedJars \u003d Boolean.valueOf(\n+          environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n           );\n \n         boolean needsSeparator \u003d false;\n         StringBuilder newClassPath \u003d new StringBuilder();\n         if (!preferLocalizedJars) {\n           newClassPath.append(inputClassPath);\n           needsSeparator \u003d true;\n         }\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             if (needsSeparator) {\n               newClassPath.append(File.pathSeparator);\n             } else {\n               needsSeparator \u003d true;\n             }\n             newClassPath.append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n         if (preferLocalizedJars) {\n           if (needsSeparator) {\n             newClassPath.append(File.pathSeparator);\n           }\n           newClassPath.append(inputClassPath);\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n         \n         // this is hacky and temporary - it\u0027s to preserve the windows secure\n         // behavior but enable non-secure windows to properly build the class\n         // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n         Path jarDir;\n         if (exec instanceof WindowsSecureContainerExecutor) {\n           jarDir \u003d nmPrivateClasspathJarDir;\n         } else {\n           jarDir \u003d pwd; \n         }\n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), jarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n         Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n             new Path(jarCp[0]), pwd, container.getUser());\n         String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n\n        //On non-windows, localized resources\n        //from distcache are available via the classpath as they were placed\n        //there but on windows they are not available when the classpath\n        //jar is created and so they \"are lost\" and have to be explicitly\n        //added to the classpath instead.  This also means that their position\n        //is lost relative to other non-distcache classpath entries which will\n        //break things like mapreduce.job.user.classpath.first.  An environment\n        //variable can be set to indicate that distcache entries should come\n        //first\n\n        boolean preferLocalizedJars \u003d Boolean.valueOf(\n          environment.get(Environment.CLASSPATH_PREPEND_DISTCACHE.name())\n          );\n\n        boolean needsSeparator \u003d false;\n        StringBuilder newClassPath \u003d new StringBuilder();\n        if (!preferLocalizedJars) {\n          newClassPath.append(inputClassPath);\n          needsSeparator \u003d true;\n        }\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            if (needsSeparator) {\n              newClassPath.append(File.pathSeparator);\n            } else {\n              needsSeparator \u003d true;\n            }\n            newClassPath.append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n        if (preferLocalizedJars) {\n          if (needsSeparator) {\n            newClassPath.append(File.pathSeparator);\n          }\n          newClassPath.append(inputClassPath);\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        // this is hacky and temporary - it\u0027s to preserve the windows secure\n        // behavior but enable non-secure windows to properly build the class\n        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n        Path jarDir;\n        if (exec instanceof WindowsSecureContainerExecutor) {\n          jarDir \u003d nmPrivateClasspathJarDir;\n        } else {\n          jarDir \u003d pwd; \n        }\n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), jarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "0f95921447ea547bdf9caf18f7fde46bc66031f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3626. On Windows localized resources are not moved to the front of the classpath when they should be. Contributed by Craig Welch\n",
      "commitDate": "13/05/15 1:10 PM",
      "commitName": "0f95921447ea547bdf9caf18f7fde46bc66031f8",
      "commitAuthor": "Xuan",
      "commitDateOld": "28/03/15 8:00 AM",
      "commitNameOld": "e0ccea33c9e12f6930b2867e14b1b37569fed659",
      "commitAuthorOld": "Ravi Prakash",
      "daysBetweenCommits": 46.22,
      "commitsBetweenForRepo": 472,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,166 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n+\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n-        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n+\n+        //On non-windows, localized resources\n+        //from distcache are available via the classpath as they were placed\n+        //there but on windows they are not available when the classpath\n+        //jar is created and so they \"are lost\" and have to be explicitly\n+        //added to the classpath instead.  This also means that their position\n+        //is lost relative to other non-distcache classpath entries which will\n+        //break things like mapreduce.job.user.classpath.first.\n+\n+        boolean preferLocalizedJars \u003d conf.getBoolean(\n+          YarnConfiguration.YARN_APPLICATION_CLASSPATH_PREPEND_DISTCACHE,\n+          YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH_PREPEND_DISTCACHE\n+          );\n+\n+        boolean needsSeparator \u003d false;\n+        StringBuilder newClassPath \u003d new StringBuilder();\n+        if (!preferLocalizedJars) {\n+          newClassPath.append(inputClassPath);\n+          needsSeparator \u003d true;\n+        }\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n-            newClassPath.append(File.pathSeparator).append(pwd.toString())\n+            if (needsSeparator) {\n+              newClassPath.append(File.pathSeparator);\n+            } else {\n+              needsSeparator \u003d true;\n+            }\n+            newClassPath.append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n+        if (preferLocalizedJars) {\n+          if (needsSeparator) {\n+            newClassPath.append(File.pathSeparator);\n+          }\n+          newClassPath.append(inputClassPath);\n+        }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n         \n         // this is hacky and temporary - it\u0027s to preserve the windows secure\n         // behavior but enable non-secure windows to properly build the class\n         // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n         Path jarDir;\n         if (exec instanceof WindowsSecureContainerExecutor) {\n           jarDir \u003d nmPrivateClasspathJarDir;\n         } else {\n           jarDir \u003d pwd; \n         }\n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), jarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n         Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n             new Path(jarCp[0]), pwd, container.getUser());\n         String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n\n        //On non-windows, localized resources\n        //from distcache are available via the classpath as they were placed\n        //there but on windows they are not available when the classpath\n        //jar is created and so they \"are lost\" and have to be explicitly\n        //added to the classpath instead.  This also means that their position\n        //is lost relative to other non-distcache classpath entries which will\n        //break things like mapreduce.job.user.classpath.first.\n\n        boolean preferLocalizedJars \u003d conf.getBoolean(\n          YarnConfiguration.YARN_APPLICATION_CLASSPATH_PREPEND_DISTCACHE,\n          YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH_PREPEND_DISTCACHE\n          );\n\n        boolean needsSeparator \u003d false;\n        StringBuilder newClassPath \u003d new StringBuilder();\n        if (!preferLocalizedJars) {\n          newClassPath.append(inputClassPath);\n          needsSeparator \u003d true;\n        }\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            if (needsSeparator) {\n              newClassPath.append(File.pathSeparator);\n            } else {\n              needsSeparator \u003d true;\n            }\n            newClassPath.append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n        if (preferLocalizedJars) {\n          if (needsSeparator) {\n            newClassPath.append(File.pathSeparator);\n          }\n          newClassPath.append(inputClassPath);\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        // this is hacky and temporary - it\u0027s to preserve the windows secure\n        // behavior but enable non-secure windows to properly build the class\n        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n        Path jarDir;\n        if (exec instanceof WindowsSecureContainerExecutor) {\n          jarDir \u003d nmPrivateClasspathJarDir;\n        } else {\n          jarDir \u003d pwd; \n        }\n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), jarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "06b797947c980d7d21864eb8b700cf565756aac1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2803. MR distributed cache not working correctly on Windows after NodeManager privileged account changes. Contributed by Craig Welch.\n",
      "commitDate": "07/11/14 12:29 PM",
      "commitName": "06b797947c980d7d21864eb8b700cf565756aac1",
      "commitAuthor": "cnauroth",
      "commitDateOld": "03/11/14 4:38 PM",
      "commitNameOld": "c5a46d4c8ca236ff641a309f256bbbdf4dd56db5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.83,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,135 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources,\n       Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n         \n+        // this is hacky and temporary - it\u0027s to preserve the windows secure\n+        // behavior but enable non-secure windows to properly build the class\n+        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n+        Path jarDir;\n+        if (exec instanceof WindowsSecureContainerExecutor) {\n+          jarDir \u003d nmPrivateClasspathJarDir;\n+        } else {\n+          jarDir \u003d pwd; \n+        }\n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n-          newClassPath.toString(), nmPrivateClasspathJarDir, pwd, mergedEnv);\n+          newClassPath.toString(), jarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n         Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n             new Path(jarCp[0]), pwd, container.getUser());\n         String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        // this is hacky and temporary - it\u0027s to preserve the windows secure\n        // behavior but enable non-secure windows to properly build the class\n        // path for access to job.jar/lib/xyz and friends (see YARN-2803)\n        Path jarDir;\n        if (exec instanceof WindowsSecureContainerExecutor) {\n          jarDir \u003d nmPrivateClasspathJarDir;\n        } else {\n          jarDir \u003d pwd; \n        }\n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), jarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
      "commitDate": "22/10/14 3:57 PM",
      "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "21/10/14 12:33 PM",
          "commitNameOld": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.14,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,124 +1,126 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n-      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n+      Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n+      \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n-\n+        \n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n-          newClassPath.toString(), pwd, mergedEnv);\n-        String classPathJar \u003d jarCp[0];\n+          newClassPath.toString(), nmPrivateClasspathJarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n-        this.exec.localizeClasspathJar(new Path(classPathJar), container.getUser());\n-        String replacementClassPath \u003d classPathJar + jarCp[1];\n+        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n+            new Path(jarCp[0]), pwd, container.getUser());\n+        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), nmPrivateClasspathJarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e]",
            "newValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e, nmPrivateClasspathJarDir-Path]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "21/10/14 12:33 PM",
          "commitNameOld": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.14,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,124 +1,126 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n-      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n+      Map\u003cPath, List\u003cString\u003e\u003e resources,\n+      Path nmPrivateClasspathJarDir) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n+      \n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n-\n+        \n         String[] jarCp \u003d FileUtil.createJarWithClassPath(\n-          newClassPath.toString(), pwd, mergedEnv);\n-        String classPathJar \u003d jarCp[0];\n+          newClassPath.toString(), nmPrivateClasspathJarDir, pwd, mergedEnv);\n         // In a secure cluster the classpath jar must be localized to grant access\n-        this.exec.localizeClasspathJar(new Path(classPathJar), container.getUser());\n-        String replacementClassPath \u003d classPathJar + jarCp[1];\n+        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n+            new Path(jarCp[0]), pwd, container.getUser());\n+        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n         environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources,\n      Path nmPrivateClasspathJarDir) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      \n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n        \n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), nmPrivateClasspathJarDir, pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        Path localizedClassPathJar \u003d exec.localizeClasspathJar(\n            new Path(jarCp[0]), pwd, container.getUser());\n        String replacementClassPath \u003d localizedClassPathJar.toString() + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2720. Windows: Wildcard classpath variables not expanded against resources contained in archives. Contributed by Craig Welch.\n",
      "commitDate": "21/10/14 12:33 PM",
      "commitName": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "21/10/14 10:31 AM",
      "commitNameOld": "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,124 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n-        String classPathJar \u003d FileUtil.createJarWithClassPath(\n+        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n+        String classPathJar \u003d jarCp[0];\n         // In a secure cluster the classpath jar must be localized to grant access\n         this.exec.localizeClasspathJar(new Path(classPathJar), container.getUser());\n-        environment.put(Environment.CLASSPATH.name(), classPathJar);\n+        String replacementClassPath \u003d classPathJar + jarCp[1];\n+        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String[] jarCp \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        String classPathJar \u003d jarCp[0];\n        // In a secure cluster the classpath jar must be localized to grant access\n        this.exec.localizeClasspathJar(new Path(classPathJar), container.getUser());\n        String replacementClassPath \u003d classPathJar + jarCp[1];\n        environment.put(Environment.CLASSPATH.name(), replacementClassPath);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1972. Added a secure container-executor for Windows. Contributed by Remus Rusanu.\n",
      "commitDate": "01/10/14 10:14 AM",
      "commitName": "ba7f31c2ee8d23ecb183f88920ef06053c0b9769",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/08/14 3:56 AM",
      "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 50.26,
      "commitsBetweenForRepo": 539,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,122 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(environment, conf.get(\n       YarnConfiguration.NM_ADMIN_USER_ENV,\n       YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n+        // In a secure cluster the classpath jar must be localized to grant access\n+        this.exec.localizeClasspathJar(new Path(classPathJar), container.getUser());\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        // In a secure cluster the classpath jar must be localized to grant access\n        this.exec.localizeClasspathJar(new Path(classPathJar), container.getUser());\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1824. Improved NodeManager and clients to be able to handle cross platform application submissions. Contributed by Jian He.\nMAPREDUCE-4052. Improved MapReduce clients to use NodeManagers\u0027 ability to handle cross platform application submissions. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1578135 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/03/14 11:32 AM",
      "commitName": "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/11/13 11:52 AM",
      "commitNameOld": "1a76ccbbc47ba51f9a9813512e93abc09136f280",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 121.94,
      "commitsBetweenForRepo": 852,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,120 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n-    Apps.setEnvFromInputString(\n-      environment,\n-      conf.get(\n-        YarnConfiguration.NM_ADMIN_USER_ENV,\n-        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n-    );\n+    Apps.setEnvFromInputString(environment, conf.get(\n+      YarnConfiguration.NM_ADMIN_USER_ENV,\n+      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n     // put AuxiliaryService data to environment\n     for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n         .getAuxServiceMetaData().entrySet()) {\n       AuxiliaryServiceHelper.setServiceDataIntoEnv(\n           meta.getKey(), meta.getValue(), environment);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(environment, conf.get(\n      YarnConfiguration.NM_ADMIN_USER_ENV,\n      YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV), File.pathSeparator);\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "49afc64cd469bc3a775c18e0458661e39270b7a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1065. NM should provide AuxillaryService data to the container (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520135 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/13 1:42 PM",
      "commitName": "49afc64cd469bc3a775c18e0458661e39270b7a5",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "01/09/13 8:10 PM",
      "commitNameOld": "ff69557040fb414254e75bf57287aee1dc7ad855",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.73,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,123 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n     environment.put(Environment.USER.name(), container.getUser());\n     \n     environment.put(Environment.LOGNAME.name(), container.getUser());\n \n     environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n+    // put AuxiliaryService data to environment\n+    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n+        .getAuxServiceMetaData().entrySet()) {\n+      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n+          meta.getKey(), meta.getValue(), environment);\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n    // put AuxiliaryService data to environment\n    for (Map.Entry\u003cString, ByteBuffer\u003e meta : containerManager\n        .getAuxServiceMetaData().entrySet()) {\n      AuxiliaryServiceHelper.setServiceDataIntoEnv(\n          meta.getKey(), meta.getValue(), environment);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "4047ad72cffa03ba8383f4448a0f921a3d4fcdf2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-602. Fixed NodeManager to not let users override some mandatory environmental variables. Contributed by Kenji Kikushima.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518077 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/08/13 10:13 PM",
      "commitName": "4047ad72cffa03ba8383f4448a0f921a3d4fcdf2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/07/13 4:58 PM",
      "commitNameOld": "813efd25a19f6e36537245b8cb6f9e6e42f40cc1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 28.22,
      "commitsBetweenForRepo": 164,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,117 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n       List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n       Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     environment.put(Environment.LOG_DIRS.name(),\n       StringUtils.join(\",\", containerLogDirs));\n \n-    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n+    environment.put(Environment.USER.name(), container.getUser());\n     \n-    putEnvIfNotNull(environment, \n-        Environment.LOGNAME.name(),container.getUser());\n-    \n-    putEnvIfNotNull(environment, \n-        Environment.HOME.name(),\n+    environment.put(Environment.LOGNAME.name(), container.getUser());\n+\n+    environment.put(Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n-    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n+    environment.put(Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    environment.put(Environment.USER.name(), container.getUser());\n    \n    environment.put(Environment.LOGNAME.name(), container.getUser());\n\n    environment.put(Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    environment.put(Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "29a370872435ee558fbeb9f64bf70da87f8cd27a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-781. Exposing LOGDIR in all containers\u0027 environment which should be used by containers for logging purposes. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493428 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/06/13 4:09 PM",
      "commitName": "29a370872435ee558fbeb9f64bf70da87f8cd27a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-781. Exposing LOGDIR in all containers\u0027 environment which should be used by containers for logging purposes. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493428 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/06/13 4:09 PM",
          "commitName": "29a370872435ee558fbeb9f64bf70da87f8cd27a",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "14/06/13 9:10 AM",
          "commitNameOld": "fdc9412a810564c79fbebf5eb730cb1018a95c6c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 1.29,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,119 @@\n-  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n-      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n-      throws IOException {\n+  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n+      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n+      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n+    environment.put(Environment.LOG_DIRS.name(),\n+      StringUtils.join(\",\", containerLogDirs));\n+\n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e]",
            "newValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, containerLogDirs-List\u003cString\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-781. Exposing LOGDIR in all containers\u0027 environment which should be used by containers for logging purposes. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493428 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "15/06/13 4:09 PM",
          "commitName": "29a370872435ee558fbeb9f64bf70da87f8cd27a",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "14/06/13 9:10 AM",
          "commitNameOld": "fdc9412a810564c79fbebf5eb730cb1018a95c6c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 1.29,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,119 @@\n-  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n-      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n-      throws IOException {\n+  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n+      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n+      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n         .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n       String.valueOf(this.context.getNodeId().getPort()));\n \n     environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n       .getHost());\n \n     environment.put(Environment.NM_HTTP_PORT.name(),\n       String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n+    environment.put(Environment.LOG_DIRS.name(),\n+      StringUtils.join(\",\", containerLogDirs));\n+\n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, Path pwd,\n      List\u003cPath\u003e appDirs, List\u003cString\u003e containerLogDirs,\n      Map\u003cPath, List\u003cString\u003e\u003e resources) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    environment.put(Environment.LOG_DIRS.name(),\n      StringUtils.join(\",\", containerLogDirs));\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/05/13 8:22 PM",
      "commitNameOld": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,116 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n       Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n       throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     environment.put(Environment.CONTAINER_ID.name(), container\n-        .getContainer().getId().toString());\n+        .getContainerId().toString());\n \n     environment.put(Environment.NM_PORT.name(),\n-        String.valueOf(container.getContainer().getNodeId().getPort()));\n+      String.valueOf(this.context.getNodeId().getPort()));\n \n-    environment.put(Environment.NM_HOST.name(), container.getContainer()\n-        .getNodeId().getHost());\n+    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n+      .getHost());\n \n-    environment.put(Environment.NM_HTTP_PORT.name(), container.getContainer()\n-        .getNodeHttpAddress().split(\":\")[1]);\n+    environment.put(Environment.NM_HTTP_PORT.name(),\n+      String.valueOf(this.context.getHttpPort()));\n \n     environment.put(Environment.LOCAL_DIRS.name(),\n         StringUtils.join(\",\", appDirs));\n \n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n      throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainerId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n      String.valueOf(this.context.getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), this.context.getNodeId()\n      .getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(),\n      String.valueOf(this.context.getHttpPort()));\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/04/13 12:29 PM",
      "commitNameOld": "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,116 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n       Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n       throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n+    environment.put(Environment.CONTAINER_ID.name(), container\n+        .getContainer().getId().toString());\n+\n+    environment.put(Environment.NM_PORT.name(),\n+        String.valueOf(container.getContainer().getNodeId().getPort()));\n+\n+    environment.put(Environment.NM_HOST.name(), container.getContainer()\n+        .getNodeId().getHost());\n+\n+    environment.put(Environment.NM_HTTP_PORT.name(), container.getContainer()\n+        .getNodeHttpAddress().split(\":\")[1]);\n+\n+    environment.put(Environment.LOCAL_DIRS.name(),\n+        StringUtils.join(\",\", appDirs));\n+\n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n-    \n-    putEnvIfNotNull(environment, \n-        ApplicationConstants.LOCAL_DIR_ENV, \n-        StringUtils.join(\",\", appDirs)\n-        );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n       if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n         StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n \n         // Localized resources do not exist at the desired paths yet, because the\n         // container launch script has not run to create symlinks yet.  This\n         // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n         // wildcards to separate classpath entries for each file in the manifest.\n         // To resolve this, append classpath entries explicitly for each\n         // resource.\n         for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n           boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n             .isDirectory();\n \n           for (String linkName : entry.getValue()) {\n             // Append resource.\n             newClassPath.append(File.pathSeparator).append(pwd.toString())\n               .append(Path.SEPARATOR).append(linkName);\n \n             // FileUtil.createJarWithClassPath must use File.toURI to convert\n             // each file to a URI to write into the manifest\u0027s classpath.  For\n             // directories, the classpath must have a trailing \u0027/\u0027, but\n             // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n             // already exists.  To resolve this, add the classpath entries with\n             // explicit trailing \u0027/\u0027 here for any localized resource that targets\n             // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n             // that the resulting entry in the manifest\u0027s classpath will have a\n             // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n             if (targetIsDirectory) {\n               newClassPath.append(Path.SEPARATOR);\n             }\n           }\n         }\n \n         // When the container launches, it takes the parent process\u0027s environment\n         // and then adds/overwrites with the entries from the container launch\n         // context.  Do the same thing here for correct substitution of\n         // environment variables in the classpath jar manifest.\n         Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n           System.getenv());\n         mergedEnv.putAll(environment);\n \n         String classPathJar \u003d FileUtil.createJarWithClassPath(\n           newClassPath.toString(), pwd, mergedEnv);\n         environment.put(Environment.CLASSPATH.name(), classPathJar);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n      throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    environment.put(Environment.CONTAINER_ID.name(), container\n        .getContainer().getId().toString());\n\n    environment.put(Environment.NM_PORT.name(),\n        String.valueOf(container.getContainer().getNodeId().getPort()));\n\n    environment.put(Environment.NM_HOST.name(), container.getContainer()\n        .getNodeId().getHost());\n\n    environment.put(Environment.NM_HTTP_PORT.name(), container.getContainer()\n        .getNodeHttpAddress().split(\":\")[1]);\n\n    environment.put(Environment.LOCAL_DIRS.name(),\n        StringUtils.join(\",\", appDirs));\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "edcfd4527ca93acdf54403aafaa070b17aff5dd0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-593. container launch on Windows does not correctly populate classpath with new process\u0027s environment variables and localized resources (Chris Nauroth via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469998 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/04/13 12:29 PM",
      "commitName": "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
      "commitAuthor": "Bikas Saha",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-593. container launch on Windows does not correctly populate classpath with new process\u0027s environment variables and localized resources (Chris Nauroth via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469998 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/04/13 12:29 PM",
          "commitName": "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "18/04/13 7:14 PM",
          "commitNameOld": "44bf8525a591b56b5c09cd4201bd193516ea9530",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.72,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,106 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n-      Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n+      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n+      throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n     \n     putEnvIfNotNull(environment, \n         ApplicationConstants.LOCAL_DIR_ENV, \n         StringUtils.join(\",\", appDirs)\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n-    // TODO: Remove Windows check and use this approach on all platforms after\n-    // additional testing.  See YARN-358.\n-    if (Shell.WINDOWS) {\n-      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n-      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n-        environment.put(Environment.CLASSPATH.name(),\n-            FileUtil.createJarWithClassPath(inputClassPath, pwd));\n-      }\n-    }\n-\n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n+\n+    // TODO: Remove Windows check and use this approach on all platforms after\n+    // additional testing.  See YARN-358.\n+    if (Shell.WINDOWS) {\n+      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n+      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n+        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n+\n+        // Localized resources do not exist at the desired paths yet, because the\n+        // container launch script has not run to create symlinks yet.  This\n+        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n+        // wildcards to separate classpath entries for each file in the manifest.\n+        // To resolve this, append classpath entries explicitly for each\n+        // resource.\n+        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n+          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n+            .isDirectory();\n+\n+          for (String linkName : entry.getValue()) {\n+            // Append resource.\n+            newClassPath.append(File.pathSeparator).append(pwd.toString())\n+              .append(Path.SEPARATOR).append(linkName);\n+\n+            // FileUtil.createJarWithClassPath must use File.toURI to convert\n+            // each file to a URI to write into the manifest\u0027s classpath.  For\n+            // directories, the classpath must have a trailing \u0027/\u0027, but\n+            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n+            // already exists.  To resolve this, add the classpath entries with\n+            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n+            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n+            // that the resulting entry in the manifest\u0027s classpath will have a\n+            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n+            if (targetIsDirectory) {\n+              newClassPath.append(Path.SEPARATOR);\n+            }\n+          }\n+        }\n+\n+        // When the container launches, it takes the parent process\u0027s environment\n+        // and then adds/overwrites with the entries from the container launch\n+        // context.  Do the same thing here for correct substitution of\n+        // environment variables in the classpath jar manifest.\n+        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n+          System.getenv());\n+        mergedEnv.putAll(environment);\n+\n+        String classPathJar \u003d FileUtil.createJarWithClassPath(\n+          newClassPath.toString(), pwd, mergedEnv);\n+        environment.put(Environment.CLASSPATH.name(), classPathJar);\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n      throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e]",
            "newValue": "[environment-Map\u003cString,String\u003e, pwd-Path, appDirs-List\u003cPath\u003e, resources-Map\u003cPath,List\u003cString\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-593. container launch on Windows does not correctly populate classpath with new process\u0027s environment variables and localized resources (Chris Nauroth via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469998 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/04/13 12:29 PM",
          "commitName": "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "18/04/13 7:14 PM",
          "commitNameOld": "44bf8525a591b56b5c09cd4201bd193516ea9530",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.72,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,106 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n-      Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n+      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n+      throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n     \n     putEnvIfNotNull(environment, \n         ApplicationConstants.LOCAL_DIR_ENV, \n         StringUtils.join(\",\", appDirs)\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n-    // TODO: Remove Windows check and use this approach on all platforms after\n-    // additional testing.  See YARN-358.\n-    if (Shell.WINDOWS) {\n-      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n-      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n-        environment.put(Environment.CLASSPATH.name(),\n-            FileUtil.createJarWithClassPath(inputClassPath, pwd));\n-      }\n-    }\n-\n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n+\n+    // TODO: Remove Windows check and use this approach on all platforms after\n+    // additional testing.  See YARN-358.\n+    if (Shell.WINDOWS) {\n+      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n+      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n+        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n+\n+        // Localized resources do not exist at the desired paths yet, because the\n+        // container launch script has not run to create symlinks yet.  This\n+        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n+        // wildcards to separate classpath entries for each file in the manifest.\n+        // To resolve this, append classpath entries explicitly for each\n+        // resource.\n+        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n+          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n+            .isDirectory();\n+\n+          for (String linkName : entry.getValue()) {\n+            // Append resource.\n+            newClassPath.append(File.pathSeparator).append(pwd.toString())\n+              .append(Path.SEPARATOR).append(linkName);\n+\n+            // FileUtil.createJarWithClassPath must use File.toURI to convert\n+            // each file to a URI to write into the manifest\u0027s classpath.  For\n+            // directories, the classpath must have a trailing \u0027/\u0027, but\n+            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n+            // already exists.  To resolve this, add the classpath entries with\n+            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n+            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n+            // that the resulting entry in the manifest\u0027s classpath will have a\n+            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n+            if (targetIsDirectory) {\n+              newClassPath.append(Path.SEPARATOR);\n+            }\n+          }\n+        }\n+\n+        // When the container launches, it takes the parent process\u0027s environment\n+        // and then adds/overwrites with the entries from the container launch\n+        // context.  Do the same thing here for correct substitution of\n+        // environment variables in the classpath jar manifest.\n+        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n+          System.getenv());\n+        mergedEnv.putAll(environment);\n+\n+        String classPathJar \u003d FileUtil.createJarWithClassPath(\n+          newClassPath.toString(), pwd, mergedEnv);\n+        environment.put(Environment.CLASSPATH.name(), classPathJar);\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs, Map\u003cPath, List\u003cString\u003e\u003e resources)\n      throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        StringBuilder newClassPath \u003d new StringBuilder(inputClassPath);\n\n        // Localized resources do not exist at the desired paths yet, because the\n        // container launch script has not run to create symlinks yet.  This\n        // means that FileUtil.createJarWithClassPath can\u0027t automatically expand\n        // wildcards to separate classpath entries for each file in the manifest.\n        // To resolve this, append classpath entries explicitly for each\n        // resource.\n        for (Map.Entry\u003cPath,List\u003cString\u003e\u003e entry : resources.entrySet()) {\n          boolean targetIsDirectory \u003d new File(entry.getKey().toUri().getPath())\n            .isDirectory();\n\n          for (String linkName : entry.getValue()) {\n            // Append resource.\n            newClassPath.append(File.pathSeparator).append(pwd.toString())\n              .append(Path.SEPARATOR).append(linkName);\n\n            // FileUtil.createJarWithClassPath must use File.toURI to convert\n            // each file to a URI to write into the manifest\u0027s classpath.  For\n            // directories, the classpath must have a trailing \u0027/\u0027, but\n            // File.toURI only appends the trailing \u0027/\u0027 if it is a directory that\n            // already exists.  To resolve this, add the classpath entries with\n            // explicit trailing \u0027/\u0027 here for any localized resource that targets\n            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee\n            // that the resulting entry in the manifest\u0027s classpath will have a\n            // trailing \u0027/\u0027, and thus refer to a directory instead of a file.\n            if (targetIsDirectory) {\n              newClassPath.append(Path.SEPARATOR);\n            }\n          }\n        }\n\n        // When the container launches, it takes the parent process\u0027s environment\n        // and then adds/overwrites with the entries from the container launch\n        // context.  Do the same thing here for correct substitution of\n        // environment variables in the classpath jar manifest.\n        Map\u003cString, String\u003e mergedEnv \u003d new HashMap\u003cString, String\u003e(\n          System.getenv());\n        mergedEnv.putAll(environment);\n\n        String classPathJar \u003d FileUtil.createJarWithClassPath(\n          newClassPath.toString(), pwd, mergedEnv);\n        environment.put(Environment.CLASSPATH.name(), classPathJar);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "92fb7cdcdeedf2a68b127667ced2633dae22f970": {
      "type": "Ybodychange",
      "commitMessage": "YARN-488. TestContainerManagerSecurity fails on Windows. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459514 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/13 1:38 PM",
      "commitName": "92fb7cdcdeedf2a68b127667ced2633dae22f970",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "06/03/13 11:15 AM",
      "commitNameOld": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 15.06,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,64 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n       Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n     \n     putEnvIfNotNull(environment, \n         ApplicationConstants.LOCAL_DIR_ENV, \n         StringUtils.join(\",\", appDirs)\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     // TODO: Remove Windows check and use this approach on all platforms after\n     // additional testing.  See YARN-358.\n     if (Shell.WINDOWS) {\n       String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n-      environment.put(Environment.CLASSPATH.name(),\n-          FileUtil.createJarWithClassPath(inputClassPath, pwd));\n+      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n+        environment.put(Environment.CLASSPATH.name(),\n+            FileUtil.createJarWithClassPath(inputClassPath, pwd));\n+      }\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      if (inputClassPath !\u003d null \u0026\u0026 !inputClassPath.isEmpty()) {\n        environment.put(Environment.CLASSPATH.name(),\n            FileUtil.createJarWithClassPath(inputClassPath, pwd));\n      }\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "638801cce16fc1dc3259c541dc30a599faaddda1": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/03/13 11:15 AM",
      "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/03/13 11:15 AM",
          "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "09/08/12 12:15 PM",
          "commitNameOld": "82910ecaa383381ea04932a9d5e2dfa78ae9e5cb",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 209.0,
          "commitsBetweenForRepo": 1053,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,62 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n-      Path pwd, List\u003cPath\u003e appDirs) {\n+      Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n     \n     putEnvIfNotNull(environment, \n         ApplicationConstants.LOCAL_DIR_ENV, \n         StringUtils.join(\",\", appDirs)\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n+    // TODO: Remove Windows check and use this approach on all platforms after\n+    // additional testing.  See YARN-358.\n+    if (Shell.WINDOWS) {\n+      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n+      environment.put(Environment.CLASSPATH.name(),\n+          FileUtil.createJarWithClassPath(inputClassPath, pwd));\n+    }\n+\n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      environment.put(Environment.CLASSPATH.name(),\n          FileUtil.createJarWithClassPath(inputClassPath, pwd));\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/03/13 11:15 AM",
          "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "09/08/12 12:15 PM",
          "commitNameOld": "82910ecaa383381ea04932a9d5e2dfa78ae9e5cb",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 209.0,
          "commitsBetweenForRepo": 1053,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,62 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n-      Path pwd, List\u003cPath\u003e appDirs) {\n+      Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n     /**\n      * Non-modifiable environment variables\n      */\n \n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n     \n     putEnvIfNotNull(environment, \n         ApplicationConstants.LOCAL_DIR_ENV, \n         StringUtils.join(\",\", appDirs)\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n+    // TODO: Remove Windows check and use this approach on all platforms after\n+    // additional testing.  See YARN-358.\n+    if (Shell.WINDOWS) {\n+      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n+      environment.put(Environment.CLASSPATH.name(),\n+          FileUtil.createJarWithClassPath(inputClassPath, pwd));\n+    }\n+\n     /**\n      * Modifiable environment variables\n      */\n     \n     // allow containers to override these variables\n     String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n     \n     for(String whitelistEnvVariable : whitelist) {\n       putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n     }\n \n     // variables here will be forced in, even if the container has specified them.\n     Apps.setEnvFromInputString(\n       environment,\n       conf.get(\n         YarnConfiguration.NM_ADMIN_USER_ENV,\n         YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n     );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs) throws IOException {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    // TODO: Remove Windows check and use this approach on all platforms after\n    // additional testing.  See YARN-358.\n    if (Shell.WINDOWS) {\n      String inputClassPath \u003d environment.get(Environment.CLASSPATH.name());\n      environment.put(Environment.CLASSPATH.name(),\n          FileUtil.createJarWithClassPath(inputClassPath, pwd));\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs) {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java"
      }
    },
    "c1d90772b6e38bb4e4be7ed75cb5d34f3048ad7b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3068. Added a whitelist of environment variables for containers from the NodeManager and set MALLOC_ARENA_MAX for all daemons and containers. Contributed by Chris Riccomini. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185447 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/10/11 6:22 PM",
      "commitName": "c1d90772b6e38bb4e4be7ed75cb5d34f3048ad7b",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "09/10/11 8:27 PM",
      "commitNameOld": "811a6a9e308935fca762a57610c56b317c43a349",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 7.91,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,54 @@\n   public void sanitizeEnv(Map\u003cString, String\u003e environment, \n       Path pwd, List\u003cPath\u003e appDirs) {\n     /**\n      * Non-modifiable environment variables\n      */\n-    \n+\n     putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.LOGNAME.name(),container.getUser());\n     \n     putEnvIfNotNull(environment, \n         Environment.HOME.name(),\n         conf.get(\n             YarnConfiguration.NM_USER_HOME_DIR, \n             YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n             )\n         );\n     \n     putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n     \n     putEnvIfNotNull(environment, \n         Environment.HADOOP_CONF_DIR.name(), \n         System.getenv(Environment.HADOOP_CONF_DIR.name())\n         );\n     \n     putEnvIfNotNull(environment, \n         ApplicationConstants.LOCAL_DIR_ENV, \n         StringUtils.join(\",\", appDirs)\n         );\n \n     if (!Shell.WINDOWS) {\n       environment.put(\"JVM_PID\", \"$$\");\n     }\n \n     /**\n      * Modifiable environment variables\n      */\n     \n-    putEnvIfAbsent(environment, Environment.JAVA_HOME.name());\n-    putEnvIfAbsent(environment, Environment.HADOOP_COMMON_HOME.name());\n-    putEnvIfAbsent(environment, Environment.HADOOP_HDFS_HOME.name());\n-    putEnvIfAbsent(environment, Environment.YARN_HOME.name());\n+    // allow containers to override these variables\n+    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n+    \n+    for(String whitelistEnvVariable : whitelist) {\n+      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n+    }\n \n+    // variables here will be forced in, even if the container has specified them.\n+    Apps.setEnvFromInputString(\n+      environment,\n+      conf.get(\n+        YarnConfiguration.NM_ADMIN_USER_ENV,\n+        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n+    );\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs) {\n    /**\n     * Non-modifiable environment variables\n     */\n\n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    // allow containers to override these variables\n    String[] whitelist \u003d conf.get(YarnConfiguration.NM_ENV_WHITELIST, YarnConfiguration.DEFAULT_NM_ENV_WHITELIST).split(\",\");\n    \n    for(String whitelistEnvVariable : whitelist) {\n      putEnvIfAbsent(environment, whitelistEnvVariable.trim());\n    }\n\n    // variables here will be forced in, even if the container has specified them.\n    Apps.setEnvFromInputString(\n      environment,\n      conf.get(\n        YarnConfiguration.NM_ADMIN_USER_ENV,\n        YarnConfiguration.DEFAULT_NM_ADMIN_USER_ENV)\n    );\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2880. Improved classpath-construction for mapreduce AM and containers. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1173783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/09/11 11:28 AM",
      "commitName": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,45 @@\n+  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n+      Path pwd, List\u003cPath\u003e appDirs) {\n+    /**\n+     * Non-modifiable environment variables\n+     */\n+    \n+    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n+    \n+    putEnvIfNotNull(environment, \n+        Environment.LOGNAME.name(),container.getUser());\n+    \n+    putEnvIfNotNull(environment, \n+        Environment.HOME.name(),\n+        conf.get(\n+            YarnConfiguration.NM_USER_HOME_DIR, \n+            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n+            )\n+        );\n+    \n+    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n+    \n+    putEnvIfNotNull(environment, \n+        Environment.HADOOP_CONF_DIR.name(), \n+        System.getenv(Environment.HADOOP_CONF_DIR.name())\n+        );\n+    \n+    putEnvIfNotNull(environment, \n+        ApplicationConstants.LOCAL_DIR_ENV, \n+        StringUtils.join(\",\", appDirs)\n+        );\n+\n+    if (!Shell.WINDOWS) {\n+      environment.put(\"JVM_PID\", \"$$\");\n+    }\n+\n+    /**\n+     * Modifiable environment variables\n+     */\n+    \n+    putEnvIfAbsent(environment, Environment.JAVA_HOME.name());\n+    putEnvIfAbsent(environment, Environment.HADOOP_COMMON_HOME.name());\n+    putEnvIfAbsent(environment, Environment.HADOOP_HDFS_HOME.name());\n+    putEnvIfAbsent(environment, Environment.YARN_HOME.name());\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void sanitizeEnv(Map\u003cString, String\u003e environment, \n      Path pwd, List\u003cPath\u003e appDirs) {\n    /**\n     * Non-modifiable environment variables\n     */\n    \n    putEnvIfNotNull(environment, Environment.USER.name(), container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.LOGNAME.name(),container.getUser());\n    \n    putEnvIfNotNull(environment, \n        Environment.HOME.name(),\n        conf.get(\n            YarnConfiguration.NM_USER_HOME_DIR, \n            YarnConfiguration.DEFAULT_NM_USER_HOME_DIR\n            )\n        );\n    \n    putEnvIfNotNull(environment, Environment.PWD.name(), pwd.toString());\n    \n    putEnvIfNotNull(environment, \n        Environment.HADOOP_CONF_DIR.name(), \n        System.getenv(Environment.HADOOP_CONF_DIR.name())\n        );\n    \n    putEnvIfNotNull(environment, \n        ApplicationConstants.LOCAL_DIR_ENV, \n        StringUtils.join(\",\", appDirs)\n        );\n\n    if (!Shell.WINDOWS) {\n      environment.put(\"JVM_PID\", \"$$\");\n    }\n\n    /**\n     * Modifiable environment variables\n     */\n    \n    putEnvIfAbsent(environment, Environment.JAVA_HOME.name());\n    putEnvIfAbsent(environment, Environment.HADOOP_COMMON_HOME.name());\n    putEnvIfAbsent(environment, Environment.HADOOP_HDFS_HOME.name());\n    putEnvIfAbsent(environment, Environment.YARN_HOME.name());\n\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java"
    }
  }
}