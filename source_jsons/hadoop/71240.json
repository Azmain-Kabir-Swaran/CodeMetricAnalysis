{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AuditReplayThread.java",
  "functionName": "replayLog",
  "functionId": "replayLog___command-AuditReplayCommand(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-workload/src/main/java/org/apache/hadoop/tools/dynamometer/workloadgenerator/audit/AuditReplayThread.java",
  "functionStartLine": 198,
  "functionEndLine": 327,
  "numCommitsSeen": 2,
  "timeTaken": 949,
  "changeHistory": [
    "477505ccfc480f2605a7b65de95ea6f6ff5ce090",
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91"
  ],
  "changeHistoryShort": {
    "477505ccfc480f2605a7b65de95ea6f6ff5ce090": "Ybodychange",
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": "Yintroduced"
  },
  "changeHistoryDetails": {
    "477505ccfc480f2605a7b65de95ea6f6ff5ce090": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14824. [Dynamometer] Dynamometer in org.apache.hadoop.tools does not output the benchmark results. (#1685)\n\n\r\n",
      "commitDate": "01/11/19 9:32 AM",
      "commitName": "477505ccfc480f2605a7b65de95ea6f6ff5ce090",
      "commitAuthor": "Takanobu Asanuma",
      "commitDateOld": "25/06/19 8:07 AM",
      "commitNameOld": "ab0b180ddb5d0775a2452d5eeb7badd252aadb91",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 129.06,
      "commitsBetweenForRepo": 962,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,130 @@\n   private boolean replayLog(final AuditReplayCommand command) {\n     final String src \u003d command.getSrc();\n     final String dst \u003d command.getDest();\n     FileSystem proxyFs \u003d fsCache.get(command.getSimpleUgi());\n     if (proxyFs \u003d\u003d null) {\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(command.getSimpleUgi(), loginUser);\n       proxyFs \u003d ugi.doAs((PrivilegedAction\u003cFileSystem\u003e) () -\u003e {\n         try {\n           FileSystem fs \u003d new DistributedFileSystem();\n           fs.initialize(namenodeUri, mapperConf);\n           return fs;\n         } catch (IOException ioe) {\n           throw new RuntimeException(ioe);\n         }\n       });\n       fsCache.put(command.getSimpleUgi(), proxyFs);\n     }\n     final FileSystem fs \u003d proxyFs;\n     ReplayCommand replayCommand;\n     try {\n       replayCommand \u003d ReplayCommand\n           .valueOf(command.getCommand().split(\" \")[0].toUpperCase());\n     } catch (IllegalArgumentException iae) {\n       LOG.warn(\"Unsupported/invalid command: \" + command);\n       replayCountersMap.get(REPLAYCOUNTERS.TOTALUNSUPPORTEDCOMMANDS)\n           .increment(1);\n       return false;\n     }\n     try {\n       long startTime \u003d System.currentTimeMillis();\n       switch (replayCommand) {\n       case CREATE:\n         FSDataOutputStream fsDos \u003d fs.create(new Path(src));\n         if (createBlocks) {\n           fsDos.writeByte(0);\n         }\n         fsDos.close();\n         break;\n       case GETFILEINFO:\n         fs.getFileStatus(new Path(src));\n         break;\n       case CONTENTSUMMARY:\n         fs.getContentSummary(new Path(src));\n         break;\n       case MKDIRS:\n         fs.mkdirs(new Path(src));\n         break;\n       case RENAME:\n         fs.rename(new Path(src), new Path(dst));\n         break;\n       case LISTSTATUS:\n         ((DistributedFileSystem) fs).getClient().listPaths(src,\n             HdfsFileStatus.EMPTY_NAME);\n         break;\n       case APPEND:\n         fs.append(new Path(src));\n         return true;\n       case DELETE:\n         fs.delete(new Path(src), true);\n         break;\n       case OPEN:\n         fs.open(new Path(src)).close();\n         break;\n       case SETPERMISSION:\n         fs.setPermission(new Path(src), FsPermission.getDefault());\n         break;\n       case SETOWNER:\n         fs.setOwner(new Path(src),\n             UserGroupInformation.getCurrentUser().getShortUserName(),\n             UserGroupInformation.getCurrentUser().getPrimaryGroupName());\n         break;\n       case SETTIMES:\n         fs.setTimes(new Path(src), System.currentTimeMillis(),\n             System.currentTimeMillis());\n         break;\n       case SETREPLICATION:\n         fs.setReplication(new Path(src), (short) 1);\n         break;\n       case CONCAT:\n         // dst is like [path1, path2] - strip brackets and split on comma\n         String bareDist \u003d dst.length() \u003c 2 ? \"\"\n             : dst.substring(1, dst.length() - 1).trim();\n         List\u003cPath\u003e dsts \u003d new ArrayList\u003c\u003e();\n         for (String s : Splitter.on(\",\").omitEmptyStrings().trimResults()\n             .split(bareDist)) {\n           dsts.add(new Path(s));\n         }\n         fs.concat(new Path(src), dsts.toArray(new Path[] {}));\n         break;\n       default:\n         throw new RuntimeException(\"Unexpected command: \" + replayCommand);\n       }\n       long latency \u003d System.currentTimeMillis() - startTime;\n+\n+      UserCommandKey userCommandKey \u003d new UserCommandKey(command.getSimpleUgi(),\n+          replayCommand.toString(), replayCommand.getType().toString());\n+      commandLatencyMap.putIfAbsent(userCommandKey, new CountTimeWritable());\n+      CountTimeWritable latencyWritable \u003d commandLatencyMap.get(userCommandKey);\n+      latencyWritable.setCount(latencyWritable.getCount() + 1);\n+      latencyWritable.setTime(latencyWritable.getTime() + latency);\n+\n       switch (replayCommand.getType()) {\n       case WRITE:\n         replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDLATENCY)\n             .increment(latency);\n         replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDS).increment(1);\n         break;\n       case READ:\n         replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDLATENCY)\n             .increment(latency);\n         replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDS).increment(1);\n         break;\n       default:\n         throw new RuntimeException(\"Unexpected command type: \"\n             + replayCommand.getType());\n       }\n       individualCommandsMap\n           .get(replayCommand + INDIVIDUAL_COMMANDS_LATENCY_SUFFIX)\n           .increment(latency);\n       individualCommandsMap\n           .get(replayCommand + INDIVIDUAL_COMMANDS_COUNT_SUFFIX).increment(1);\n       return true;\n     } catch (IOException e) {\n       LOG.debug(\"IOException: \" + e.getLocalizedMessage());\n       individualCommandsMap\n           .get(replayCommand + INDIVIDUAL_COMMANDS_INVALID_SUFFIX).increment(1);\n       return false;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean replayLog(final AuditReplayCommand command) {\n    final String src \u003d command.getSrc();\n    final String dst \u003d command.getDest();\n    FileSystem proxyFs \u003d fsCache.get(command.getSimpleUgi());\n    if (proxyFs \u003d\u003d null) {\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(command.getSimpleUgi(), loginUser);\n      proxyFs \u003d ugi.doAs((PrivilegedAction\u003cFileSystem\u003e) () -\u003e {\n        try {\n          FileSystem fs \u003d new DistributedFileSystem();\n          fs.initialize(namenodeUri, mapperConf);\n          return fs;\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      });\n      fsCache.put(command.getSimpleUgi(), proxyFs);\n    }\n    final FileSystem fs \u003d proxyFs;\n    ReplayCommand replayCommand;\n    try {\n      replayCommand \u003d ReplayCommand\n          .valueOf(command.getCommand().split(\" \")[0].toUpperCase());\n    } catch (IllegalArgumentException iae) {\n      LOG.warn(\"Unsupported/invalid command: \" + command);\n      replayCountersMap.get(REPLAYCOUNTERS.TOTALUNSUPPORTEDCOMMANDS)\n          .increment(1);\n      return false;\n    }\n    try {\n      long startTime \u003d System.currentTimeMillis();\n      switch (replayCommand) {\n      case CREATE:\n        FSDataOutputStream fsDos \u003d fs.create(new Path(src));\n        if (createBlocks) {\n          fsDos.writeByte(0);\n        }\n        fsDos.close();\n        break;\n      case GETFILEINFO:\n        fs.getFileStatus(new Path(src));\n        break;\n      case CONTENTSUMMARY:\n        fs.getContentSummary(new Path(src));\n        break;\n      case MKDIRS:\n        fs.mkdirs(new Path(src));\n        break;\n      case RENAME:\n        fs.rename(new Path(src), new Path(dst));\n        break;\n      case LISTSTATUS:\n        ((DistributedFileSystem) fs).getClient().listPaths(src,\n            HdfsFileStatus.EMPTY_NAME);\n        break;\n      case APPEND:\n        fs.append(new Path(src));\n        return true;\n      case DELETE:\n        fs.delete(new Path(src), true);\n        break;\n      case OPEN:\n        fs.open(new Path(src)).close();\n        break;\n      case SETPERMISSION:\n        fs.setPermission(new Path(src), FsPermission.getDefault());\n        break;\n      case SETOWNER:\n        fs.setOwner(new Path(src),\n            UserGroupInformation.getCurrentUser().getShortUserName(),\n            UserGroupInformation.getCurrentUser().getPrimaryGroupName());\n        break;\n      case SETTIMES:\n        fs.setTimes(new Path(src), System.currentTimeMillis(),\n            System.currentTimeMillis());\n        break;\n      case SETREPLICATION:\n        fs.setReplication(new Path(src), (short) 1);\n        break;\n      case CONCAT:\n        // dst is like [path1, path2] - strip brackets and split on comma\n        String bareDist \u003d dst.length() \u003c 2 ? \"\"\n            : dst.substring(1, dst.length() - 1).trim();\n        List\u003cPath\u003e dsts \u003d new ArrayList\u003c\u003e();\n        for (String s : Splitter.on(\",\").omitEmptyStrings().trimResults()\n            .split(bareDist)) {\n          dsts.add(new Path(s));\n        }\n        fs.concat(new Path(src), dsts.toArray(new Path[] {}));\n        break;\n      default:\n        throw new RuntimeException(\"Unexpected command: \" + replayCommand);\n      }\n      long latency \u003d System.currentTimeMillis() - startTime;\n\n      UserCommandKey userCommandKey \u003d new UserCommandKey(command.getSimpleUgi(),\n          replayCommand.toString(), replayCommand.getType().toString());\n      commandLatencyMap.putIfAbsent(userCommandKey, new CountTimeWritable());\n      CountTimeWritable latencyWritable \u003d commandLatencyMap.get(userCommandKey);\n      latencyWritable.setCount(latencyWritable.getCount() + 1);\n      latencyWritable.setTime(latencyWritable.getTime() + latency);\n\n      switch (replayCommand.getType()) {\n      case WRITE:\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDLATENCY)\n            .increment(latency);\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDS).increment(1);\n        break;\n      case READ:\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDLATENCY)\n            .increment(latency);\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDS).increment(1);\n        break;\n      default:\n        throw new RuntimeException(\"Unexpected command type: \"\n            + replayCommand.getType());\n      }\n      individualCommandsMap\n          .get(replayCommand + INDIVIDUAL_COMMANDS_LATENCY_SUFFIX)\n          .increment(latency);\n      individualCommandsMap\n          .get(replayCommand + INDIVIDUAL_COMMANDS_COUNT_SUFFIX).increment(1);\n      return true;\n    } catch (IOException e) {\n      LOG.debug(\"IOException: \" + e.getLocalizedMessage());\n      individualCommandsMap\n          .get(replayCommand + INDIVIDUAL_COMMANDS_INVALID_SUFFIX).increment(1);\n      return false;\n    }\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-workload/src/main/java/org/apache/hadoop/tools/dynamometer/workloadgenerator/audit/AuditReplayThread.java",
      "extendedDetails": {}
    },
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12345 Add Dynamometer to hadoop-tools, a tool for scale testing the HDFS NameNode with real metadata and workloads. Contributed by Erik Krogen.\n",
      "commitDate": "25/06/19 8:07 AM",
      "commitName": "ab0b180ddb5d0775a2452d5eeb7badd252aadb91",
      "commitAuthor": "Erik Krogen",
      "diff": "@@ -0,0 +1,122 @@\n+  private boolean replayLog(final AuditReplayCommand command) {\n+    final String src \u003d command.getSrc();\n+    final String dst \u003d command.getDest();\n+    FileSystem proxyFs \u003d fsCache.get(command.getSimpleUgi());\n+    if (proxyFs \u003d\u003d null) {\n+      UserGroupInformation ugi \u003d UserGroupInformation\n+          .createProxyUser(command.getSimpleUgi(), loginUser);\n+      proxyFs \u003d ugi.doAs((PrivilegedAction\u003cFileSystem\u003e) () -\u003e {\n+        try {\n+          FileSystem fs \u003d new DistributedFileSystem();\n+          fs.initialize(namenodeUri, mapperConf);\n+          return fs;\n+        } catch (IOException ioe) {\n+          throw new RuntimeException(ioe);\n+        }\n+      });\n+      fsCache.put(command.getSimpleUgi(), proxyFs);\n+    }\n+    final FileSystem fs \u003d proxyFs;\n+    ReplayCommand replayCommand;\n+    try {\n+      replayCommand \u003d ReplayCommand\n+          .valueOf(command.getCommand().split(\" \")[0].toUpperCase());\n+    } catch (IllegalArgumentException iae) {\n+      LOG.warn(\"Unsupported/invalid command: \" + command);\n+      replayCountersMap.get(REPLAYCOUNTERS.TOTALUNSUPPORTEDCOMMANDS)\n+          .increment(1);\n+      return false;\n+    }\n+    try {\n+      long startTime \u003d System.currentTimeMillis();\n+      switch (replayCommand) {\n+      case CREATE:\n+        FSDataOutputStream fsDos \u003d fs.create(new Path(src));\n+        if (createBlocks) {\n+          fsDos.writeByte(0);\n+        }\n+        fsDos.close();\n+        break;\n+      case GETFILEINFO:\n+        fs.getFileStatus(new Path(src));\n+        break;\n+      case CONTENTSUMMARY:\n+        fs.getContentSummary(new Path(src));\n+        break;\n+      case MKDIRS:\n+        fs.mkdirs(new Path(src));\n+        break;\n+      case RENAME:\n+        fs.rename(new Path(src), new Path(dst));\n+        break;\n+      case LISTSTATUS:\n+        ((DistributedFileSystem) fs).getClient().listPaths(src,\n+            HdfsFileStatus.EMPTY_NAME);\n+        break;\n+      case APPEND:\n+        fs.append(new Path(src));\n+        return true;\n+      case DELETE:\n+        fs.delete(new Path(src), true);\n+        break;\n+      case OPEN:\n+        fs.open(new Path(src)).close();\n+        break;\n+      case SETPERMISSION:\n+        fs.setPermission(new Path(src), FsPermission.getDefault());\n+        break;\n+      case SETOWNER:\n+        fs.setOwner(new Path(src),\n+            UserGroupInformation.getCurrentUser().getShortUserName(),\n+            UserGroupInformation.getCurrentUser().getPrimaryGroupName());\n+        break;\n+      case SETTIMES:\n+        fs.setTimes(new Path(src), System.currentTimeMillis(),\n+            System.currentTimeMillis());\n+        break;\n+      case SETREPLICATION:\n+        fs.setReplication(new Path(src), (short) 1);\n+        break;\n+      case CONCAT:\n+        // dst is like [path1, path2] - strip brackets and split on comma\n+        String bareDist \u003d dst.length() \u003c 2 ? \"\"\n+            : dst.substring(1, dst.length() - 1).trim();\n+        List\u003cPath\u003e dsts \u003d new ArrayList\u003c\u003e();\n+        for (String s : Splitter.on(\",\").omitEmptyStrings().trimResults()\n+            .split(bareDist)) {\n+          dsts.add(new Path(s));\n+        }\n+        fs.concat(new Path(src), dsts.toArray(new Path[] {}));\n+        break;\n+      default:\n+        throw new RuntimeException(\"Unexpected command: \" + replayCommand);\n+      }\n+      long latency \u003d System.currentTimeMillis() - startTime;\n+      switch (replayCommand.getType()) {\n+      case WRITE:\n+        replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDLATENCY)\n+            .increment(latency);\n+        replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDS).increment(1);\n+        break;\n+      case READ:\n+        replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDLATENCY)\n+            .increment(latency);\n+        replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDS).increment(1);\n+        break;\n+      default:\n+        throw new RuntimeException(\"Unexpected command type: \"\n+            + replayCommand.getType());\n+      }\n+      individualCommandsMap\n+          .get(replayCommand + INDIVIDUAL_COMMANDS_LATENCY_SUFFIX)\n+          .increment(latency);\n+      individualCommandsMap\n+          .get(replayCommand + INDIVIDUAL_COMMANDS_COUNT_SUFFIX).increment(1);\n+      return true;\n+    } catch (IOException e) {\n+      LOG.debug(\"IOException: \" + e.getLocalizedMessage());\n+      individualCommandsMap\n+          .get(replayCommand + INDIVIDUAL_COMMANDS_INVALID_SUFFIX).increment(1);\n+      return false;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean replayLog(final AuditReplayCommand command) {\n    final String src \u003d command.getSrc();\n    final String dst \u003d command.getDest();\n    FileSystem proxyFs \u003d fsCache.get(command.getSimpleUgi());\n    if (proxyFs \u003d\u003d null) {\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(command.getSimpleUgi(), loginUser);\n      proxyFs \u003d ugi.doAs((PrivilegedAction\u003cFileSystem\u003e) () -\u003e {\n        try {\n          FileSystem fs \u003d new DistributedFileSystem();\n          fs.initialize(namenodeUri, mapperConf);\n          return fs;\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      });\n      fsCache.put(command.getSimpleUgi(), proxyFs);\n    }\n    final FileSystem fs \u003d proxyFs;\n    ReplayCommand replayCommand;\n    try {\n      replayCommand \u003d ReplayCommand\n          .valueOf(command.getCommand().split(\" \")[0].toUpperCase());\n    } catch (IllegalArgumentException iae) {\n      LOG.warn(\"Unsupported/invalid command: \" + command);\n      replayCountersMap.get(REPLAYCOUNTERS.TOTALUNSUPPORTEDCOMMANDS)\n          .increment(1);\n      return false;\n    }\n    try {\n      long startTime \u003d System.currentTimeMillis();\n      switch (replayCommand) {\n      case CREATE:\n        FSDataOutputStream fsDos \u003d fs.create(new Path(src));\n        if (createBlocks) {\n          fsDos.writeByte(0);\n        }\n        fsDos.close();\n        break;\n      case GETFILEINFO:\n        fs.getFileStatus(new Path(src));\n        break;\n      case CONTENTSUMMARY:\n        fs.getContentSummary(new Path(src));\n        break;\n      case MKDIRS:\n        fs.mkdirs(new Path(src));\n        break;\n      case RENAME:\n        fs.rename(new Path(src), new Path(dst));\n        break;\n      case LISTSTATUS:\n        ((DistributedFileSystem) fs).getClient().listPaths(src,\n            HdfsFileStatus.EMPTY_NAME);\n        break;\n      case APPEND:\n        fs.append(new Path(src));\n        return true;\n      case DELETE:\n        fs.delete(new Path(src), true);\n        break;\n      case OPEN:\n        fs.open(new Path(src)).close();\n        break;\n      case SETPERMISSION:\n        fs.setPermission(new Path(src), FsPermission.getDefault());\n        break;\n      case SETOWNER:\n        fs.setOwner(new Path(src),\n            UserGroupInformation.getCurrentUser().getShortUserName(),\n            UserGroupInformation.getCurrentUser().getPrimaryGroupName());\n        break;\n      case SETTIMES:\n        fs.setTimes(new Path(src), System.currentTimeMillis(),\n            System.currentTimeMillis());\n        break;\n      case SETREPLICATION:\n        fs.setReplication(new Path(src), (short) 1);\n        break;\n      case CONCAT:\n        // dst is like [path1, path2] - strip brackets and split on comma\n        String bareDist \u003d dst.length() \u003c 2 ? \"\"\n            : dst.substring(1, dst.length() - 1).trim();\n        List\u003cPath\u003e dsts \u003d new ArrayList\u003c\u003e();\n        for (String s : Splitter.on(\",\").omitEmptyStrings().trimResults()\n            .split(bareDist)) {\n          dsts.add(new Path(s));\n        }\n        fs.concat(new Path(src), dsts.toArray(new Path[] {}));\n        break;\n      default:\n        throw new RuntimeException(\"Unexpected command: \" + replayCommand);\n      }\n      long latency \u003d System.currentTimeMillis() - startTime;\n      switch (replayCommand.getType()) {\n      case WRITE:\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDLATENCY)\n            .increment(latency);\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALWRITECOMMANDS).increment(1);\n        break;\n      case READ:\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDLATENCY)\n            .increment(latency);\n        replayCountersMap.get(REPLAYCOUNTERS.TOTALREADCOMMANDS).increment(1);\n        break;\n      default:\n        throw new RuntimeException(\"Unexpected command type: \"\n            + replayCommand.getType());\n      }\n      individualCommandsMap\n          .get(replayCommand + INDIVIDUAL_COMMANDS_LATENCY_SUFFIX)\n          .increment(latency);\n      individualCommandsMap\n          .get(replayCommand + INDIVIDUAL_COMMANDS_COUNT_SUFFIX).increment(1);\n      return true;\n    } catch (IOException e) {\n      LOG.debug(\"IOException: \" + e.getLocalizedMessage());\n      individualCommandsMap\n          .get(replayCommand + INDIVIDUAL_COMMANDS_INVALID_SUFFIX).increment(1);\n      return false;\n    }\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-workload/src/main/java/org/apache/hadoop/tools/dynamometer/workloadgenerator/audit/AuditReplayThread.java"
    }
  }
}