{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TopCLI.java",
  "functionName": "getQueueMetrics",
  "functionId": "getQueueMetrics",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/TopCLI.java",
  "functionStartLine": 709,
  "functionEndLine": 760,
  "numCommitsSeen": 12,
  "timeTaken": 1313,
  "changeHistory": [
    "154c9d2e421390c808dea3b2826cdaae492ea337",
    "577d755e4bf72d6adedeba51be01ff5f3f028de0"
  ],
  "changeHistoryShort": {
    "154c9d2e421390c808dea3b2826cdaae492ea337": "Ybodychange",
    "577d755e4bf72d6adedeba51be01ff5f3f028de0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "154c9d2e421390c808dea3b2826cdaae492ea337": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3961. Expose pending, running and reserved containers of a queue in REST api and yarn top (adhoot via asuresh)\n",
      "commitDate": "05/08/15 11:14 PM",
      "commitName": "154c9d2e421390c808dea3b2826cdaae492ea337",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "10/04/15 9:57 AM",
      "commitNameOld": "577d755e4bf72d6adedeba51be01ff5f3f028de0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 117.55,
      "commitsBetweenForRepo": 914,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,52 @@\n   protected QueueMetrics getQueueMetrics() {\n     QueueMetrics queueMetrics \u003d new QueueMetrics();\n     List\u003cQueueInfo\u003e queuesInfo;\n     if (queues.isEmpty()) {\n       try {\n         queuesInfo \u003d client.getRootQueueInfos();\n       } catch (Exception ie) {\n         LOG.error(\"Unable to get queue information\", ie);\n         return queueMetrics;\n       }\n     } else {\n       queuesInfo \u003d new ArrayList\u003c\u003e();\n       for (String queueName : queues) {\n         try {\n           QueueInfo qInfo \u003d client.getQueueInfo(queueName);\n           queuesInfo.add(qInfo);\n         } catch (Exception ie) {\n           LOG.error(\"Unable to get queue information\", ie);\n           return queueMetrics;\n         }\n       }\n     }\n \n     for (QueueInfo childInfo : queuesInfo) {\n       QueueStatistics stats \u003d childInfo.getQueueStatistics();\n       if (stats !\u003d null) {\n         queueMetrics.appsSubmitted +\u003d stats.getNumAppsSubmitted();\n         queueMetrics.appsRunning +\u003d stats.getNumAppsRunning();\n         queueMetrics.appsPending +\u003d stats.getNumAppsPending();\n         queueMetrics.appsCompleted +\u003d stats.getNumAppsCompleted();\n         queueMetrics.appsKilled +\u003d stats.getNumAppsKilled();\n         queueMetrics.appsFailed +\u003d stats.getNumAppsFailed();\n         queueMetrics.activeUsers +\u003d stats.getNumActiveUsers();\n         queueMetrics.availableMemoryGB +\u003d stats.getAvailableMemoryMB();\n         queueMetrics.allocatedMemoryGB +\u003d stats.getAllocatedMemoryMB();\n         queueMetrics.pendingMemoryGB +\u003d stats.getPendingMemoryMB();\n         queueMetrics.reservedMemoryGB +\u003d stats.getReservedMemoryMB();\n         queueMetrics.availableVCores +\u003d stats.getAvailableVCores();\n         queueMetrics.allocatedVCores +\u003d stats.getAllocatedVCores();\n         queueMetrics.pendingVCores +\u003d stats.getPendingVCores();\n         queueMetrics.reservedVCores +\u003d stats.getReservedVCores();\n+        queueMetrics.allocatedContainers +\u003d stats.getAllocatedContainers();\n+        queueMetrics.pendingContainers +\u003d stats.getPendingContainers();\n+        queueMetrics.reservedContainers +\u003d stats.getReservedContainers();\n       }\n     }\n     queueMetrics.availableMemoryGB \u003d queueMetrics.availableMemoryGB / 1024;\n     queueMetrics.allocatedMemoryGB \u003d queueMetrics.allocatedMemoryGB / 1024;\n     queueMetrics.pendingMemoryGB \u003d queueMetrics.pendingMemoryGB / 1024;\n     queueMetrics.reservedMemoryGB \u003d queueMetrics.reservedMemoryGB / 1024;\n     return queueMetrics;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected QueueMetrics getQueueMetrics() {\n    QueueMetrics queueMetrics \u003d new QueueMetrics();\n    List\u003cQueueInfo\u003e queuesInfo;\n    if (queues.isEmpty()) {\n      try {\n        queuesInfo \u003d client.getRootQueueInfos();\n      } catch (Exception ie) {\n        LOG.error(\"Unable to get queue information\", ie);\n        return queueMetrics;\n      }\n    } else {\n      queuesInfo \u003d new ArrayList\u003c\u003e();\n      for (String queueName : queues) {\n        try {\n          QueueInfo qInfo \u003d client.getQueueInfo(queueName);\n          queuesInfo.add(qInfo);\n        } catch (Exception ie) {\n          LOG.error(\"Unable to get queue information\", ie);\n          return queueMetrics;\n        }\n      }\n    }\n\n    for (QueueInfo childInfo : queuesInfo) {\n      QueueStatistics stats \u003d childInfo.getQueueStatistics();\n      if (stats !\u003d null) {\n        queueMetrics.appsSubmitted +\u003d stats.getNumAppsSubmitted();\n        queueMetrics.appsRunning +\u003d stats.getNumAppsRunning();\n        queueMetrics.appsPending +\u003d stats.getNumAppsPending();\n        queueMetrics.appsCompleted +\u003d stats.getNumAppsCompleted();\n        queueMetrics.appsKilled +\u003d stats.getNumAppsKilled();\n        queueMetrics.appsFailed +\u003d stats.getNumAppsFailed();\n        queueMetrics.activeUsers +\u003d stats.getNumActiveUsers();\n        queueMetrics.availableMemoryGB +\u003d stats.getAvailableMemoryMB();\n        queueMetrics.allocatedMemoryGB +\u003d stats.getAllocatedMemoryMB();\n        queueMetrics.pendingMemoryGB +\u003d stats.getPendingMemoryMB();\n        queueMetrics.reservedMemoryGB +\u003d stats.getReservedMemoryMB();\n        queueMetrics.availableVCores +\u003d stats.getAvailableVCores();\n        queueMetrics.allocatedVCores +\u003d stats.getAllocatedVCores();\n        queueMetrics.pendingVCores +\u003d stats.getPendingVCores();\n        queueMetrics.reservedVCores +\u003d stats.getReservedVCores();\n        queueMetrics.allocatedContainers +\u003d stats.getAllocatedContainers();\n        queueMetrics.pendingContainers +\u003d stats.getPendingContainers();\n        queueMetrics.reservedContainers +\u003d stats.getReservedContainers();\n      }\n    }\n    queueMetrics.availableMemoryGB \u003d queueMetrics.availableMemoryGB / 1024;\n    queueMetrics.allocatedMemoryGB \u003d queueMetrics.allocatedMemoryGB / 1024;\n    queueMetrics.pendingMemoryGB \u003d queueMetrics.pendingMemoryGB / 1024;\n    queueMetrics.reservedMemoryGB \u003d queueMetrics.reservedMemoryGB / 1024;\n    return queueMetrics;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/TopCLI.java",
      "extendedDetails": {}
    },
    "577d755e4bf72d6adedeba51be01ff5f3f028de0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3348. Add a \u0027yarn top\u0027 tool to help understand cluster usage. Contributed by Varun Vasudev\n",
      "commitDate": "10/04/15 9:57 AM",
      "commitName": "577d755e4bf72d6adedeba51be01ff5f3f028de0",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,49 @@\n+  protected QueueMetrics getQueueMetrics() {\n+    QueueMetrics queueMetrics \u003d new QueueMetrics();\n+    List\u003cQueueInfo\u003e queuesInfo;\n+    if (queues.isEmpty()) {\n+      try {\n+        queuesInfo \u003d client.getRootQueueInfos();\n+      } catch (Exception ie) {\n+        LOG.error(\"Unable to get queue information\", ie);\n+        return queueMetrics;\n+      }\n+    } else {\n+      queuesInfo \u003d new ArrayList\u003c\u003e();\n+      for (String queueName : queues) {\n+        try {\n+          QueueInfo qInfo \u003d client.getQueueInfo(queueName);\n+          queuesInfo.add(qInfo);\n+        } catch (Exception ie) {\n+          LOG.error(\"Unable to get queue information\", ie);\n+          return queueMetrics;\n+        }\n+      }\n+    }\n+\n+    for (QueueInfo childInfo : queuesInfo) {\n+      QueueStatistics stats \u003d childInfo.getQueueStatistics();\n+      if (stats !\u003d null) {\n+        queueMetrics.appsSubmitted +\u003d stats.getNumAppsSubmitted();\n+        queueMetrics.appsRunning +\u003d stats.getNumAppsRunning();\n+        queueMetrics.appsPending +\u003d stats.getNumAppsPending();\n+        queueMetrics.appsCompleted +\u003d stats.getNumAppsCompleted();\n+        queueMetrics.appsKilled +\u003d stats.getNumAppsKilled();\n+        queueMetrics.appsFailed +\u003d stats.getNumAppsFailed();\n+        queueMetrics.activeUsers +\u003d stats.getNumActiveUsers();\n+        queueMetrics.availableMemoryGB +\u003d stats.getAvailableMemoryMB();\n+        queueMetrics.allocatedMemoryGB +\u003d stats.getAllocatedMemoryMB();\n+        queueMetrics.pendingMemoryGB +\u003d stats.getPendingMemoryMB();\n+        queueMetrics.reservedMemoryGB +\u003d stats.getReservedMemoryMB();\n+        queueMetrics.availableVCores +\u003d stats.getAvailableVCores();\n+        queueMetrics.allocatedVCores +\u003d stats.getAllocatedVCores();\n+        queueMetrics.pendingVCores +\u003d stats.getPendingVCores();\n+        queueMetrics.reservedVCores +\u003d stats.getReservedVCores();\n+      }\n+    }\n+    queueMetrics.availableMemoryGB \u003d queueMetrics.availableMemoryGB / 1024;\n+    queueMetrics.allocatedMemoryGB \u003d queueMetrics.allocatedMemoryGB / 1024;\n+    queueMetrics.pendingMemoryGB \u003d queueMetrics.pendingMemoryGB / 1024;\n+    queueMetrics.reservedMemoryGB \u003d queueMetrics.reservedMemoryGB / 1024;\n+    return queueMetrics;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected QueueMetrics getQueueMetrics() {\n    QueueMetrics queueMetrics \u003d new QueueMetrics();\n    List\u003cQueueInfo\u003e queuesInfo;\n    if (queues.isEmpty()) {\n      try {\n        queuesInfo \u003d client.getRootQueueInfos();\n      } catch (Exception ie) {\n        LOG.error(\"Unable to get queue information\", ie);\n        return queueMetrics;\n      }\n    } else {\n      queuesInfo \u003d new ArrayList\u003c\u003e();\n      for (String queueName : queues) {\n        try {\n          QueueInfo qInfo \u003d client.getQueueInfo(queueName);\n          queuesInfo.add(qInfo);\n        } catch (Exception ie) {\n          LOG.error(\"Unable to get queue information\", ie);\n          return queueMetrics;\n        }\n      }\n    }\n\n    for (QueueInfo childInfo : queuesInfo) {\n      QueueStatistics stats \u003d childInfo.getQueueStatistics();\n      if (stats !\u003d null) {\n        queueMetrics.appsSubmitted +\u003d stats.getNumAppsSubmitted();\n        queueMetrics.appsRunning +\u003d stats.getNumAppsRunning();\n        queueMetrics.appsPending +\u003d stats.getNumAppsPending();\n        queueMetrics.appsCompleted +\u003d stats.getNumAppsCompleted();\n        queueMetrics.appsKilled +\u003d stats.getNumAppsKilled();\n        queueMetrics.appsFailed +\u003d stats.getNumAppsFailed();\n        queueMetrics.activeUsers +\u003d stats.getNumActiveUsers();\n        queueMetrics.availableMemoryGB +\u003d stats.getAvailableMemoryMB();\n        queueMetrics.allocatedMemoryGB +\u003d stats.getAllocatedMemoryMB();\n        queueMetrics.pendingMemoryGB +\u003d stats.getPendingMemoryMB();\n        queueMetrics.reservedMemoryGB +\u003d stats.getReservedMemoryMB();\n        queueMetrics.availableVCores +\u003d stats.getAvailableVCores();\n        queueMetrics.allocatedVCores +\u003d stats.getAllocatedVCores();\n        queueMetrics.pendingVCores +\u003d stats.getPendingVCores();\n        queueMetrics.reservedVCores +\u003d stats.getReservedVCores();\n      }\n    }\n    queueMetrics.availableMemoryGB \u003d queueMetrics.availableMemoryGB / 1024;\n    queueMetrics.allocatedMemoryGB \u003d queueMetrics.allocatedMemoryGB / 1024;\n    queueMetrics.pendingMemoryGB \u003d queueMetrics.pendingMemoryGB / 1024;\n    queueMetrics.reservedMemoryGB \u003d queueMetrics.reservedMemoryGB / 1024;\n    return queueMetrics;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/TopCLI.java"
    }
  }
}