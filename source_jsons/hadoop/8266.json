{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AclTransformation.java",
  "functionName": "buildAndValidateAcl",
  "functionId": "buildAndValidateAcl___aclBuilder-ArrayList__AclEntry__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
  "functionStartLine": 271,
  "functionEndLine": 315,
  "numCommitsSeen": 8,
  "timeTaken": 1372,
  "changeHistory": [
    "29cf887b226f4ab3c336a6e681db5e8e70699d66",
    "5300294fbe9e235ce42253d6bcd69d8154d8f198",
    "023c11ec7eae9bb21598f3d3ad0cd5b07b2b737e",
    "c6585675710aa800317ad35e6fdf95c50c559d68"
  ],
  "changeHistoryShort": {
    "29cf887b226f4ab3c336a6e681db5e8e70699d66": "Ybodychange",
    "5300294fbe9e235ce42253d6bcd69d8154d8f198": "Ybodychange",
    "023c11ec7eae9bb21598f3d3ad0cd5b07b2b737e": "Ybodychange",
    "c6585675710aa800317ad35e6fdf95c50c559d68": "Yintroduced"
  },
  "changeHistoryDetails": {
    "29cf887b226f4ab3c336a6e681db5e8e70699d66": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7582. Enforce maximum number of ACL entries separately per access and default. (Contributed by Vinayakumar B)\n",
      "commitDate": "21/07/15 2:46 AM",
      "commitName": "29cf887b226f4ab3c336a6e681db5e8e70699d66",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "16/05/14 11:25 AM",
      "commitNameOld": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 430.64,
      "commitsBetweenForRepo": 3568,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,45 @@\n   private static List\u003cAclEntry\u003e buildAndValidateAcl(\n       ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n-    if (aclBuilder.size() \u003e MAX_ENTRIES) {\n-      throw new AclException(\"Invalid ACL: ACL has \" + aclBuilder.size() +\n-        \" entries, which exceeds maximum of \" + MAX_ENTRIES + \".\");\n-    }\n     aclBuilder.trimToSize();\n     Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n     // Full iteration to check for duplicates and invalid named entries.\n     AclEntry prevEntry \u003d null;\n     for (AclEntry entry: aclBuilder) {\n       if (prevEntry !\u003d null \u0026\u0026\n           ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n         throw new AclException(\n           \"Invalid ACL: multiple entries with same scope, type and name.\");\n       }\n       if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n           entry.getType() \u003d\u003d OTHER)) {\n         throw new AclException(\n           \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n       }\n       prevEntry \u003d entry;\n     }\n+\n+    ScopedAclEntries scopedEntries \u003d new ScopedAclEntries(aclBuilder);\n+    checkMaxEntries(scopedEntries);\n+\n     // Search for the required base access entries.  If there is a default ACL,\n     // then do the same check on the default entries.\n-    ScopedAclEntries scopedEntries \u003d new ScopedAclEntries(aclBuilder);\n     for (AclEntryType type: EnumSet.of(USER, GROUP, OTHER)) {\n       AclEntry accessEntryKey \u003d new AclEntry.Builder().setScope(ACCESS)\n         .setType(type).build();\n       if (Collections.binarySearch(scopedEntries.getAccessEntries(),\n           accessEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n         throw new AclException(\n           \"Invalid ACL: the user, group and other entries are required.\");\n       }\n       if (!scopedEntries.getDefaultEntries().isEmpty()) {\n         AclEntry defaultEntryKey \u003d new AclEntry.Builder().setScope(DEFAULT)\n           .setType(type).build();\n         if (Collections.binarySearch(scopedEntries.getDefaultEntries(),\n             defaultEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n           throw new AclException(\n             \"Invalid default ACL: the user, group and other entries are required.\");\n         }\n       }\n     }\n     return Collections.unmodifiableList(aclBuilder);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cAclEntry\u003e buildAndValidateAcl(\n      ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n    aclBuilder.trimToSize();\n    Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n    // Full iteration to check for duplicates and invalid named entries.\n    AclEntry prevEntry \u003d null;\n    for (AclEntry entry: aclBuilder) {\n      if (prevEntry !\u003d null \u0026\u0026\n          ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n        throw new AclException(\n          \"Invalid ACL: multiple entries with same scope, type and name.\");\n      }\n      if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n          entry.getType() \u003d\u003d OTHER)) {\n        throw new AclException(\n          \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n      }\n      prevEntry \u003d entry;\n    }\n\n    ScopedAclEntries scopedEntries \u003d new ScopedAclEntries(aclBuilder);\n    checkMaxEntries(scopedEntries);\n\n    // Search for the required base access entries.  If there is a default ACL,\n    // then do the same check on the default entries.\n    for (AclEntryType type: EnumSet.of(USER, GROUP, OTHER)) {\n      AclEntry accessEntryKey \u003d new AclEntry.Builder().setScope(ACCESS)\n        .setType(type).build();\n      if (Collections.binarySearch(scopedEntries.getAccessEntries(),\n          accessEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n        throw new AclException(\n          \"Invalid ACL: the user, group and other entries are required.\");\n      }\n      if (!scopedEntries.getDefaultEntries().isEmpty()) {\n        AclEntry defaultEntryKey \u003d new AclEntry.Builder().setScope(DEFAULT)\n          .setType(type).build();\n        if (Collections.binarySearch(scopedEntries.getDefaultEntries(),\n            defaultEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n          throw new AclException(\n            \"Invalid default ACL: the user, group and other entries are required.\");\n        }\n      }\n    }\n    return Collections.unmodifiableList(aclBuilder);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
      "extendedDetails": {}
    },
    "5300294fbe9e235ce42253d6bcd69d8154d8f198": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5758. NameNode: complete implementation of inode modifications for ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1559267 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/01/14 2:05 PM",
      "commitName": "5300294fbe9e235ce42253d6bcd69d8154d8f198",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/01/14 2:02 PM",
      "commitNameOld": "023c11ec7eae9bb21598f3d3ad0cd5b07b2b737e",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 9.0,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private static List\u003cAclEntry\u003e buildAndValidateAcl(\n       ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n     if (aclBuilder.size() \u003e MAX_ENTRIES) {\n       throw new AclException(\"Invalid ACL: ACL has \" + aclBuilder.size() +\n         \" entries, which exceeds maximum of \" + MAX_ENTRIES + \".\");\n     }\n     aclBuilder.trimToSize();\n     Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n     // Full iteration to check for duplicates and invalid named entries.\n     AclEntry prevEntry \u003d null;\n     for (AclEntry entry: aclBuilder) {\n       if (prevEntry !\u003d null \u0026\u0026\n           ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n         throw new AclException(\n           \"Invalid ACL: multiple entries with same scope, type and name.\");\n       }\n       if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n           entry.getType() \u003d\u003d OTHER)) {\n         throw new AclException(\n           \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n       }\n       prevEntry \u003d entry;\n     }\n     // Search for the required base access entries.  If there is a default ACL,\n     // then do the same check on the default entries.\n-    int pivot \u003d calculatePivotOnDefaultEntries(aclBuilder);\n+    ScopedAclEntries scopedEntries \u003d new ScopedAclEntries(aclBuilder);\n     for (AclEntryType type: EnumSet.of(USER, GROUP, OTHER)) {\n       AclEntry accessEntryKey \u003d new AclEntry.Builder().setScope(ACCESS)\n         .setType(type).build();\n-      if (Collections.binarySearch(aclBuilder, accessEntryKey,\n-          ACL_ENTRY_COMPARATOR) \u003c 0) {\n+      if (Collections.binarySearch(scopedEntries.getAccessEntries(),\n+          accessEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n         throw new AclException(\n           \"Invalid ACL: the user, group and other entries are required.\");\n       }\n-      if (pivot !\u003d PIVOT_NOT_FOUND) {\n+      if (!scopedEntries.getDefaultEntries().isEmpty()) {\n         AclEntry defaultEntryKey \u003d new AclEntry.Builder().setScope(DEFAULT)\n           .setType(type).build();\n-        if (Collections.binarySearch(aclBuilder, defaultEntryKey,\n-            ACL_ENTRY_COMPARATOR) \u003c 0) {\n+        if (Collections.binarySearch(scopedEntries.getDefaultEntries(),\n+            defaultEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n           throw new AclException(\n             \"Invalid default ACL: the user, group and other entries are required.\");\n         }\n       }\n     }\n     return Collections.unmodifiableList(aclBuilder);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cAclEntry\u003e buildAndValidateAcl(\n      ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n    if (aclBuilder.size() \u003e MAX_ENTRIES) {\n      throw new AclException(\"Invalid ACL: ACL has \" + aclBuilder.size() +\n        \" entries, which exceeds maximum of \" + MAX_ENTRIES + \".\");\n    }\n    aclBuilder.trimToSize();\n    Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n    // Full iteration to check for duplicates and invalid named entries.\n    AclEntry prevEntry \u003d null;\n    for (AclEntry entry: aclBuilder) {\n      if (prevEntry !\u003d null \u0026\u0026\n          ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n        throw new AclException(\n          \"Invalid ACL: multiple entries with same scope, type and name.\");\n      }\n      if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n          entry.getType() \u003d\u003d OTHER)) {\n        throw new AclException(\n          \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n      }\n      prevEntry \u003d entry;\n    }\n    // Search for the required base access entries.  If there is a default ACL,\n    // then do the same check on the default entries.\n    ScopedAclEntries scopedEntries \u003d new ScopedAclEntries(aclBuilder);\n    for (AclEntryType type: EnumSet.of(USER, GROUP, OTHER)) {\n      AclEntry accessEntryKey \u003d new AclEntry.Builder().setScope(ACCESS)\n        .setType(type).build();\n      if (Collections.binarySearch(scopedEntries.getAccessEntries(),\n          accessEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n        throw new AclException(\n          \"Invalid ACL: the user, group and other entries are required.\");\n      }\n      if (!scopedEntries.getDefaultEntries().isEmpty()) {\n        AclEntry defaultEntryKey \u003d new AclEntry.Builder().setScope(DEFAULT)\n          .setType(type).build();\n        if (Collections.binarySearch(scopedEntries.getDefaultEntries(),\n            defaultEntryKey, ACL_ENTRY_COMPARATOR) \u003c 0) {\n          throw new AclException(\n            \"Invalid default ACL: the user, group and other entries are required.\");\n        }\n      }\n    }\n    return Collections.unmodifiableList(aclBuilder);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
      "extendedDetails": {}
    },
    "023c11ec7eae9bb21598f3d3ad0cd5b07b2b737e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5737. Replacing only the default ACL can fail to copy unspecified base entries from the access ACL. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1556652 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/14 2:02 PM",
      "commitName": "023c11ec7eae9bb21598f3d3ad0cd5b07b2b737e",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "06/01/14 4:47 PM",
      "commitNameOld": "c6585675710aa800317ad35e6fdf95c50c559d68",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.89,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,46 @@\n   private static List\u003cAclEntry\u003e buildAndValidateAcl(\n       ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n     if (aclBuilder.size() \u003e MAX_ENTRIES) {\n       throw new AclException(\"Invalid ACL: ACL has \" + aclBuilder.size() +\n         \" entries, which exceeds maximum of \" + MAX_ENTRIES + \".\");\n     }\n     aclBuilder.trimToSize();\n     Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n-    AclEntry userEntry \u003d null, groupEntry \u003d null, otherEntry \u003d null;\n+    // Full iteration to check for duplicates and invalid named entries.\n     AclEntry prevEntry \u003d null;\n     for (AclEntry entry: aclBuilder) {\n       if (prevEntry !\u003d null \u0026\u0026\n           ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n         throw new AclException(\n           \"Invalid ACL: multiple entries with same scope, type and name.\");\n       }\n       if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n           entry.getType() \u003d\u003d OTHER)) {\n         throw new AclException(\n           \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n       }\n-      if (entry.getScope() \u003d\u003d ACCESS) {\n-        if (entry.getType() \u003d\u003d USER \u0026\u0026 entry.getName() \u003d\u003d null) {\n-          userEntry \u003d entry;\n-        }\n-        if (entry.getType() \u003d\u003d GROUP \u0026\u0026 entry.getName() \u003d\u003d null) {\n-          groupEntry \u003d entry;\n-        }\n-        if (entry.getType() \u003d\u003d OTHER \u0026\u0026 entry.getName() \u003d\u003d null) {\n-          otherEntry \u003d entry;\n-        }\n-      }\n       prevEntry \u003d entry;\n     }\n-    if (userEntry \u003d\u003d null || groupEntry \u003d\u003d null || otherEntry \u003d\u003d null) {\n-      throw new AclException(\n-        \"Invalid ACL: the user, group and other entries are required.\");\n+    // Search for the required base access entries.  If there is a default ACL,\n+    // then do the same check on the default entries.\n+    int pivot \u003d calculatePivotOnDefaultEntries(aclBuilder);\n+    for (AclEntryType type: EnumSet.of(USER, GROUP, OTHER)) {\n+      AclEntry accessEntryKey \u003d new AclEntry.Builder().setScope(ACCESS)\n+        .setType(type).build();\n+      if (Collections.binarySearch(aclBuilder, accessEntryKey,\n+          ACL_ENTRY_COMPARATOR) \u003c 0) {\n+        throw new AclException(\n+          \"Invalid ACL: the user, group and other entries are required.\");\n+      }\n+      if (pivot !\u003d PIVOT_NOT_FOUND) {\n+        AclEntry defaultEntryKey \u003d new AclEntry.Builder().setScope(DEFAULT)\n+          .setType(type).build();\n+        if (Collections.binarySearch(aclBuilder, defaultEntryKey,\n+            ACL_ENTRY_COMPARATOR) \u003c 0) {\n+          throw new AclException(\n+            \"Invalid default ACL: the user, group and other entries are required.\");\n+        }\n+      }\n     }\n     return Collections.unmodifiableList(aclBuilder);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cAclEntry\u003e buildAndValidateAcl(\n      ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n    if (aclBuilder.size() \u003e MAX_ENTRIES) {\n      throw new AclException(\"Invalid ACL: ACL has \" + aclBuilder.size() +\n        \" entries, which exceeds maximum of \" + MAX_ENTRIES + \".\");\n    }\n    aclBuilder.trimToSize();\n    Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n    // Full iteration to check for duplicates and invalid named entries.\n    AclEntry prevEntry \u003d null;\n    for (AclEntry entry: aclBuilder) {\n      if (prevEntry !\u003d null \u0026\u0026\n          ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n        throw new AclException(\n          \"Invalid ACL: multiple entries with same scope, type and name.\");\n      }\n      if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n          entry.getType() \u003d\u003d OTHER)) {\n        throw new AclException(\n          \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n      }\n      prevEntry \u003d entry;\n    }\n    // Search for the required base access entries.  If there is a default ACL,\n    // then do the same check on the default entries.\n    int pivot \u003d calculatePivotOnDefaultEntries(aclBuilder);\n    for (AclEntryType type: EnumSet.of(USER, GROUP, OTHER)) {\n      AclEntry accessEntryKey \u003d new AclEntry.Builder().setScope(ACCESS)\n        .setType(type).build();\n      if (Collections.binarySearch(aclBuilder, accessEntryKey,\n          ACL_ENTRY_COMPARATOR) \u003c 0) {\n        throw new AclException(\n          \"Invalid ACL: the user, group and other entries are required.\");\n      }\n      if (pivot !\u003d PIVOT_NOT_FOUND) {\n        AclEntry defaultEntryKey \u003d new AclEntry.Builder().setScope(DEFAULT)\n          .setType(type).build();\n        if (Collections.binarySearch(aclBuilder, defaultEntryKey,\n            ACL_ENTRY_COMPARATOR) \u003c 0) {\n          throw new AclException(\n            \"Invalid default ACL: the user, group and other entries are required.\");\n        }\n      }\n    }\n    return Collections.unmodifiableList(aclBuilder);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
      "extendedDetails": {}
    },
    "c6585675710aa800317ad35e6fdf95c50c559d68": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5673. Implement logic for modification of ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1556090 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/14 4:47 PM",
      "commitName": "c6585675710aa800317ad35e6fdf95c50c559d68",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,40 @@\n+  private static List\u003cAclEntry\u003e buildAndValidateAcl(\n+      ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n+    if (aclBuilder.size() \u003e MAX_ENTRIES) {\n+      throw new AclException(\"Invalid ACL: ACL has \" + aclBuilder.size() +\n+        \" entries, which exceeds maximum of \" + MAX_ENTRIES + \".\");\n+    }\n+    aclBuilder.trimToSize();\n+    Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n+    AclEntry userEntry \u003d null, groupEntry \u003d null, otherEntry \u003d null;\n+    AclEntry prevEntry \u003d null;\n+    for (AclEntry entry: aclBuilder) {\n+      if (prevEntry !\u003d null \u0026\u0026\n+          ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n+        throw new AclException(\n+          \"Invalid ACL: multiple entries with same scope, type and name.\");\n+      }\n+      if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n+          entry.getType() \u003d\u003d OTHER)) {\n+        throw new AclException(\n+          \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n+      }\n+      if (entry.getScope() \u003d\u003d ACCESS) {\n+        if (entry.getType() \u003d\u003d USER \u0026\u0026 entry.getName() \u003d\u003d null) {\n+          userEntry \u003d entry;\n+        }\n+        if (entry.getType() \u003d\u003d GROUP \u0026\u0026 entry.getName() \u003d\u003d null) {\n+          groupEntry \u003d entry;\n+        }\n+        if (entry.getType() \u003d\u003d OTHER \u0026\u0026 entry.getName() \u003d\u003d null) {\n+          otherEntry \u003d entry;\n+        }\n+      }\n+      prevEntry \u003d entry;\n+    }\n+    if (userEntry \u003d\u003d null || groupEntry \u003d\u003d null || otherEntry \u003d\u003d null) {\n+      throw new AclException(\n+        \"Invalid ACL: the user, group and other entries are required.\");\n+    }\n+    return Collections.unmodifiableList(aclBuilder);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cAclEntry\u003e buildAndValidateAcl(\n      ArrayList\u003cAclEntry\u003e aclBuilder) throws AclException {\n    if (aclBuilder.size() \u003e MAX_ENTRIES) {\n      throw new AclException(\"Invalid ACL: ACL has \" + aclBuilder.size() +\n        \" entries, which exceeds maximum of \" + MAX_ENTRIES + \".\");\n    }\n    aclBuilder.trimToSize();\n    Collections.sort(aclBuilder, ACL_ENTRY_COMPARATOR);\n    AclEntry userEntry \u003d null, groupEntry \u003d null, otherEntry \u003d null;\n    AclEntry prevEntry \u003d null;\n    for (AclEntry entry: aclBuilder) {\n      if (prevEntry !\u003d null \u0026\u0026\n          ACL_ENTRY_COMPARATOR.compare(prevEntry, entry) \u003d\u003d 0) {\n        throw new AclException(\n          \"Invalid ACL: multiple entries with same scope, type and name.\");\n      }\n      if (entry.getName() !\u003d null \u0026\u0026 (entry.getType() \u003d\u003d MASK ||\n          entry.getType() \u003d\u003d OTHER)) {\n        throw new AclException(\n          \"Invalid ACL: this entry type must not have a name: \" + entry + \".\");\n      }\n      if (entry.getScope() \u003d\u003d ACCESS) {\n        if (entry.getType() \u003d\u003d USER \u0026\u0026 entry.getName() \u003d\u003d null) {\n          userEntry \u003d entry;\n        }\n        if (entry.getType() \u003d\u003d GROUP \u0026\u0026 entry.getName() \u003d\u003d null) {\n          groupEntry \u003d entry;\n        }\n        if (entry.getType() \u003d\u003d OTHER \u0026\u0026 entry.getName() \u003d\u003d null) {\n          otherEntry \u003d entry;\n        }\n      }\n      prevEntry \u003d entry;\n    }\n    if (userEntry \u003d\u003d null || groupEntry \u003d\u003d null || otherEntry \u003d\u003d null) {\n      throw new AclException(\n        \"Invalid ACL: the user, group and other entries are required.\");\n    }\n    return Collections.unmodifiableList(aclBuilder);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java"
    }
  }
}