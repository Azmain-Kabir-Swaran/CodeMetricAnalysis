{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AggregatedLogFormat.java",
  "functionName": "getPendingLogFilesToUpload",
  "functionId": "getPendingLogFilesToUpload___containerLogDir-File",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
  "functionStartLine": 309,
  "functionEndLine": 344,
  "numCommitsSeen": 47,
  "timeTaken": 3720,
  "changeHistory": [
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "7582dedad1c73eabdc3eeece0a3a860e7bb33c1a",
    "4b5bd73ac53f7de4899b5b70078249ad20216048",
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
    "863079bb874ba77918ca1c0741eae10e245995c8",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc"
  ],
  "changeHistoryShort": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "7582dedad1c73eabdc3eeece0a3a860e7bb33c1a": "Ybodychange",
    "4b5bd73ac53f7de4899b5b70078249ad20216048": "Ybodychange",
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0": "Ybodychange",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": "Ybodychange",
    "863079bb874ba77918ca1c0741eae10e245995c8": "Ybodychange",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "06/07/18 11:56 AM",
      "commitNameOld": "498e3bfb6b93bf542e5581d83e64e920983fe87e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 23.96,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n     private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n       if(containerLogDir \u003d\u003d null) {\n         return new HashSet\u003c\u003e(0);\n       }\n \n       File[] filesList \u003d containerLogDir.listFiles();\n       if (filesList \u003d\u003d null) {\n         return new HashSet\u003c\u003e(0);\n       }\n \n       Set\u003cFile\u003e candidates \u003d\n           new HashSet\u003cFile\u003e(Arrays.asList(filesList));\n       for (File logFile : candidates) {\n         this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n       }\n \n       // if log files are older than retention policy, do not upload them.\n       // but schedule them for deletion.\n       if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n-        obseleteRetentionLogFiles.addAll(candidates);\n+        obsoleteRetentionLogFiles.addAll(candidates);\n         candidates.clear();\n         return candidates;\n       }\n \n       Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n       if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n         fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n         if (!this.appFinished \u0026\u0026 this.containerFinished) {\n           Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n           addition \u003d getFileCandidates(addition, true);\n           fileCandidates.addAll(addition);\n         }\n       }\n \n       return fileCandidates;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n      if(containerLogDir \u003d\u003d null) {\n        return new HashSet\u003c\u003e(0);\n      }\n\n      File[] filesList \u003d containerLogDir.listFiles();\n      if (filesList \u003d\u003d null) {\n        return new HashSet\u003c\u003e(0);\n      }\n\n      Set\u003cFile\u003e candidates \u003d\n          new HashSet\u003cFile\u003e(Arrays.asList(filesList));\n      for (File logFile : candidates) {\n        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n      }\n\n      // if log files are older than retention policy, do not upload them.\n      // but schedule them for deletion.\n      if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n        obsoleteRetentionLogFiles.addAll(candidates);\n        candidates.clear();\n        return candidates;\n      }\n\n      Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n        fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n        if (!this.appFinished \u0026\u0026 this.containerFinished) {\n          Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n          addition \u003d getFileCandidates(addition, true);\n          fileCandidates.addAll(addition);\n        }\n      }\n\n      return fileCandidates;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "7582dedad1c73eabdc3eeece0a3a860e7bb33c1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6517. Fix warnings from Spotbugs in hadoop-yarn-common(addendum). Contributed by Weiwei Yang.\n",
      "commitDate": "18/06/17 7:23 AM",
      "commitName": "7582dedad1c73eabdc3eeece0a3a860e7bb33c1a",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "01/05/17 4:01 AM",
      "commitNameOld": "4b5bd73ac53f7de4899b5b70078249ad20216048",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 48.14,
      "commitsBetweenForRepo": 242,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,36 @@\n     private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n-      if(containerLogDir \u003d\u003d null ||\n-          containerLogDir.listFiles() \u003d\u003d null) {\n+      if(containerLogDir \u003d\u003d null) {\n         return new HashSet\u003c\u003e(0);\n       }\n+\n+      File[] filesList \u003d containerLogDir.listFiles();\n+      if (filesList \u003d\u003d null) {\n+        return new HashSet\u003c\u003e(0);\n+      }\n+\n       Set\u003cFile\u003e candidates \u003d\n-          new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n+          new HashSet\u003cFile\u003e(Arrays.asList(filesList));\n       for (File logFile : candidates) {\n         this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n       }\n \n       // if log files are older than retention policy, do not upload them.\n       // but schedule them for deletion.\n       if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n         obseleteRetentionLogFiles.addAll(candidates);\n         candidates.clear();\n         return candidates;\n       }\n \n       Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n       if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n         fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n         if (!this.appFinished \u0026\u0026 this.containerFinished) {\n           Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n           addition \u003d getFileCandidates(addition, true);\n           fileCandidates.addAll(addition);\n         }\n       }\n \n       return fileCandidates;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n      if(containerLogDir \u003d\u003d null) {\n        return new HashSet\u003c\u003e(0);\n      }\n\n      File[] filesList \u003d containerLogDir.listFiles();\n      if (filesList \u003d\u003d null) {\n        return new HashSet\u003c\u003e(0);\n      }\n\n      Set\u003cFile\u003e candidates \u003d\n          new HashSet\u003cFile\u003e(Arrays.asList(filesList));\n      for (File logFile : candidates) {\n        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n      }\n\n      // if log files are older than retention policy, do not upload them.\n      // but schedule them for deletion.\n      if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n        obseleteRetentionLogFiles.addAll(candidates);\n        candidates.clear();\n        return candidates;\n      }\n\n      Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n        fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n        if (!this.appFinished \u0026\u0026 this.containerFinished) {\n          Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n          addition \u003d getFileCandidates(addition, true);\n          fileCandidates.addAll(addition);\n        }\n      }\n\n      return fileCandidates;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "4b5bd73ac53f7de4899b5b70078249ad20216048": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6517. Fix warnings from Spotbugs in hadoop-yarn-common. Contributed by Weiwei Yang\n",
      "commitDate": "01/05/17 4:01 AM",
      "commitName": "4b5bd73ac53f7de4899b5b70078249ad20216048",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "12/04/17 1:43 PM",
      "commitNameOld": "9d9087a67ad599e678948d5c1036e51cb8cf5e3a",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 18.6,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,31 @@\n     private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n+      if(containerLogDir \u003d\u003d null ||\n+          containerLogDir.listFiles() \u003d\u003d null) {\n+        return new HashSet\u003c\u003e(0);\n+      }\n       Set\u003cFile\u003e candidates \u003d\n           new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n       for (File logFile : candidates) {\n         this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n       }\n \n       // if log files are older than retention policy, do not upload them.\n       // but schedule them for deletion.\n       if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n         obseleteRetentionLogFiles.addAll(candidates);\n         candidates.clear();\n         return candidates;\n       }\n \n       Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n       if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n         fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n         if (!this.appFinished \u0026\u0026 this.containerFinished) {\n           Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n           addition \u003d getFileCandidates(addition, true);\n           fileCandidates.addAll(addition);\n         }\n       }\n \n       return fileCandidates;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n      if(containerLogDir \u003d\u003d null ||\n          containerLogDir.listFiles() \u003d\u003d null) {\n        return new HashSet\u003c\u003e(0);\n      }\n      Set\u003cFile\u003e candidates \u003d\n          new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n      for (File logFile : candidates) {\n        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n      }\n\n      // if log files are older than retention policy, do not upload them.\n      // but schedule them for deletion.\n      if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n        obseleteRetentionLogFiles.addAll(candidates);\n        candidates.clear();\n        return candidates;\n      }\n\n      Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n        fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n        if (!this.appFinished \u0026\u0026 this.containerFinished) {\n          Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n          addition \u003d getFileCandidates(addition, true);\n          fileCandidates.addAll(addition);\n        }\n      }\n\n      return fileCandidates;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5237. Fix missing log files issue in rolling log aggregation. Contributed by Xuan Gong.\n",
      "commitDate": "15/06/16 4:17 PM",
      "commitName": "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 1.05,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,27 @@\n     private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n       Set\u003cFile\u003e candidates \u003d\n           new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n       for (File logFile : candidates) {\n         this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n       }\n \n       // if log files are older than retention policy, do not upload them.\n       // but schedule them for deletion.\n       if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n         obseleteRetentionLogFiles.addAll(candidates);\n         candidates.clear();\n         return candidates;\n       }\n \n+      Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n       if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n-        filterFiles(\n-          this.appFinished ? this.logAggregationContext.getIncludePattern()\n-              : this.logAggregationContext.getRolledLogsIncludePattern(),\n-          candidates, false);\n-\n-        filterFiles(\n-          this.appFinished ? this.logAggregationContext.getExcludePattern()\n-              : this.logAggregationContext.getRolledLogsExcludePattern(),\n-          candidates, true);\n-\n-        Iterable\u003cFile\u003e mask \u003d\n-            Iterables.filter(candidates, new Predicate\u003cFile\u003e() {\n-              @Override\n-              public boolean apply(File next) {\n-                return !alreadyUploadedLogFiles\n-                  .contains(getLogFileMetaData(next));\n-              }\n-            });\n-        candidates \u003d Sets.newHashSet(mask);\n+        fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n+        if (!this.appFinished \u0026\u0026 this.containerFinished) {\n+          Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n+          addition \u003d getFileCandidates(addition, true);\n+          fileCandidates.addAll(addition);\n+        }\n       }\n \n-      return candidates;\n+      return fileCandidates;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n      Set\u003cFile\u003e candidates \u003d\n          new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n      for (File logFile : candidates) {\n        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n      }\n\n      // if log files are older than retention policy, do not upload them.\n      // but schedule them for deletion.\n      if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n        obseleteRetentionLogFiles.addAll(candidates);\n        candidates.clear();\n        return candidates;\n      }\n\n      Set\u003cFile\u003e fileCandidates \u003d new HashSet\u003cFile\u003e(candidates);\n      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n        fileCandidates \u003d getFileCandidates(fileCandidates, this.appFinished);\n        if (!this.appFinished \u0026\u0026 this.containerFinished) {\n          Set\u003cFile\u003e addition \u003d new HashSet\u003cFile\u003e(candidates);\n          addition \u003d getFileCandidates(addition, true);\n          fileCandidates.addAll(addition);\n        }\n      }\n\n      return fileCandidates;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4766. NM should not aggregate logs older than the retention policy (haibochen via rkanter)\n",
      "commitDate": "25/05/16 10:25 AM",
      "commitName": "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "04/05/16 2:16 PM",
      "commitNameOld": "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 20.84,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,39 @@\n     private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n       Set\u003cFile\u003e candidates \u003d\n           new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n       for (File logFile : candidates) {\n         this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n       }\n \n+      // if log files are older than retention policy, do not upload them.\n+      // but schedule them for deletion.\n+      if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n+        obseleteRetentionLogFiles.addAll(candidates);\n+        candidates.clear();\n+        return candidates;\n+      }\n+\n       if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n         filterFiles(\n           this.appFinished ? this.logAggregationContext.getIncludePattern()\n               : this.logAggregationContext.getRolledLogsIncludePattern(),\n           candidates, false);\n \n         filterFiles(\n           this.appFinished ? this.logAggregationContext.getExcludePattern()\n               : this.logAggregationContext.getRolledLogsExcludePattern(),\n           candidates, true);\n \n         Iterable\u003cFile\u003e mask \u003d\n             Iterables.filter(candidates, new Predicate\u003cFile\u003e() {\n               @Override\n               public boolean apply(File next) {\n                 return !alreadyUploadedLogFiles\n                   .contains(getLogFileMetaData(next));\n               }\n             });\n         candidates \u003d Sets.newHashSet(mask);\n       }\n+\n       return candidates;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n      Set\u003cFile\u003e candidates \u003d\n          new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n      for (File logFile : candidates) {\n        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n      }\n\n      // if log files are older than retention policy, do not upload them.\n      // but schedule them for deletion.\n      if(logRetentionContext !\u003d null \u0026\u0026 !logRetentionContext.shouldRetainLog()){\n        obseleteRetentionLogFiles.addAll(candidates);\n        candidates.clear();\n        return candidates;\n      }\n\n      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n        filterFiles(\n          this.appFinished ? this.logAggregationContext.getIncludePattern()\n              : this.logAggregationContext.getRolledLogsIncludePattern(),\n          candidates, false);\n\n        filterFiles(\n          this.appFinished ? this.logAggregationContext.getExcludePattern()\n              : this.logAggregationContext.getRolledLogsExcludePattern(),\n          candidates, true);\n\n        Iterable\u003cFile\u003e mask \u003d\n            Iterables.filter(candidates, new Predicate\u003cFile\u003e() {\n              @Override\n              public boolean apply(File next) {\n                return !alreadyUploadedLogFiles\n                  .contains(getLogFileMetaData(next));\n              }\n            });\n        candidates \u003d Sets.newHashSet(mask);\n      }\n\n      return candidates;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "863079bb874ba77918ca1c0741eae10e245995c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
      "commitDate": "12/03/15 1:32 PM",
      "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "22/12/14 3:06 AM",
      "commitNameOld": "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 80.39,
      "commitsBetweenForRepo": 609,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,30 @@\n     private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n       Set\u003cFile\u003e candidates \u003d\n           new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n       for (File logFile : candidates) {\n         this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n       }\n \n       if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n-        if (this.logAggregationContext.getIncludePattern() !\u003d null\n-            \u0026\u0026 !this.logAggregationContext.getIncludePattern().isEmpty()) {\n-          filterFiles(this.logAggregationContext.getIncludePattern(),\n-              candidates, false);\n-        }\n+        filterFiles(\n+          this.appFinished ? this.logAggregationContext.getIncludePattern()\n+              : this.logAggregationContext.getRolledLogsIncludePattern(),\n+          candidates, false);\n \n-        if (this.logAggregationContext.getExcludePattern() !\u003d null\n-            \u0026\u0026 !this.logAggregationContext.getExcludePattern().isEmpty()) {\n-          filterFiles(this.logAggregationContext.getExcludePattern(),\n-              candidates, true);\n-        }\n+        filterFiles(\n+          this.appFinished ? this.logAggregationContext.getExcludePattern()\n+              : this.logAggregationContext.getRolledLogsExcludePattern(),\n+          candidates, true);\n \n         Iterable\u003cFile\u003e mask \u003d\n             Iterables.filter(candidates, new Predicate\u003cFile\u003e() {\n               @Override\n               public boolean apply(File next) {\n                 return !alreadyUploadedLogFiles\n                   .contains(getLogFileMetaData(next));\n               }\n             });\n         candidates \u003d Sets.newHashSet(mask);\n       }\n       return candidates;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n      Set\u003cFile\u003e candidates \u003d\n          new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n      for (File logFile : candidates) {\n        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n      }\n\n      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n        filterFiles(\n          this.appFinished ? this.logAggregationContext.getIncludePattern()\n              : this.logAggregationContext.getRolledLogsIncludePattern(),\n          candidates, false);\n\n        filterFiles(\n          this.appFinished ? this.logAggregationContext.getExcludePattern()\n              : this.logAggregationContext.getRolledLogsExcludePattern(),\n          candidates, true);\n\n        Iterable\u003cFile\u003e mask \u003d\n            Iterables.filter(candidates, new Predicate\u003cFile\u003e() {\n              @Override\n              public boolean apply(File next) {\n                return !alreadyUploadedLogFiles\n                  .contains(getLogFileMetaData(next));\n              }\n            });\n        candidates \u003d Sets.newHashSet(mask);\n      }\n      return candidates;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
      "commitDate": "03/10/14 12:15 PM",
      "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,32 @@\n+    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n+      Set\u003cFile\u003e candidates \u003d\n+          new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n+      for (File logFile : candidates) {\n+        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n+      }\n+\n+      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n+        if (this.logAggregationContext.getIncludePattern() !\u003d null\n+            \u0026\u0026 !this.logAggregationContext.getIncludePattern().isEmpty()) {\n+          filterFiles(this.logAggregationContext.getIncludePattern(),\n+              candidates, false);\n+        }\n+\n+        if (this.logAggregationContext.getExcludePattern() !\u003d null\n+            \u0026\u0026 !this.logAggregationContext.getExcludePattern().isEmpty()) {\n+          filterFiles(this.logAggregationContext.getExcludePattern(),\n+              candidates, true);\n+        }\n+\n+        Iterable\u003cFile\u003e mask \u003d\n+            Iterables.filter(candidates, new Predicate\u003cFile\u003e() {\n+              @Override\n+              public boolean apply(File next) {\n+                return !alreadyUploadedLogFiles\n+                  .contains(getLogFileMetaData(next));\n+              }\n+            });\n+        candidates \u003d Sets.newHashSet(mask);\n+      }\n+      return candidates;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private Set\u003cFile\u003e getPendingLogFilesToUpload(File containerLogDir) {\n      Set\u003cFile\u003e candidates \u003d\n          new HashSet\u003cFile\u003e(Arrays.asList(containerLogDir.listFiles()));\n      for (File logFile : candidates) {\n        this.allExistingFileMeta.add(getLogFileMetaData(logFile));\n      }\n\n      if (this.logAggregationContext !\u003d null \u0026\u0026 candidates.size() \u003e 0) {\n        if (this.logAggregationContext.getIncludePattern() !\u003d null\n            \u0026\u0026 !this.logAggregationContext.getIncludePattern().isEmpty()) {\n          filterFiles(this.logAggregationContext.getIncludePattern(),\n              candidates, false);\n        }\n\n        if (this.logAggregationContext.getExcludePattern() !\u003d null\n            \u0026\u0026 !this.logAggregationContext.getExcludePattern().isEmpty()) {\n          filterFiles(this.logAggregationContext.getExcludePattern(),\n              candidates, true);\n        }\n\n        Iterable\u003cFile\u003e mask \u003d\n            Iterables.filter(candidates, new Predicate\u003cFile\u003e() {\n              @Override\n              public boolean apply(File next) {\n                return !alreadyUploadedLogFiles\n                  .contains(getLogFileMetaData(next));\n              }\n            });\n        candidates \u003d Sets.newHashSet(mask);\n      }\n      return candidates;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java"
    }
  }
}