{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RLESparseResourceAllocation.java",
  "functionName": "addInterval",
  "functionId": "addInterval___reservationInterval-ReservationInterval__totCap-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
  "functionStartLine": 74,
  "functionEndLine": 95,
  "numCommitsSeen": 13,
  "timeTaken": 2501,
  "changeHistory": [
    "da1016365aba1cee9c06771ab142d077379f27af",
    "0e602fa3a1529134214452fba10a90307d9c2072",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168"
  ],
  "changeHistoryShort": {
    "da1016365aba1cee9c06771ab142d077379f27af": "Ybodychange",
    "0e602fa3a1529134214452fba10a90307d9c2072": "Ymultichange(Yparameterchange,Ybodychange)",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": "Yintroduced"
  },
  "changeHistoryDetails": {
    "da1016365aba1cee9c06771ab142d077379f27af": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3454. Add efficient merge operation to RLESparseResourceAllocation (Carlo Curino via asuresh)\n",
      "commitDate": "21/11/15 9:59 AM",
      "commitName": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "25/07/15 7:39 AM",
      "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthorOld": "ccurino",
      "daysBetweenCommits": 119.14,
      "commitsBetweenForRepo": 803,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,22 @@\n   public boolean addInterval(ReservationInterval reservationInterval,\n       Resource totCap) {\n     if (totCap.equals(ZERO_RESOURCE)) {\n       return true;\n     }\n     writeLock.lock();\n     try {\n-      long startKey \u003d reservationInterval.getStartTime();\n-      long endKey \u003d reservationInterval.getEndTime();\n-      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n-          cumulativeCapacity.headMap(endKey, false);\n-      if (ticks !\u003d null \u0026\u0026 !ticks.isEmpty()) {\n-        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n-        Entry\u003cLong, Resource\u003e lowEntry \u003d ticks.floorEntry(startKey);\n-        if (lowEntry \u003d\u003d null) {\n-          // This is the earliest starting interval\n-          cumulativeCapacity.put(startKey, totCap);\n-        } else {\n-          updatedCapacity \u003d Resources.add(lowEntry.getValue(), totCap);\n-          // Add a new tick only if the updated value is different\n-          // from the previous tick\n-          if ((startKey \u003d\u003d lowEntry.getKey())\n-              \u0026\u0026 (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {\n-            cumulativeCapacity.remove(lowEntry.getKey());\n-          } else {\n-            cumulativeCapacity.put(startKey, updatedCapacity);\n-          }\n-        }\n-        // Increase all the capacities of overlapping intervals\n-        Set\u003cEntry\u003cLong, Resource\u003e\u003e overlapSet \u003d\n-            ticks.tailMap(startKey, false).entrySet();\n-        for (Entry\u003cLong, Resource\u003e entry : overlapSet) {\n-          updatedCapacity \u003d Resources.add(entry.getValue(), totCap);\n-          entry.setValue(updatedCapacity);\n-        }\n-      } else {\n-        // This is the first interval to be added\n-        cumulativeCapacity.put(startKey, totCap);\n-      }\n-      Resource nextTick \u003d cumulativeCapacity.get(endKey);\n-      if (nextTick !\u003d null) {\n-        // If there is overlap, remove the duplicate entry\n-        if (isSameAsPrevious(endKey, nextTick)) {\n-          cumulativeCapacity.remove(endKey);\n-        }\n-      } else {\n-        // Decrease capacity as this is end of the interval\n-        cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity\n-            .floorEntry(endKey).getValue(), totCap));\n+      NavigableMap\u003cLong, Resource\u003e addInt \u003d new TreeMap\u003cLong, Resource\u003e();\n+      addInt.put(reservationInterval.getStartTime(), totCap);\n+      addInt.put(reservationInterval.getEndTime(), ZERO_RESOURCE);\n+      try {\n+        cumulativeCapacity \u003d\n+            merge(resourceCalculator, totCap, cumulativeCapacity, addInt,\n+                Long.MIN_VALUE, Long.MAX_VALUE, RLEOperator.add);\n+      } catch (PlanningException e) {\n+        // never happens for add\n       }\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addInterval(ReservationInterval reservationInterval,\n      Resource totCap) {\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n      NavigableMap\u003cLong, Resource\u003e addInt \u003d new TreeMap\u003cLong, Resource\u003e();\n      addInt.put(reservationInterval.getStartTime(), totCap);\n      addInt.put(reservationInterval.getEndTime(), ZERO_RESOURCE);\n      try {\n        cumulativeCapacity \u003d\n            merge(resourceCalculator, totCap, cumulativeCapacity, addInt,\n                Long.MIN_VALUE, Long.MAX_VALUE, RLEOperator.add);\n      } catch (PlanningException e) {\n        // never happens for add\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
      "extendedDetails": {}
    },
    "0e602fa3a1529134214452fba10a90307d9c2072": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
      "commitDate": "09/07/15 4:51 PM",
      "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
      "commitAuthor": "carlo curino",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
          "commitDate": "09/07/15 4:51 PM",
          "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
          "commitAuthor": "carlo curino",
          "commitDateOld": "03/10/14 3:43 PM",
          "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
          "commitAuthorOld": "subru",
          "daysBetweenCommits": 279.05,
          "commitsBetweenForRepo": 2292,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,55 @@\n   public boolean addInterval(ReservationInterval reservationInterval,\n-      ReservationRequest capacity) {\n-    Resource totCap \u003d\n-        Resources.multiply(capacity.getCapability(),\n-            (float) capacity.getNumContainers());\n+      Resource totCap) {\n     if (totCap.equals(ZERO_RESOURCE)) {\n       return true;\n     }\n     writeLock.lock();\n     try {\n       long startKey \u003d reservationInterval.getStartTime();\n       long endKey \u003d reservationInterval.getEndTime();\n       NavigableMap\u003cLong, Resource\u003e ticks \u003d\n           cumulativeCapacity.headMap(endKey, false);\n       if (ticks !\u003d null \u0026\u0026 !ticks.isEmpty()) {\n         Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n         Entry\u003cLong, Resource\u003e lowEntry \u003d ticks.floorEntry(startKey);\n         if (lowEntry \u003d\u003d null) {\n           // This is the earliest starting interval\n           cumulativeCapacity.put(startKey, totCap);\n         } else {\n           updatedCapacity \u003d Resources.add(lowEntry.getValue(), totCap);\n           // Add a new tick only if the updated value is different\n           // from the previous tick\n           if ((startKey \u003d\u003d lowEntry.getKey())\n               \u0026\u0026 (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {\n             cumulativeCapacity.remove(lowEntry.getKey());\n           } else {\n             cumulativeCapacity.put(startKey, updatedCapacity);\n           }\n         }\n         // Increase all the capacities of overlapping intervals\n         Set\u003cEntry\u003cLong, Resource\u003e\u003e overlapSet \u003d\n             ticks.tailMap(startKey, false).entrySet();\n         for (Entry\u003cLong, Resource\u003e entry : overlapSet) {\n           updatedCapacity \u003d Resources.add(entry.getValue(), totCap);\n           entry.setValue(updatedCapacity);\n         }\n       } else {\n         // This is the first interval to be added\n         cumulativeCapacity.put(startKey, totCap);\n       }\n       Resource nextTick \u003d cumulativeCapacity.get(endKey);\n       if (nextTick !\u003d null) {\n         // If there is overlap, remove the duplicate entry\n         if (isSameAsPrevious(endKey, nextTick)) {\n           cumulativeCapacity.remove(endKey);\n         }\n       } else {\n         // Decrease capacity as this is end of the interval\n         cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity\n             .floorEntry(endKey).getValue(), totCap));\n       }\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean addInterval(ReservationInterval reservationInterval,\n      Resource totCap) {\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n      long startKey \u003d reservationInterval.getStartTime();\n      long endKey \u003d reservationInterval.getEndTime();\n      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n          cumulativeCapacity.headMap(endKey, false);\n      if (ticks !\u003d null \u0026\u0026 !ticks.isEmpty()) {\n        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n        Entry\u003cLong, Resource\u003e lowEntry \u003d ticks.floorEntry(startKey);\n        if (lowEntry \u003d\u003d null) {\n          // This is the earliest starting interval\n          cumulativeCapacity.put(startKey, totCap);\n        } else {\n          updatedCapacity \u003d Resources.add(lowEntry.getValue(), totCap);\n          // Add a new tick only if the updated value is different\n          // from the previous tick\n          if ((startKey \u003d\u003d lowEntry.getKey())\n              \u0026\u0026 (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {\n            cumulativeCapacity.remove(lowEntry.getKey());\n          } else {\n            cumulativeCapacity.put(startKey, updatedCapacity);\n          }\n        }\n        // Increase all the capacities of overlapping intervals\n        Set\u003cEntry\u003cLong, Resource\u003e\u003e overlapSet \u003d\n            ticks.tailMap(startKey, false).entrySet();\n        for (Entry\u003cLong, Resource\u003e entry : overlapSet) {\n          updatedCapacity \u003d Resources.add(entry.getValue(), totCap);\n          entry.setValue(updatedCapacity);\n        }\n      } else {\n        // This is the first interval to be added\n        cumulativeCapacity.put(startKey, totCap);\n      }\n      Resource nextTick \u003d cumulativeCapacity.get(endKey);\n      if (nextTick !\u003d null) {\n        // If there is overlap, remove the duplicate entry\n        if (isSameAsPrevious(endKey, nextTick)) {\n          cumulativeCapacity.remove(endKey);\n        }\n      } else {\n        // Decrease capacity as this is end of the interval\n        cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity\n            .floorEntry(endKey).getValue(), totCap));\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
          "extendedDetails": {
            "oldValue": "[reservationInterval-ReservationInterval, capacity-ReservationRequest]",
            "newValue": "[reservationInterval-ReservationInterval, totCap-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
          "commitDate": "09/07/15 4:51 PM",
          "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
          "commitAuthor": "carlo curino",
          "commitDateOld": "03/10/14 3:43 PM",
          "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
          "commitAuthorOld": "subru",
          "daysBetweenCommits": 279.05,
          "commitsBetweenForRepo": 2292,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,55 @@\n   public boolean addInterval(ReservationInterval reservationInterval,\n-      ReservationRequest capacity) {\n-    Resource totCap \u003d\n-        Resources.multiply(capacity.getCapability(),\n-            (float) capacity.getNumContainers());\n+      Resource totCap) {\n     if (totCap.equals(ZERO_RESOURCE)) {\n       return true;\n     }\n     writeLock.lock();\n     try {\n       long startKey \u003d reservationInterval.getStartTime();\n       long endKey \u003d reservationInterval.getEndTime();\n       NavigableMap\u003cLong, Resource\u003e ticks \u003d\n           cumulativeCapacity.headMap(endKey, false);\n       if (ticks !\u003d null \u0026\u0026 !ticks.isEmpty()) {\n         Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n         Entry\u003cLong, Resource\u003e lowEntry \u003d ticks.floorEntry(startKey);\n         if (lowEntry \u003d\u003d null) {\n           // This is the earliest starting interval\n           cumulativeCapacity.put(startKey, totCap);\n         } else {\n           updatedCapacity \u003d Resources.add(lowEntry.getValue(), totCap);\n           // Add a new tick only if the updated value is different\n           // from the previous tick\n           if ((startKey \u003d\u003d lowEntry.getKey())\n               \u0026\u0026 (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {\n             cumulativeCapacity.remove(lowEntry.getKey());\n           } else {\n             cumulativeCapacity.put(startKey, updatedCapacity);\n           }\n         }\n         // Increase all the capacities of overlapping intervals\n         Set\u003cEntry\u003cLong, Resource\u003e\u003e overlapSet \u003d\n             ticks.tailMap(startKey, false).entrySet();\n         for (Entry\u003cLong, Resource\u003e entry : overlapSet) {\n           updatedCapacity \u003d Resources.add(entry.getValue(), totCap);\n           entry.setValue(updatedCapacity);\n         }\n       } else {\n         // This is the first interval to be added\n         cumulativeCapacity.put(startKey, totCap);\n       }\n       Resource nextTick \u003d cumulativeCapacity.get(endKey);\n       if (nextTick !\u003d null) {\n         // If there is overlap, remove the duplicate entry\n         if (isSameAsPrevious(endKey, nextTick)) {\n           cumulativeCapacity.remove(endKey);\n         }\n       } else {\n         // Decrease capacity as this is end of the interval\n         cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity\n             .floorEntry(endKey).getValue(), totCap));\n       }\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean addInterval(ReservationInterval reservationInterval,\n      Resource totCap) {\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n      long startKey \u003d reservationInterval.getStartTime();\n      long endKey \u003d reservationInterval.getEndTime();\n      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n          cumulativeCapacity.headMap(endKey, false);\n      if (ticks !\u003d null \u0026\u0026 !ticks.isEmpty()) {\n        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n        Entry\u003cLong, Resource\u003e lowEntry \u003d ticks.floorEntry(startKey);\n        if (lowEntry \u003d\u003d null) {\n          // This is the earliest starting interval\n          cumulativeCapacity.put(startKey, totCap);\n        } else {\n          updatedCapacity \u003d Resources.add(lowEntry.getValue(), totCap);\n          // Add a new tick only if the updated value is different\n          // from the previous tick\n          if ((startKey \u003d\u003d lowEntry.getKey())\n              \u0026\u0026 (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {\n            cumulativeCapacity.remove(lowEntry.getKey());\n          } else {\n            cumulativeCapacity.put(startKey, updatedCapacity);\n          }\n        }\n        // Increase all the capacities of overlapping intervals\n        Set\u003cEntry\u003cLong, Resource\u003e\u003e overlapSet \u003d\n            ticks.tailMap(startKey, false).entrySet();\n        for (Entry\u003cLong, Resource\u003e entry : overlapSet) {\n          updatedCapacity \u003d Resources.add(entry.getValue(), totCap);\n          entry.setValue(updatedCapacity);\n        }\n      } else {\n        // This is the first interval to be added\n        cumulativeCapacity.put(startKey, totCap);\n      }\n      Resource nextTick \u003d cumulativeCapacity.get(endKey);\n      if (nextTick !\u003d null) {\n        // If there is overlap, remove the duplicate entry\n        if (isSameAsPrevious(endKey, nextTick)) {\n          cumulativeCapacity.remove(endKey);\n        }\n      } else {\n        // Decrease capacity as this is end of the interval\n        cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity\n            .floorEntry(endKey).getValue(), totCap));\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
          "extendedDetails": {}
        }
      ]
    },
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1709. In-memory data structures used to track resources over time to enable reservations.\n(cherry picked from commit 0d8b2cd88b958b1e602fd4ea4078ef8d4742a7c3)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "cf4b34282aafee9f6b09d3433c4de1ae4b359168",
      "commitAuthor": "subru",
      "diff": "@@ -0,0 +1,58 @@\n+  public boolean addInterval(ReservationInterval reservationInterval,\n+      ReservationRequest capacity) {\n+    Resource totCap \u003d\n+        Resources.multiply(capacity.getCapability(),\n+            (float) capacity.getNumContainers());\n+    if (totCap.equals(ZERO_RESOURCE)) {\n+      return true;\n+    }\n+    writeLock.lock();\n+    try {\n+      long startKey \u003d reservationInterval.getStartTime();\n+      long endKey \u003d reservationInterval.getEndTime();\n+      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n+          cumulativeCapacity.headMap(endKey, false);\n+      if (ticks !\u003d null \u0026\u0026 !ticks.isEmpty()) {\n+        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n+        Entry\u003cLong, Resource\u003e lowEntry \u003d ticks.floorEntry(startKey);\n+        if (lowEntry \u003d\u003d null) {\n+          // This is the earliest starting interval\n+          cumulativeCapacity.put(startKey, totCap);\n+        } else {\n+          updatedCapacity \u003d Resources.add(lowEntry.getValue(), totCap);\n+          // Add a new tick only if the updated value is different\n+          // from the previous tick\n+          if ((startKey \u003d\u003d lowEntry.getKey())\n+              \u0026\u0026 (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {\n+            cumulativeCapacity.remove(lowEntry.getKey());\n+          } else {\n+            cumulativeCapacity.put(startKey, updatedCapacity);\n+          }\n+        }\n+        // Increase all the capacities of overlapping intervals\n+        Set\u003cEntry\u003cLong, Resource\u003e\u003e overlapSet \u003d\n+            ticks.tailMap(startKey, false).entrySet();\n+        for (Entry\u003cLong, Resource\u003e entry : overlapSet) {\n+          updatedCapacity \u003d Resources.add(entry.getValue(), totCap);\n+          entry.setValue(updatedCapacity);\n+        }\n+      } else {\n+        // This is the first interval to be added\n+        cumulativeCapacity.put(startKey, totCap);\n+      }\n+      Resource nextTick \u003d cumulativeCapacity.get(endKey);\n+      if (nextTick !\u003d null) {\n+        // If there is overlap, remove the duplicate entry\n+        if (isSameAsPrevious(endKey, nextTick)) {\n+          cumulativeCapacity.remove(endKey);\n+        }\n+      } else {\n+        // Decrease capacity as this is end of the interval\n+        cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity\n+            .floorEntry(endKey).getValue(), totCap));\n+      }\n+      return true;\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addInterval(ReservationInterval reservationInterval,\n      ReservationRequest capacity) {\n    Resource totCap \u003d\n        Resources.multiply(capacity.getCapability(),\n            (float) capacity.getNumContainers());\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n      long startKey \u003d reservationInterval.getStartTime();\n      long endKey \u003d reservationInterval.getEndTime();\n      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n          cumulativeCapacity.headMap(endKey, false);\n      if (ticks !\u003d null \u0026\u0026 !ticks.isEmpty()) {\n        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n        Entry\u003cLong, Resource\u003e lowEntry \u003d ticks.floorEntry(startKey);\n        if (lowEntry \u003d\u003d null) {\n          // This is the earliest starting interval\n          cumulativeCapacity.put(startKey, totCap);\n        } else {\n          updatedCapacity \u003d Resources.add(lowEntry.getValue(), totCap);\n          // Add a new tick only if the updated value is different\n          // from the previous tick\n          if ((startKey \u003d\u003d lowEntry.getKey())\n              \u0026\u0026 (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {\n            cumulativeCapacity.remove(lowEntry.getKey());\n          } else {\n            cumulativeCapacity.put(startKey, updatedCapacity);\n          }\n        }\n        // Increase all the capacities of overlapping intervals\n        Set\u003cEntry\u003cLong, Resource\u003e\u003e overlapSet \u003d\n            ticks.tailMap(startKey, false).entrySet();\n        for (Entry\u003cLong, Resource\u003e entry : overlapSet) {\n          updatedCapacity \u003d Resources.add(entry.getValue(), totCap);\n          entry.setValue(updatedCapacity);\n        }\n      } else {\n        // This is the first interval to be added\n        cumulativeCapacity.put(startKey, totCap);\n      }\n      Resource nextTick \u003d cumulativeCapacity.get(endKey);\n      if (nextTick !\u003d null) {\n        // If there is overlap, remove the duplicate entry\n        if (isSameAsPrevious(endKey, nextTick)) {\n          cumulativeCapacity.remove(endKey);\n        }\n      } else {\n        // Decrease capacity as this is end of the interval\n        cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity\n            .floorEntry(endKey).getValue(), totCap));\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java"
    }
  }
}