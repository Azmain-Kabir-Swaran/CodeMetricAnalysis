{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RpcProgram.java",
  "functionName": "messageReceived",
  "functionId": "messageReceived___ctx-ChannelHandlerContext__e-MessageEvent",
  "sourceFilePath": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/oncrpc/RpcProgram.java",
  "functionStartLine": 165,
  "functionEndLine": 189,
  "numCommitsSeen": 15,
  "timeTaken": 1190,
  "changeHistory": [
    "2ecab65e3e290a1ee192b39ec70868863853543a",
    "da3992b4e39019cd02e95460518b5d13d0e4eecd",
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891"
  ],
  "changeHistoryShort": {
    "2ecab65e3e290a1ee192b39ec70868863853543a": "Ybodychange",
    "da3992b4e39019cd02e95460518b5d13d0e4eecd": "Ybodychange",
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2ecab65e3e290a1ee192b39ec70868863853543a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6439. NFS should not reject NFS requests to the NULL procedure whether port monitoring is enabled or not. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603622 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/14 1:45 PM",
      "commitName": "2ecab65e3e290a1ee192b39ec70868863853543a",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "16/05/14 2:23 PM",
      "commitNameOld": "da3992b4e39019cd02e95460518b5d13d0e4eecd",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 32.97,
      "commitsBetweenForRepo": 181,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,25 @@\n   public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n       throws Exception {\n     RpcInfo info \u003d (RpcInfo) e.getMessage();\n     RpcCall call \u003d (RpcCall) info.header();\n     \n     SocketAddress remoteAddress \u003d info.remoteAddress();\n-    if (!allowInsecurePorts) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Will not allow connections from unprivileged ports. \" +\n-            \"Checking for valid client port...\");\n-      }\n-      if (remoteAddress instanceof InetSocketAddress) {\n-        InetSocketAddress inetRemoteAddress \u003d (InetSocketAddress) remoteAddress;\n-        if (inetRemoteAddress.getPort() \u003e 1023) {\n-          LOG.warn(\"Connection attempted from \u0027\" + inetRemoteAddress + \"\u0027 \"\n-              + \"which is an unprivileged port. Rejecting connection.\");\n-          sendRejectedReply(call, remoteAddress, ctx);\n-          return;\n-        } else {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Accepting connection from \u0027\" + remoteAddress + \"\u0027\");\n-          }\n-        }\n-      } else {\n-        LOG.warn(\"Could not determine remote port of socket address \u0027\" +\n-            remoteAddress + \"\u0027. Rejecting connection.\");\n-        sendRejectedReply(call, remoteAddress, ctx);\n-        return;\n-      }\n-    }\n-    \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(program + \" procedure #\" + call.getProcedure());\n     }\n     \n     if (this.progNumber !\u003d call.getProgram()) {\n       LOG.warn(\"Invalid RPC call program \" + call.getProgram());\n       sendAcceptedReply(call, remoteAddress, AcceptState.PROG_UNAVAIL, ctx);\n       return;\n     }\n \n     int ver \u003d call.getVersion();\n     if (ver \u003c lowProgVersion || ver \u003e highProgVersion) {\n       LOG.warn(\"Invalid RPC call version \" + ver);\n       sendAcceptedReply(call, remoteAddress, AcceptState.PROG_MISMATCH, ctx);\n       return;\n     }\n     \n     handleInternal(ctx, info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n      throws Exception {\n    RpcInfo info \u003d (RpcInfo) e.getMessage();\n    RpcCall call \u003d (RpcCall) info.header();\n    \n    SocketAddress remoteAddress \u003d info.remoteAddress();\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(program + \" procedure #\" + call.getProcedure());\n    }\n    \n    if (this.progNumber !\u003d call.getProgram()) {\n      LOG.warn(\"Invalid RPC call program \" + call.getProgram());\n      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_UNAVAIL, ctx);\n      return;\n    }\n\n    int ver \u003d call.getVersion();\n    if (ver \u003c lowProgVersion || ver \u003e highProgVersion) {\n      LOG.warn(\"Invalid RPC call version \" + ver);\n      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_MISMATCH, ctx);\n      return;\n    }\n    \n    handleInternal(ctx, info);\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/oncrpc/RpcProgram.java",
      "extendedDetails": {}
    },
    "da3992b4e39019cd02e95460518b5d13d0e4eecd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6406. Add capability for NFS gateway to reject connections from unprivileged ports. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595351 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/14 2:23 PM",
      "commitName": "da3992b4e39019cd02e95460518b5d13d0e4eecd",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/04/14 5:16 PM",
      "commitNameOld": "7bad941152417ebfafe1349cedfa2aafc906f8dc",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 21.88,
      "commitsBetweenForRepo": 119,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,50 @@\n   public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n       throws Exception {\n     RpcInfo info \u003d (RpcInfo) e.getMessage();\n     RpcCall call \u003d (RpcCall) info.header();\n+    \n+    SocketAddress remoteAddress \u003d info.remoteAddress();\n+    if (!allowInsecurePorts) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Will not allow connections from unprivileged ports. \" +\n+            \"Checking for valid client port...\");\n+      }\n+      if (remoteAddress instanceof InetSocketAddress) {\n+        InetSocketAddress inetRemoteAddress \u003d (InetSocketAddress) remoteAddress;\n+        if (inetRemoteAddress.getPort() \u003e 1023) {\n+          LOG.warn(\"Connection attempted from \u0027\" + inetRemoteAddress + \"\u0027 \"\n+              + \"which is an unprivileged port. Rejecting connection.\");\n+          sendRejectedReply(call, remoteAddress, ctx);\n+          return;\n+        } else {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Accepting connection from \u0027\" + remoteAddress + \"\u0027\");\n+          }\n+        }\n+      } else {\n+        LOG.warn(\"Could not determine remote port of socket address \u0027\" +\n+            remoteAddress + \"\u0027. Rejecting connection.\");\n+        sendRejectedReply(call, remoteAddress, ctx);\n+        return;\n+      }\n+    }\n+    \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(program + \" procedure #\" + call.getProcedure());\n     }\n     \n     if (this.progNumber !\u003d call.getProgram()) {\n       LOG.warn(\"Invalid RPC call program \" + call.getProgram());\n-      RpcAcceptedReply reply \u003d RpcAcceptedReply.getInstance(call.getXid(),\n-          AcceptState.PROG_UNAVAIL, Verifier.VERIFIER_NONE);\n-\n-      XDR out \u003d new XDR();\n-      reply.write(out);\n-      ChannelBuffer b \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n-          .buffer());\n-      RpcResponse rsp \u003d new RpcResponse(b, info.remoteAddress());\n-      RpcUtil.sendRpcResponse(ctx, rsp);\n+      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_UNAVAIL, ctx);\n       return;\n     }\n \n     int ver \u003d call.getVersion();\n     if (ver \u003c lowProgVersion || ver \u003e highProgVersion) {\n       LOG.warn(\"Invalid RPC call version \" + ver);\n-      RpcAcceptedReply reply \u003d RpcAcceptedReply.getInstance(call.getXid(),\n-          AcceptState.PROG_MISMATCH, Verifier.VERIFIER_NONE);\n-\n-      XDR out \u003d new XDR();\n-      reply.write(out);\n-      out.writeInt(lowProgVersion);\n-      out.writeInt(highProgVersion);\n-      ChannelBuffer b \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n-          .buffer());\n-      RpcResponse rsp \u003d new RpcResponse(b, info.remoteAddress());\n-      RpcUtil.sendRpcResponse(ctx, rsp);\n+      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_MISMATCH, ctx);\n       return;\n     }\n     \n     handleInternal(ctx, info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n      throws Exception {\n    RpcInfo info \u003d (RpcInfo) e.getMessage();\n    RpcCall call \u003d (RpcCall) info.header();\n    \n    SocketAddress remoteAddress \u003d info.remoteAddress();\n    if (!allowInsecurePorts) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Will not allow connections from unprivileged ports. \" +\n            \"Checking for valid client port...\");\n      }\n      if (remoteAddress instanceof InetSocketAddress) {\n        InetSocketAddress inetRemoteAddress \u003d (InetSocketAddress) remoteAddress;\n        if (inetRemoteAddress.getPort() \u003e 1023) {\n          LOG.warn(\"Connection attempted from \u0027\" + inetRemoteAddress + \"\u0027 \"\n              + \"which is an unprivileged port. Rejecting connection.\");\n          sendRejectedReply(call, remoteAddress, ctx);\n          return;\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Accepting connection from \u0027\" + remoteAddress + \"\u0027\");\n          }\n        }\n      } else {\n        LOG.warn(\"Could not determine remote port of socket address \u0027\" +\n            remoteAddress + \"\u0027. Rejecting connection.\");\n        sendRejectedReply(call, remoteAddress, ctx);\n        return;\n      }\n    }\n    \n    if (LOG.isTraceEnabled()) {\n      LOG.trace(program + \" procedure #\" + call.getProcedure());\n    }\n    \n    if (this.progNumber !\u003d call.getProgram()) {\n      LOG.warn(\"Invalid RPC call program \" + call.getProgram());\n      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_UNAVAIL, ctx);\n      return;\n    }\n\n    int ver \u003d call.getVersion();\n    if (ver \u003c lowProgVersion || ver \u003e highProgVersion) {\n      LOG.warn(\"Invalid RPC call version \" + ver);\n      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_MISMATCH, ctx);\n      return;\n    }\n    \n    handleInternal(ctx, info);\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/oncrpc/RpcProgram.java",
      "extendedDetails": {}
    },
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/13 12:21 PM",
      "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,41 @@\n+  public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n+      throws Exception {\n+    RpcInfo info \u003d (RpcInfo) e.getMessage();\n+    RpcCall call \u003d (RpcCall) info.header();\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(program + \" procedure #\" + call.getProcedure());\n+    }\n+    \n+    if (this.progNumber !\u003d call.getProgram()) {\n+      LOG.warn(\"Invalid RPC call program \" + call.getProgram());\n+      RpcAcceptedReply reply \u003d RpcAcceptedReply.getInstance(call.getXid(),\n+          AcceptState.PROG_UNAVAIL, Verifier.VERIFIER_NONE);\n+\n+      XDR out \u003d new XDR();\n+      reply.write(out);\n+      ChannelBuffer b \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n+          .buffer());\n+      RpcResponse rsp \u003d new RpcResponse(b, info.remoteAddress());\n+      RpcUtil.sendRpcResponse(ctx, rsp);\n+      return;\n+    }\n+\n+    int ver \u003d call.getVersion();\n+    if (ver \u003c lowProgVersion || ver \u003e highProgVersion) {\n+      LOG.warn(\"Invalid RPC call version \" + ver);\n+      RpcAcceptedReply reply \u003d RpcAcceptedReply.getInstance(call.getXid(),\n+          AcceptState.PROG_MISMATCH, Verifier.VERIFIER_NONE);\n+\n+      XDR out \u003d new XDR();\n+      reply.write(out);\n+      out.writeInt(lowProgVersion);\n+      out.writeInt(highProgVersion);\n+      ChannelBuffer b \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n+          .buffer());\n+      RpcResponse rsp \u003d new RpcResponse(b, info.remoteAddress());\n+      RpcUtil.sendRpcResponse(ctx, rsp);\n+      return;\n+    }\n+    \n+    handleInternal(ctx, info);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n      throws Exception {\n    RpcInfo info \u003d (RpcInfo) e.getMessage();\n    RpcCall call \u003d (RpcCall) info.header();\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(program + \" procedure #\" + call.getProcedure());\n    }\n    \n    if (this.progNumber !\u003d call.getProgram()) {\n      LOG.warn(\"Invalid RPC call program \" + call.getProgram());\n      RpcAcceptedReply reply \u003d RpcAcceptedReply.getInstance(call.getXid(),\n          AcceptState.PROG_UNAVAIL, Verifier.VERIFIER_NONE);\n\n      XDR out \u003d new XDR();\n      reply.write(out);\n      ChannelBuffer b \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n          .buffer());\n      RpcResponse rsp \u003d new RpcResponse(b, info.remoteAddress());\n      RpcUtil.sendRpcResponse(ctx, rsp);\n      return;\n    }\n\n    int ver \u003d call.getVersion();\n    if (ver \u003c lowProgVersion || ver \u003e highProgVersion) {\n      LOG.warn(\"Invalid RPC call version \" + ver);\n      RpcAcceptedReply reply \u003d RpcAcceptedReply.getInstance(call.getXid(),\n          AcceptState.PROG_MISMATCH, Verifier.VERIFIER_NONE);\n\n      XDR out \u003d new XDR();\n      reply.write(out);\n      out.writeInt(lowProgVersion);\n      out.writeInt(highProgVersion);\n      ChannelBuffer b \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n          .buffer());\n      RpcResponse rsp \u003d new RpcResponse(b, info.remoteAddress());\n      RpcUtil.sendRpcResponse(ctx, rsp);\n      return;\n    }\n    \n    handleInternal(ctx, info);\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/oncrpc/RpcProgram.java"
    }
  }
}