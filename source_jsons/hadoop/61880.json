{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineEntityV2Converter.java",
  "functionName": "convertToContainerReport",
  "functionId": "convertToContainerReport___entity-TimelineEntity__serverAddress-String__user-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java",
  "functionStartLine": 61,
  "functionEndLine": 164,
  "numCommitsSeen": 6,
  "timeTaken": 2967,
  "changeHistory": [
    "571838920d2faca703e3c3417d64123927dfc4ad",
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
    "ee3355be3cd1cd956296a1b79b264177ff139ce6"
  ],
  "changeHistoryShort": {
    "571838920d2faca703e3c3417d64123927dfc4ad": "Ymultichange(Yparameterchange,Ybodychange)",
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": "Ybodychange",
    "ee3355be3cd1cd956296a1b79b264177ff139ce6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "571838920d2faca703e3c3417d64123927dfc4ad": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9149. yarn container -status misses logUrl when integrated with ATSv2. Contributed by Abhishek Modi.\n",
      "commitDate": "04/02/19 11:09 PM",
      "commitName": "571838920d2faca703e3c3417d64123927dfc4ad",
      "commitAuthor": "Rohith Sharma K S",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9149. yarn container -status misses logUrl when integrated with ATSv2. Contributed by Abhishek Modi.\n",
          "commitDate": "04/02/19 11:09 PM",
          "commitName": "571838920d2faca703e3c3417d64123927dfc4ad",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "21/12/18 4:44 PM",
          "commitNameOld": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 45.27,
          "commitsBetweenForRepo": 297,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,104 @@\n   public static ContainerReport convertToContainerReport(\n-      TimelineEntity entity) {\n+      TimelineEntity entity, String serverAddress, String user) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n     String nodeHttpAddress \u003d null;\n     Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n \n     Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n         allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n         nodeHttpAddress \u003d\n             (String) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n         exposedPorts \u003d\n             (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n         diagnosticsInfo \u003d\n             entityInfo.get(\n                 ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n         exitStatus \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.EXIT_STATUS_INFO);\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n         state \u003d\n             ContainerState.valueOf(entityInfo.get(\n                 ContainerMetricsConstants.STATE_INFO).toString());\n       }\n     }\n     NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getId().equals(\n             ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getId().equals(\n             ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n         }\n       }\n     }\n     String logUrl \u003d null;\n     NodeId allocatedNode \u003d null;\n+    String containerId \u003d entity.getId();\n     if (allocatedHost !\u003d null) {\n       allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n+      if (serverAddress !\u003d null \u0026\u0026 user !\u003d null) {\n+        logUrl \u003d PATH_JOINER.join(serverAddress,\n+            \"logs\", allocatedNode, containerId, containerId, user);\n+      }\n     }\n     ContainerReport container \u003d ContainerReport.newInstance(\n         ContainerId.fromString(entity.getId()),\n         Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n         Priority.newInstance(allocatedPriority),\n         createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n         nodeHttpAddress);\n     container.setExposedPorts(exposedPorts);\n \n     return container;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n        allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n        exposedPorts \u003d\n            (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n        diagnosticsInfo \u003d\n            entityInfo.get(\n                ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n        exitStatus \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.EXIT_STATUS_INFO);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n        state \u003d\n            ContainerState.valueOf(entityInfo.get(\n                ContainerMetricsConstants.STATE_INFO).toString());\n      }\n    }\n    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getId().equals(\n            ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getId().equals(\n            ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n        }\n      }\n    }\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    String containerId \u003d entity.getId();\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n      if (serverAddress !\u003d null \u0026\u0026 user !\u003d null) {\n        logUrl \u003d PATH_JOINER.join(serverAddress,\n            \"logs\", allocatedNode, containerId, containerId, user);\n      }\n    }\n    ContainerReport container \u003d ContainerReport.newInstance(\n        ContainerId.fromString(entity.getId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n    container.setExposedPorts(exposedPorts);\n\n    return container;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java",
          "extendedDetails": {
            "oldValue": "[entity-TimelineEntity]",
            "newValue": "[entity-TimelineEntity, serverAddress-String, user-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9149. yarn container -status misses logUrl when integrated with ATSv2. Contributed by Abhishek Modi.\n",
          "commitDate": "04/02/19 11:09 PM",
          "commitName": "571838920d2faca703e3c3417d64123927dfc4ad",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "21/12/18 4:44 PM",
          "commitNameOld": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 45.27,
          "commitsBetweenForRepo": 297,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,104 @@\n   public static ContainerReport convertToContainerReport(\n-      TimelineEntity entity) {\n+      TimelineEntity entity, String serverAddress, String user) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n     String nodeHttpAddress \u003d null;\n     Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n \n     Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n         allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n         nodeHttpAddress \u003d\n             (String) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n         exposedPorts \u003d\n             (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n         diagnosticsInfo \u003d\n             entityInfo.get(\n                 ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n         exitStatus \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.EXIT_STATUS_INFO);\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n         state \u003d\n             ContainerState.valueOf(entityInfo.get(\n                 ContainerMetricsConstants.STATE_INFO).toString());\n       }\n     }\n     NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getId().equals(\n             ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getId().equals(\n             ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n         }\n       }\n     }\n     String logUrl \u003d null;\n     NodeId allocatedNode \u003d null;\n+    String containerId \u003d entity.getId();\n     if (allocatedHost !\u003d null) {\n       allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n+      if (serverAddress !\u003d null \u0026\u0026 user !\u003d null) {\n+        logUrl \u003d PATH_JOINER.join(serverAddress,\n+            \"logs\", allocatedNode, containerId, containerId, user);\n+      }\n     }\n     ContainerReport container \u003d ContainerReport.newInstance(\n         ContainerId.fromString(entity.getId()),\n         Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n         Priority.newInstance(allocatedPriority),\n         createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n         nodeHttpAddress);\n     container.setExposedPorts(exposedPorts);\n \n     return container;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n        allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n        exposedPorts \u003d\n            (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n        diagnosticsInfo \u003d\n            entityInfo.get(\n                ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n        exitStatus \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.EXIT_STATUS_INFO);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n        state \u003d\n            ContainerState.valueOf(entityInfo.get(\n                ContainerMetricsConstants.STATE_INFO).toString());\n      }\n    }\n    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getId().equals(\n            ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getId().equals(\n            ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n        }\n      }\n    }\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    String containerId \u003d entity.getId();\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n      if (serverAddress !\u003d null \u0026\u0026 user !\u003d null) {\n        logUrl \u003d PATH_JOINER.join(serverAddress,\n            \"logs\", allocatedNode, containerId, containerId, user);\n      }\n    }\n    ContainerReport container \u003d ContainerReport.newInstance(\n        ContainerId.fromString(entity.getId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n    container.setExposedPorts(exposedPorts);\n\n    return container;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java",
          "extendedDetails": {}
        }
      ]
    },
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5168. Added exposed port information for Docker container.\n           Contributed by Xun Liu\n",
      "commitDate": "21/12/18 4:44 PM",
      "commitName": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "16/11/18 4:28 AM",
      "commitNameOld": "ee3355be3cd1cd956296a1b79b264177ff139ce6",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 35.51,
      "commitsBetweenForRepo": 219,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,99 @@\n   public static ContainerReport convertToContainerReport(\n       TimelineEntity entity) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n     String nodeHttpAddress \u003d null;\n+    Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n+\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n         allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n             ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n         nodeHttpAddress \u003d\n             (String) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n       }\n+      if (entityInfo.containsKey(\n+          ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n+        exposedPorts \u003d\n+            (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n+                .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n+      }\n       if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n         diagnosticsInfo \u003d\n             entityInfo.get(\n                 ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n         exitStatus \u003d (Integer) entityInfo.get(\n             ContainerMetricsConstants.EXIT_STATUS_INFO);\n       }\n       if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n         state \u003d\n             ContainerState.valueOf(entityInfo.get(\n                 ContainerMetricsConstants.STATE_INFO).toString());\n       }\n     }\n     NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getId().equals(\n             ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getId().equals(\n             ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n         }\n       }\n     }\n     String logUrl \u003d null;\n     NodeId allocatedNode \u003d null;\n     if (allocatedHost !\u003d null) {\n       allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n     }\n-    return ContainerReport.newInstance(\n+    ContainerReport container \u003d ContainerReport.newInstance(\n         ContainerId.fromString(entity.getId()),\n         Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n         Priority.newInstance(allocatedPriority),\n         createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n         nodeHttpAddress);\n+    container.setExposedPorts(exposedPorts);\n+\n+    return container;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static ContainerReport convertToContainerReport(\n      TimelineEntity entity) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n        allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n        exposedPorts \u003d\n            (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n        diagnosticsInfo \u003d\n            entityInfo.get(\n                ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n        exitStatus \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.EXIT_STATUS_INFO);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n        state \u003d\n            ContainerState.valueOf(entityInfo.get(\n                ContainerMetricsConstants.STATE_INFO).toString());\n      }\n    }\n    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getId().equals(\n            ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getId().equals(\n            ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n        }\n      }\n    }\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n    }\n    ContainerReport container \u003d ContainerReport.newInstance(\n        ContainerId.fromString(entity.getId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n    container.setExposedPorts(exposedPorts);\n\n    return container;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java",
      "extendedDetails": {}
    },
    "ee3355be3cd1cd956296a1b79b264177ff139ce6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8303. YarnClient should contact TimelineReader for application/attempt/container report.\n",
      "commitDate": "16/11/18 4:28 AM",
      "commitName": "ee3355be3cd1cd956296a1b79b264177ff139ce6",
      "commitAuthor": "Rohith Sharma K S",
      "diff": "@@ -0,0 +1,88 @@\n+  public static ContainerReport convertToContainerReport(\n+      TimelineEntity entity) {\n+    int allocatedMem \u003d 0;\n+    int allocatedVcore \u003d 0;\n+    String allocatedHost \u003d null;\n+    int allocatedPort \u003d -1;\n+    int allocatedPriority \u003d 0;\n+    long createdTime \u003d 0;\n+    long finishedTime \u003d 0;\n+    String diagnosticsInfo \u003d null;\n+    int exitStatus \u003d ContainerExitStatus.INVALID;\n+    ContainerState state \u003d null;\n+    String nodeHttpAddress \u003d null;\n+    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n+    if (entityInfo !\u003d null) {\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n+        allocatedMem \u003d (Integer) entityInfo.get(\n+            ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n+        allocatedVcore \u003d (Integer) entityInfo.get(\n+            ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n+        allocatedHost \u003d\n+            entityInfo\n+                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n+                .toString();\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n+        allocatedPort \u003d (Integer) entityInfo.get(\n+            ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n+        allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n+            ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n+      }\n+      if (entityInfo.containsKey(\n+          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n+        nodeHttpAddress \u003d\n+            (String) entityInfo.get(\n+                ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n+      }\n+      if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n+        diagnosticsInfo \u003d\n+            entityInfo.get(\n+                ContainerMetricsConstants.DIAGNOSTICS_INFO)\n+                .toString();\n+      }\n+      if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n+        exitStatus \u003d (Integer) entityInfo.get(\n+            ContainerMetricsConstants.EXIT_STATUS_INFO);\n+      }\n+      if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n+        state \u003d\n+            ContainerState.valueOf(entityInfo.get(\n+                ContainerMetricsConstants.STATE_INFO).toString());\n+      }\n+    }\n+    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n+    if (events !\u003d null) {\n+      for (TimelineEvent event : events) {\n+        if (event.getId().equals(\n+            ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n+          createdTime \u003d event.getTimestamp();\n+        } else if (event.getId().equals(\n+            ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n+          finishedTime \u003d event.getTimestamp();\n+        }\n+      }\n+    }\n+    String logUrl \u003d null;\n+    NodeId allocatedNode \u003d null;\n+    if (allocatedHost !\u003d null) {\n+      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n+    }\n+    return ContainerReport.newInstance(\n+        ContainerId.fromString(entity.getId()),\n+        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n+        Priority.newInstance(allocatedPriority),\n+        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n+        nodeHttpAddress);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static ContainerReport convertToContainerReport(\n      TimelineEntity entity) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n        allocatedPriority \u003d Integer.parseInt(entityInfo.get(\n            ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO).toString());\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n        diagnosticsInfo \u003d\n            entityInfo.get(\n                ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n        exitStatus \u003d (Integer) entityInfo.get(\n            ContainerMetricsConstants.EXIT_STATUS_INFO);\n      }\n      if (entityInfo.containsKey(ContainerMetricsConstants.STATE_INFO)) {\n        state \u003d\n            ContainerState.valueOf(entityInfo.get(\n                ContainerMetricsConstants.STATE_INFO).toString());\n      }\n    }\n    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getId().equals(\n            ContainerMetricsConstants.CREATED_IN_RM_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getId().equals(\n            ContainerMetricsConstants.FINISHED_IN_RM_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n        }\n      }\n    }\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n    }\n    return ContainerReport.newInstance(\n        ContainerId.fromString(entity.getId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java"
    }
  }
}