{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "updateParentFolderLastModifiedTime",
  "functionId": "updateParentFolderLastModifiedTime___key-String",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 3299,
  "functionEndLine": 3350,
  "numCommitsSeen": 66,
  "timeTaken": 3646,
  "changeHistory": [
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
    "5f6edb30c2bb648d5564c951edc25645e17e6636",
    "f2c91098c400da6db0f5e8e49e9bf0e6444af531",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40"
  ],
  "changeHistoryShort": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": "Ybodychange",
    "5f6edb30c2bb648d5564c951edc25645e17e6636": "Ybodychange",
    "f2c91098c400da6db0f5e8e49e9bf0e6444af531": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15547/ WASB: improve listStatus performance.\nContributed by Thomas Marquardt.\n\n(cherry picked from commit 749fff577ed9afb4ef8a54b8948f74be083cc620)\n",
      "commitDate": "19/07/18 12:31 PM",
      "commitName": "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.58,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private void updateParentFolderLastModifiedTime(String key)\n       throws IOException {\n     Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n       String parentKey \u003d pathToKey(parent);\n \n       // ensure the parent is a materialized folder\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       // The metadata could be null if the implicit folder only contains a\n       // single file. In this case, the parent folder no longer exists if the\n       // file is renamed; so we can safely ignore the null pointer case.\n       if (parentMetadata !\u003d null) {\n-        if (parentMetadata.isDir()\n+        if (parentMetadata.isDirectory()\n             \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n \n         if (store.isAtomicRenameKey(parentKey)) {\n           SelfRenewingLease lease \u003d null;\n           try {\n             lease \u003d leaseSourceFolder(parentKey);\n             store.updateFolderLastModifiedTime(parentKey, lease);\n           } catch (AzureException e) {\n             String errorCode \u003d \"\";\n             try {\n               StorageException e2 \u003d (StorageException) e.getCause();\n               errorCode \u003d e2.getErrorCode();\n             } catch (Exception e3) {\n               // do nothing if cast fails\n             }\n             if (errorCode.equals(\"BlobNotFound\")) {\n               throw new FileNotFoundException(\"Folder does not exist: \" + parentKey);\n             }\n             LOG.warn(\"Got unexpected exception trying to get lease on {}. {}\",\n                 parentKey, e.getMessage());\n             throw e;\n           } finally {\n             try {\n               if (lease !\u003d null) {\n                 lease.free();\n               }\n             } catch (Exception e) {\n               LOG.error(\"Unable to free lease on {}\", parentKey, e);\n             }\n           }\n         } else {\n           store.updateFolderLastModifiedTime(parentKey, null);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateParentFolderLastModifiedTime(String key)\n      throws IOException {\n    Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n      String parentKey \u003d pathToKey(parent);\n\n      // ensure the parent is a materialized folder\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      // The metadata could be null if the implicit folder only contains a\n      // single file. In this case, the parent folder no longer exists if the\n      // file is renamed; so we can safely ignore the null pointer case.\n      if (parentMetadata !\u003d null) {\n        if (parentMetadata.isDirectory()\n            \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n\n        if (store.isAtomicRenameKey(parentKey)) {\n          SelfRenewingLease lease \u003d null;\n          try {\n            lease \u003d leaseSourceFolder(parentKey);\n            store.updateFolderLastModifiedTime(parentKey, lease);\n          } catch (AzureException e) {\n            String errorCode \u003d \"\";\n            try {\n              StorageException e2 \u003d (StorageException) e.getCause();\n              errorCode \u003d e2.getErrorCode();\n            } catch (Exception e3) {\n              // do nothing if cast fails\n            }\n            if (errorCode.equals(\"BlobNotFound\")) {\n              throw new FileNotFoundException(\"Folder does not exist: \" + parentKey);\n            }\n            LOG.warn(\"Got unexpected exception trying to get lease on {}. {}\",\n                parentKey, e.getMessage());\n            throw e;\n          } finally {\n            try {\n              if (lease !\u003d null) {\n                lease.free();\n              }\n            } catch (Exception e) {\n              LOG.error(\"Unable to free lease on {}\", parentKey, e);\n            }\n          }\n        } else {\n          store.updateFolderLastModifiedTime(parentKey, null);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "5f6edb30c2bb648d5564c951edc25645e17e6636": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12350. WASB Logging: Improve WASB Logging around deletes, reads and writes. Contributed by Dushyanth.\n",
      "commitDate": "05/10/15 8:11 PM",
      "commitName": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthor": "cnauroth",
      "commitDateOld": "28/09/15 3:31 PM",
      "commitNameOld": "3abbdc929bde05f8819f5410cef1eaeb8940203f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.19,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private void updateParentFolderLastModifiedTime(String key)\n       throws IOException {\n     Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n       String parentKey \u003d pathToKey(parent);\n \n       // ensure the parent is a materialized folder\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       // The metadata could be null if the implicit folder only contains a\n       // single file. In this case, the parent folder no longer exists if the\n       // file is renamed; so we can safely ignore the null pointer case.\n       if (parentMetadata !\u003d null) {\n         if (parentMetadata.isDir()\n             \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n \n         if (store.isAtomicRenameKey(parentKey)) {\n           SelfRenewingLease lease \u003d null;\n           try {\n             lease \u003d leaseSourceFolder(parentKey);\n             store.updateFolderLastModifiedTime(parentKey, lease);\n           } catch (AzureException e) {\n             String errorCode \u003d \"\";\n             try {\n               StorageException e2 \u003d (StorageException) e.getCause();\n               errorCode \u003d e2.getErrorCode();\n             } catch (Exception e3) {\n               // do nothing if cast fails\n             }\n             if (errorCode.equals(\"BlobNotFound\")) {\n               throw new FileNotFoundException(\"Folder does not exist: \" + parentKey);\n             }\n-            LOG.warn(\"Got unexpected exception trying to get lease on \"\n-                + parentKey + \". \" + e.getMessage());\n+            LOG.warn(\"Got unexpected exception trying to get lease on {}. {}\",\n+                parentKey, e.getMessage());\n             throw e;\n           } finally {\n             try {\n               if (lease !\u003d null) {\n                 lease.free();\n               }\n             } catch (Exception e) {\n-              LOG.error(\"Unable to free lease on \" + parentKey, e);\n+              LOG.error(\"Unable to free lease on {}\", parentKey, e);\n             }\n           }\n         } else {\n           store.updateFolderLastModifiedTime(parentKey, null);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateParentFolderLastModifiedTime(String key)\n      throws IOException {\n    Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n      String parentKey \u003d pathToKey(parent);\n\n      // ensure the parent is a materialized folder\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      // The metadata could be null if the implicit folder only contains a\n      // single file. In this case, the parent folder no longer exists if the\n      // file is renamed; so we can safely ignore the null pointer case.\n      if (parentMetadata !\u003d null) {\n        if (parentMetadata.isDir()\n            \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n\n        if (store.isAtomicRenameKey(parentKey)) {\n          SelfRenewingLease lease \u003d null;\n          try {\n            lease \u003d leaseSourceFolder(parentKey);\n            store.updateFolderLastModifiedTime(parentKey, lease);\n          } catch (AzureException e) {\n            String errorCode \u003d \"\";\n            try {\n              StorageException e2 \u003d (StorageException) e.getCause();\n              errorCode \u003d e2.getErrorCode();\n            } catch (Exception e3) {\n              // do nothing if cast fails\n            }\n            if (errorCode.equals(\"BlobNotFound\")) {\n              throw new FileNotFoundException(\"Folder does not exist: \" + parentKey);\n            }\n            LOG.warn(\"Got unexpected exception trying to get lease on {}. {}\",\n                parentKey, e.getMessage());\n            throw e;\n          } finally {\n            try {\n              if (lease !\u003d null) {\n                lease.free();\n              }\n            } catch (Exception e) {\n              LOG.error(\"Unable to free lease on {}\", parentKey, e);\n            }\n          }\n        } else {\n          store.updateFolderLastModifiedTime(parentKey, null);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "f2c91098c400da6db0f5e8e49e9bf0e6444af531": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11523. StorageException complaining \" no lease ID\" when updating FolderLastModifiedTime in WASB. Contributed by Duo Xu.\n",
      "commitDate": "29/01/15 5:02 PM",
      "commitName": "f2c91098c400da6db0f5e8e49e9bf0e6444af531",
      "commitAuthor": "cnauroth",
      "commitDateOld": "09/12/14 8:45 PM",
      "commitNameOld": "2e98ad34ce64a9e5184c53447004de20a637f927",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 50.85,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,52 @@\n   private void updateParentFolderLastModifiedTime(String key)\n       throws IOException {\n     Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n       String parentKey \u003d pathToKey(parent);\n \n       // ensure the parent is a materialized folder\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       // The metadata could be null if the implicit folder only contains a\n       // single file. In this case, the parent folder no longer exists if the\n       // file is renamed; so we can safely ignore the null pointer case.\n       if (parentMetadata !\u003d null) {\n         if (parentMetadata.isDir()\n             \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n \n-        store.updateFolderLastModifiedTime(parentKey, null);\n+        if (store.isAtomicRenameKey(parentKey)) {\n+          SelfRenewingLease lease \u003d null;\n+          try {\n+            lease \u003d leaseSourceFolder(parentKey);\n+            store.updateFolderLastModifiedTime(parentKey, lease);\n+          } catch (AzureException e) {\n+            String errorCode \u003d \"\";\n+            try {\n+              StorageException e2 \u003d (StorageException) e.getCause();\n+              errorCode \u003d e2.getErrorCode();\n+            } catch (Exception e3) {\n+              // do nothing if cast fails\n+            }\n+            if (errorCode.equals(\"BlobNotFound\")) {\n+              throw new FileNotFoundException(\"Folder does not exist: \" + parentKey);\n+            }\n+            LOG.warn(\"Got unexpected exception trying to get lease on \"\n+                + parentKey + \". \" + e.getMessage());\n+            throw e;\n+          } finally {\n+            try {\n+              if (lease !\u003d null) {\n+                lease.free();\n+              }\n+            } catch (Exception e) {\n+              LOG.error(\"Unable to free lease on \" + parentKey, e);\n+            }\n+          }\n+        } else {\n+          store.updateFolderLastModifiedTime(parentKey, null);\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateParentFolderLastModifiedTime(String key)\n      throws IOException {\n    Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n      String parentKey \u003d pathToKey(parent);\n\n      // ensure the parent is a materialized folder\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      // The metadata could be null if the implicit folder only contains a\n      // single file. In this case, the parent folder no longer exists if the\n      // file is renamed; so we can safely ignore the null pointer case.\n      if (parentMetadata !\u003d null) {\n        if (parentMetadata.isDir()\n            \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n\n        if (store.isAtomicRenameKey(parentKey)) {\n          SelfRenewingLease lease \u003d null;\n          try {\n            lease \u003d leaseSourceFolder(parentKey);\n            store.updateFolderLastModifiedTime(parentKey, lease);\n          } catch (AzureException e) {\n            String errorCode \u003d \"\";\n            try {\n              StorageException e2 \u003d (StorageException) e.getCause();\n              errorCode \u003d e2.getErrorCode();\n            } catch (Exception e3) {\n              // do nothing if cast fails\n            }\n            if (errorCode.equals(\"BlobNotFound\")) {\n              throw new FileNotFoundException(\"Folder does not exist: \" + parentKey);\n            }\n            LOG.warn(\"Got unexpected exception trying to get lease on \"\n                + parentKey + \". \" + e.getMessage());\n            throw e;\n          } finally {\n            try {\n              if (lease !\u003d null) {\n                lease.free();\n              }\n            } catch (Exception e) {\n              LOG.error(\"Unable to free lease on \" + parentKey, e);\n            }\n          }\n        } else {\n          store.updateFolderLastModifiedTime(parentKey, null);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "diff": "@@ -0,0 +1,22 @@\n+  private void updateParentFolderLastModifiedTime(String key)\n+      throws IOException {\n+    Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n+    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n+      String parentKey \u003d pathToKey(parent);\n+\n+      // ensure the parent is a materialized folder\n+      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+      // The metadata could be null if the implicit folder only contains a\n+      // single file. In this case, the parent folder no longer exists if the\n+      // file is renamed; so we can safely ignore the null pointer case.\n+      if (parentMetadata !\u003d null) {\n+        if (parentMetadata.isDir()\n+            \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+          store.storeEmptyFolder(parentKey,\n+              createPermissionStatus(FsPermission.getDefault()));\n+        }\n+\n+        store.updateFolderLastModifiedTime(parentKey, null);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateParentFolderLastModifiedTime(String key)\n      throws IOException {\n    Path parent \u003d makeAbsolute(keyToPath(key)).getParent();\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n      String parentKey \u003d pathToKey(parent);\n\n      // ensure the parent is a materialized folder\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      // The metadata could be null if the implicit folder only contains a\n      // single file. In this case, the parent folder no longer exists if the\n      // file is renamed; so we can safely ignore the null pointer case.\n      if (parentMetadata !\u003d null) {\n        if (parentMetadata.isDir()\n            \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n\n        store.updateFolderLastModifiedTime(parentKey, null);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}