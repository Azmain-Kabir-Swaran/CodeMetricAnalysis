{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DockerLinuxContainerRuntime.java",
  "functionName": "launchContainer",
  "functionId": "launchContainer___ctx-ContainerRuntimeContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
  "functionStartLine": 584,
  "functionEndLine": 892,
  "numCommitsSeen": 91,
  "timeTaken": 19213,
  "changeHistory": [
    "31e0122f4d4ddc4026470b45d2bf683ece137d44",
    "254efc93588beff6b93fd887ddd43a8e14ea4903",
    "3dc252326693170ac1b31bf2914bae72ca73d31a",
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d",
    "fe7dab8ef55f08cf18c2d62c782c1ab8930a5a15",
    "33e0df4b3558bea4a7977695d2c564af9a0c57e7",
    "d07e873b7db6cb317eccb4768607c1afb505c99b",
    "b237a0dd44ab285941983648d7ef26b99b30d624",
    "73625168c0f29aa646d7a715c9fb15e43d6c7e05",
    "05b2bbeb357d4fa03e71f2bfd5d8eeb0ea6c3f60",
    "8688a0c7f88f2adf1a7fce695e06f3dd1f745080",
    "31998643a51f1e08f723f18dc5476ac1512d5b81",
    "1388de18ad51434569589a8f5b0b05c38fe02ab3",
    "d45a0b7d73519acb78cd94ac3186bd8481f6c13e",
    "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0",
    "502914ca32ac02b19116fd681eb8301b92fccbb3",
    "883f68222a9cfd06f79a8fcd75ec9fef00abc035",
    "85585f9eef26baded5b3ef7fcc3283aa37fc362d",
    "933477e9e0526e2ed81ea454f8806de31981822a",
    "f480367af68e06ed17b8018092c9987a13bb9f63",
    "eb2449d5398e9ac869bc088e10d838a7f13deac0",
    "456705a07c8b80658950acc99f23086244c6b20f",
    "2e5865606b7701ee79d0d297238ab58a07a9f61f",
    "97fe3cc187cb9f773777ca79db6f1c7e4d1d5a68",
    "d42a336cfab106d052aa30d80d9d30904123cb55",
    "d00b6f7c1ff2d7569ae9efdc6823ebcfb86ef2d4",
    "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5",
    "d3b1c6319546706c41a2011ead6c3fe208883200",
    "bfd1a72ba8fbb06da73fede2a85e0b544d6ab43f",
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0",
    "10d7493587643b52cee5fde87eca9ef99c422a70",
    "ac9489f7fc2dd351fbe5be4b7a3add4782da81c3",
    "2054324d471a6152ba34284b4259d4fd09c71704",
    "4a771d9010de0867ac901bead075383ddf1f30dc",
    "e120ee865aa78eaff4a80122c5f3207a97b4924d",
    "74a61438ca01e2191b54000af73b654a2d0b8253",
    "f3eb4c3c738204e099cbaa03471497c46530efbf",
    "08f55ccbb075b90a6e534f4ac0f9840f2e6890d5",
    "525d52bf7c18d1e334e02e6fb936400c9cf2b0bc",
    "522ddbde79cd453cac066b6136f004f54e2123b0",
    "58e18508018081b5b5aa7c12cc5af386146cd26b",
    "dbe97aa768e2987209811c407969fea47641418c",
    "86fb58b7dc832c2df30469d128598a6a1bed8df5",
    "72b047715c1ae89dff3dfe76c1af91dfe255ed70",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c",
    "059caf99891943d9587cac19b48e82efbed06b2d",
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
    "3ddb92bd30d4a267c5c35b410b21c6ea42a7238b",
    "e39ae0e676f77fab216e2281ae946ab8c647733f",
    "63020c54c12dffe03a1b3712759ec65c49df3e64",
    "3e6fce91a471b4a5099de109582e7c6417e8a822"
  ],
  "changeHistoryShort": {
    "31e0122f4d4ddc4026470b45d2bf683ece137d44": "Ybodychange",
    "254efc93588beff6b93fd887ddd43a8e14ea4903": "Ybodychange",
    "3dc252326693170ac1b31bf2914bae72ca73d31a": "Ybodychange",
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d": "Ybodychange",
    "fe7dab8ef55f08cf18c2d62c782c1ab8930a5a15": "Ybodychange",
    "33e0df4b3558bea4a7977695d2c564af9a0c57e7": "Ybodychange",
    "d07e873b7db6cb317eccb4768607c1afb505c99b": "Ybodychange",
    "b237a0dd44ab285941983648d7ef26b99b30d624": "Ybodychange",
    "73625168c0f29aa646d7a715c9fb15e43d6c7e05": "Ybodychange",
    "05b2bbeb357d4fa03e71f2bfd5d8eeb0ea6c3f60": "Ybodychange",
    "8688a0c7f88f2adf1a7fce695e06f3dd1f745080": "Ybodychange",
    "31998643a51f1e08f723f18dc5476ac1512d5b81": "Ybodychange",
    "1388de18ad51434569589a8f5b0b05c38fe02ab3": "Ybodychange",
    "d45a0b7d73519acb78cd94ac3186bd8481f6c13e": "Ybodychange",
    "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0": "Ybodychange",
    "502914ca32ac02b19116fd681eb8301b92fccbb3": "Ybodychange",
    "883f68222a9cfd06f79a8fcd75ec9fef00abc035": "Ybodychange",
    "85585f9eef26baded5b3ef7fcc3283aa37fc362d": "Ybodychange",
    "933477e9e0526e2ed81ea454f8806de31981822a": "Ybodychange",
    "f480367af68e06ed17b8018092c9987a13bb9f63": "Ybodychange",
    "eb2449d5398e9ac869bc088e10d838a7f13deac0": "Ybodychange",
    "456705a07c8b80658950acc99f23086244c6b20f": "Ybodychange",
    "2e5865606b7701ee79d0d297238ab58a07a9f61f": "Ybodychange",
    "97fe3cc187cb9f773777ca79db6f1c7e4d1d5a68": "Ybodychange",
    "d42a336cfab106d052aa30d80d9d30904123cb55": "Ybodychange",
    "d00b6f7c1ff2d7569ae9efdc6823ebcfb86ef2d4": "Ybodychange",
    "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5": "Ybodychange",
    "d3b1c6319546706c41a2011ead6c3fe208883200": "Ybodychange",
    "bfd1a72ba8fbb06da73fede2a85e0b544d6ab43f": "Ybodychange",
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0": "Ybodychange",
    "10d7493587643b52cee5fde87eca9ef99c422a70": "Ybodychange",
    "ac9489f7fc2dd351fbe5be4b7a3add4782da81c3": "Ybodychange",
    "2054324d471a6152ba34284b4259d4fd09c71704": "Ybodychange",
    "4a771d9010de0867ac901bead075383ddf1f30dc": "Ybodychange",
    "e120ee865aa78eaff4a80122c5f3207a97b4924d": "Ybodychange",
    "74a61438ca01e2191b54000af73b654a2d0b8253": "Ybodychange",
    "f3eb4c3c738204e099cbaa03471497c46530efbf": "Ybodychange",
    "08f55ccbb075b90a6e534f4ac0f9840f2e6890d5": "Ybodychange",
    "525d52bf7c18d1e334e02e6fb936400c9cf2b0bc": "Ybodychange",
    "522ddbde79cd453cac066b6136f004f54e2123b0": "Ybodychange",
    "58e18508018081b5b5aa7c12cc5af386146cd26b": "Ybodychange",
    "dbe97aa768e2987209811c407969fea47641418c": "Ybodychange",
    "86fb58b7dc832c2df30469d128598a6a1bed8df5": "Ybodychange",
    "72b047715c1ae89dff3dfe76c1af91dfe255ed70": "Ybodychange",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": "Ybodychange",
    "059caf99891943d9587cac19b48e82efbed06b2d": "Ybodychange",
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2": "Ybodychange",
    "3ddb92bd30d4a267c5c35b410b21c6ea42a7238b": "Ybodychange",
    "e39ae0e676f77fab216e2281ae946ab8c647733f": "Ybodychange",
    "63020c54c12dffe03a1b3712759ec65c49df3e64": "Ybodychange",
    "3e6fce91a471b4a5099de109582e7c6417e8a822": "Yintroduced"
  },
  "changeHistoryDetails": {
    "31e0122f4d4ddc4026470b45d2bf683ece137d44": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9860. Enable service mode for Docker containers on YARN\n           Contributed by Prabhu Joseph and Shane Kumpf\n",
      "commitDate": "10/10/19 4:02 PM",
      "commitName": "31e0122f4d4ddc4026470b45d2bf683ece137d44",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "28/06/19 2:18 PM",
      "commitNameOld": "29465bf169a7e348a4f32265083450faf66d5631",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 104.07,
      "commitsBetweenForRepo": 873,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,292 +1,309 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     String runtime \u003d environment.get(ENV_DOCKER_CONTAINER_DOCKER_RUNTIME);\n-    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n+    boolean serviceMode \u003d Boolean.parseBoolean(environment.get(\n+        ENV_DOCKER_CONTAINER_DOCKER_SERVICE_MODE));\n+    boolean useEntryPoint \u003d serviceMode || checkUseEntryPoint(environment);\n \n     if (imageName \u003d\u003d null || imageName.isEmpty()) {\n       imageName \u003d defaultImageName;\n     }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     validateContainerRuntimeType(runtime);\n \n     if (defaultImageUpdate) {\n       pullImageFromRemote(containerIdStr, imageName);\n     }\n \n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     // Add ports mapping value.\n     if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n       String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n       for (String mapping:portsMapping.split(\",\")) {\n         if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n           throw new ContainerExecutionException(\n               \"Invalid port mappings: \" + mapping);\n         }\n         runCommand.addPortsMapping(mapping);\n       }\n     }\n \n     runCommand.setCapabilities(capabilities);\n     if (runtime !\u003d null \u0026\u0026 !runtime.isEmpty()) {\n       runCommand.addRuntime(runtime);\n     }\n \n-    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n-    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n-    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n-    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n+    if (!serviceMode) {\n+      runCommand.addAllReadWriteMountLocations(containerLogDirs);\n+      runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n+      runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n+      runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n+    }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n         container, container.getCsiVolumesRootDir(), this);\n     try {\n       Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n       volumeMounts.forEach((local, remote) -\u003e\n           runCommand.addReadWriteMountLocation(local, remote));\n     } catch (YarnException | IOException e) {\n       throw new ContainerExecutionException(\n           \"Container requests for volume resource but we are failed\"\n               + \" to publish volumes on this node\");\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n         Boolean.parseBoolean(environment\n             .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n       runCommand.setYarnSysFS(true);\n     }\n \n+    // In service mode, the YARN log dirs are not mounted into the container.\n+    // As a result, the container fails to start due to stdout and stderr output\n+    // being sent to a file in a directory that does not exist. In service mode,\n+    // only supply the command with no stdout or stderr redirection.\n+    List\u003cString\u003e commands \u003d container.getLaunchContext().getCommands();\n+    if (serviceMode) {\n+      commands \u003d Arrays.asList(\n+          String.join(\" \", commands).split(\"1\u003e\")[0].split(\" \"));\n+    }\n+\n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n-      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n-          .getCommands());\n+      runCommand.setOverrideCommandWithArgs(commands);\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n+    if (serviceMode) {\n+      runCommand.setServiceMode(serviceMode);\n+    }\n+\n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to create volume and update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n \n         if (dockerCommandPlugin !\u003d null) {\n           // Create volumes when needed.\n           DockerVolumeCommand dockerVolumeCommand \u003d\n               dockerCommandPlugin.getCreateDockerVolumeCommand(\n                   ctx.getContainer());\n           if (dockerVolumeCommand !\u003d null) {\n             runDockerVolumeCommand(dockerVolumeCommand, container);\n \n             // After volume created, run inspect to make sure volume properly\n             // created.\n             if (dockerVolumeCommand.getSubCommand().equals(\n                 DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n               checkDockerVolumeCreated(dockerVolumeCommand, container);\n             }\n           }\n           // Update cmd\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    String runtime \u003d environment.get(ENV_DOCKER_CONTAINER_DOCKER_RUNTIME);\n    boolean serviceMode \u003d Boolean.parseBoolean(environment.get(\n        ENV_DOCKER_CONTAINER_DOCKER_SERVICE_MODE));\n    boolean useEntryPoint \u003d serviceMode || checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    validateContainerRuntimeType(runtime);\n\n    if (defaultImageUpdate) {\n      pullImageFromRemote(containerIdStr, imageName);\n    }\n\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    // Add ports mapping value.\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n      String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n      for (String mapping:portsMapping.split(\",\")) {\n        if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n          throw new ContainerExecutionException(\n              \"Invalid port mappings: \" + mapping);\n        }\n        runCommand.addPortsMapping(mapping);\n      }\n    }\n\n    runCommand.setCapabilities(capabilities);\n    if (runtime !\u003d null \u0026\u0026 !runtime.isEmpty()) {\n      runCommand.addRuntime(runtime);\n    }\n\n    if (!serviceMode) {\n      runCommand.addAllReadWriteMountLocations(containerLogDirs);\n      runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n      runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n      runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n        container, container.getCsiVolumesRootDir(), this);\n    try {\n      Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n      volumeMounts.forEach((local, remote) -\u003e\n          runCommand.addReadWriteMountLocation(local, remote));\n    } catch (YarnException | IOException e) {\n      throw new ContainerExecutionException(\n          \"Container requests for volume resource but we are failed\"\n              + \" to publish volumes on this node\");\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n        Boolean.parseBoolean(environment\n            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n      runCommand.setYarnSysFS(true);\n    }\n\n    // In service mode, the YARN log dirs are not mounted into the container.\n    // As a result, the container fails to start due to stdout and stderr output\n    // being sent to a file in a directory that does not exist. In service mode,\n    // only supply the command with no stdout or stderr redirection.\n    List\u003cString\u003e commands \u003d container.getLaunchContext().getCommands();\n    if (serviceMode) {\n      commands \u003d Arrays.asList(\n          String.join(\" \", commands).split(\"1\u003e\")[0].split(\" \"));\n    }\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(commands);\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if (serviceMode) {\n      runCommand.setServiceMode(serviceMode);\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to create volume and update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n\n        if (dockerCommandPlugin !\u003d null) {\n          // Create volumes when needed.\n          DockerVolumeCommand dockerVolumeCommand \u003d\n              dockerCommandPlugin.getCreateDockerVolumeCommand(\n                  ctx.getContainer());\n          if (dockerVolumeCommand !\u003d null) {\n            runDockerVolumeCommand(dockerVolumeCommand, container);\n\n            // After volume created, run inspect to make sure volume properly\n            // created.\n            if (dockerVolumeCommand.getSubCommand().equals(\n                DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n              checkDockerVolumeCreated(dockerVolumeCommand, container);\n            }\n          }\n          // Update cmd\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "254efc93588beff6b93fd887ddd43a8e14ea4903": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9379. Can\u0027t specify docker runtime through environment. Contributed by caozhiqiang\n",
      "commitDate": "15/04/19 11:24 AM",
      "commitName": "254efc93588beff6b93fd887ddd43a8e14ea4903",
      "commitAuthor": "Eric Badger",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 30.79,
      "commitsBetweenForRepo": 212,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,286 +1,292 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n+    String runtime \u003d environment.get(ENV_DOCKER_CONTAINER_DOCKER_RUNTIME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if (imageName \u003d\u003d null || imageName.isEmpty()) {\n       imageName \u003d defaultImageName;\n     }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n+    validateContainerRuntimeType(runtime);\n+\n     if (defaultImageUpdate) {\n       pullImageFromRemote(containerIdStr, imageName);\n     }\n \n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     // Add ports mapping value.\n     if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n       String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n       for (String mapping:portsMapping.split(\",\")) {\n         if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n           throw new ContainerExecutionException(\n               \"Invalid port mappings: \" + mapping);\n         }\n         runCommand.addPortsMapping(mapping);\n       }\n     }\n \n     runCommand.setCapabilities(capabilities);\n+    if (runtime !\u003d null \u0026\u0026 !runtime.isEmpty()) {\n+      runCommand.addRuntime(runtime);\n+    }\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n         container, container.getCsiVolumesRootDir(), this);\n     try {\n       Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n       volumeMounts.forEach((local, remote) -\u003e\n           runCommand.addReadWriteMountLocation(local, remote));\n     } catch (YarnException | IOException e) {\n       throw new ContainerExecutionException(\n           \"Container requests for volume resource but we are failed\"\n               + \" to publish volumes on this node\");\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n         Boolean.parseBoolean(environment\n             .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n       runCommand.setYarnSysFS(true);\n     }\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to create volume and update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n \n         if (dockerCommandPlugin !\u003d null) {\n           // Create volumes when needed.\n           DockerVolumeCommand dockerVolumeCommand \u003d\n               dockerCommandPlugin.getCreateDockerVolumeCommand(\n                   ctx.getContainer());\n           if (dockerVolumeCommand !\u003d null) {\n             runDockerVolumeCommand(dockerVolumeCommand, container);\n \n             // After volume created, run inspect to make sure volume properly\n             // created.\n             if (dockerVolumeCommand.getSubCommand().equals(\n                 DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n               checkDockerVolumeCreated(dockerVolumeCommand, container);\n             }\n           }\n           // Update cmd\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    String runtime \u003d environment.get(ENV_DOCKER_CONTAINER_DOCKER_RUNTIME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    validateContainerRuntimeType(runtime);\n\n    if (defaultImageUpdate) {\n      pullImageFromRemote(containerIdStr, imageName);\n    }\n\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    // Add ports mapping value.\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n      String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n      for (String mapping:portsMapping.split(\",\")) {\n        if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n          throw new ContainerExecutionException(\n              \"Invalid port mappings: \" + mapping);\n        }\n        runCommand.addPortsMapping(mapping);\n      }\n    }\n\n    runCommand.setCapabilities(capabilities);\n    if (runtime !\u003d null \u0026\u0026 !runtime.isEmpty()) {\n      runCommand.addRuntime(runtime);\n    }\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n        container, container.getCsiVolumesRootDir(), this);\n    try {\n      Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n      volumeMounts.forEach((local, remote) -\u003e\n          runCommand.addReadWriteMountLocation(local, remote));\n    } catch (YarnException | IOException e) {\n      throw new ContainerExecutionException(\n          \"Container requests for volume resource but we are failed\"\n              + \" to publish volumes on this node\");\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n        Boolean.parseBoolean(environment\n            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n      runCommand.setYarnSysFS(true);\n    }\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to create volume and update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n\n        if (dockerCommandPlugin !\u003d null) {\n          // Create volumes when needed.\n          DockerVolumeCommand dockerVolumeCommand \u003d\n              dockerCommandPlugin.getCreateDockerVolumeCommand(\n                  ctx.getContainer());\n          if (dockerVolumeCommand !\u003d null) {\n            runDockerVolumeCommand(dockerVolumeCommand, container);\n\n            // After volume created, run inspect to make sure volume properly\n            // created.\n            if (dockerVolumeCommand.getSubCommand().equals(\n                DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n              checkDockerVolumeCreated(dockerVolumeCommand, container);\n            }\n          }\n          // Update cmd\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "3dc252326693170ac1b31bf2914bae72ca73d31a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9184. Add a system flag to allow update to latest docker images.\n           Contributed by Zhaohui Xin\n",
      "commitDate": "12/02/19 1:16 PM",
      "commitName": "3dc252326693170ac1b31bf2914bae72ca73d31a",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "03/01/19 10:40 PM",
      "commitNameOld": "f4906ac01960c78ff0c91797eaa4b36d80f6826d",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 39.61,
      "commitsBetweenForRepo": 281,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,282 +1,286 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n+    String containerIdStr \u003d containerId.toString();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if (imageName \u003d\u003d null || imageName.isEmpty()) {\n       imageName \u003d defaultImageName;\n     }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n-    String containerIdStr \u003d containerId.toString();\n+    if (defaultImageUpdate) {\n+      pullImageFromRemote(containerIdStr, imageName);\n+    }\n+\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     // Add ports mapping value.\n     if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n       String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n       for (String mapping:portsMapping.split(\",\")) {\n         if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n           throw new ContainerExecutionException(\n               \"Invalid port mappings: \" + mapping);\n         }\n         runCommand.addPortsMapping(mapping);\n       }\n     }\n \n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n         container, container.getCsiVolumesRootDir(), this);\n     try {\n       Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n       volumeMounts.forEach((local, remote) -\u003e\n           runCommand.addReadWriteMountLocation(local, remote));\n     } catch (YarnException | IOException e) {\n       throw new ContainerExecutionException(\n           \"Container requests for volume resource but we are failed\"\n               + \" to publish volumes on this node\");\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n         Boolean.parseBoolean(environment\n             .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n       runCommand.setYarnSysFS(true);\n     }\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to create volume and update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n \n         if (dockerCommandPlugin !\u003d null) {\n           // Create volumes when needed.\n           DockerVolumeCommand dockerVolumeCommand \u003d\n               dockerCommandPlugin.getCreateDockerVolumeCommand(\n                   ctx.getContainer());\n           if (dockerVolumeCommand !\u003d null) {\n             runDockerVolumeCommand(dockerVolumeCommand, container);\n \n             // After volume created, run inspect to make sure volume properly\n             // created.\n             if (dockerVolumeCommand.getSubCommand().equals(\n                 DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n               checkDockerVolumeCreated(dockerVolumeCommand, container);\n             }\n           }\n           // Update cmd\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    if (defaultImageUpdate) {\n      pullImageFromRemote(containerIdStr, imageName);\n    }\n\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    // Add ports mapping value.\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n      String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n      for (String mapping:portsMapping.split(\",\")) {\n        if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n          throw new ContainerExecutionException(\n              \"Invalid port mappings: \" + mapping);\n        }\n        runCommand.addPortsMapping(mapping);\n      }\n    }\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n        container, container.getCsiVolumesRootDir(), this);\n    try {\n      Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n      volumeMounts.forEach((local, remote) -\u003e\n          runCommand.addReadWriteMountLocation(local, remote));\n    } catch (YarnException | IOException e) {\n      throw new ContainerExecutionException(\n          \"Container requests for volume resource but we are failed\"\n              + \" to publish volumes on this node\");\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n        Boolean.parseBoolean(environment\n            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n      runCommand.setYarnSysFS(true);\n    }\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to create volume and update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n\n        if (dockerCommandPlugin !\u003d null) {\n          // Create volumes when needed.\n          DockerVolumeCommand dockerVolumeCommand \u003d\n              dockerCommandPlugin.getCreateDockerVolumeCommand(\n                  ctx.getContainer());\n          if (dockerVolumeCommand !\u003d null) {\n            runDockerVolumeCommand(dockerVolumeCommand, container);\n\n            // After volume created, run inspect to make sure volume properly\n            // created.\n            if (dockerVolumeCommand.getSubCommand().equals(\n                DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n              checkDockerVolumeCreated(dockerVolumeCommand, container);\n            }\n          }\n          // Update cmd\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9038. [CSI] Add ability to publish/unpublish volumes on node managers. Contributed by Weiwei Yang.\n",
      "commitDate": "03/01/19 10:40 PM",
      "commitName": "f4906ac01960c78ff0c91797eaa4b36d80f6826d",
      "commitAuthor": "Sunil G",
      "commitDateOld": "21/12/18 4:44 PM",
      "commitNameOld": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 13.25,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,270 +1,282 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if (imageName \u003d\u003d null || imageName.isEmpty()) {\n       imageName \u003d defaultImageName;\n     }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     // Add ports mapping value.\n     if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n       String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n       for (String mapping:portsMapping.split(\",\")) {\n         if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n           throw new ContainerExecutionException(\n               \"Invalid port mappings: \" + mapping);\n         }\n         runCommand.addPortsMapping(mapping);\n       }\n     }\n \n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n+    ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n+        container, container.getCsiVolumesRootDir(), this);\n+    try {\n+      Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n+      volumeMounts.forEach((local, remote) -\u003e\n+          runCommand.addReadWriteMountLocation(local, remote));\n+    } catch (YarnException | IOException e) {\n+      throw new ContainerExecutionException(\n+          \"Container requests for volume resource but we are failed\"\n+              + \" to publish volumes on this node\");\n+    }\n+\n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n         Boolean.parseBoolean(environment\n             .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n       runCommand.setYarnSysFS(true);\n     }\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to create volume and update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n \n         if (dockerCommandPlugin !\u003d null) {\n           // Create volumes when needed.\n           DockerVolumeCommand dockerVolumeCommand \u003d\n               dockerCommandPlugin.getCreateDockerVolumeCommand(\n                   ctx.getContainer());\n           if (dockerVolumeCommand !\u003d null) {\n             runDockerVolumeCommand(dockerVolumeCommand, container);\n \n             // After volume created, run inspect to make sure volume properly\n             // created.\n             if (dockerVolumeCommand.getSubCommand().equals(\n                 DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n               checkDockerVolumeCreated(dockerVolumeCommand, container);\n             }\n           }\n           // Update cmd\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    // Add ports mapping value.\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n      String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n      for (String mapping:portsMapping.split(\",\")) {\n        if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n          throw new ContainerExecutionException(\n              \"Invalid port mappings: \" + mapping);\n        }\n        runCommand.addPortsMapping(mapping);\n      }\n    }\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    ContainerVolumePublisher publisher \u003d new ContainerVolumePublisher(\n        container, container.getCsiVolumesRootDir(), this);\n    try {\n      Map\u003cString, String\u003e volumeMounts \u003d publisher.publishVolumes();\n      volumeMounts.forEach((local, remote) -\u003e\n          runCommand.addReadWriteMountLocation(local, remote));\n    } catch (YarnException | IOException e) {\n      throw new ContainerExecutionException(\n          \"Container requests for volume resource but we are failed\"\n              + \" to publish volumes on this node\");\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n        Boolean.parseBoolean(environment\n            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n      runCommand.setYarnSysFS(true);\n    }\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to create volume and update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n\n        if (dockerCommandPlugin !\u003d null) {\n          // Create volumes when needed.\n          DockerVolumeCommand dockerVolumeCommand \u003d\n              dockerCommandPlugin.getCreateDockerVolumeCommand(\n                  ctx.getContainer());\n          if (dockerVolumeCommand !\u003d null) {\n            runDockerVolumeCommand(dockerVolumeCommand, container);\n\n            // After volume created, run inspect to make sure volume properly\n            // created.\n            if (dockerVolumeCommand.getSubCommand().equals(\n                DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n              checkDockerVolumeCreated(dockerVolumeCommand, container);\n            }\n          }\n          // Update cmd\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "fe7dab8ef55f08cf18c2d62c782c1ab8930a5a15": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8989. [YARN-8851] Move DockerCommandPlugin volume related APIs\u0027 invocation from DockerLinuxContainerRuntime#prepareContainer to #launchContainer. (Zhankun Tang via wangda)\n\nChange-Id: Ia6d532c687168448416dfdf46f0ac34bff20e6ca\n",
      "commitDate": "28/11/18 3:03 PM",
      "commitName": "fe7dab8ef55f08cf18c2d62c782c1ab8930a5a15",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/11/18 4:45 PM",
      "commitNameOld": "33e0df4b3558bea4a7977695d2c564af9a0c57e7",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 1.93,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,254 +1,270 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if (imageName \u003d\u003d null || imageName.isEmpty()) {\n       imageName \u003d defaultImageName;\n     }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     // Add ports mapping value.\n     if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n       String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n       for (String mapping:portsMapping.split(\",\")) {\n         if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n           throw new ContainerExecutionException(\n               \"Invalid port mappings: \" + mapping);\n         }\n         runCommand.addPortsMapping(mapping);\n       }\n     }\n \n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n         Boolean.parseBoolean(environment\n             .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n       runCommand.setYarnSysFS(true);\n     }\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n-    // use plugins to update docker run command.\n+    // use plugins to create volume and update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n+\n         if (dockerCommandPlugin !\u003d null) {\n+          // Create volumes when needed.\n+          DockerVolumeCommand dockerVolumeCommand \u003d\n+              dockerCommandPlugin.getCreateDockerVolumeCommand(\n+                  ctx.getContainer());\n+          if (dockerVolumeCommand !\u003d null) {\n+            runDockerVolumeCommand(dockerVolumeCommand, container);\n+\n+            // After volume created, run inspect to make sure volume properly\n+            // created.\n+            if (dockerVolumeCommand.getSubCommand().equals(\n+                DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n+              checkDockerVolumeCreated(dockerVolumeCommand, container);\n+            }\n+          }\n+          // Update cmd\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    // Add ports mapping value.\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n      String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n      for (String mapping:portsMapping.split(\",\")) {\n        if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n          throw new ContainerExecutionException(\n              \"Invalid port mappings: \" + mapping);\n        }\n        runCommand.addPortsMapping(mapping);\n      }\n    }\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n        Boolean.parseBoolean(environment\n            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n      runCommand.setYarnSysFS(true);\n    }\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to create volume and update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n\n        if (dockerCommandPlugin !\u003d null) {\n          // Create volumes when needed.\n          DockerVolumeCommand dockerVolumeCommand \u003d\n              dockerCommandPlugin.getCreateDockerVolumeCommand(\n                  ctx.getContainer());\n          if (dockerVolumeCommand !\u003d null) {\n            runDockerVolumeCommand(dockerVolumeCommand, container);\n\n            // After volume created, run inspect to make sure volume properly\n            // created.\n            if (dockerVolumeCommand.getSubCommand().equals(\n                DockerVolumeCommand.VOLUME_CREATE_SUB_COMMAND)) {\n              checkDockerVolumeCreated(dockerVolumeCommand, container);\n            }\n          }\n          // Update cmd\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "33e0df4b3558bea4a7977695d2c564af9a0c57e7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8986. Added port publish for Docker container running with bridge network.\n           Contributed by Charo Zhang\n",
      "commitDate": "26/11/18 4:45 PM",
      "commitName": "33e0df4b3558bea4a7977695d2c564af9a0c57e7",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "12/11/18 10:42 AM",
      "commitNameOld": "1f9c4f32e842529be5980e395587f135452372bb",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 14.25,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,242 +1,254 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if (imageName \u003d\u003d null || imageName.isEmpty()) {\n       imageName \u003d defaultImageName;\n     }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n+    // Add ports mapping value.\n+    if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n+      String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n+      for (String mapping:portsMapping.split(\",\")) {\n+        if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n+          throw new ContainerExecutionException(\n+              \"Invalid port mappings: \" + mapping);\n+        }\n+        runCommand.addPortsMapping(mapping);\n+      }\n+    }\n+\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n         Boolean.parseBoolean(environment\n             .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n       runCommand.setYarnSysFS(true);\n     }\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    // Add ports mapping value.\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_PORTS_MAPPING)) {\n      String portsMapping \u003d environment.get(ENV_DOCKER_CONTAINER_PORTS_MAPPING);\n      for (String mapping:portsMapping.split(\",\")) {\n        if (!Pattern.matches(PORTS_MAPPING_PATTERN, mapping)) {\n          throw new ContainerExecutionException(\n              \"Invalid port mappings: \" + mapping);\n        }\n        runCommand.addPortsMapping(mapping);\n      }\n    }\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n        Boolean.parseBoolean(environment\n            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n      runCommand.setYarnSysFS(true);\n    }\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "d07e873b7db6cb317eccb4768607c1afb505c99b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8569. Create an interface to provide cluster information to application. Contributed by Eric Yang\n",
      "commitDate": "26/10/18 5:57 PM",
      "commitName": "d07e873b7db6cb317eccb4768607c1afb505c99b",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "19/10/18 9:49 AM",
      "commitNameOld": "5e02b4915b876eab943b30cf728cfc26ba832188",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 7.34,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,236 +1,242 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if (imageName \u003d\u003d null || imageName.isEmpty()) {\n       imageName \u003d defaultImageName;\n     }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n+    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n+        Boolean.parseBoolean(environment\n+            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n+      runCommand.setYarnSysFS(true);\n+    }\n+\n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if(environment.containsKey(ENV_DOCKER_CONTAINER_YARN_SYSFS) \u0026\u0026\n        Boolean.parseBoolean(environment\n            .get(ENV_DOCKER_CONTAINER_YARN_SYSFS))) {\n      runCommand.setYarnSysFS(true);\n    }\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "b237a0dd44ab285941983648d7ef26b99b30d624": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6456.  Added config to set default container runtimes.\n            Contributed by Craig Condit\n",
      "commitDate": "27/09/18 12:31 PM",
      "commitName": "b237a0dd44ab285941983648d7ef26b99b30d624",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "19/09/18 10:16 AM",
      "commitNameOld": "efdea85ad1cd4cc5a2a306898dbdb2c14b952d02",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.09,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,233 +1,236 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n+    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n+      imageName \u003d defaultImageName;\n+    }\n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n       String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n           .split(\",\");\n       for (String mount : tmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n       for (String mount : defaultTmpfsMounts) {\n         if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n           throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n               mount);\n         }\n         runCommand.addTmpfsMount(mount);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if (imageName \u003d\u003d null || imageName.isEmpty()) {\n      imageName \u003d defaultImageName;\n    }\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "73625168c0f29aa646d7a715c9fb15e43d6c7e05": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8642. Add support for tmpfs mounts with the Docker runtime. Contributed by Craig Condit\n",
      "commitDate": "29/08/18 6:08 AM",
      "commitName": "73625168c0f29aa646d7a715c9fb15e43d6c7e05",
      "commitAuthor": "Shane Kumpf",
      "commitDateOld": "27/08/18 11:34 AM",
      "commitNameOld": "05b2bbeb357d4fa03e71f2bfd5d8eeb0ea6c3f60",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 1.77,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,211 +1,233 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n \n     setHostname(runCommand, containerIdStr, network, hostname);\n \n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n+    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n+      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n+          .split(\",\");\n+      for (String mount : tmpfsMounts) {\n+        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n+          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n+              mount);\n+        }\n+        runCommand.addTmpfsMount(mount);\n+      }\n+    }\n+\n+    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n+      for (String mount : defaultTmpfsMounts) {\n+        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n+          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n+              mount);\n+        }\n+        runCommand.addTmpfsMount(mount);\n+      }\n+    }\n+\n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)) {\n      String[] tmpfsMounts \u003d environment.get(ENV_DOCKER_CONTAINER_TMPFS_MOUNTS)\n          .split(\",\");\n      for (String mount : tmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (defaultTmpfsMounts !\u003d null \u0026\u0026 !defaultTmpfsMounts.isEmpty()) {\n      for (String mount : defaultTmpfsMounts) {\n        if (!TMPFS_MOUNT_PATTERN.matcher(mount).matches()) {\n          throw new ContainerExecutionException(\"Invalid tmpfs mount : \" +\n              mount);\n        }\n        runCommand.addTmpfsMount(mount);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "05b2bbeb357d4fa03e71f2bfd5d8eeb0ea6c3f60": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8675. Remove default hostname for docker containers when net\u003dhost. Contributed by Suma Shivaprasad\n",
      "commitDate": "27/08/18 11:34 AM",
      "commitName": "05b2bbeb357d4fa03e71f2bfd5d8eeb0ea6c3f60",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "16/08/18 8:06 AM",
      "commitNameOld": "cb21eaa026d80a2c9836030d959c0dd7f87c4d6b",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 11.14,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,214 +1,211 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n-    // Only add hostname if network is not host or if Registry DNS is enabled.\n-    if (!network.equalsIgnoreCase(\"host\") ||\n-        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n-            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n-      setHostname(runCommand, containerIdStr, hostname);\n-    }\n+\n+    setHostname(runCommand, containerIdStr, network, hostname);\n+\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n         mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(4);\n         if (mode \u003d\u003d null) {\n           mode \u003d \"rw\";\n         } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n           mode \u003d \"rw+\" + mode;\n         }\n         runCommand.addMountLocation(src, dst, mode);\n       }\n       long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n           .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n       if (mountCount !\u003d commaCount + 1) {\n         // this means the matcher skipped an improperly formatted mount\n         throw new ContainerExecutionException(\n             \"Unable to parse some mounts in user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n\n    setHostname(runCommand, containerIdStr, network, hostname);\n\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "8688a0c7f88f2adf1a7fce695e06f3dd1f745080": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8380.  Support bind propagation options for mounts in docker runtime.\n            Contributed by Billie Rinaldi\n",
      "commitDate": "23/07/18 5:12 PM",
      "commitName": "8688a0c7f88f2adf1a7fce695e06f3dd1f745080",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "02/07/18 10:37 AM",
      "commitNameOld": "5cc2541a163591181b80bf2ec42c1e7e7f8929f5",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 21.27,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,208 +1,214 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n+      long mountCount \u003d 0;\n       while (parsedMounts.find()) {\n+        mountCount++;\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n-        String mode \u003d parsedMounts.group(3);\n-        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n-          throw new ContainerExecutionException(\n-              \"Invalid mount mode requested for mount: \"\n-                  + parsedMounts.group());\n+        String mode \u003d parsedMounts.group(4);\n+        if (mode \u003d\u003d null) {\n+          mode \u003d \"rw\";\n+        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n+          mode \u003d \"rw+\" + mode;\n         }\n-        if (mode.equals(\"ro\")) {\n-          runCommand.addReadOnlyMountLocation(src, dst);\n-        } else {\n-          runCommand.addReadWriteMountLocation(src, dst);\n-        }\n+        runCommand.addMountLocation(src, dst, mode);\n+      }\n+      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n+          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n+      if (mountCount !\u003d commaCount + 1) {\n+        // this means the matcher skipped an improperly formatted mount\n+        throw new ContainerExecutionException(\n+            \"Unable to parse some mounts in user supplied mount list: \"\n+                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      long mountCount \u003d 0;\n      while (parsedMounts.find()) {\n        mountCount++;\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(4);\n        if (mode \u003d\u003d null) {\n          mode \u003d \"rw\";\n        } else if (!mode.startsWith(\"ro\") \u0026\u0026 !mode.startsWith(\"rw\")) {\n          mode \u003d \"rw+\" + mode;\n        }\n        runCommand.addMountLocation(src, dst, mode);\n      }\n      long commaCount \u003d environment.get(ENV_DOCKER_CONTAINER_MOUNTS).chars()\n          .filter(c -\u003e c \u003d\u003d \u0027,\u0027).count();\n      if (mountCount !\u003d commaCount + 1) {\n        // this means the matcher skipped an improperly formatted mount\n        throw new ContainerExecutionException(\n            \"Unable to parse some mounts in user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "31998643a51f1e08f723f18dc5476ac1512d5b81": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8342. Enable untrusted docker image to run with launch command. Contributed by Eric Yang\n",
      "commitDate": "02/06/18 2:46 PM",
      "commitName": "31998643a51f1e08f723f18dc5476ac1512d5b81",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "29/05/18 12:43 PM",
      "commitNameOld": "4827e9a9085b306bc379cb6e0b1fe4b92326edcd",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,209 +1,208 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n-    boolean useEntryPoint \u003d Boolean.parseBoolean(environment\n-              .get(ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE));\n+    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n       for (String mount : defaultROMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadOnlyMountLocation(src, dst);\n       }\n     }\n \n     if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n       for (String mount : defaultRWMounts) {\n         String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n         if (dir.length !\u003d 2) {\n           throw new ContainerExecutionException(\"Invalid mount : \" +\n               mount);\n         }\n         String src \u003d dir[0];\n         String dst \u003d dir[1];\n         runCommand.addReadWriteMountLocation(src, dst);\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d checkUseEntryPoint(environment);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "1388de18ad51434569589a8f5b0b05c38fe02ab3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6919. Add default volume mount list. Contributed by Eric Badger\n",
      "commitDate": "24/05/18 8:30 AM",
      "commitName": "1388de18ad51434569589a8f5b0b05c38fe02ab3",
      "commitAuthor": "Shane Kumpf",
      "commitDateOld": "23/05/18 5:43 AM",
      "commitNameOld": "9837ca9cc746573571029f9fb996a1be10b588ab",
      "commitAuthorOld": "Shane Kumpf",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,183 +1,209 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d Boolean.parseBoolean(environment\n               .get(ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE));\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n         if (!srcPath.isAbsolute()) {\n           src \u003d mountReadOnlyPath(src, localizedResources);\n         }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n+    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n+      for (String mount : defaultROMounts) {\n+        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n+        if (dir.length !\u003d 2) {\n+          throw new ContainerExecutionException(\"Invalid mount : \" +\n+              mount);\n+        }\n+        String src \u003d dir[0];\n+        String dst \u003d dir[1];\n+        runCommand.addReadOnlyMountLocation(src, dst);\n+      }\n+    }\n+\n+    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n+      for (String mount : defaultRWMounts) {\n+        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n+        if (dir.length !\u003d 2) {\n+          throw new ContainerExecutionException(\"Invalid mount : \" +\n+              mount);\n+        }\n+        String src \u003d dir[0];\n+        String dst \u003d dir[1];\n+        runCommand.addReadWriteMountLocation(src, dst);\n+      }\n+    }\n+\n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d Boolean.parseBoolean(environment\n              .get(ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE));\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if(defaultROMounts !\u003d null \u0026\u0026 !defaultROMounts.isEmpty()) {\n      for (String mount : defaultROMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadOnlyMountLocation(src, dst);\n      }\n    }\n\n    if(defaultRWMounts !\u003d null \u0026\u0026 !defaultRWMounts.isEmpty()) {\n      for (String mount : defaultRWMounts) {\n        String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n        if (dir.length !\u003d 2) {\n          throw new ContainerExecutionException(\"Invalid mount : \" +\n              mount);\n        }\n        String src \u003d dir[0];\n        String dst \u003d dir[1];\n        runCommand.addReadWriteMountLocation(src, dst);\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "d45a0b7d73519acb78cd94ac3186bd8481f6c13e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8141.  Removed YARN_CONTAINER_RUNTIME_DOCKER_LOCAL_RESOURCE_MOUNTS flag.\n            Contributed by Chandni Singh\n",
      "commitDate": "17/05/18 2:29 PM",
      "commitName": "d45a0b7d73519acb78cd94ac3186bd8481f6c13e",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "11/05/18 4:56 PM",
      "commitNameOld": "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,183 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n     boolean useEntryPoint \u003d Boolean.parseBoolean(environment\n               .get(ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE));\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n-    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n-      String mounts \u003d environment.get(\n-          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n-      if (!mounts.isEmpty()) {\n-        for (String mount : StringUtils.split(mounts)) {\n-          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n-          if (dir.length !\u003d 2) {\n-            throw new ContainerExecutionException(\"Invalid mount : \" +\n-                mount);\n-          }\n-          String src \u003d validateMount(dir[0], localizedResources);\n-          String dst \u003d dir[1];\n-          runCommand.addReadOnlyMountLocation(src, dst, true);\n-        }\n-      }\n-    }\n-\n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n+        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n+        if (!srcPath.isAbsolute()) {\n+          src \u003d mountReadOnlyPath(src, localizedResources);\n+        }\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     if (useEntryPoint) {\n       runCommand.setOverrideDisabled(true);\n       runCommand.addEnv(environment);\n       runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n           .getCommands());\n       runCommand.disableDetach();\n       runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n       runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d Boolean.parseBoolean(environment\n              .get(ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE));\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        java.nio.file.Path srcPath \u003d java.nio.file.Paths.get(src);\n        if (!srcPath.isAbsolute()) {\n          src \u003d mountReadOnlyPath(src, localizedResources);\n        }\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7654. Support ENTRY_POINT for docker container. Contributed by Eric Yang\n",
      "commitDate": "11/05/18 4:56 PM",
      "commitName": "6c8e51ca7eaaeef0626658b3c45d446a537e4dc0",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "04/05/18 8:53 AM",
      "commitNameOld": "502914ca32ac02b19116fd681eb8301b92fccbb3",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 7.33,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,196 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n+    boolean useEntryPoint \u003d Boolean.parseBoolean(environment\n+              .get(ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE));\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n-        .detachOnRun()\n-        .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n-    String disableOverride \u003d environment.get(\n-        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n-\n-    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n-      LOG.info(\"command override disabled\");\n+    if (useEntryPoint) {\n+      runCommand.setOverrideDisabled(true);\n+      runCommand.addEnv(environment);\n+      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n+          .getCommands());\n+      runCommand.disableDetach();\n+      runCommand.setLogDir(container.getLogDir());\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n-\n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n+      runCommand.setContainerWorkDir(containerWorkDir.toString());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n+      runCommand.detachOnRun();\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n    boolean useEntryPoint \u003d Boolean.parseBoolean(environment\n              .get(ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE));\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    if (useEntryPoint) {\n      runCommand.setOverrideDisabled(true);\n      runCommand.addEnv(environment);\n      runCommand.setOverrideCommandWithArgs(container.getLaunchContext()\n          .getCommands());\n      runCommand.disableDetach();\n      runCommand.setLogDir(container.getLogDir());\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setContainerWorkDir(containerWorkDir.toString());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n      runCommand.detachOnRun();\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "502914ca32ac02b19116fd681eb8301b92fccbb3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7818. Remove privileged operation warnings during container launch for the ContainerRuntimes. Contributed by Shane Kumpf\n",
      "commitDate": "04/05/18 8:53 AM",
      "commitName": "502914ca32ac02b19116fd681eb8301b92fccbb3",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "02/05/18 11:33 AM",
      "commitNameOld": "883f68222a9cfd06f79a8fcd75ec9fef00abc035",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 1.89,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,193 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n+    // Some failures here are acceptable. Let the calling executor decide.\n+    launchOp.disableFailureLogging();\n+\n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n-      LOG.warn(\"Launch container failed. Exception: \", e);\n-      LOG.info(\"Docker command used: \" + runCommand);\n-\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "883f68222a9cfd06f79a8fcd75ec9fef00abc035": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8209.  Fixed NPE in Yarn Service deletion.\n            Contributed by Eric Badger\n",
      "commitDate": "02/05/18 11:33 AM",
      "commitName": "883f68222a9cfd06f79a8fcd75ec9fef00abc035",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "30/04/18 4:12 PM",
      "commitNameOld": "a966ec6e23b3ac8e233b2cf9b9ddaa6628a8c996",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 1.81,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,192 +1,193 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n+    ContainerId containerId \u003d container.getContainerId();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n-    String containerIdStr \u003d container.getContainerId().toString();\n+    String containerIdStr \u003d containerId.toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n-        container, nmContext);\n+        containerId, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d containerId.toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerId, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "85585f9eef26baded5b3ef7fcc3283aa37fc362d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8064.  Bugfix for clean up container-executor cmd helper file.\n            Contributed by Eric Badger\n",
      "commitDate": "20/04/18 10:49 AM",
      "commitName": "85585f9eef26baded5b3ef7fcc3283aa37fc362d",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "11/04/18 11:24 AM",
      "commitNameOld": "933477e9e0526e2ed81ea454f8806de31981822a",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 8.98,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,192 +1,192 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       if (!allowPrivilegedContainerExecution(container)) {\n         dockerRunAsUser \u003d uid + \":\" + gid;\n       } else {\n         dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n       }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       if (!allowPrivilegedContainerExecution(container)) {\n         runCommand.groupAdd(groups);\n       }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n-        containerIdStr);\n+        container, nmContext);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        container, nmContext);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "933477e9e0526e2ed81ea454f8806de31981822a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7221. Add security check for privileged docker container. Contributed by Eric Yang\n",
      "commitDate": "11/04/18 11:24 AM",
      "commitName": "933477e9e0526e2ed81ea454f8806de31981822a",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "10/04/18 4:25 PM",
      "commitNameOld": "c467f311d0c7155c09052d93fac12045af925583",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,186 +1,192 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n-      dockerRunAsUser \u003d uid + \":\" + gid;\n+      if (!allowPrivilegedContainerExecution(container)) {\n+        dockerRunAsUser \u003d uid + \":\" + gid;\n+      } else {\n+        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n+      }\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     // Only add hostname if network is not host or if Registry DNS is enabled.\n     if (!network.equalsIgnoreCase(\"host\") ||\n         conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n             RegistryConstants.DEFAULT_DNS_ENABLED)) {\n       setHostname(runCommand, containerIdStr, hostname);\n     }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n-      runCommand.groupAdd(groups);\n+      if (!allowPrivilegedContainerExecution(container)) {\n+        runCommand.groupAdd(groups);\n+      }\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      if (!allowPrivilegedContainerExecution(container)) {\n        dockerRunAsUser \u003d uid + \":\" + gid;\n      } else {\n        dockerRunAsUser \u003d ctx.getExecutionAttribute(USER);\n      }\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      if (!allowPrivilegedContainerExecution(container)) {\n        runCommand.groupAdd(groups);\n      }\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "f480367af68e06ed17b8018092c9987a13bb9f63": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8027. Setting hostname of docker container breaks for --net\u003dhost in docker 1.13. Contributed by Jim Brennan\n",
      "commitDate": "19/03/18 2:59 PM",
      "commitName": "f480367af68e06ed17b8018092c9987a13bb9f63",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "07/03/18 7:20 AM",
      "commitNameOld": "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 12.28,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,181 +1,186 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n-    setHostname(runCommand, containerIdStr, hostname);\n+    // Only add hostname if network is not host or if Registry DNS is enabled.\n+    if (!network.equalsIgnoreCase(\"host\") ||\n+        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n+            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n+      setHostname(runCommand, containerIdStr, hostname);\n+    }\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     addDockerClientConfigToRunCommand(ctx, runCommand);\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    // Only add hostname if network is not host or if Registry DNS is enabled.\n    if (!network.equalsIgnoreCase(\"host\") ||\n        conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n            RegistryConstants.DEFAULT_DNS_ENABLED)) {\n      setHostname(runCommand, containerIdStr, hostname);\n    }\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "eb2449d5398e9ac869bc088e10d838a7f13deac0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5428. Allow for specifying the docker client configuration directory. Contributed by Shane Kumpf\n",
      "commitDate": "08/02/18 11:35 AM",
      "commitName": "eb2449d5398e9ac869bc088e10d838a7f13deac0",
      "commitAuthor": "Jian He",
      "commitDateOld": "07/02/18 11:09 AM",
      "commitNameOld": "456705a07c8b80658950acc99f23086244c6b20f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,181 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userFilecacheDirs \u003d\n         ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e applicationLocalDirs \u003d\n         ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     runCommand.addAllReadWriteMountLocations(containerLogDirs);\n     runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n     runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n     runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n+    addDockerClientConfigToRunCommand(ctx, runCommand);\n+\n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    addDockerClientConfigToRunCommand(ctx, runCommand);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "456705a07c8b80658950acc99f23086244c6b20f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7815. Make the YARN mounts added to Docker containers more restrictive. Contributed by Shane Kumpf\n",
      "commitDate": "07/02/18 11:09 AM",
      "commitName": "456705a07c8b80658950acc99f23086244c6b20f",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "01/02/18 10:14 AM",
      "commitNameOld": "682ea21f2bbc587e1b727b3c895c2f513a908432",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.04,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,182 +1,179 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n-    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n-        CONTAINER_LOCAL_DIRS);\n-    @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e userFilecacheDirs \u003d\n+        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e applicationLocalDirs \u003d\n+        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n-    @SuppressWarnings(\"unchecked\")\n-    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n-    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n-    allDirs.addAll(filecacheDirs);\n-    allDirs.add(containerWorkDir.toString());\n-    allDirs.addAll(containerLogDirs);\n-    allDirs.addAll(userLocalDirs);\n-    for (String dir: allDirs) {\n-      runCommand.addMountLocation(dir, dir, true);\n-    }\n+    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n+    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n+    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n+    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userFilecacheDirs \u003d\n        ctx.getExecutionAttribute(USER_FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e applicationLocalDirs \u003d\n        ctx.getExecutionAttribute(APPLICATION_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    runCommand.addAllReadWriteMountLocations(containerLogDirs);\n    runCommand.addAllReadWriteMountLocations(applicationLocalDirs);\n    runCommand.addAllReadOnlyMountLocations(filecacheDirs);\n    runCommand.addAllReadOnlyMountLocations(userFilecacheDirs);\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "2e5865606b7701ee79d0d297238ab58a07a9f61f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7814. Remove automatic mounting of the cgroups root directory into Docker containers. Contributed by Shane Kumpf.\n",
      "commitDate": "25/01/18 5:37 PM",
      "commitName": "2e5865606b7701ee79d0d297238ab58a07a9f61f",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "22/01/18 1:33 PM",
      "commitNameOld": "97fe3cc187cb9f773777ca79db6f1c7e4d1d5a68",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 3.17,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,182 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n-    if(cgroupsRootDirectory !\u003d null) {\n-      runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n-          cgroupsRootDirectory, false);\n-    }\n-\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n     if (allowHostPidNamespace(container)) {\n       runCommand.setPidNamespace(\"host\");\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "97fe3cc187cb9f773777ca79db6f1c7e4d1d5a68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7729.  Add support for setting Docker PID namespace mode.  (Contributed by Billie Rinaldi)\n",
      "commitDate": "22/01/18 1:33 PM",
      "commitName": "97fe3cc187cb9f773777ca79db6f1c7e4d1d5a68",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "12/01/18 10:41 AM",
      "commitNameOld": "3d65dbe032e202361d613344ccc6d9c5f99ba395",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 10.12,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,183 +1,187 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     if(cgroupsRootDirectory !\u003d null) {\n       runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n           cgroupsRootDirectory, false);\n     }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n       Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n           environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       if (!parsedMounts.find()) {\n         throw new ContainerExecutionException(\n             \"Unable to parse user supplied mount list: \"\n                 + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n       }\n       parsedMounts.reset();\n       while (parsedMounts.find()) {\n         String src \u003d parsedMounts.group(1);\n         String dst \u003d parsedMounts.group(2);\n         String mode \u003d parsedMounts.group(3);\n         if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n           throw new ContainerExecutionException(\n               \"Invalid mount mode requested for mount: \"\n                   + parsedMounts.group());\n         }\n         if (mode.equals(\"ro\")) {\n           runCommand.addReadOnlyMountLocation(src, dst);\n         } else {\n           runCommand.addReadWriteMountLocation(src, dst);\n         }\n       }\n     }\n \n+    if (allowHostPidNamespace(container)) {\n+      runCommand.setPidNamespace(\"host\");\n+    }\n+\n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory, false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowHostPidNamespace(container)) {\n      runCommand.setPidNamespace(\"host\");\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "d42a336cfab106d052aa30d80d9d30904123cb55": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5534.  Allow user provided Docker volume mount list.  (Contributed by Shane Kumpf)\n",
      "commitDate": "22/11/17 10:05 AM",
      "commitName": "d42a336cfab106d052aa30d80d9d30904123cb55",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "ce74e64363abc64561263be70a923ab3e67f043f",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 15.86,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,183 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     if(cgroupsRootDirectory !\u003d null) {\n       runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n           cgroupsRootDirectory, false);\n     }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n+    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n+      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n+          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n+      if (!parsedMounts.find()) {\n+        throw new ContainerExecutionException(\n+            \"Unable to parse user supplied mount list: \"\n+                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n+      }\n+      parsedMounts.reset();\n+      while (parsedMounts.find()) {\n+        String src \u003d parsedMounts.group(1);\n+        String dst \u003d parsedMounts.group(2);\n+        String mode \u003d parsedMounts.group(3);\n+        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n+          throw new ContainerExecutionException(\n+              \"Invalid mount mode requested for mount: \"\n+                  + parsedMounts.group());\n+        }\n+        if (mode.equals(\"ro\")) {\n+          runCommand.addReadOnlyMountLocation(src, dst);\n+        } else {\n+          runCommand.addReadWriteMountLocation(src, dst);\n+        }\n+      }\n+    }\n+\n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory, false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_MOUNTS)) {\n      Matcher parsedMounts \u003d USER_MOUNT_PATTERN.matcher(\n          environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      if (!parsedMounts.find()) {\n        throw new ContainerExecutionException(\n            \"Unable to parse user supplied mount list: \"\n                + environment.get(ENV_DOCKER_CONTAINER_MOUNTS));\n      }\n      parsedMounts.reset();\n      while (parsedMounts.find()) {\n        String src \u003d parsedMounts.group(1);\n        String dst \u003d parsedMounts.group(2);\n        String mode \u003d parsedMounts.group(3);\n        if (!mode.equals(\"ro\") \u0026\u0026 !mode.equals(\"rw\")) {\n          throw new ContainerExecutionException(\n              \"Invalid mount mode requested for mount: \"\n                  + parsedMounts.group());\n        }\n        if (mode.equals(\"ro\")) {\n          runCommand.addReadOnlyMountLocation(src, dst);\n        } else {\n          runCommand.addReadWriteMountLocation(src, dst);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "d00b6f7c1ff2d7569ae9efdc6823ebcfb86ef2d4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7286. Add support for docker to have no capabilities. Contributed by Eric Badger\n",
      "commitDate": "02/11/17 7:37 AM",
      "commitName": "d00b6f7c1ff2d7569ae9efdc6823ebcfb86ef2d4",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "28/10/17 10:38 PM",
      "commitNameOld": "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 4.37,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,157 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n-    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n-        conf.getTrimmedStrings(\n-            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n-            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     if(cgroupsRootDirectory !\u003d null) {\n       runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n           cgroupsRootDirectory, false);\n     }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     // use plugins to update docker run command.\n     if (nmContext !\u003d null\n         \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n       for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n           .getNameToPlugins().values()) {\n         DockerCommandPlugin dockerCommandPlugin \u003d\n             plugin.getDockerCommandPluginInstance();\n         if (dockerCommandPlugin !\u003d null) {\n           dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n         }\n       }\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory, false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7224. Support GPU isolation for docker container. Contributed by Wangda Tan.\n",
      "commitDate": "28/10/17 10:38 PM",
      "commitName": "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5",
      "commitAuthor": "Sunil G",
      "commitDateOld": "02/10/17 7:04 PM",
      "commitNameOld": "7eb8499996869cdb63743f1c9eca2ba91d57ad08",
      "commitAuthorOld": "Sidharta S",
      "daysBetweenCommits": 26.15,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,161 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     if(cgroupsRootDirectory !\u003d null) {\n       runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n           cgroupsRootDirectory, false);\n     }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n+    // use plugins to update docker run command.\n+    if (nmContext !\u003d null\n+        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n+      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n+          .getNameToPlugins().values()) {\n+        DockerCommandPlugin dockerCommandPlugin \u003d\n+            plugin.getDockerCommandPluginInstance();\n+        if (dockerCommandPlugin !\u003d null) {\n+          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n+        }\n+      }\n+    }\n+\n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory, false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    // use plugins to update docker run command.\n    if (nmContext !\u003d null\n        \u0026\u0026 nmContext.getResourcePluginManager().getNameToPlugins() !\u003d null) {\n      for (ResourcePlugin plugin : nmContext.getResourcePluginManager()\n          .getNameToPlugins().values()) {\n        DockerCommandPlugin dockerCommandPlugin \u003d\n            plugin.getDockerCommandPluginInstance();\n        if (dockerCommandPlugin !\u003d null) {\n          dockerCommandPlugin.updateDockerRunCommand(runCommand, container);\n        }\n      }\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "d3b1c6319546706c41a2011ead6c3fe208883200": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6623. Add support to turn off launching privileged containers in the container-executor. (Varun Vasudev via wangda)\n\nChange-Id: I76aec68cbfb42d239279d7245a03290d691e87a4\n",
      "commitDate": "28/09/17 4:41 PM",
      "commitName": "d3b1c6319546706c41a2011ead6c3fe208883200",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "21/09/17 3:41 PM",
      "commitNameOld": "bfd1a72ba8fbb06da73fede2a85e0b544d6ab43f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 7.04,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,148 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     String[] groups \u003d null;\n \n     if (enableUserReMapping) {\n       String uid \u003d getUserIdInfo(runAsUser);\n       groups \u003d getGroupIdInfo(runAsUser);\n       String gid \u003d groups[0];\n       if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n         String message \u003d \"uid: \" + uid + \" below threshold: \"\n             + userRemappingUidThreshold;\n         throw new ContainerExecutionException(message);\n       }\n       for(int i \u003d 0; i \u003c groups.length; i++) {\n         String group \u003d groups[i];\n         if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n           String message \u003d \"gid: \" + group\n               + \" below threshold: \" + userRemappingGidThreshold;\n           throw new ContainerExecutionException(message);\n         }\n       }\n       dockerRunAsUser \u003d uid + \":\" + gid;\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     if(cgroupsRootDirectory !\u003d null) {\n-      runCommand.addMountLocation(cgroupsRootDirectory,\n-          cgroupsRootDirectory + \":ro\", false);\n+      runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n+          cgroupsRootDirectory, false);\n     }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n-          runCommand.addMountLocation(src, dst + \":ro\", true);\n+          runCommand.addReadOnlyMountLocation(src, dst, true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     if(enableUserReMapping) {\n       runCommand.groupAdd(groups);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n-      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n+      LOG.info(\"Docker command used: \" + runCommand);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addReadOnlyMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory, false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addReadOnlyMountLocation(src, dst, true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "bfd1a72ba8fbb06da73fede2a85e0b544d6ab43f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4266. Allow users to enter containers as UID:GID pair instead of by username. Contributed by luhuichun, Zhankun Tang, and Eric Badger.\n",
      "commitDate": "21/09/17 3:41 PM",
      "commitName": "bfd1a72ba8fbb06da73fede2a85e0b544d6ab43f",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "21/09/17 2:01 PM",
      "commitNameOld": "e5e1851d803bf8d8b96fec1b5c0058014e9329d0",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,148 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n+    String dockerRunAsUser \u003d runAsUser;\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n+    String[] groups \u003d null;\n+\n+    if (enableUserReMapping) {\n+      String uid \u003d getUserIdInfo(runAsUser);\n+      groups \u003d getGroupIdInfo(runAsUser);\n+      String gid \u003d groups[0];\n+      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n+        String message \u003d \"uid: \" + uid + \" below threshold: \"\n+            + userRemappingUidThreshold;\n+        throw new ContainerExecutionException(message);\n+      }\n+      for(int i \u003d 0; i \u003c groups.length; i++) {\n+        String group \u003d groups[i];\n+        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n+          String message \u003d \"gid: \" + group\n+              + \" below threshold: \" + userRemappingGidThreshold;\n+          throw new ContainerExecutionException(message);\n+        }\n+      }\n+      dockerRunAsUser \u003d uid + \":\" + gid;\n+    }\n+\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n-        runAsUser, imageName)\n+        dockerRunAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     if(cgroupsRootDirectory !\u003d null) {\n       runCommand.addMountLocation(cgroupsRootDirectory,\n           cgroupsRootDirectory + \":ro\", false);\n     }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n+    if(enableUserReMapping) {\n+      runCommand.groupAdd(groups);\n+    }\n+\n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String dockerRunAsUser \u003d runAsUser;\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    String[] groups \u003d null;\n\n    if (enableUserReMapping) {\n      String uid \u003d getUserIdInfo(runAsUser);\n      groups \u003d getGroupIdInfo(runAsUser);\n      String gid \u003d groups[0];\n      if(Integer.parseInt(uid) \u003c userRemappingUidThreshold) {\n        String message \u003d \"uid: \" + uid + \" below threshold: \"\n            + userRemappingUidThreshold;\n        throw new ContainerExecutionException(message);\n      }\n      for(int i \u003d 0; i \u003c groups.length; i++) {\n        String group \u003d groups[i];\n        if (Integer.parseInt(group) \u003c userRemappingGidThreshold) {\n          String message \u003d \"gid: \" + group\n              + \" below threshold: \" + userRemappingGidThreshold;\n          throw new ContainerExecutionException(message);\n        }\n      }\n      dockerRunAsUser \u003d uid + \":\" + gid;\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        dockerRunAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory + \":ro\", false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    if(enableUserReMapping) {\n      runCommand.groupAdd(groups);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7034. DefaultLinuxContainerRuntime and DockerLinuxContainerRuntime sends client environment variables to container-executor. Contributed by Miklos Szegedi.\n",
      "commitDate": "21/09/17 2:01 PM",
      "commitName": "e5e1851d803bf8d8b96fec1b5c0058014e9329d0",
      "commitAuthor": "Junping Du",
      "commitDateOld": "21/09/17 6:38 AM",
      "commitNameOld": "10d7493587643b52cee5fde87eca9ef99c422a70",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.31,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,121 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n     runCommand.setCapabilities(capabilities);\n \n     if(cgroupsRootDirectory !\u003d null) {\n       runCommand.addMountLocation(cgroupsRootDirectory,\n           cgroupsRootDirectory + \":ro\", false);\n     }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n-          launchOp, null, container.getLaunchContext().getEnvironment(),\n-          false, false);\n+          launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory + \":ro\", false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "10d7493587643b52cee5fde87eca9ef99c422a70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6968. Hardcoded absolute pathname in DockerLinuxContainerRuntime. Contributed by Eric Badger\n",
      "commitDate": "21/09/17 6:38 AM",
      "commitName": "10d7493587643b52cee5fde87eca9ef99c422a70",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 30.22,
      "commitsBetweenForRepo": 325,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,122 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n     String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     validateHostname(hostname);\n \n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network);\n     setHostname(runCommand, containerIdStr, hostname);\n-    runCommand.setCapabilities(capabilities)\n-        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n-            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n+    runCommand.setCapabilities(capabilities);\n+\n+    if(cgroupsRootDirectory !\u003d null) {\n+      runCommand.addMountLocation(cgroupsRootDirectory,\n+          cgroupsRootDirectory + \":ro\", false);\n+    }\n \n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities);\n\n    if(cgroupsRootDirectory !\u003d null) {\n      runCommand.addMountLocation(cgroupsRootDirectory,\n          cgroupsRootDirectory + \":ro\", false);\n    }\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "ac9489f7fc2dd351fbe5be4b7a3add4782da81c3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6804. Allow custom hostname for docker containers in native services. Contributed by Billie Rinaldi\n",
      "commitDate": "25/07/17 9:57 AM",
      "commitName": "ac9489f7fc2dd351fbe5be4b7a3add4782da81c3",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/07/17 9:56 PM",
      "commitNameOld": "2054324d471a6152ba34284b4259d4fd09c71704",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 2.5,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,119 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n+    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n+    validateHostname(hostname);\n+\n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n-        .setNetworkType(network)\n-        .setCapabilities(capabilities)\n+        .setNetworkType(network);\n+    setHostname(runCommand, containerIdStr, hostname);\n+    runCommand.setCapabilities(capabilities)\n         .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n             CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n-    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n+    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n-      if (LOG.isInfoEnabled()) {\n-        LOG.info(\"command override disabled\");\n-      }\n+      LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "2054324d471a6152ba34284b4259d4fd09c71704": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-6804. [YARN core changes] Allow custom hostname for docker containers in native services. Contributed by Billie Rinaldi\"\n\nThis reverts commit 4a771d9010de0867ac901bead075383ddf1f30dc.\n",
      "commitDate": "22/07/17 9:56 PM",
      "commitName": "2054324d471a6152ba34284b4259d4fd09c71704",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "21/07/17 11:31 AM",
      "commitNameOld": "4a771d9010de0867ac901bead075383ddf1f30dc",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 1.43,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,117 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n-    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n-    validateHostname(hostname);\n-\n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n-        .setNetworkType(network);\n-    setHostname(runCommand, containerIdStr, hostname);\n-    runCommand.setCapabilities(capabilities)\n+        .setNetworkType(network)\n+        .setCapabilities(capabilities)\n         .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n             CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n-\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n+\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n-      LOG.info(\"command override disabled\");\n+      if (LOG.isInfoEnabled()) {\n+        LOG.info(\"command override disabled\");\n+      }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "4a771d9010de0867ac901bead075383ddf1f30dc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6804. [YARN core changes] Allow custom hostname for docker containers in native services. Contributed by Billie Rinaldi\n",
      "commitDate": "21/07/17 11:31 AM",
      "commitName": "4a771d9010de0867ac901bead075383ddf1f30dc",
      "commitAuthor": "Jian He",
      "commitDateOld": "17/05/17 9:59 PM",
      "commitNameOld": "e120ee865aa78eaff4a80122c5f3207a97b4924d",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 64.56,
      "commitsBetweenForRepo": 309,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,119 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n+    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n+    validateHostname(hostname);\n+\n     validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n-        .setNetworkType(network)\n-        .setCapabilities(capabilities)\n+        .setNetworkType(network);\n+    setHostname(runCommand, containerIdStr, hostname);\n+    runCommand.setCapabilities(capabilities)\n         .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n             CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n-    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n+    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n-      if (LOG.isInfoEnabled()) {\n-        LOG.info(\"command override disabled\");\n-      }\n+      LOG.info(\"command override disabled\");\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n    String hostname \u003d environment.get(ENV_DOCKER_CONTAINER_HOSTNAME);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateHostname(hostname);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network);\n    setHostname(runCommand, containerIdStr, hostname);\n    runCommand.setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      LOG.info(\"command override disabled\");\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "e120ee865aa78eaff4a80122c5f3207a97b4924d": {
      "type": "Ybodychange",
      "commitMessage": "Validate docker image name before launching container.\n",
      "commitDate": "17/05/17 9:59 PM",
      "commitName": "e120ee865aa78eaff4a80122c5f3207a97b4924d",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "10/05/17 10:46 AM",
      "commitNameOld": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 7.47,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,117 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n-    if (imageName \u003d\u003d null) {\n-      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n-          + \" not set!\");\n-    }\n+    validateImageName(imageName);\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n         .setCapabilities(capabilities)\n         .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n             CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n         commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateImageName(imageName);\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "74a61438ca01e2191b54000af73b654a2d0b8253": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6475. Fix some long function checkstyle issues\n(Contributed by Soumabrata Chakraborty via Daniel Templeton)\n",
      "commitDate": "10/05/17 10:46 AM",
      "commitName": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "31/10/16 1:51 PM",
      "commitNameOld": "f3eb4c3c738204e099cbaa03471497c46530efbf",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 190.87,
      "commitsBetweenForRepo": 1101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,120 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n-    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n-    @SuppressWarnings(\"unchecked\")\n-    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n-    @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n         .setCapabilities(capabilities)\n         .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n             CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n-    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n-        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n-\n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n-    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n-        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n-\n-    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n-        Integer.toString(PrivilegedOperation\n-            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n-        ctx.getExecutionAttribute(APPID),\n-        containerIdStr, containerWorkDir.toString(),\n-        nmPrivateContainerScriptPath.toUri().getPath(),\n-        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n-        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n-        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n-            localDirs),\n-        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n-            logDirs),\n-        commandFile,\n-        resourcesOpts);\n-\n-    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n-\n-    if (tcCommandFile !\u003d null) {\n-      launchOp.appendArgs(tcCommandFile);\n-    }\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Launching container with cmd: \" + runCommand\n-          .getCommandWithArguments());\n-    }\n+    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n+        commandFile, runCommand);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d buildLaunchOp(ctx,\n        commandFile, runCommand);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "f3eb4c3c738204e099cbaa03471497c46530efbf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5793. Trim configuration values in DockerLinuxContainerRuntime (Contributed by Tianyin Xu via Daniel Templeton)\n",
      "commitDate": "31/10/16 1:51 PM",
      "commitName": "f3eb4c3c738204e099cbaa03471497c46530efbf",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "01/09/16 1:38 AM",
      "commitNameOld": "08f55ccbb075b90a6e534f4ac0f9840f2e6890d5",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 60.51,
      "commitsBetweenForRepo": 435,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,152 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n-    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n-        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n-        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n+    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n+        conf.getTrimmedStrings(\n+            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n+            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n         .setCapabilities(capabilities)\n         .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n             CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Launching container with cmd: \" + runCommand\n           .getCommandWithArguments());\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "08f55ccbb075b90a6e534f4ac0f9840f2e6890d5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5596. Fix failing unit test in TestDockerContainerRuntime. Contributed by Sidharta Seethana.\n",
      "commitDate": "01/09/16 1:38 AM",
      "commitName": "08f55ccbb075b90a6e534f4ac0f9840f2e6890d5",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "26/08/16 4:00 AM",
      "commitNameOld": "bfb4d950596d6198e473045dac6eb36c685b0319",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,151 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n-\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n         .setCapabilities(capabilities)\n-        .addMountLocation(\"/sys/fs/cgroup\", \"/sys/fs/cgroup:ro\", false);\n+        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n+            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Launching container with cmd: \" + runCommand\n           .getCommandWithArguments());\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "525d52bf7c18d1e334e02e6fb936400c9cf2b0bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5042. Mount /sys/fs/cgroup into Docker containers as read only mount. Contributed by luhuichun.\n",
      "commitDate": "25/08/16 1:48 AM",
      "commitName": "525d52bf7c18d1e334e02e6fb936400c9cf2b0bc",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "17/08/16 3:04 AM",
      "commitNameOld": "7f05ff7a4e654693eaaa216ee5fc6e24112e0e23",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,151 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n \n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n-        .setCapabilities(capabilities);\n+        .setCapabilities(capabilities)\n+        .addMountLocation(\"/sys/fs/cgroup\", \"/sys/fs/cgroup:ro\", false);\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n-      runCommand.addMountLocation(dir, dir);\n+      runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n-          runCommand.addMountLocation(src, dst + \":ro\");\n+          runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Launching container with cmd: \" + runCommand\n           .getCommandWithArguments());\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/sys/fs/cgroup\", \"/sys/fs/cgroup:ro\", false);\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "522ddbde79cd453cac066b6136f004f54e2123b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5394. Remove bind-mount /etc/passwd for Docker containers. Contributed by Zhankun Tang.\n",
      "commitDate": "09/08/16 3:34 AM",
      "commitName": "522ddbde79cd453cac066b6136f004f54e2123b0",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/07/16 6:57 AM",
      "commitNameOld": "e5e558b0a34968eaffdd243ce605ef26346c5e85",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 25.86,
      "commitsBetweenForRepo": 172,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,150 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n \n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n-        .setCapabilities(capabilities)\n-        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n+        .setCapabilities(capabilities);\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\");\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Launching container with cmd: \" + runCommand\n           .getCommandWithArguments());\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities);\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\");\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "58e18508018081b5b5aa7c12cc5af386146cd26b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5298. Mount usercache and NM filecache directories into Docker container. Contributed by  Sidharta Seethana.\n",
      "commitDate": "14/07/16 3:41 AM",
      "commitName": "58e18508018081b5b5aa7c12cc5af386146cd26b",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "13/07/16 11:18 PM",
      "commitNameOld": "dbe97aa768e2987209811c407969fea47641418c",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,151 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n+\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n+    allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n+    allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\");\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Launching container with cmd: \" + runCommand\n           .getCommandWithArguments());\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e filecacheDirs \u003d ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e userLocalDirs \u003d ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\");\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "dbe97aa768e2987209811c407969fea47641418c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5299. Log Docker run command when container fails. Contributed by Varun Vasudev.\n",
      "commitDate": "13/07/16 11:18 PM",
      "commitName": "dbe97aa768e2987209811c407969fea47641418c",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "29/05/16 9:02 AM",
      "commitNameOld": "86fb58b7dc832c2df30469d128598a6a1bed8df5",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 45.59,
      "commitsBetweenForRepo": 420,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,144 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network \u003d\u003d null || network.isEmpty()) {\n       network \u003d defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\");\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Launching container with cmd: \" + runCommand\n+          .getCommandWithArguments());\n+    }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n+      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\");\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "86fb58b7dc832c2df30469d128598a6a1bed8df5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4007. Add support for different network setups when launching the docker container. Contributed by Sidharta Seethana.\n",
      "commitDate": "29/05/16 9:02 AM",
      "commitName": "86fb58b7dc832c2df30469d128598a6a1bed8df5",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "05/05/16 12:31 AM",
      "commitNameOld": "72b047715c1ae89dff3dfe76c1af91dfe255ed70",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 24.35,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,139 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n+    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n+\n+    if(network \u003d\u003d null || network.isEmpty()) {\n+      network \u003d defaultNetwork;\n+    }\n+\n+    validateContainerNetworkType(network);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n-        .setNetworkType(\"host\")\n+        .setNetworkType(network)\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts \u003d environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n           if (dir.length !\u003d 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src \u003d validateMount(dir[0], localizedResources);\n           String dst \u003d dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\");\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network \u003d environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network \u003d\u003d null || network.isEmpty()) {\n      network \u003d defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\");\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "72b047715c1ae89dff3dfe76c1af91dfe255ed70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4595. Add support for configurable read-only mounts when launching Docker containers. Contributed by Billie Rinaldi.\n",
      "commitDate": "05/05/16 12:31 AM",
      "commitName": "72b047715c1ae89dff3dfe76c1af91dfe255ed70",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "29/04/16 9:25 AM",
      "commitNameOld": "9d4d30243b0fc9630da51a2c17b543ef671d035c",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 5.63,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,132 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n+    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n+        LOCALIZED_RESOURCES);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n+    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n+      String mounts \u003d environment.get(\n+          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n+      if (!mounts.isEmpty()) {\n+        for (String mount : StringUtils.split(mounts)) {\n+          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n+          if (dir.length !\u003d 2) {\n+            throw new ContainerExecutionException(\"Invalid mount : \" +\n+                mount);\n+          }\n+          String src \u003d validateMount(dir[0], localizedResources);\n+          String dst \u003d dir[1];\n+          runCommand.addMountLocation(src, dst + \":ro\");\n+        }\n+      }\n+    }\n+\n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts \u003d environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir \u003d StringUtils.split(mount, \u0027:\u0027);\n          if (dir.length !\u003d 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src \u003d validateMount(dir[0], localizedResources);\n          String dst \u003d dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\");\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": {
      "type": "Ybodychange",
      "commitMessage": "Remove parent\u0027s env vars from child processes\n",
      "commitDate": "29/04/16 9:25 AM",
      "commitName": "9d4d30243b0fc9630da51a2c17b543ef671d035c",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "07/03/16 11:08 AM",
      "commitNameOld": "b2661765a5a48392a5691cee15904ed2de147b00",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 52.89,
      "commitsBetweenForRepo": 317,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,112 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n-          false);\n+          false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "059caf99891943d9587cac19b48e82efbed06b2d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4744. Too many signal to container failure in case of LCE. Contributed by Sidharta Seethana\n",
      "commitDate": "07/03/16 7:40 AM",
      "commitName": "059caf99891943d9587cac19b48e82efbed06b2d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/01/16 1:13 AM",
      "commitNameOld": "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 45.27,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,112 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n-        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n-        null);\n+        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4578. Directories that are mounted in docker containers need to be more restrictive/container-specific. Contributed by Sidharta Seethana.\n",
      "commitDate": "22/01/16 1:13 AM",
      "commitName": "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/01/16 12:59 AM",
      "commitNameOld": "3ddb92bd30d4a267c5c35b410b21c6ea42a7238b",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,113 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n+        CONTAINER_LOCAL_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n+        CONTAINER_LOG_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n-    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n+    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n \n     allDirs.add(containerWorkDir.toString());\n-    allDirs.addAll(logDirs);\n+    allDirs.addAll(containerLogDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n         null);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e containerLogDirs \u003d ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(containerLocalDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n        null);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "3ddb92bd30d4a267c5c35b410b21c6ea42a7238b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4553. Add cgroups support for docker containers. Contributed by Sidharta Seethana.\n",
      "commitDate": "14/01/16 12:59 AM",
      "commitName": "3ddb92bd30d4a267c5c35b410b21c6ea42a7238b",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "19/10/15 7:49 AM",
      "commitNameOld": "e39ae0e676f77fab216e2281ae946ab8c647733f",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 86.76,
      "commitsBetweenForRepo": 577,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,107 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(logDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n-    /** Disabling docker\u0027s cgroup parent support for the time being. Docker\n-     * needs to use a more recent libcontainer that supports net_cls. In\n-     * addition we also need to revisit current cgroup creation in YARN.\n-     */\n-    //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n+    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n         null);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(logDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n        null);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "e39ae0e676f77fab216e2281ae946ab8c647733f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4262. Allow whitelisted users to run privileged docker containers. Contributed by Sidharta Seethana.\n",
      "commitDate": "19/10/15 7:49 AM",
      "commitName": "e39ae0e676f77fab216e2281ae946ab8c647733f",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "15/10/15 1:11 AM",
      "commitNameOld": "63020c54c12dffe03a1b3712759ec65c49df3e64",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 4.28,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,111 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n     Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(logDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n+    if (allowPrivilegedContainerExecution(container)) {\n+      runCommand.setPrivileged();\n+    }\n+\n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     /** Disabling docker\u0027s cgroup parent support for the time being. Docker\n      * needs to use a more recent libcontainer that supports net_cls. In\n      * addition we also need to revisit current cgroup creation in YARN.\n      */\n     //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n         null);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(logDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    /** Disabling docker\u0027s cgroup parent support for the time being. Docker\n     * needs to use a more recent libcontainer that supports net_cls. In\n     * addition we also need to revisit current cgroup creation in YARN.\n     */\n    //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n        null);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "63020c54c12dffe03a1b3712759ec65c49df3e64": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4258. Add support for controlling capabilities for docker containers. Contributed by Sidharta Seethana.\n",
      "commitDate": "15/10/15 1:11 AM",
      "commitName": "63020c54c12dffe03a1b3712759ec65c49df3e64",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "27/07/15 11:57 AM",
      "commitNameOld": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 79.55,
      "commitsBetweenForRepo": 518,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,107 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n         .getEnvironment();\n     String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n     if (imageName \u003d\u003d null) {\n       throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n           + \" not set!\");\n     }\n \n     String containerIdStr \u003d container.getContainerId().toString();\n     String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n+    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n+        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n+        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n+\n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n+        .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(logDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     /** Disabling docker\u0027s cgroup parent support for the time being. Docker\n      * needs to use a more recent libcontainer that supports net_cls. In\n      * addition we also need to revisit current cgroup creation in YARN.\n      */\n     //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride \u003d environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n       Path launchDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n         null);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    Set\u003cString\u003e capabilities \u003d new HashSet\u003c\u003e(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(logDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    /** Disabling docker\u0027s cgroup parent support for the time being. Docker\n     * needs to use a more recent libcontainer that supports net_cls. In\n     * addition we also need to revisit current cgroup creation in YARN.\n     */\n    //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n        null);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "3e6fce91a471b4a5099de109582e7c6417e8a822": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3853. Add docker container runtime support to LinuxContainterExecutor. Contributed by Sidharta Seethana.\n",
      "commitDate": "27/07/15 11:57 AM",
      "commitName": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthor": "Varun Vasudev",
      "diff": "@@ -0,0 +1,102 @@\n+  public void launchContainer(ContainerRuntimeContext ctx)\n+      throws ContainerExecutionException {\n+    Container container \u003d ctx.getContainer();\n+    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n+        .getEnvironment();\n+    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n+\n+    if (imageName \u003d\u003d null) {\n+      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n+          + \" not set!\");\n+    }\n+\n+    String containerIdStr \u003d container.getContainerId().toString();\n+    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n+    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n+    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n+    //we can\u0027t do better here thanks to type-erasure\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n+    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n+        runAsUser, imageName)\n+        .detachOnRun()\n+        .setContainerWorkDir(containerWorkDir.toString())\n+        .setNetworkType(\"host\")\n+        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n+    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n+\n+    allDirs.add(containerWorkDir.toString());\n+    allDirs.addAll(logDirs);\n+    for (String dir: allDirs) {\n+      runCommand.addMountLocation(dir, dir);\n+    }\n+\n+    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n+\n+    /** Disabling docker\u0027s cgroup parent support for the time being. Docker\n+     * needs to use a more recent libcontainer that supports net_cls. In\n+     * addition we also need to revisit current cgroup creation in YARN.\n+     */\n+    //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n+\n+   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n+        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n+\n+    String disableOverride \u003d environment.get(\n+        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n+\n+    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n+      if (LOG.isInfoEnabled()) {\n+        LOG.info(\"command override disabled\");\n+      }\n+    } else {\n+      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n+      Path launchDst \u003d\n+          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n+\n+      overrideCommands.add(\"bash\");\n+      overrideCommands.add(launchDst.toUri().getPath());\n+      runCommand.setOverrideCommandWithArgs(overrideCommands);\n+    }\n+\n+    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n+        containerIdStr);\n+    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n+        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n+        null);\n+\n+    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n+        Integer.toString(PrivilegedOperation\n+            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n+        ctx.getExecutionAttribute(APPID),\n+        containerIdStr, containerWorkDir.toString(),\n+        nmPrivateContainerScriptPath.toUri().getPath(),\n+        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n+        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n+        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n+            localDirs),\n+        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n+            logDirs),\n+        commandFile,\n+        resourcesOpts);\n+\n+    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n+\n+    if (tcCommandFile !\u003d null) {\n+      launchOp.appendArgs(tcCommandFile);\n+    }\n+\n+    try {\n+      privilegedOperationExecutor.executePrivilegedOperation(null,\n+          launchOp, null, container.getLaunchContext().getEnvironment(),\n+          false);\n+    } catch (PrivilegedOperationException e) {\n+      LOG.warn(\"Launch container failed. Exception: \", e);\n+\n+      throw new ContainerExecutionException(\"Launch container failed\", e\n+          .getExitCode(), e.getOutput(), e.getErrorOutput());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    String imageName \u003d environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName \u003d\u003d null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr \u003d container.getContainerId().toString();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand \u003d new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List\u003cString\u003e allDirs \u003d new ArrayList\u003c\u003e(localDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(logDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    /** Disabling docker\u0027s cgroup parent support for the time being. Docker\n     * needs to use a more recent libcontainer that supports net_cls. In\n     * addition we also need to revisit current cgroup creation in YARN.\n     */\n    //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride \u003d environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride !\u003d null \u0026\u0026 disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List\u003cString\u003e overrideCommands \u003d new ArrayList\u003c\u003e();\n      Path launchDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile \u003d dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER, (String)\n        null);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java"
    }
  }
}