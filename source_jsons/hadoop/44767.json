{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAdminCLI.java",
  "functionName": "refreshNodes",
  "functionId": "refreshNodes___timeout-int__trackingMode-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
  "functionStartLine": 359,
  "functionEndLine": 417,
  "numCommitsSeen": 118,
  "timeTaken": 3587,
  "changeHistory": [
    "72fe54684198b7df5c5fb2114616dff6d17a4402",
    "0da69c324dee9baab0f0b9700db1cc5b623f8421",
    "95f2b9859718eca12fb3167775cdd2dad25dde25",
    "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501"
  ],
  "changeHistoryShort": {
    "72fe54684198b7df5c5fb2114616dff6d17a4402": "Ybodychange",
    "0da69c324dee9baab0f0b9700db1cc5b623f8421": "Ymultichange(Yparameterchange,Ybodychange)",
    "95f2b9859718eca12fb3167775cdd2dad25dde25": "Ymultichange(Yparameterchange,Ybodychange)",
    "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501": "Yintroduced"
  },
  "changeHistoryDetails": {
    "72fe54684198b7df5c5fb2114616dff6d17a4402": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5963. Spelling errors in logging and exceptions for node manager, client, web-proxy, common, and app history code (gsohn via rkanter)\n",
      "commitDate": "07/12/16 3:07 PM",
      "commitName": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "16/11/16 1:56 PM",
      "commitNameOld": "6a11877ab5b4e81769dc097e91198abd994d103f",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 21.05,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   private int refreshNodes(int timeout, String trackingMode)\n       throws IOException, YarnException {\n     boolean serverTracking \u003d !\"client\".equals(trackingMode);\n     // Graceful decommissioning with timeout\n     ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n     RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n         .newInstance(DecommissionType.GRACEFUL, timeout);\n     adminProtocol.refreshNodes(gracefulRequest);\n     if (serverTracking) {\n       return 0;\n     }\n     CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n         .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n     long waitingTime;\n     boolean nodesDecommissioning \u003d true;\n     // As RM enforces timeout automatically, client usually don\u0027t need\n     // to forcefully decommission nodes upon timeout.\n     // Here we let the client waits a small additional seconds so to avoid\n     // unnecessary double decommission.\n     final int gracePeriod \u003d 5;\n     // timeout\u003d-1 means wait for all the nodes to be gracefully\n     // decommissioned\n     for (waitingTime \u003d 0;\n         timeout \u003d\u003d -1 || (timeout \u003e\u003d 0 \u0026\u0026 waitingTime \u003c timeout + gracePeriod);\n         waitingTime++) {\n       // wait for one second to check nodes decommissioning status\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         // Ignore the InterruptedException\n       }\n       CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n           .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n       Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n           .getDecommissioningNodes();\n       if (decommissioningNodes.isEmpty()) {\n         nodesDecommissioning \u003d false;\n         break;\n       } else {\n         StringBuilder nodes \u003d new StringBuilder();\n         for (NodeId nodeId : decommissioningNodes) {\n           nodes.append(nodeId).append(\",\");\n         }\n         nodes.deleteCharAt(nodes.length() - 1);\n         System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n       }\n     }\n     if (nodesDecommissioning) {\n       System.out.println(\"Graceful decommissioning not completed in \" + timeout\n-          + \" seconds, issueing forceful decommissioning command.\");\n+          + \" seconds, issuing forceful decommissioning command.\");\n       RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n           .newInstance(DecommissionType.FORCEFUL);\n       adminProtocol.refreshNodes(forcefulRequest);\n     } else {\n       System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n           + \" seconds.\");\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int refreshNodes(int timeout, String trackingMode)\n      throws IOException, YarnException {\n    boolean serverTracking \u003d !\"client\".equals(trackingMode);\n    // Graceful decommissioning with timeout\n    ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n    RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n        .newInstance(DecommissionType.GRACEFUL, timeout);\n    adminProtocol.refreshNodes(gracefulRequest);\n    if (serverTracking) {\n      return 0;\n    }\n    CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n        .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n    long waitingTime;\n    boolean nodesDecommissioning \u003d true;\n    // As RM enforces timeout automatically, client usually don\u0027t need\n    // to forcefully decommission nodes upon timeout.\n    // Here we let the client waits a small additional seconds so to avoid\n    // unnecessary double decommission.\n    final int gracePeriod \u003d 5;\n    // timeout\u003d-1 means wait for all the nodes to be gracefully\n    // decommissioned\n    for (waitingTime \u003d 0;\n        timeout \u003d\u003d -1 || (timeout \u003e\u003d 0 \u0026\u0026 waitingTime \u003c timeout + gracePeriod);\n        waitingTime++) {\n      // wait for one second to check nodes decommissioning status\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Ignore the InterruptedException\n      }\n      CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n          .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n      Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n          .getDecommissioningNodes();\n      if (decommissioningNodes.isEmpty()) {\n        nodesDecommissioning \u003d false;\n        break;\n      } else {\n        StringBuilder nodes \u003d new StringBuilder();\n        for (NodeId nodeId : decommissioningNodes) {\n          nodes.append(nodeId).append(\",\");\n        }\n        nodes.deleteCharAt(nodes.length() - 1);\n        System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n      }\n    }\n    if (nodesDecommissioning) {\n      System.out.println(\"Graceful decommissioning not completed in \" + timeout\n          + \" seconds, issuing forceful decommissioning command.\");\n      RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n          .newInstance(DecommissionType.FORCEFUL);\n      adminProtocol.refreshNodes(forcefulRequest);\n    } else {\n      System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n          + \" seconds.\");\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
      "extendedDetails": {}
    },
    "0da69c324dee9baab0f0b9700db1cc5b623f8421": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4676. Automatic and Asynchronous Decommissioning Nodes Status Tracking. Contributed by Diniel Zhi.\n(cherry picked from commit d464483bf7f0b3e3be3ba32cd6c3eee546747ab5)\n\nConflicts:\n\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNode.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java\n",
      "commitDate": "18/08/16 7:27 AM",
      "commitName": "0da69c324dee9baab0f0b9700db1cc5b623f8421",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4676. Automatic and Asynchronous Decommissioning Nodes Status Tracking. Contributed by Diniel Zhi.\n(cherry picked from commit d464483bf7f0b3e3be3ba32cd6c3eee546747ab5)\n\nConflicts:\n\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNode.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java\n",
          "commitDate": "18/08/16 7:27 AM",
          "commitName": "0da69c324dee9baab0f0b9700db1cc5b623f8421",
          "commitAuthor": "Junping Du",
          "commitDateOld": "29/07/16 10:26 AM",
          "commitNameOld": "95f2b9859718eca12fb3167775cdd2dad25dde25",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 19.88,
          "commitsBetweenForRepo": 145,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,59 @@\n-  private int refreshNodes(long timeout, String trackingMode)\n+  private int refreshNodes(int timeout, String trackingMode)\n       throws IOException, YarnException {\n-    if (!\"client\".equals(trackingMode)) {\n-      throw new UnsupportedOperationException(\n-          \"Only client tracking mode is currently supported.\");\n-    }\n+    boolean serverTracking \u003d !\"client\".equals(trackingMode);\n     // Graceful decommissioning with timeout\n     ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n     RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n-        .newInstance(DecommissionType.GRACEFUL);\n+        .newInstance(DecommissionType.GRACEFUL, timeout);\n     adminProtocol.refreshNodes(gracefulRequest);\n+    if (serverTracking) {\n+      return 0;\n+    }\n     CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n         .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n     long waitingTime;\n     boolean nodesDecommissioning \u003d true;\n+    // As RM enforces timeout automatically, client usually don\u0027t need\n+    // to forcefully decommission nodes upon timeout.\n+    // Here we let the client waits a small additional seconds so to avoid\n+    // unnecessary double decommission.\n+    final int gracePeriod \u003d 5;\n     // timeout\u003d-1 means wait for all the nodes to be gracefully\n     // decommissioned\n-    for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n+    for (waitingTime \u003d 0;\n+        timeout \u003d\u003d -1 || (timeout \u003e\u003d 0 \u0026\u0026 waitingTime \u003c timeout + gracePeriod);\n+        waitingTime++) {\n       // wait for one second to check nodes decommissioning status\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         // Ignore the InterruptedException\n       }\n       CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n           .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n       Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n           .getDecommissioningNodes();\n       if (decommissioningNodes.isEmpty()) {\n         nodesDecommissioning \u003d false;\n         break;\n       } else {\n         StringBuilder nodes \u003d new StringBuilder();\n         for (NodeId nodeId : decommissioningNodes) {\n           nodes.append(nodeId).append(\",\");\n         }\n         nodes.deleteCharAt(nodes.length() - 1);\n         System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n       }\n     }\n     if (nodesDecommissioning) {\n       System.out.println(\"Graceful decommissioning not completed in \" + timeout\n           + \" seconds, issueing forceful decommissioning command.\");\n       RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n           .newInstance(DecommissionType.FORCEFUL);\n       adminProtocol.refreshNodes(forcefulRequest);\n     } else {\n       System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n           + \" seconds.\");\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int refreshNodes(int timeout, String trackingMode)\n      throws IOException, YarnException {\n    boolean serverTracking \u003d !\"client\".equals(trackingMode);\n    // Graceful decommissioning with timeout\n    ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n    RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n        .newInstance(DecommissionType.GRACEFUL, timeout);\n    adminProtocol.refreshNodes(gracefulRequest);\n    if (serverTracking) {\n      return 0;\n    }\n    CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n        .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n    long waitingTime;\n    boolean nodesDecommissioning \u003d true;\n    // As RM enforces timeout automatically, client usually don\u0027t need\n    // to forcefully decommission nodes upon timeout.\n    // Here we let the client waits a small additional seconds so to avoid\n    // unnecessary double decommission.\n    final int gracePeriod \u003d 5;\n    // timeout\u003d-1 means wait for all the nodes to be gracefully\n    // decommissioned\n    for (waitingTime \u003d 0;\n        timeout \u003d\u003d -1 || (timeout \u003e\u003d 0 \u0026\u0026 waitingTime \u003c timeout + gracePeriod);\n        waitingTime++) {\n      // wait for one second to check nodes decommissioning status\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Ignore the InterruptedException\n      }\n      CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n          .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n      Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n          .getDecommissioningNodes();\n      if (decommissioningNodes.isEmpty()) {\n        nodesDecommissioning \u003d false;\n        break;\n      } else {\n        StringBuilder nodes \u003d new StringBuilder();\n        for (NodeId nodeId : decommissioningNodes) {\n          nodes.append(nodeId).append(\",\");\n        }\n        nodes.deleteCharAt(nodes.length() - 1);\n        System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n      }\n    }\n    if (nodesDecommissioning) {\n      System.out.println(\"Graceful decommissioning not completed in \" + timeout\n          + \" seconds, issueing forceful decommissioning command.\");\n      RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n          .newInstance(DecommissionType.FORCEFUL);\n      adminProtocol.refreshNodes(forcefulRequest);\n    } else {\n      System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n          + \" seconds.\");\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {
            "oldValue": "[timeout-long, trackingMode-String]",
            "newValue": "[timeout-int, trackingMode-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4676. Automatic and Asynchronous Decommissioning Nodes Status Tracking. Contributed by Diniel Zhi.\n(cherry picked from commit d464483bf7f0b3e3be3ba32cd6c3eee546747ab5)\n\nConflicts:\n\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNode.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java\n",
          "commitDate": "18/08/16 7:27 AM",
          "commitName": "0da69c324dee9baab0f0b9700db1cc5b623f8421",
          "commitAuthor": "Junping Du",
          "commitDateOld": "29/07/16 10:26 AM",
          "commitNameOld": "95f2b9859718eca12fb3167775cdd2dad25dde25",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 19.88,
          "commitsBetweenForRepo": 145,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,59 @@\n-  private int refreshNodes(long timeout, String trackingMode)\n+  private int refreshNodes(int timeout, String trackingMode)\n       throws IOException, YarnException {\n-    if (!\"client\".equals(trackingMode)) {\n-      throw new UnsupportedOperationException(\n-          \"Only client tracking mode is currently supported.\");\n-    }\n+    boolean serverTracking \u003d !\"client\".equals(trackingMode);\n     // Graceful decommissioning with timeout\n     ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n     RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n-        .newInstance(DecommissionType.GRACEFUL);\n+        .newInstance(DecommissionType.GRACEFUL, timeout);\n     adminProtocol.refreshNodes(gracefulRequest);\n+    if (serverTracking) {\n+      return 0;\n+    }\n     CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n         .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n     long waitingTime;\n     boolean nodesDecommissioning \u003d true;\n+    // As RM enforces timeout automatically, client usually don\u0027t need\n+    // to forcefully decommission nodes upon timeout.\n+    // Here we let the client waits a small additional seconds so to avoid\n+    // unnecessary double decommission.\n+    final int gracePeriod \u003d 5;\n     // timeout\u003d-1 means wait for all the nodes to be gracefully\n     // decommissioned\n-    for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n+    for (waitingTime \u003d 0;\n+        timeout \u003d\u003d -1 || (timeout \u003e\u003d 0 \u0026\u0026 waitingTime \u003c timeout + gracePeriod);\n+        waitingTime++) {\n       // wait for one second to check nodes decommissioning status\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         // Ignore the InterruptedException\n       }\n       CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n           .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n       Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n           .getDecommissioningNodes();\n       if (decommissioningNodes.isEmpty()) {\n         nodesDecommissioning \u003d false;\n         break;\n       } else {\n         StringBuilder nodes \u003d new StringBuilder();\n         for (NodeId nodeId : decommissioningNodes) {\n           nodes.append(nodeId).append(\",\");\n         }\n         nodes.deleteCharAt(nodes.length() - 1);\n         System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n       }\n     }\n     if (nodesDecommissioning) {\n       System.out.println(\"Graceful decommissioning not completed in \" + timeout\n           + \" seconds, issueing forceful decommissioning command.\");\n       RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n           .newInstance(DecommissionType.FORCEFUL);\n       adminProtocol.refreshNodes(forcefulRequest);\n     } else {\n       System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n           + \" seconds.\");\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int refreshNodes(int timeout, String trackingMode)\n      throws IOException, YarnException {\n    boolean serverTracking \u003d !\"client\".equals(trackingMode);\n    // Graceful decommissioning with timeout\n    ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n    RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n        .newInstance(DecommissionType.GRACEFUL, timeout);\n    adminProtocol.refreshNodes(gracefulRequest);\n    if (serverTracking) {\n      return 0;\n    }\n    CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n        .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n    long waitingTime;\n    boolean nodesDecommissioning \u003d true;\n    // As RM enforces timeout automatically, client usually don\u0027t need\n    // to forcefully decommission nodes upon timeout.\n    // Here we let the client waits a small additional seconds so to avoid\n    // unnecessary double decommission.\n    final int gracePeriod \u003d 5;\n    // timeout\u003d-1 means wait for all the nodes to be gracefully\n    // decommissioned\n    for (waitingTime \u003d 0;\n        timeout \u003d\u003d -1 || (timeout \u003e\u003d 0 \u0026\u0026 waitingTime \u003c timeout + gracePeriod);\n        waitingTime++) {\n      // wait for one second to check nodes decommissioning status\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Ignore the InterruptedException\n      }\n      CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n          .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n      Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n          .getDecommissioningNodes();\n      if (decommissioningNodes.isEmpty()) {\n        nodesDecommissioning \u003d false;\n        break;\n      } else {\n        StringBuilder nodes \u003d new StringBuilder();\n        for (NodeId nodeId : decommissioningNodes) {\n          nodes.append(nodeId).append(\",\");\n        }\n        nodes.deleteCharAt(nodes.length() - 1);\n        System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n      }\n    }\n    if (nodesDecommissioning) {\n      System.out.println(\"Graceful decommissioning not completed in \" + timeout\n          + \" seconds, issueing forceful decommissioning command.\");\n      RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n          .newInstance(DecommissionType.FORCEFUL);\n      adminProtocol.refreshNodes(forcefulRequest);\n    } else {\n      System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n          + \" seconds.\");\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "95f2b9859718eca12fb3167775cdd2dad25dde25": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5434. Add -client|server argument for graceful decommmission. Contributed by Robert Kanter.\n",
      "commitDate": "29/07/16 10:26 AM",
      "commitName": "95f2b9859718eca12fb3167775cdd2dad25dde25",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5434. Add -client|server argument for graceful decommmission. Contributed by Robert Kanter.\n",
          "commitDate": "29/07/16 10:26 AM",
          "commitName": "95f2b9859718eca12fb3167775cdd2dad25dde25",
          "commitAuthor": "Junping Du",
          "commitDateOld": "14/06/16 3:06 PM",
          "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 44.81,
          "commitsBetweenForRepo": 428,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,52 @@\n-  private int refreshNodes(long timeout) throws IOException, YarnException {\n+  private int refreshNodes(long timeout, String trackingMode)\n+      throws IOException, YarnException {\n+    if (!\"client\".equals(trackingMode)) {\n+      throw new UnsupportedOperationException(\n+          \"Only client tracking mode is currently supported.\");\n+    }\n     // Graceful decommissioning with timeout\n     ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n     RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n         .newInstance(DecommissionType.GRACEFUL);\n     adminProtocol.refreshNodes(gracefulRequest);\n     CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n         .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n     long waitingTime;\n     boolean nodesDecommissioning \u003d true;\n     // timeout\u003d-1 means wait for all the nodes to be gracefully\n     // decommissioned\n     for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n       // wait for one second to check nodes decommissioning status\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         // Ignore the InterruptedException\n       }\n       CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n           .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n       Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n           .getDecommissioningNodes();\n       if (decommissioningNodes.isEmpty()) {\n         nodesDecommissioning \u003d false;\n         break;\n       } else {\n         StringBuilder nodes \u003d new StringBuilder();\n         for (NodeId nodeId : decommissioningNodes) {\n           nodes.append(nodeId).append(\",\");\n         }\n         nodes.deleteCharAt(nodes.length() - 1);\n         System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n       }\n     }\n     if (nodesDecommissioning) {\n       System.out.println(\"Graceful decommissioning not completed in \" + timeout\n           + \" seconds, issueing forceful decommissioning command.\");\n       RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n           .newInstance(DecommissionType.FORCEFUL);\n       adminProtocol.refreshNodes(forcefulRequest);\n     } else {\n       System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n           + \" seconds.\");\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int refreshNodes(long timeout, String trackingMode)\n      throws IOException, YarnException {\n    if (!\"client\".equals(trackingMode)) {\n      throw new UnsupportedOperationException(\n          \"Only client tracking mode is currently supported.\");\n    }\n    // Graceful decommissioning with timeout\n    ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n    RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n        .newInstance(DecommissionType.GRACEFUL);\n    adminProtocol.refreshNodes(gracefulRequest);\n    CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n        .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n    long waitingTime;\n    boolean nodesDecommissioning \u003d true;\n    // timeout\u003d-1 means wait for all the nodes to be gracefully\n    // decommissioned\n    for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n      // wait for one second to check nodes decommissioning status\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Ignore the InterruptedException\n      }\n      CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n          .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n      Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n          .getDecommissioningNodes();\n      if (decommissioningNodes.isEmpty()) {\n        nodesDecommissioning \u003d false;\n        break;\n      } else {\n        StringBuilder nodes \u003d new StringBuilder();\n        for (NodeId nodeId : decommissioningNodes) {\n          nodes.append(nodeId).append(\",\");\n        }\n        nodes.deleteCharAt(nodes.length() - 1);\n        System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n      }\n    }\n    if (nodesDecommissioning) {\n      System.out.println(\"Graceful decommissioning not completed in \" + timeout\n          + \" seconds, issueing forceful decommissioning command.\");\n      RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n          .newInstance(DecommissionType.FORCEFUL);\n      adminProtocol.refreshNodes(forcefulRequest);\n    } else {\n      System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n          + \" seconds.\");\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {
            "oldValue": "[timeout-long]",
            "newValue": "[timeout-long, trackingMode-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5434. Add -client|server argument for graceful decommmission. Contributed by Robert Kanter.\n",
          "commitDate": "29/07/16 10:26 AM",
          "commitName": "95f2b9859718eca12fb3167775cdd2dad25dde25",
          "commitAuthor": "Junping Du",
          "commitDateOld": "14/06/16 3:06 PM",
          "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 44.81,
          "commitsBetweenForRepo": 428,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,52 @@\n-  private int refreshNodes(long timeout) throws IOException, YarnException {\n+  private int refreshNodes(long timeout, String trackingMode)\n+      throws IOException, YarnException {\n+    if (!\"client\".equals(trackingMode)) {\n+      throw new UnsupportedOperationException(\n+          \"Only client tracking mode is currently supported.\");\n+    }\n     // Graceful decommissioning with timeout\n     ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n     RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n         .newInstance(DecommissionType.GRACEFUL);\n     adminProtocol.refreshNodes(gracefulRequest);\n     CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n         .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n     long waitingTime;\n     boolean nodesDecommissioning \u003d true;\n     // timeout\u003d-1 means wait for all the nodes to be gracefully\n     // decommissioned\n     for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n       // wait for one second to check nodes decommissioning status\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         // Ignore the InterruptedException\n       }\n       CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n           .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n       Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n           .getDecommissioningNodes();\n       if (decommissioningNodes.isEmpty()) {\n         nodesDecommissioning \u003d false;\n         break;\n       } else {\n         StringBuilder nodes \u003d new StringBuilder();\n         for (NodeId nodeId : decommissioningNodes) {\n           nodes.append(nodeId).append(\",\");\n         }\n         nodes.deleteCharAt(nodes.length() - 1);\n         System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n       }\n     }\n     if (nodesDecommissioning) {\n       System.out.println(\"Graceful decommissioning not completed in \" + timeout\n           + \" seconds, issueing forceful decommissioning command.\");\n       RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n           .newInstance(DecommissionType.FORCEFUL);\n       adminProtocol.refreshNodes(forcefulRequest);\n     } else {\n       System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n           + \" seconds.\");\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int refreshNodes(long timeout, String trackingMode)\n      throws IOException, YarnException {\n    if (!\"client\".equals(trackingMode)) {\n      throw new UnsupportedOperationException(\n          \"Only client tracking mode is currently supported.\");\n    }\n    // Graceful decommissioning with timeout\n    ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n    RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n        .newInstance(DecommissionType.GRACEFUL);\n    adminProtocol.refreshNodes(gracefulRequest);\n    CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n        .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n    long waitingTime;\n    boolean nodesDecommissioning \u003d true;\n    // timeout\u003d-1 means wait for all the nodes to be gracefully\n    // decommissioned\n    for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n      // wait for one second to check nodes decommissioning status\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Ignore the InterruptedException\n      }\n      CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n          .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n      Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n          .getDecommissioningNodes();\n      if (decommissioningNodes.isEmpty()) {\n        nodesDecommissioning \u003d false;\n        break;\n      } else {\n        StringBuilder nodes \u003d new StringBuilder();\n        for (NodeId nodeId : decommissioningNodes) {\n          nodes.append(nodeId).append(\",\");\n        }\n        nodes.deleteCharAt(nodes.length() - 1);\n        System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n      }\n    }\n    if (nodesDecommissioning) {\n      System.out.println(\"Graceful decommissioning not completed in \" + timeout\n          + \" seconds, issueing forceful decommissioning command.\");\n      RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n          .newInstance(DecommissionType.FORCEFUL);\n      adminProtocol.refreshNodes(forcefulRequest);\n    } else {\n      System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n          + \" seconds.\");\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501": {
      "type": "Yintroduced",
      "commitMessage": "New parameter of CLI for decommissioning node gracefully in RMAdmin CLI. Contributed by Devaraj K\n",
      "commitDate": "22/04/15 10:07 AM",
      "commitName": "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,47 @@\n+  private int refreshNodes(long timeout) throws IOException, YarnException {\n+    // Graceful decommissioning with timeout\n+    ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n+    RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n+        .newInstance(DecommissionType.GRACEFUL);\n+    adminProtocol.refreshNodes(gracefulRequest);\n+    CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n+        .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n+    long waitingTime;\n+    boolean nodesDecommissioning \u003d true;\n+    // timeout\u003d-1 means wait for all the nodes to be gracefully\n+    // decommissioned\n+    for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n+      // wait for one second to check nodes decommissioning status\n+      try {\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+        // Ignore the InterruptedException\n+      }\n+      CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n+          .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n+      Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n+          .getDecommissioningNodes();\n+      if (decommissioningNodes.isEmpty()) {\n+        nodesDecommissioning \u003d false;\n+        break;\n+      } else {\n+        StringBuilder nodes \u003d new StringBuilder();\n+        for (NodeId nodeId : decommissioningNodes) {\n+          nodes.append(nodeId).append(\",\");\n+        }\n+        nodes.deleteCharAt(nodes.length() - 1);\n+        System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n+      }\n+    }\n+    if (nodesDecommissioning) {\n+      System.out.println(\"Graceful decommissioning not completed in \" + timeout\n+          + \" seconds, issueing forceful decommissioning command.\");\n+      RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n+          .newInstance(DecommissionType.FORCEFUL);\n+      adminProtocol.refreshNodes(forcefulRequest);\n+    } else {\n+      System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n+          + \" seconds.\");\n+    }\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int refreshNodes(long timeout) throws IOException, YarnException {\n    // Graceful decommissioning with timeout\n    ResourceManagerAdministrationProtocol adminProtocol \u003d createAdminProtocol();\n    RefreshNodesRequest gracefulRequest \u003d RefreshNodesRequest\n        .newInstance(DecommissionType.GRACEFUL);\n    adminProtocol.refreshNodes(gracefulRequest);\n    CheckForDecommissioningNodesRequest checkForDecommissioningNodesRequest \u003d recordFactory\n        .newRecordInstance(CheckForDecommissioningNodesRequest.class);\n    long waitingTime;\n    boolean nodesDecommissioning \u003d true;\n    // timeout\u003d-1 means wait for all the nodes to be gracefully\n    // decommissioned\n    for (waitingTime \u003d 0; waitingTime \u003c timeout || timeout \u003d\u003d -1; waitingTime++) {\n      // wait for one second to check nodes decommissioning status\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Ignore the InterruptedException\n      }\n      CheckForDecommissioningNodesResponse checkForDecommissioningNodes \u003d adminProtocol\n          .checkForDecommissioningNodes(checkForDecommissioningNodesRequest);\n      Set\u003cNodeId\u003e decommissioningNodes \u003d checkForDecommissioningNodes\n          .getDecommissioningNodes();\n      if (decommissioningNodes.isEmpty()) {\n        nodesDecommissioning \u003d false;\n        break;\n      } else {\n        StringBuilder nodes \u003d new StringBuilder();\n        for (NodeId nodeId : decommissioningNodes) {\n          nodes.append(nodeId).append(\",\");\n        }\n        nodes.deleteCharAt(nodes.length() - 1);\n        System.out.println(\"Nodes \u0027\" + nodes + \"\u0027 are still decommissioning.\");\n      }\n    }\n    if (nodesDecommissioning) {\n      System.out.println(\"Graceful decommissioning not completed in \" + timeout\n          + \" seconds, issueing forceful decommissioning command.\");\n      RefreshNodesRequest forcefulRequest \u003d RefreshNodesRequest\n          .newInstance(DecommissionType.FORCEFUL);\n      adminProtocol.refreshNodes(forcefulRequest);\n    } else {\n      System.out.println(\"Graceful decommissioning completed in \" + waitingTime\n          + \" seconds.\");\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java"
    }
  }
}