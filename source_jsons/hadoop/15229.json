{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSAdmin.java",
  "functionName": "printHelp",
  "functionId": "printHelp___cmd-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
  "functionStartLine": 1114,
  "functionEndLine": 1403,
  "numCommitsSeen": 118,
  "timeTaken": 15490,
  "changeHistory": [
    "9a1d8cfaf50ec29ffb2d8522ba2f4bc6605d8b8b",
    "3f4a29813beccd85191886f4d7421c4f33180594",
    "bc6d9d4c796d3c9d27dbbe3266031bf2adecde4f",
    "42a1c98597e6dba2e371510a6b2b6b1fb94e4090",
    "f8cd55fe33665faf2d1b14df231516fc891118fc",
    "fb68980959f95f0d89e86f91909867724ad01791",
    "8d9084eb62f4593d4dfeb618abacf6ae89019109",
    "93fa48fcf243dc759db1736af145633da760f937",
    "4164a2032a41e7318749efd0301751eb2b369cdc",
    "aede8c10ecad4f2a8802a834e4bd0b8286cebade",
    "d62b4a4de75edb840df6634f49cb4beb74e3fb07",
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
    "0f0e897bf1ff8383f3f524ba83161969531b0772",
    "d112d183242f447d4b742139f3a4ea531a997f45",
    "b2540f486ed99e1433d4e5118608da8dd365a934",
    "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
    "5b0d060d2a868cefcd12252140d5a8e310738aca",
    "baf794dc404ac54f4e8332654eadfac1bebacb8f",
    "1861b32eb551a07d748afc6205ea9573f9503eda",
    "9e941d9f99168cae01f8d50622a616fc26c196d9",
    "185200e7096d15a5c2c2d59b7c7705362820aebf",
    "34e9173c00f7e1ae55dec365850849c793cde8e3",
    "9445859930b8653cb0b9a0e1abf38cc05dbe2658",
    "620809b9a063bd6ea84d582166eed3fb957dcd0a",
    "d00605f8f0214ed8e2304db8688e140f0a1d62d8",
    "c066cef587bdc3c1d33cba47f4fb5ab5d11e5892",
    "1a68f13521e6902943bea7b16369ac9a4e6943f5",
    "5fe73a986e6850b1cc07bc52fe8b920d1437641d",
    "e2efe52ac89e9f8298be139873e7a0d24392ef11",
    "59e968a114dfe1b513f31424211116f23525def8",
    "c334cc89a8f42c98ab4dad02ae41c5a02a855974",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
    "ce1a7ec9755f17527c29b0db713d7e01750e10c9",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "8390152d08306caad31b78abbd509e5ea8580671",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "9a1d8cfaf50ec29ffb2d8522ba2f4bc6605d8b8b": "Ybodychange",
    "3f4a29813beccd85191886f4d7421c4f33180594": "Ybodychange",
    "bc6d9d4c796d3c9d27dbbe3266031bf2adecde4f": "Ybodychange",
    "42a1c98597e6dba2e371510a6b2b6b1fb94e4090": "Ybodychange",
    "f8cd55fe33665faf2d1b14df231516fc891118fc": "Ybodychange",
    "fb68980959f95f0d89e86f91909867724ad01791": "Ybodychange",
    "8d9084eb62f4593d4dfeb618abacf6ae89019109": "Ybodychange",
    "93fa48fcf243dc759db1736af145633da760f937": "Ybodychange",
    "4164a2032a41e7318749efd0301751eb2b369cdc": "Ybodychange",
    "aede8c10ecad4f2a8802a834e4bd0b8286cebade": "Ybodychange",
    "d62b4a4de75edb840df6634f49cb4beb74e3fb07": "Ybodychange",
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe": "Ybodychange",
    "0f0e897bf1ff8383f3f524ba83161969531b0772": "Ybodychange",
    "d112d183242f447d4b742139f3a4ea531a997f45": "Ybodychange",
    "b2540f486ed99e1433d4e5118608da8dd365a934": "Ybodychange",
    "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0": "Ybodychange",
    "5b0d060d2a868cefcd12252140d5a8e310738aca": "Ybodychange",
    "baf794dc404ac54f4e8332654eadfac1bebacb8f": "Ybodychange",
    "1861b32eb551a07d748afc6205ea9573f9503eda": "Ybodychange",
    "9e941d9f99168cae01f8d50622a616fc26c196d9": "Ybodychange",
    "185200e7096d15a5c2c2d59b7c7705362820aebf": "Ybodychange",
    "34e9173c00f7e1ae55dec365850849c793cde8e3": "Ybodychange",
    "9445859930b8653cb0b9a0e1abf38cc05dbe2658": "Ybodychange",
    "620809b9a063bd6ea84d582166eed3fb957dcd0a": "Ybodychange",
    "d00605f8f0214ed8e2304db8688e140f0a1d62d8": "Ybodychange",
    "c066cef587bdc3c1d33cba47f4fb5ab5d11e5892": "Ybodychange",
    "1a68f13521e6902943bea7b16369ac9a4e6943f5": "Ybodychange",
    "5fe73a986e6850b1cc07bc52fe8b920d1437641d": "Ybodychange",
    "e2efe52ac89e9f8298be139873e7a0d24392ef11": "Ybodychange",
    "59e968a114dfe1b513f31424211116f23525def8": "Ybodychange",
    "c334cc89a8f42c98ab4dad02ae41c5a02a855974": "Ybodychange",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": "Ybodychange",
    "ce1a7ec9755f17527c29b0db713d7e01750e10c9": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "8390152d08306caad31b78abbd509e5ea8580671": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9a1d8cfaf50ec29ffb2d8522ba2f4bc6605d8b8b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14678. Allow triggerBlockReport to a specific namenode. (#1252). Contributed by Leon Gao.\n\n",
      "commitDate": "16/08/19 8:00 AM",
      "commitName": "9a1d8cfaf50ec29ffb2d8522ba2f4bc6605d8b8b",
      "commitAuthor": "LeonGao91",
      "commitDateOld": "17/07/19 10:52 AM",
      "commitNameOld": "af0665c7f5b1a28eb2262bae9a577fd908ad79ea",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 29.88,
      "commitsBetweenForRepo": 273,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,290 +1,290 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n         + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n         \"\\tReports basic filesystem information and statistics. \\n\" +\n         \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n         \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n         \"\\tand etc. on all the DNs.\\n\" +\n         \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String upgrade \u003d \"-upgrade \u003cquery | finalize\u003e:\\n\"\n         + \"     query: query the current upgrade status.\\n\"\n         + \"  finalize: finalize the upgrade of HDFS (equivalent to \" +\n         \"-finalizeUpgrade.\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n             \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n             \"\\tTriggers a runtime-refresh of the resource specified by \" +\n             \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n             \"\\tAll other args after are sent to the host.\\n\" +\n             \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n             \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n             \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n             \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n     \n     String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n             \" as argument,For the given datanode,get the volume report.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n             \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n             \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n             \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n             \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n             \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n             \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n             \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n-      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n+      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e [-namenode \u003cnamenode_host:ipc_port\u003e]\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n         + \"\\tList all open files currently managed by the NameNode along\\n\"\n         + \"\\twith client name and client machine accessing them.\\n\"\n         + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n         + \"\\topen files only that are blocking the ongoing Decommission.\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"upgrade\".equals(cmd)) {\n       System.out.println(upgrade);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"getVolumeReport\".equals(cmd)) {\n       System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"triggerBlockReport\".equalsIgnoreCase(cmd)) {\n       System.out.println(triggerBlockReport);\n     } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n       System.out.println(listOpenFiles);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(upgrade);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(listOpenFiles);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n        \"\\tReports basic filesystem information and statistics. \\n\" +\n        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n        \"\\tand etc. on all the DNs.\\n\" +\n        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgrade \u003d \"-upgrade \u003cquery | finalize\u003e:\\n\"\n        + \"     query: query the current upgrade status.\\n\"\n        + \"  finalize: finalize the upgrade of HDFS (equivalent to \" +\n        \"-finalizeUpgrade.\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n            \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n            \"\\tTriggers a runtime-refresh of the resource specified by \" +\n            \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n            \"\\tAll other args after are sent to the host.\\n\" +\n            \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n            \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n            \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n            \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n            \" as argument,For the given datanode,get the volume report.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n            \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n            \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n            \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n            \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n            \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n            \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n            \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e [-namenode \u003cnamenode_host:ipc_port\u003e]\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n        + \"\\tList all open files currently managed by the NameNode along\\n\"\n        + \"\\twith client name and client machine accessing them.\\n\"\n        + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n        + \"\\topen files only that are blocking the ongoing Decommission.\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"upgrade\".equals(cmd)) {\n      System.out.println(upgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"triggerBlockReport\".equalsIgnoreCase(cmd)) {\n      System.out.println(triggerBlockReport);\n    } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n      System.out.println(listOpenFiles);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(upgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(listOpenFiles);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "3f4a29813beccd85191886f4d7421c4f33180594": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13646. DFSAdmin doesn\u0027t display specialized help for triggerBlockReport. Contributed by Takanobu Asanuma.\n",
      "commitDate": "31/05/18 3:26 PM",
      "commitName": "3f4a29813beccd85191886f4d7421c4f33180594",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "23/05/18 10:15 AM",
      "commitNameOld": "bc6d9d4c796d3c9d27dbbe3266031bf2adecde4f",
      "commitAuthorOld": "Bharat Viswanadham",
      "daysBetweenCommits": 8.22,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,288 +1,290 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n         + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n         \"\\tReports basic filesystem information and statistics. \\n\" +\n         \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n         \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n         \"\\tand etc. on all the DNs.\\n\" +\n         \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String upgrade \u003d \"-upgrade \u003cquery | finalize\u003e:\\n\"\n         + \"     query: query the current upgrade status.\\n\"\n         + \"  finalize: finalize the upgrade of HDFS (equivalent to \" +\n         \"-finalizeUpgrade.\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n             \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n             \"\\tTriggers a runtime-refresh of the resource specified by \" +\n             \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n             \"\\tAll other args after are sent to the host.\\n\" +\n             \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n             \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n             \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n             \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n     \n     String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n             \" as argument,For the given datanode,get the volume report.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n             \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n             \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n             \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n             \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n             \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n             \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n             \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n         + \"\\tList all open files currently managed by the NameNode along\\n\"\n         + \"\\twith client name and client machine accessing them.\\n\"\n         + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n         + \"\\topen files only that are blocking the ongoing Decommission.\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"upgrade\".equals(cmd)) {\n       System.out.println(upgrade);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"getVolumeReport\".equals(cmd)) {\n       System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n+    } else if (\"triggerBlockReport\".equalsIgnoreCase(cmd)) {\n+      System.out.println(triggerBlockReport);\n     } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n       System.out.println(listOpenFiles);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(upgrade);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(listOpenFiles);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n        \"\\tReports basic filesystem information and statistics. \\n\" +\n        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n        \"\\tand etc. on all the DNs.\\n\" +\n        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgrade \u003d \"-upgrade \u003cquery | finalize\u003e:\\n\"\n        + \"     query: query the current upgrade status.\\n\"\n        + \"  finalize: finalize the upgrade of HDFS (equivalent to \" +\n        \"-finalizeUpgrade.\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n            \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n            \"\\tTriggers a runtime-refresh of the resource specified by \" +\n            \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n            \"\\tAll other args after are sent to the host.\\n\" +\n            \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n            \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n            \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n            \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n            \" as argument,For the given datanode,get the volume report.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n            \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n            \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n            \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n            \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n            \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n            \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n            \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n        + \"\\tList all open files currently managed by the NameNode along\\n\"\n        + \"\\twith client name and client machine accessing them.\\n\"\n        + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n        + \"\\topen files only that are blocking the ongoing Decommission.\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"upgrade\".equals(cmd)) {\n      System.out.println(upgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"triggerBlockReport\".equalsIgnoreCase(cmd)) {\n      System.out.println(triggerBlockReport);\n    } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n      System.out.println(listOpenFiles);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(upgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(listOpenFiles);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "bc6d9d4c796d3c9d27dbbe3266031bf2adecde4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13589: Add dfsAdmin command to query if upgrade is finalized. Contributed by Hanisha Koneru\n",
      "commitDate": "23/05/18 10:15 AM",
      "commitName": "bc6d9d4c796d3c9d27dbbe3266031bf2adecde4f",
      "commitAuthor": "Bharat Viswanadham",
      "commitDateOld": "07/02/18 9:40 AM",
      "commitNameOld": "01bd6ab18fa48f4c7cac1497905b52e547962599",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 104.98,
      "commitsBetweenForRepo": 1353,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,280 +1,288 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n         + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n         \"\\tReports basic filesystem information and statistics. \\n\" +\n         \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n         \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n         \"\\tand etc. on all the DNs.\\n\" +\n         \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n+    String upgrade \u003d \"-upgrade \u003cquery | finalize\u003e:\\n\"\n+        + \"     query: query the current upgrade status.\\n\"\n+        + \"  finalize: finalize the upgrade of HDFS (equivalent to \" +\n+        \"-finalizeUpgrade.\";\n+\n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n             \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n             \"\\tTriggers a runtime-refresh of the resource specified by \" +\n             \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n             \"\\tAll other args after are sent to the host.\\n\" +\n             \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n             \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n             \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n             \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n     \n     String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n             \" as argument,For the given datanode,get the volume report.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n             \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n             \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n             \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n             \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n             \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n             \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n             \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n         + \"\\tList all open files currently managed by the NameNode along\\n\"\n         + \"\\twith client name and client machine accessing them.\\n\"\n         + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n         + \"\\topen files only that are blocking the ongoing Decommission.\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n+    } else if (\"upgrade\".equals(cmd)) {\n+      System.out.println(upgrade);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"getVolumeReport\".equals(cmd)) {\n       System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n       System.out.println(listOpenFiles);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n+      System.out.println(upgrade);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(listOpenFiles);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n        \"\\tReports basic filesystem information and statistics. \\n\" +\n        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n        \"\\tand etc. on all the DNs.\\n\" +\n        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgrade \u003d \"-upgrade \u003cquery | finalize\u003e:\\n\"\n        + \"     query: query the current upgrade status.\\n\"\n        + \"  finalize: finalize the upgrade of HDFS (equivalent to \" +\n        \"-finalizeUpgrade.\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n            \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n            \"\\tTriggers a runtime-refresh of the resource specified by \" +\n            \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n            \"\\tAll other args after are sent to the host.\\n\" +\n            \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n            \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n            \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n            \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n            \" as argument,For the given datanode,get the volume report.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n            \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n            \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n            \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n            \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n            \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n            \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n            \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n        + \"\\tList all open files currently managed by the NameNode along\\n\"\n        + \"\\twith client name and client machine accessing them.\\n\"\n        + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n        + \"\\topen files only that are blocking the ongoing Decommission.\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"upgrade\".equals(cmd)) {\n      System.out.println(upgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n      System.out.println(listOpenFiles);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(upgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(listOpenFiles);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "42a1c98597e6dba2e371510a6b2b6b1fb94e4090": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11847. Enhance dfsadmin listOpenFiles command to list files blocking datanode decommissioning.\n",
      "commitDate": "02/01/18 2:59 PM",
      "commitName": "42a1c98597e6dba2e371510a6b2b6b1fb94e4090",
      "commitAuthor": "Manoj Govindassamy",
      "commitDateOld": "25/10/17 2:11 PM",
      "commitNameOld": "f66ad1fab958a28ef40c684366c23695237a8e60",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 69.08,
      "commitsBetweenForRepo": 482,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,278 +1,280 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n         + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n         \"\\tReports basic filesystem information and statistics. \\n\" +\n         \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n         \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n         \"\\tand etc. on all the DNs.\\n\" +\n         \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n             \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n             \"\\tTriggers a runtime-refresh of the resource specified by \" +\n             \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n             \"\\tAll other args after are sent to the host.\\n\" +\n             \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n             \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n             \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n             \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n     \n     String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n             \" as argument,For the given datanode,get the volume report.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n             \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n             \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n             \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n             \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n             \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n             \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n             \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n             \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n             \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n-    String listOpenFiles \u003d \"-listOpenFiles\\n\"\n+    String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n         + \"\\tList all open files currently managed by the NameNode along\\n\"\n-        + \"\\twith client name and client machine accessing them.\\n\";\n+        + \"\\twith client name and client machine accessing them.\\n\"\n+        + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n+        + \"\\topen files only that are blocking the ongoing Decommission.\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"getVolumeReport\".equals(cmd)) {\n       System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n       System.out.println(listOpenFiles);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(listOpenFiles);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n        \"\\tReports basic filesystem information and statistics. \\n\" +\n        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n        \"\\tand etc. on all the DNs.\\n\" +\n        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n            \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n            \"\\tTriggers a runtime-refresh of the resource specified by \" +\n            \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n            \"\\tAll other args after are sent to the host.\\n\" +\n            \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n            \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n            \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n            \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n            \" as argument,For the given datanode,get the volume report.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n            \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n            \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n            \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n            \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n            \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n            \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n            \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String listOpenFiles \u003d \"-listOpenFiles [-blockingDecommission]\\n\"\n        + \"\\tList all open files currently managed by the NameNode along\\n\"\n        + \"\\twith client name and client machine accessing them.\\n\"\n        + \"\\tIf \u0027blockingDecommission\u0027 option is specified, it will list the\\n\"\n        + \"\\topen files only that are blocking the ongoing Decommission.\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n      System.out.println(listOpenFiles);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(listOpenFiles);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "f8cd55fe33665faf2d1b14df231516fc891118fc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12067. Correct dfsadmin commands usage message to reflects IPC port. Contributed by steven-wugang.\n",
      "commitDate": "19/07/17 8:21 AM",
      "commitName": "f8cd55fe33665faf2d1b14df231516fc891118fc",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "29/06/17 1:54 PM",
      "commitNameOld": "441378e7e4609d89b7181dacc8ba92b253a962df",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 19.77,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,268 +1,278 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n         + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n         \"\\tReports basic filesystem information and statistics. \\n\" +\n         \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n         \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n         \"\\tand etc. on all the DNs.\\n\" +\n         \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n-    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n-      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n-      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n+    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n+            \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n+            \"\\tTriggers a runtime-refresh of the resource specified by \" +\n+            \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n+            \"\\tAll other args after are sent to the host.\\n\" +\n+            \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n+            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n-    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n-                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n-                              \"\\t\\tstops serving the removed block-pools\\n\"+\n-                              \"\\t\\tand starts serving new block-pools\\n\";\n+    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n+            \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n+            \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n+            \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n+            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n+            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n     \n-    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:port as \"\n-        + \"argument,\\n\\t\\tFor the given datanode, get the volume report\\n\";\n+    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n+            \" as argument,For the given datanode,get the volume report.\\n\" +\n+            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n+            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n-    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n-                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n-                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n-                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n-                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n-                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n-                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n-                             \"\\t\\t service on a datanode.\\n\";\n+    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n+            \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n+            \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n+            \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n+            \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n+            \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n+            \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n+            \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n+            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n+            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String listOpenFiles \u003d \"-listOpenFiles\\n\"\n         + \"\\tList all open files currently managed by the NameNode along\\n\"\n         + \"\\twith client name and client machine accessing them.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"getVolumeReport\".equals(cmd)) {\n       System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n       System.out.println(listOpenFiles);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(listOpenFiles);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n        \"\\tReports basic filesystem information and statistics. \\n\" +\n        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n        \"\\tand etc. on all the DNs.\\n\" +\n        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:ipc_port\u003e\" +\n            \" \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n            \"\\tTriggers a runtime-refresh of the resource specified by \" +\n            \"\u003cresource_identifier\u003e on \u003chostname:ipc_port\u003e.\\n\" +\n            \"\\tAll other args after are sent to the host.\\n\" +\n            \"\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a \" +\n            \"datanodehost:ipc_port as argument,For the given datanode\\n\" +\n            \"\\t\\treloads the configuration files,stops serving the removed\\n\" +\n            \"\\t\\tblock-pools and starts serving new block-pools.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:ipc_port\"+\n            \" as argument,For the given datanode,get the volume report.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are \" +\n            \"datanodehost:ipc_port, blockpool id and an optional argument\\n\" +\n            \"\\t\\t\\\"force\\\". If force is passed,block pool directory for\\n\" +\n            \"\\t\\tthe given blockpool id on the given datanode is deleted\\n\" +\n            \"\\t\\talong with its contents,otherwise the directory is deleted\\n\"+\n            \"\\t\\tonly if it is empty.The command will fail if datanode is\\n\" +\n            \"\\t\\tstill serving the block pool.Refer to refreshNamenodes to\\n\" +\n            \"\\t\\tshutdown a block pool service on a datanode.\\n\" +\n            \"\\t\\tThe ipc_port is determined by \u0027dfs.datanode.ipc.address\u0027,\" +\n            \"default is DFS_DATANODE_IPC_DEFAULT_PORT.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String listOpenFiles \u003d \"-listOpenFiles\\n\"\n        + \"\\tList all open files currently managed by the NameNode along\\n\"\n        + \"\\twith client name and client machine accessing them.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n      System.out.println(listOpenFiles);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(listOpenFiles);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "fb68980959f95f0d89e86f91909867724ad01791": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10480. Add an admin command to list currently open files. Contributed by Manoj Govindassamy.\n",
      "commitDate": "15/06/17 2:46 PM",
      "commitName": "fb68980959f95f0d89e86f91909867724ad01791",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "14/06/17 10:44 AM",
      "commitNameOld": "999c8fcbefc876d9c26c23c5b87a64a81e4f113e",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,261 +1,268 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n         + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n         \"\\tReports basic filesystem information and statistics. \\n\" +\n         \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n         \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n         \"\\tand etc. on all the DNs.\\n\" +\n         \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:port as \"\n         + \"argument,\\n\\t\\tFor the given datanode, get the volume report\\n\";\n \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n+    String listOpenFiles \u003d \"-listOpenFiles\\n\"\n+        + \"\\tList all open files currently managed by the NameNode along\\n\"\n+        + \"\\twith client name and client machine accessing them.\\n\";\n+\n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"getVolumeReport\".equals(cmd)) {\n       System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n+    } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n+      System.out.println(listOpenFiles);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n+      System.out.println(listOpenFiles);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n        \"\\tReports basic filesystem information and statistics. \\n\" +\n        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n        \"\\tand etc. on all the DNs.\\n\" +\n        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:port as \"\n        + \"argument,\\n\\t\\tFor the given datanode, get the volume report\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String listOpenFiles \u003d \"-listOpenFiles\\n\"\n        + \"\\tList all open files currently managed by the NameNode along\\n\"\n        + \"\\twith client name and client machine accessing them.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"listOpenFiles\".equalsIgnoreCase(cmd)) {\n      System.out.println(listOpenFiles);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(listOpenFiles);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "8d9084eb62f4593d4dfeb618abacf6ae89019109": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11359. DFSAdmin report command supports displaying maintenance state datanodes. Contributed by Yiqun Lin.\n",
      "commitDate": "01/06/17 9:48 PM",
      "commitName": "8d9084eb62f4593d4dfeb618abacf6ae89019109",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "16/05/17 9:41 AM",
      "commitNameOld": "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 16.5,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,260 +1,261 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n-    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n-      \"\\tReports basic filesystem information and statistics. \\n\" +\n-      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n-      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n-      \"\\tand etc. on all the DNs.\\n\" +\n-      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n+    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n+        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n+        \"\\tReports basic filesystem information and statistics. \\n\" +\n+        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n+        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n+        \"\\tand etc. on all the DNs.\\n\" +\n+        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:port as \"\n         + \"argument,\\n\\t\\tFor the given datanode, get the volume report\\n\";\n \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"getVolumeReport\".equals(cmd)) {\n       System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning] \"\n        + \"[-enteringmaintenance] [-inmaintenance]:\\n\" +\n        \"\\tReports basic filesystem information and statistics. \\n\" +\n        \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n        \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n        \"\\tand etc. on all the DNs.\\n\" +\n        \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:port as \"\n        + \"argument,\\n\\t\\tFor the given datanode, get the volume report\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "93fa48fcf243dc759db1736af145633da760f937": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11417. Add datanode admin command to get the storage info. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "26/04/17 1:43 AM",
      "commitName": "93fa48fcf243dc759db1736af145633da760f937",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "28/02/17 9:15 PM",
      "commitNameOld": "dcd03df9f9e0080d7e179060ffc8148336c31b3e",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 56.14,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,255 +1,260 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics. \\n\" +\n       \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n       \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n       \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n+    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:port as \"\n+        + \"argument,\\n\\t\\tFor the given datanode, get the volume report\\n\";\n+\n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n+    } else if (\"getVolumeReport\".equals(cmd)) {\n+      System.out.println(getVolumeReport);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String getVolumeReport \u003d \"-getVolumeReport: Takes a datanodehost:port as \"\n        + \"argument,\\n\\t\\tFor the given datanode, get the volume report\\n\";\n\n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"getVolumeReport\".equals(cmd)) {\n      System.out.println(getVolumeReport);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "4164a2032a41e7318749efd0301751eb2b369cdc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11408. The config name of balance bandwidth is out of date. Contributed by Yiqun Lin.\n",
      "commitDate": "14/02/17 2:57 AM",
      "commitName": "4164a2032a41e7318749efd0301751eb2b369cdc",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "13/10/16 9:35 AM",
      "commitNameOld": "129125404244f35ee63b8f0491a095371685e9ba",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 123.77,
      "commitsBetweenForRepo": 761,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,255 +1,255 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics. \\n\" +\n       \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n       \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n       \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n-      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n+      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n         + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n       System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.datanode.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "aede8c10ecad4f2a8802a834e4bd0b8286cebade": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9945. Datanode command for evicting writers. Contributed by Kihwal Lee\n",
      "commitDate": "06/04/16 1:20 PM",
      "commitName": "aede8c10ecad4f2a8802a834e4bd0b8286cebade",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "08/02/16 1:47 PM",
      "commitNameOld": "bffaa38a91b26920206a3350bf1cd60ec950aa74",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 57.94,
      "commitsBetweenForRepo": 366,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,248 +1,255 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics. \\n\" +\n       \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n       \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n       \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n         \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n \n         \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n+    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n+        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n+        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n+\n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n+    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n+      System.out.println(evictWriters);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n+      System.out.println(evictWriters);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String evictWriters \u003d \"-evictWriters \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tMake the datanode evict all clients that are writing a block.\\n\"\n        + \"\\tThis is useful if decommissioning is hung due to slow writers.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"evictWriters\".equalsIgnoreCase(cmd)) {\n      System.out.println(evictWriters);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(evictWriters);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "d62b4a4de75edb840df6634f49cb4beb74e3fb07": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9094. Add command line option to ask NameNode reload configuration. (Contributed by Xiaobing Zhou)\n",
      "commitDate": "25/01/16 12:17 PM",
      "commitName": "d62b4a4de75edb840df6634f49cb4beb74e3fb07",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "24/01/16 2:19 PM",
      "commitNameOld": "10a2bc0dffaece216eb9a6bac3236a086b9ece31",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,248 +1,248 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics. \\n\" +\n       \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n       \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n       \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n         \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n-    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status|properties\u003e:\\n\" +\n+    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n+        \"\u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n-        \"\\tThe second parameter specifies the node type.\\n\" +\n-        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n+        \"\\tThe second parameter specifies the node type\\n\";\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cnamenode|datanode\u003e \u003chost:ipc_port\u003e \" +\n        \"\u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n\n        \"\\tThe second parameter specifies the node type\\n\";\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4015. Safemode should count and report orphaned blocks. (Contributed by Anu Engineer)\n",
      "commitDate": "23/10/15 6:07 PM",
      "commitName": "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/09/15 8:52 PM",
      "commitNameOld": "63d9f1596c92206cce3b72e3214d2fb5f6242b90",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 30.89,
      "commitsBetweenForRepo": 255,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,247 +1,248 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics. \\n\" +\n       \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n       \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n       \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n-    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n+    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n+        \"maintenance command.\\n\" +\n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n         \"\\tThe second parameter specifies the node type.\\n\" +\n         \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n \n     String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n         \"\\tGet the network bandwidth for the given datanode.\\n\" +\n         \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n         \"\\tduring HDFS block balancing.\\n\\n\" +\n         \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"getBalancerBandwidth\".equals(cmd)) {\n       System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait|forceExit\u003e:  Safe mode \" +\n        \"maintenance command.\\n\" +\n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "0f0e897bf1ff8383f3f524ba83161969531b0772": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7116. Add a command to get the balancer bandwidth (Contributed by Rakesh R)\n",
      "commitDate": "09/09/15 10:28 AM",
      "commitName": "0f0e897bf1ff8383f3f524ba83161969531b0772",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "28/08/15 2:38 PM",
      "commitNameOld": "e2c9b288b223b9fd82dc12018936e13128413492",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 11.83,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,238 +1,247 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics. \\n\" +\n       \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n       \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n       \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status|properties\u003e:\\n\" +\n         \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n         \"\\tor gets a list of reconfigurable properties.\\n\" +\n         \"\\tThe second parameter specifies the node type.\\n\" +\n         \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n-    \n+\n+    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n+        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n+        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n+        \"\\tduring HDFS block balancing.\\n\\n\" +\n+        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n+\n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n+    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n+      System.out.println(getBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n+      System.out.println(getBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n\n    String getBalancerBandwidth \u003d \"-getBalancerBandwidth \u003cdatanode_host:ipc_port\u003e:\\n\" +\n        \"\\tGet the network bandwidth for the given datanode.\\n\" +\n        \"\\tThis is the maximum network bandwidth used by the datanode\\n\" +\n        \"\\tduring HDFS block balancing.\\n\\n\" +\n        \"\\t--- NOTE: This value is not persistent on the DataNode.---\\n\";\n\n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"getBalancerBandwidth\".equals(cmd)) {\n      System.out.println(getBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(getBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "d112d183242f447d4b742139f3a4ea531a997f45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8582. Support getting a list of reconfigurable config properties and do not generate spurious reconfig warnings (Lei (Eddy) Xu via Colin P.  McCabe)\n",
      "commitDate": "19/06/15 7:14 PM",
      "commitName": "d112d183242f447d4b742139f3a4ea531a997f45",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "04/06/15 3:35 PM",
      "commitNameOld": "b2540f486ed99e1433d4e5118608da8dd365a934",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 15.15,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,237 +1,238 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics. \\n\" +\n       \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n       \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n       \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n-    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n-        \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n+    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status|properties\u003e:\\n\" +\n+        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n+        \"\\tor gets a list of reconfigurable properties.\\n\" +\n         \"\\tThe second parameter specifies the node type.\\n\" +\n         \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status|properties\u003e:\\n\" +\n        \"\\tStarts or gets the status of a reconfiguration operation, \\n\" +\n        \"\\tor gets a list of reconfigurable properties.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "b2540f486ed99e1433d4e5118608da8dd365a934": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8535. Clarify that dfs usage in dfsadmin -report output includes all block replicas. Contributed by Eddy Xu.\n",
      "commitDate": "04/06/15 3:35 PM",
      "commitName": "b2540f486ed99e1433d4e5118608da8dd365a934",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/04/15 12:23 PM",
      "commitNameOld": "0d5b0143cc003e132ce454415e35d55d46311416",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 38.13,
      "commitsBetweenForRepo": 398,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,235 +1,237 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n-      \"\\tReports basic filesystem information and statistics.\\n\" +\n+      \"\\tReports basic filesystem information and statistics. \\n\" +\n+      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n+      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n+      \"\\tand etc. on all the DNs.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n-    \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n         \"Save current namespace into storage directories and reset edits \\n\" +\n         \"\\t\\t log. Requires safe mode.\\n\" +\n         \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n         \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n         \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n         \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n         \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n         \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n         \"\\tThe second parameter specifies the node type.\\n\" +\n         \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics. \\n\" +\n      \"\\tThe dfs usage can be different from \\\"du\\\" usage, because it\\n\" +\n      \"\\tmeasures raw space used by replication, checksums, snapshots\\n\" +\n      \"\\tand etc. on all the DNs.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n        \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6353. Check and make checkpoint before stopping the NameNode. Contributed by Jing Zhao.\n",
      "commitDate": "25/03/15 10:38 AM",
      "commitName": "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/03/15 1:08 AM",
      "commitNameOld": "3560180b6e9926aa3ee1357da59b28a4b4689a0d",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 21.35,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,230 +1,235 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n     \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n-    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n-    \"Save current namespace into storage directories and reset edits log.\\n\" +\n-    \"\\t\\tRequires safe mode.\\n\";\n+    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n+        \"Save current namespace into storage directories and reset edits \\n\" +\n+        \"\\t\\t log. Requires safe mode.\\n\" +\n+        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n+        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n+        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n+        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n+        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n         \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n         \"\\tThe second parameter specifies the node type.\\n\" +\n         \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace [-beforeShutdown]:\\t\" +\n        \"Save current namespace into storage directories and reset edits \\n\" +\n        \"\\t\\t log. Requires safe mode.\\n\" +\n        \"\\t\\tIf the \\\"beforeShutdown\\\" option is given, the NameNode does a \\n\" +\n        \"\\t\\tcheckpoint if and only if there is no checkpoint done during \\n\" +\n        \"\\t\\ta time window (a configurable number of checkpoint periods).\\n\" +\n        \"\\t\\tThis is usually used before shutting down the NameNode to \\n\" +\n        \"\\t\\tprevent potential fsimage/editlog corruption.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n        \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "5b0d060d2a868cefcd12252140d5a8e310738aca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7323. Move the get/setStoragePolicy commands out from dfsadmin. (jing9 via yliu)\n",
      "commitDate": "11/01/15 8:35 AM",
      "commitName": "5b0d060d2a868cefcd12252140d5a8e310738aca",
      "commitAuthor": "yliu",
      "commitDateOld": "11/12/14 12:36 PM",
      "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 30.83,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,242 +1,230 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n     \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n         \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n         \"\\tThe second parameter specifies the node type.\\n\" +\n         \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n-    String setStoragePolicy \u003d \"-setStoragePolicy path policyName\\n\"\n-        + \"\\tSet the storage policy for a file/directory.\\n\";\n-\n-    String getStoragePolicy \u003d \"-getStoragePolicy path\\n\"\n-        + \"\\tGet the storage policy for a file/directory.\\n\";\n-\n     String triggerBlockReport \u003d\n       \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tTrigger a block report for the datanode.\\n\"\n         + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n         + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n-    } else if (\"setStoragePolicy\".equalsIgnoreCase(cmd))  {\n-      System.out.println(setStoragePolicy);\n-    } else if (\"getStoragePolicy\".equalsIgnoreCase(cmd))  {\n-      System.out.println(getStoragePolicy);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n-      System.out.println(setStoragePolicy);\n-      System.out.println(getStoragePolicy);\n       System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n        \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "baf794dc404ac54f4e8332654eadfac1bebacb8f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7278. Add a command that allows sysadmins to manually trigger full block reports from a DN (cmccabe)\n",
      "commitDate": "27/10/14 9:53 AM",
      "commitName": "baf794dc404ac54f4e8332654eadfac1bebacb8f",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "23/10/14 12:28 PM",
      "commitNameOld": "8c5b23b5473e447384f818d69d907d5c35ed6d6a",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,235 +1,242 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n     \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n         \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n         \"\\tThe second parameter specifies the node type.\\n\" +\n         \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String setStoragePolicy \u003d \"-setStoragePolicy path policyName\\n\"\n         + \"\\tSet the storage policy for a file/directory.\\n\";\n \n     String getStoragePolicy \u003d \"-getStoragePolicy path\\n\"\n         + \"\\tGet the storage policy for a file/directory.\\n\";\n \n+    String triggerBlockReport \u003d\n+      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n+        + \"\\tTrigger a block report for the datanode.\\n\"\n+        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n+        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n+\n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"reconfig\".equals(cmd)) {\n       System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"setStoragePolicy\".equalsIgnoreCase(cmd))  {\n       System.out.println(setStoragePolicy);\n     } else if (\"getStoragePolicy\".equalsIgnoreCase(cmd))  {\n       System.out.println(getStoragePolicy);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(setStoragePolicy);\n       System.out.println(getStoragePolicy);\n+      System.out.println(triggerBlockReport);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n        \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String setStoragePolicy \u003d \"-setStoragePolicy path policyName\\n\"\n        + \"\\tSet the storage policy for a file/directory.\\n\";\n\n    String getStoragePolicy \u003d \"-getStoragePolicy path\\n\"\n        + \"\\tGet the storage policy for a file/directory.\\n\";\n\n    String triggerBlockReport \u003d\n      \"-triggerBlockReport [-incremental] \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tTrigger a block report for the datanode.\\n\"\n        + \"\\tIf \u0027incremental\u0027 is specified, it will be an incremental\\n\"\n        + \"\\tblock report; otherwise, it will be a full block report.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"setStoragePolicy\".equalsIgnoreCase(cmd))  {\n      System.out.println(setStoragePolicy);\n    } else if (\"getStoragePolicy\".equalsIgnoreCase(cmd))  {\n      System.out.println(getStoragePolicy);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(setStoragePolicy);\n      System.out.println(getStoragePolicy);\n      System.out.println(triggerBlockReport);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "1861b32eb551a07d748afc6205ea9573f9503eda": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6808. Add command line option to ask DataNode reload configuration. (Lei Xu via Colin McCabe)\n",
      "commitDate": "25/09/14 1:11 PM",
      "commitName": "1861b32eb551a07d748afc6205ea9573f9503eda",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "24/09/14 7:11 PM",
      "commitNameOld": "428a76663a0de5d0d74cc9525273ddc470760e44",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.75,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,227 +1,235 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n       \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hdfs dfsadmin\\n\" +\n       commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n     \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n+    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n+        \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n+        \"\\tThe second parameter specifies the node type.\\n\" +\n+        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n+\n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n-      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\";\n+      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n \n     String setStoragePolicy \u003d \"-setStoragePolicy path policyName\\n\"\n         + \"\\tSet the storage policy for a file/directory.\\n\";\n \n     String getStoragePolicy \u003d \"-getStoragePolicy path\\n\"\n         + \"\\tGet the storage policy for a file/directory.\\n\";\n \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n+    } else if (\"reconfig\".equals(cmd)) {\n+      System.out.println(reconfig);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"setStoragePolicy\".equalsIgnoreCase(cmd))  {\n       System.out.println(setStoragePolicy);\n     } else if (\"getStoragePolicy\".equalsIgnoreCase(cmd))  {\n       System.out.println(getStoragePolicy);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n+      System.out.println(reconfig);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(setStoragePolicy);\n       System.out.println(getStoragePolicy);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String reconfig \u003d \"-reconfig \u003cdatanode|...\u003e \u003chost:ipc_port\u003e \u003cstart|status\u003e:\\n\" +\n        \"\\tStarts reconfiguration or gets the status of an ongoing reconfiguration.\\n\" +\n        \"\\tThe second parameter specifies the node type.\\n\" +\n        \"\\tCurrently, only reloading DataNode\u0027s configuration is supported.\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String setStoragePolicy \u003d \"-setStoragePolicy path policyName\\n\"\n        + \"\\tSet the storage policy for a file/directory.\\n\";\n\n    String getStoragePolicy \u003d \"-getStoragePolicy path\\n\"\n        + \"\\tGet the storage policy for a file/directory.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"reconfig\".equals(cmd)) {\n      System.out.println(reconfig);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"setStoragePolicy\".equalsIgnoreCase(cmd))  {\n      System.out.println(setStoragePolicy);\n    } else if (\"getStoragePolicy\".equalsIgnoreCase(cmd))  {\n      System.out.println(getStoragePolicy);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(reconfig);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(setStoragePolicy);\n      System.out.println(getStoragePolicy);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "9e941d9f99168cae01f8d50622a616fc26c196d9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6831. Inconsistency between \u0027hdfs dfsadmin\u0027 and \u0027hdfs dfsadmin -help\u0027. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "05/09/14 10:45 AM",
      "commitName": "9e941d9f99168cae01f8d50622a616fc26c196d9",
      "commitAuthor": "arp",
      "commitDateOld": "22/08/14 11:14 AM",
      "commitNameOld": "e6c36500705d3d756de82ee0ce9ff226f34b938f",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 13.98,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,242 +1,215 @@\n   private void printHelp(String cmd) {\n-    String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n+    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n+      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n-      \"hadoop dfsadmin\\n\" +\n-      \"\\t[-report [-live] [-dead] [-decommissioning]]\\n\" +\n-      \"\\t[-safemode \u003center | leave | get | wait\u003e]\\n\" +\n-      \"\\t[-saveNamespace]\\n\" +\n-      \"\\t[-rollEdits]\\n\" +\n-      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n-      \"\\t[-refreshNodes]\\n\" +\n-      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n-      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n-      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n-      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n-      \"\\t[-finalizeUpgrade]\\n\" +\n-      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n-      \"\\t[-refreshServiceAcl]\\n\" +\n-      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n-      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n-      \"\\t[-refreshCallQueue]\\n\" +\n-      \"\\t[-refresh \u003chost:ipc_port\u003e \u003ckey\u003e [arg1..argn]\\n\" +\n-      \"\\t[-printTopology]\\n\" +\n-      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n-      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n-      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n-      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n-      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n-      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n-      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n-      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n-      \"\\t[-help [cmd]]\\n\";\n+      \"hdfs dfsadmin\\n\" +\n+      commonUsageSummary;\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n     \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n-    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n+    \"\\t\\tRequires safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n-    \"Rolls the edit log.\\n\" +\n-    \"\\t\\tRequires superuser permissions.\\n\";\n+    \"Rolls the edit log.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n-    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n-    \"\\t\\tRequires superuser permissions.\\n\";\n+    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hdfs dfsadmin performs DFS administrative commands.\\n\" +\n      \"Note: Administrative commands can only be run with superuser permission.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hdfs dfsadmin\\n\" +\n      commonUsageSummary;\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "185200e7096d15a5c2c2d59b7c7705362820aebf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6876. Archival Storage: support set/get storage policy in DFSAdmin. Contributed by Jing Zhao.\n",
      "commitDate": "04/09/14 8:14 PM",
      "commitName": "185200e7096d15a5c2c2d59b7c7705362820aebf",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "22/08/14 11:14 AM",
      "commitNameOld": "e6c36500705d3d756de82ee0ce9ff226f34b938f",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 13.37,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,242 +1,256 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin\\n\" +\n       \"\\t[-report [-live] [-dead] [-decommissioning]]\\n\" +\n       \"\\t[-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-finalizeUpgrade]\\n\" +\n       \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-refreshCallQueue]\\n\" +\n       \"\\t[-refresh \u003chost:ipc_port\u003e \u003ckey\u003e [arg1..argn]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n       \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n+      \"\\t[-setStoragePolicy path policyName\\n\" +\n+      \"\\t[-getStoragePolicy path\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n     \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n       \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n       \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n-    \n+\n+    String setStoragePolicy \u003d \"-setStoragePolicy path policyName\\n\"\n+        + \"\\tSet the storage policy for a file/directory.\\n\";\n+\n+    String getStoragePolicy \u003d \"-getStoragePolicy path\\n\"\n+        + \"\\tGet the storage policy for a file/directory.\\n\";\n+\n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"refresh\".equals(cmd)) {\n       System.out.println(genericRefresh);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n+    } else if (\"setStoragePolicy\".equalsIgnoreCase(cmd))  {\n+      System.out.println(setStoragePolicy);\n+    } else if (\"getStoragePolicy\".equalsIgnoreCase(cmd))  {\n+      System.out.println(getStoragePolicy);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(genericRefresh);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n+      System.out.println(setStoragePolicy);\n+      System.out.println(getStoragePolicy);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin\\n\" +\n      \"\\t[-report [-live] [-dead] [-decommissioning]]\\n\" +\n      \"\\t[-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-finalizeUpgrade]\\n\" +\n      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-refreshCallQueue]\\n\" +\n      \"\\t[-refresh \u003chost:ipc_port\u003e \u003ckey\u003e [arg1..argn]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n      \"\\t[-setStoragePolicy path policyName\\n\" +\n      \"\\t[-getStoragePolicy path\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n\n    String setStoragePolicy \u003d \"-setStoragePolicy path policyName\\n\"\n        + \"\\tSet the storage policy for a file/directory.\\n\";\n\n    String getStoragePolicy \u003d \"-getStoragePolicy path\\n\"\n        + \"\\tGet the storage policy for a file/directory.\\n\";\n\n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"setStoragePolicy\".equalsIgnoreCase(cmd))  {\n      System.out.println(setStoragePolicy);\n    } else if (\"getStoragePolicy\".equalsIgnoreCase(cmd))  {\n      System.out.println(getStoragePolicy);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(setStoragePolicy);\n      System.out.println(getStoragePolicy);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "34e9173c00f7e1ae55dec365850849c793cde8e3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10376. Refactor refresh*Protocols into a single generic refreshConfigProtocol. (Contributed by Chris Li)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1602055 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/14 6:27 PM",
      "commitName": "34e9173c00f7e1ae55dec365850849c793cde8e3",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "11/06/14 10:12 AM",
      "commitNameOld": "49fecbd4026ec7b8309cd28740239f536d73d388",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,234 +1,242 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin\\n\" +\n       \"\\t[-report [-live] [-dead] [-decommissioning]]\\n\" +\n       \"\\t[-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-finalizeUpgrade]\\n\" +\n       \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-refreshCallQueue]\\n\" +\n+      \"\\t[-refresh \u003chost:ipc_port\u003e \u003ckey\u003e [arg1..argn]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n       \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n       \"\\tReports basic filesystem information and statistics.\\n\" +\n       \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n     \n \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n+    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n+      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n+      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\";\n+\n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n+    } else if (\"refresh\".equals(cmd)) {\n+      System.out.println(genericRefresh);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n+      System.out.println(genericRefresh);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin\\n\" +\n      \"\\t[-report [-live] [-dead] [-decommissioning]]\\n\" +\n      \"\\t[-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-finalizeUpgrade]\\n\" +\n      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-refreshCallQueue]\\n\" +\n      \"\\t[-refresh \u003chost:ipc_port\u003e \u003ckey\u003e [arg1..argn]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String genericRefresh \u003d \"-refresh: Arguments are \u003chostname:port\u003e \u003cresource_identifier\u003e [arg1..argn]\\n\" +\n      \"\\tTriggers a runtime-refresh of the resource specified by \u003cresource_identifier\u003e\\n\" +\n      \"\\ton \u003chostname:port\u003e. All other args after are sent to the host.\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"refresh\".equals(cmd)) {\n      System.out.println(genericRefresh);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(genericRefresh);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "9445859930b8653cb0b9a0e1abf38cc05dbe2658": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6295. Add decommissioning state and node state filtering to dfsadmin. Contributed by Andrew Wang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1592438 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/14 8:38 PM",
      "commitName": "9445859930b8653cb0b9a0e1abf38cc05dbe2658",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "28/04/14 11:04 PM",
      "commitNameOld": "02d28907beab7110abf768fd4006b076a6bf2bd2",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,229 +1,234 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n-      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n+      \"hadoop dfsadmin\\n\" +\n+      \"\\t[-report [-live] [-dead] [-decommissioning]]\\n\" +\n+      \"\\t[-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-finalizeUpgrade]\\n\" +\n       \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-refreshCallQueue]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n       \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n-    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n-        \n+    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n+      \"\\tReports basic filesystem information and statistics.\\n\" +\n+      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n+    \n+\n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin\\n\" +\n      \"\\t[-report [-live] [-dead] [-decommissioning]]\\n\" +\n      \"\\t[-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-finalizeUpgrade]\\n\" +\n      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-refreshCallQueue]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report [-live] [-dead] [-decommissioning]:\\n\" +\n      \"\\tReports basic filesystem information and statistics.\\n\" +\n      \"\\tOptional flags may be used to filter the list of displayed DNs.\\n\";\n    \n\n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "620809b9a063bd6ea84d582166eed3fb957dcd0a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6190. Minor textual fixes in DFSClient. Contributed by Charles Lamb.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1584376 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/14 1:18 PM",
      "commitName": "620809b9a063bd6ea84d582166eed3fb957dcd0a",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/02/14 5:14 PM",
      "commitNameOld": "0a7db7f1791200669a4e0bce1debbf7428b30e96",
      "commitAuthorOld": "",
      "daysBetweenCommits": 33.79,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,229 +1,229 @@\n   private void printHelp(String cmd) {\n-    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n+    String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-finalizeUpgrade]\\n\" +\n       \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-refreshCallQueue]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n       \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n     String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n         + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n         + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n         + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n         + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n         + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n         + \"\\tfast start-up mode will also be disabled.\\n\";\n \n     String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n         + \"\\tGet the information about the given datanode. This command can\\n\"\n         + \"\\tbe used for checking if a datanode is alive.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"refreshCallQueue\".equals(cmd)) {\n       System.out.println(refreshCallQueue);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(refreshCallQueue);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin performs DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-finalizeUpgrade]\\n\" +\n      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-refreshCallQueue]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "d00605f8f0214ed8e2304db8688e140f0a1d62d8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10285. Admin interface to swap callqueue at runtime. (Contributed by Chris Li)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573052 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/14 11:48 AM",
      "commitName": "d00605f8f0214ed8e2304db8688e140f0a1d62d8",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "25/01/14 12:01 PM",
      "commitNameOld": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 33.99,
      "commitsBetweenForRepo": 289,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,204 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n+      \"\\t[-refreshCallQueue]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n+    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n+\n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n+    } else if (\"refreshCallQueue\".equals(cmd)) {\n+      System.out.println(refreshCallQueue);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n+      System.out.println(refreshCallQueue);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-refreshCallQueue]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String refreshCallQueue \u003d \"-refreshCallQueue: Reload the call queue from config\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"refreshCallQueue\".equals(cmd)) {\n      System.out.println(refreshCallQueue);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(refreshCallQueue);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "c066cef587bdc3c1d33cba47f4fb5ab5d11e5892": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6004. Change DFSAdmin for rolling upgrade commands. (Contributed by szetszwo)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571463 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/02/14 2:05 PM",
      "commitName": "c066cef587bdc3c1d33cba47f4fb5ab5d11e5892",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "14/02/14 1:20 PM",
      "commitNameOld": "1a68f13521e6902943bea7b16369ac9a4e6943f5",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 10.03,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,223 +1,223 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-finalizeUpgrade]\\n\" +\n       \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n       \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n \n-    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\" +\n-        \"\\tShut down the datanode. If an optional argument \\\"upgrade\\\" is\\n\" +\n-        \"\\tpassed, the clients will be advised to wait for the datanode to\\n\" +\n-        \"\\trestart and the fast start-up mode will be enabled. Clients will\\n\" +\n-        \"\\ttimeout and ignore the datanode, if the restart does not happen\\n\" +\n-        \"\\tin time. The fast start-up mode will also be disabled, if restart\\n\" +\n-        \"\\tis delayed too much.\\n\";\n+    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n+        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n+        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n+        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n+        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n+        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n+        + \"\\tfast start-up mode will also be disabled.\\n\";\n \n-    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n-        \"\\tCheck the datanode for liveness. If the datanode responds,\\n\" +\n-        \"\\timore information about the datanode is printed.\\n\";\n+    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n+        + \"\\tGet the information about the given datanode. This command can\\n\"\n+        + \"\\tbe used for checking if a datanode is alive.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n       System.out.println(shutdownDatanode);\n     } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n       System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(shutdownDatanode);\n       System.out.println(getDatanodeInfo);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-finalizeUpgrade]\\n\" +\n      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\"\n        + \"\\tSubmit a shutdown request for the given datanode. If an optional\\n\"\n        + \"\\t\\\"upgrade\\\" argument is specified, clients accessing the datanode\\n\"\n        + \"\\twill be advised to wait for it to restart and the fast start-up\\n\"\n        + \"\\tmode will be enabled. When the restart does not happen in time,\\n\"\n        + \"\\tclients will timeout and ignore the datanode. In such case, the\\n\"\n        + \"\\tfast start-up mode will also be disabled.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\"\n        + \"\\tGet the information about the given datanode. This command can\\n\"\n        + \"\\tbe used for checking if a datanode is alive.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "1a68f13521e6902943bea7b16369ac9a4e6943f5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5585. Provide admin commands for data node upgrade. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1568523 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/02/14 1:20 PM",
      "commitName": "1a68f13521e6902943bea7b16369ac9a4e6943f5",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "06/02/14 6:08 PM",
      "commitNameOld": "c780454413caffbc37a02c4252eb5ec7abe57f97",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 7.8,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,223 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-finalizeUpgrade]\\n\" +\n       \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n+      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n+      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n+\n+    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\" +\n+        \"\\tShut down the datanode. If an optional argument \\\"upgrade\\\" is\\n\" +\n+        \"\\tpassed, the clients will be advised to wait for the datanode to\\n\" +\n+        \"\\trestart and the fast start-up mode will be enabled. Clients will\\n\" +\n+        \"\\ttimeout and ignore the datanode, if the restart does not happen\\n\" +\n+        \"\\tin time. The fast start-up mode will also be disabled, if restart\\n\" +\n+        \"\\tis delayed too much.\\n\";\n+\n+    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n+        \"\\tCheck the datanode for liveness. If the datanode responds,\\n\" +\n+        \"\\timore information about the datanode is printed.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n+    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n+      System.out.println(shutdownDatanode);\n+    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n+      System.out.println(getDatanodeInfo);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n+      System.out.println(shutdownDatanode);\n+      System.out.println(getDatanodeInfo);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-finalizeUpgrade]\\n\" +\n      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]]\\n\" +\n      \"\\t[-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n\n    String shutdownDatanode \u003d \"-shutdownDatanode \u003cdatanode_host:ipc_port\u003e [upgrade]\\n\" +\n        \"\\tShut down the datanode. If an optional argument \\\"upgrade\\\" is\\n\" +\n        \"\\tpassed, the clients will be advised to wait for the datanode to\\n\" +\n        \"\\trestart and the fast start-up mode will be enabled. Clients will\\n\" +\n        \"\\ttimeout and ignore the datanode, if the restart does not happen\\n\" +\n        \"\\tin time. The fast start-up mode will also be disabled, if restart\\n\" +\n        \"\\tis delayed too much.\\n\";\n\n    String getDatanodeInfo \u003d \"-getDatanodeInfo \u003cdatanode_host:ipc_port\u003e\\n\" +\n        \"\\tCheck the datanode for liveness. If the datanode responds,\\n\" +\n        \"\\timore information about the datanode is printed.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"shutdownDatanode\".equalsIgnoreCase(cmd)) {\n      System.out.println(shutdownDatanode);\n    } else if (\"getDatanodeInfo\".equalsIgnoreCase(cmd)) {\n      System.out.println(getDatanodeInfo);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(shutdownDatanode);\n      System.out.println(getDatanodeInfo);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "5fe73a986e6850b1cc07bc52fe8b920d1437641d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5752. Add a new DFSAdmin command to query, start and finalize rolling upgrade.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1558299 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/01/14 9:56 PM",
      "commitName": "5fe73a986e6850b1cc07bc52fe8b920d1437641d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/12/13 10:01 AM",
      "commitNameOld": "045dc880e13271737b3cf316296e92fb95806663",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 39.5,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,203 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n+      \"\\t[-finalizeUpgrade]\\n\" +\n+      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n-      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n+      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n+    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n+      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n+      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-finalizeUpgrade]\\n\" +\n      \"\\t[\" + RollingUpgradeCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[-refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (RollingUpgradeCommand.matches(\"-\"+cmd)) {\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(RollingUpgradeCommand.DESCRIPTION);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "e2efe52ac89e9f8298be139873e7a0d24392ef11": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4996. ClientProtocol#metaSave can be made idempotent by overwriting the output file instead of appending to it. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504679 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 2:57 PM",
      "commitName": "e2efe52ac89e9f8298be139873e7a0d24392ef11",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "17/07/13 5:04 PM",
      "commitNameOld": "68faa67f1b3b681b40ecdc9002d9fb508e529af4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,197 +1,198 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n+      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tAllow snapshots to be taken on a directory.\\n\";\n     \n     String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n         \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(allowSnapshot);\n     } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n       System.out.println(disallowSnapshot);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(allowSnapshot);\n       System.out.println(disallowSnapshot);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e is overwritten if it exists.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "59e968a114dfe1b513f31424211116f23525def8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4514. Add CLI for supporting snapshot rename, diff report, and snapshottable directory listing.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1449956 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/13 3:14 PM",
      "commitName": "59e968a114dfe1b513f31424211116f23525def8",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "09/02/13 1:29 PM",
      "commitNameOld": "fa8bafbd4673d385498e81874e58cd0eafad3d22",
      "commitAuthorOld": "",
      "daysBetweenCommits": 16.07,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,183 +1,197 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n+      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n+      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String rollEdits \u003d \"-rollEdits:\\t\" +\n     \"Rolls the edit log.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n+    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n+        \"\\tAllow snapshots to be taken on a directory.\\n\";\n+    \n+    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n+        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n+    \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"rollEdits\".equals(cmd)) {\n       System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n+    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n+      System.out.println(allowSnapshot);\n+    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n+      System.out.println(disallowSnapshot);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n+      System.out.println(allowSnapshot);\n+      System.out.println(disallowSnapshot);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-allowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-disallowSnapshot \u003csnapshotDir\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String allowSnapshot \u003d \"-allowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tAllow snapshots to be taken on a directory.\\n\";\n    \n    String disallowSnapshot \u003d \"-disallowSnapshot \u003csnapshotDir\u003e:\\n\" +\n        \"\\tDo not allow snapshots to be taken on a directory any more.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"allowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(allowSnapshot);\n    } else if (\"disallowSnapshot\".equalsIgnoreCase(cmd)) {\n      System.out.println(disallowSnapshot);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(allowSnapshot);\n      System.out.println(disallowSnapshot);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "c334cc89a8f42c98ab4dad02ae41c5a02a855974": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2793. Add an admin command to trigger an edit log roll. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1380982 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/12 9:40 PM",
      "commitName": "c334cc89a8f42c98ab4dad02ae41c5a02a855974",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "21/08/12 2:18 PM",
      "commitNameOld": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 14.31,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,183 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n+      \"\\t[-rollEdits]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n+    String rollEdits \u003d \"-rollEdits:\\t\" +\n+    \"Rolls the edit log.\\n\" +\n+    \"\\t\\tRequires superuser permissions.\\n\";\n+    \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n+    } else if (\"rollEdits\".equals(cmd)) {\n+      System.out.println(rollEdits);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n+      System.out.println(rollEdits);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-rollEdits]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String rollEdits \u003d \"-rollEdits:\\t\" +\n    \"Rolls the edit log.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"rollEdits\".equals(cmd)) {\n      System.out.println(rollEdits);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(rollEdits);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2686. Remove DistributedUpgrade related code. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375800 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/12 2:18 PM",
      "commitName": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "16/08/12 1:35 PM",
      "commitNameOld": "cf93dfba4e5b7849a3917caa78b29b8a4fb5ef12",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 5.03,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,182 +1,175 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n-    String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n-      \"\\t\\trequest current distributed upgrade status, \\n\" +\n-      \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n-\n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n       \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n       \"\\tthe specified local directory.\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n-    } else if (\"upgradeProgress\".equals(cmd)) {\n-      System.out.println(upgradeProgress);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n     } else if (\"fetchImage\".equals(cmd)) {\n       System.out.println(fetchImage);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n-      System.out.println(upgradeProgress);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(setBalancerBandwidth);\n       System.out.println(fetchImage);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "ce1a7ec9755f17527c29b0db713d7e01750e10c9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2941. Add an administrative command to download a copy of the fsimage from the NN. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1305447 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/03/12 10:02 AM",
      "commitName": "ce1a7ec9755f17527c29b0db713d7e01750e10c9",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "28/02/12 12:09 PM",
      "commitNameOld": "c69dfdd5e14af490790dff8227b11962ec816577",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 26.87,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,173 +1,182 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n       \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n+      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n       \"\\t\\trequest current distributed upgrade status, \\n\" +\n       \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n \n     String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n       \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n       \"\\tHDFS block balancing.\\n\\n\" +\n       \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n       \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n       \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n       \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n+    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n+      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n+      \"\\tthe specified local directory.\\n\";\n+    \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (\"upgradeProgress\".equals(cmd)) {\n       System.out.println(upgradeProgress);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n     } else if (\"setBalancerBandwidth\".equals(cmd)) {\n       System.out.println(setBalancerBandwidth);\n+    } else if (\"fetchImage\".equals(cmd)) {\n+      System.out.println(fetchImage);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(upgradeProgress);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n+      System.out.println(setBalancerBandwidth);\n+      System.out.println(fetchImage);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-fetchImage \u003clocal directory\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n      \"\\t\\trequest current distributed upgrade status, \\n\" +\n      \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String fetchImage \u003d \"-fetchImage \u003clocal directory\u003e:\\n\" +\n      \"\\tDownloads the most recent fsimage from the Name Node and saves it in\" +\n      \"\\tthe specified local directory.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"upgradeProgress\".equals(cmd)) {\n      System.out.println(upgradeProgress);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"fetchImage\".equals(cmd)) {\n      System.out.println(fetchImage);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(upgradeProgress);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(setBalancerBandwidth);\n      System.out.println(fetchImage);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n      \"\\t\\trequest current distributed upgrade status, \\n\" +\n      \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"upgradeProgress\".equals(cmd)) {\n      System.out.println(upgradeProgress);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(upgradeProgress);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n      \"\\t\\trequest current distributed upgrade status, \\n\" +\n      \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"upgradeProgress\".equals(cmd)) {\n      System.out.println(upgradeProgress);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(upgradeProgress);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java"
      }
    },
    "8390152d08306caad31b78abbd509e5ea8580671": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2202. Add a new DFSAdmin command to set balancer bandwidth of datanodes without restarting.  Contributed by Eric Payne\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152401 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 5:10 PM",
      "commitName": "8390152d08306caad31b78abbd509e5ea8580671",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "15/07/11 10:12 PM",
      "commitNameOld": "c163455df487f99171e5045cdf0c2e1be1c4f99e",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 13.79,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,173 @@\n   private void printHelp(String cmd) {\n     String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n       \"The full syntax is: \\n\\n\" +\n       \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n       \"\\t[-saveNamespace]\\n\" +\n       \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n       \"\\t[-refreshNodes]\\n\" +\n       \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n       \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n       \"\\t[-refreshServiceAcl]\\n\" +\n       \"\\t[-refreshUserToGroupsMappings]\\n\" +\n       \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n       \"\\t[-printTopology]\\n\" +\n       \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n       \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n+      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n       \"\\t[-help [cmd]]\\n\";\n \n     String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n         \n     String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n       \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n       \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n       \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n       \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n       \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n       \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n       \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n       \"\\t\\tit can only be turned off manually as well.\\n\";\n \n     String saveNamespace \u003d \"-saveNamespace:\\t\" +\n     \"Save current namespace into storage directories and reset edits log.\\n\" +\n     \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n \n     String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n     \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n     \"\\t\\tRequires superuser permissions.\\n\";\n     \n     String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n       \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n       \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n       \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n       \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n       \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n       \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n       \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n       \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n       \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n       \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n       \"\\t\\tare not chosen for writing new replicas.\\n\";\n \n     String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n       \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n       \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n       \"\\t\\tThis completes the upgrade process.\\n\";\n \n     String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n       \"\\t\\trequest current distributed upgrade status, \\n\" +\n       \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n \n     String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n       \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n       \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n       \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n       \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n       \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n       \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n \n     String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n       \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n     \n     String refreshUserToGroupsMappings \u003d \n       \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n     \n     String refreshSuperUserGroupsConfiguration \u003d \n       \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n \n     String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                            \"\\t\\tnodes as reported by the Namenode\\n\";\n     \n     String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                               \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                               \"\\t\\tstops serving the removed block-pools\\n\"+\n                               \"\\t\\tand starts serving new block-pools\\n\";\n     \n     String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                              \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                              \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                              \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                              \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                              \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                              \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                              \"\\t\\t service on a datanode.\\n\";\n+\n+    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n+      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n+      \"\\tHDFS block balancing.\\n\\n\" +\n+      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n+      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n+      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n+      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n     \n     String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n       \"\\t\\tis specified.\\n\";\n \n     if (\"report\".equals(cmd)) {\n       System.out.println(report);\n     } else if (\"safemode\".equals(cmd)) {\n       System.out.println(safemode);\n     } else if (\"saveNamespace\".equals(cmd)) {\n       System.out.println(saveNamespace);\n     } else if (\"restoreFailedStorage\".equals(cmd)) {\n       System.out.println(restoreFailedStorage);\n     } else if (\"refreshNodes\".equals(cmd)) {\n       System.out.println(refreshNodes);\n     } else if (\"finalizeUpgrade\".equals(cmd)) {\n       System.out.println(finalizeUpgrade);\n     } else if (\"upgradeProgress\".equals(cmd)) {\n       System.out.println(upgradeProgress);\n     } else if (\"metasave\".equals(cmd)) {\n       System.out.println(metaSave);\n     } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n     } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n     } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n     } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n     } else if (\"refreshServiceAcl\".equals(cmd)) {\n       System.out.println(refreshServiceAcl);\n     } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n       System.out.println(refreshUserToGroupsMappings);\n     } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n       System.out.println(refreshSuperUserGroupsConfiguration);\n     } else if (\"printTopology\".equals(cmd)) {\n       System.out.println(printTopology);\n     } else if (\"refreshNamenodes\".equals(cmd)) {\n       System.out.println(refreshNamenodes);\n     } else if (\"deleteBlockPool\".equals(cmd)) {\n       System.out.println(deleteBlockPool);\n+    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n+      System.out.println(setBalancerBandwidth);\n     } else if (\"help\".equals(cmd)) {\n       System.out.println(help);\n     } else {\n       System.out.println(summary);\n       System.out.println(report);\n       System.out.println(safemode);\n       System.out.println(saveNamespace);\n       System.out.println(restoreFailedStorage);\n       System.out.println(refreshNodes);\n       System.out.println(finalizeUpgrade);\n       System.out.println(upgradeProgress);\n       System.out.println(metaSave);\n       System.out.println(SetQuotaCommand.DESCRIPTION);\n       System.out.println(ClearQuotaCommand.DESCRIPTION);\n       System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n       System.out.println(refreshServiceAcl);\n       System.out.println(refreshUserToGroupsMappings);\n       System.out.println(refreshSuperUserGroupsConfiguration);\n       System.out.println(printTopology);\n       System.out.println(refreshNamenodes);\n       System.out.println(deleteBlockPool);\n       System.out.println(help);\n       System.out.println();\n       ToolRunner.printGenericCommandUsage(System.out);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-setBalancerBandwidth \u003cbandwidth\u003e]\\n\" +\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n      \"\\t\\trequest current distributed upgrade status, \\n\" +\n      \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n\n    String setBalancerBandwidth \u003d \"-setBalancerBandwidth \u003cbandwidth\u003e:\\n\" +\n      \"\\tChanges the network bandwidth used by each datanode during\\n\" +\n      \"\\tHDFS block balancing.\\n\\n\" +\n      \"\\t\\t\u003cbandwidth\u003e is the maximum number of bytes per second\\n\" +\n      \"\\t\\tthat will be used by each datanode. This value overrides\\n\" +\n      \"\\t\\tthe dfs.balance.bandwidthPerSec parameter.\\n\\n\" +\n      \"\\t\\t--- NOTE: The new value is not persistent on the DataNode.---\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"upgradeProgress\".equals(cmd)) {\n      System.out.println(upgradeProgress);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"setBalancerBandwidth\".equals(cmd)) {\n      System.out.println(setBalancerBandwidth);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(upgradeProgress);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,162 @@\n+  private void printHelp(String cmd) {\n+    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n+      \"The full syntax is: \\n\\n\" +\n+      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n+      \"\\t[-saveNamespace]\\n\" +\n+      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n+      \"\\t[-refreshNodes]\\n\" +\n+      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n+      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n+      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n+      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n+      \"\\t[-refreshServiceAcl]\\n\" +\n+      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n+      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n+      \"\\t[-printTopology]\\n\" +\n+      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n+      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n+      \"\\t[-help [cmd]]\\n\";\n+\n+    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n+        \n+    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n+      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n+      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n+      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n+      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n+      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n+      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n+      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n+      \"\\t\\tit can only be turned off manually as well.\\n\";\n+\n+    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n+    \"Save current namespace into storage directories and reset edits log.\\n\" +\n+    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n+\n+    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n+    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n+    \"\\t\\tRequires superuser permissions.\\n\";\n+    \n+    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n+      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n+      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n+      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n+      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n+      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n+      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n+      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n+      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n+      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n+      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n+      \"\\t\\tare not chosen for writing new replicas.\\n\";\n+\n+    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n+      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n+      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n+      \"\\t\\tThis completes the upgrade process.\\n\";\n+\n+    String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n+      \"\\t\\trequest current distributed upgrade status, \\n\" +\n+      \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n+\n+    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n+      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n+      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n+      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n+      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n+      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n+      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n+\n+    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n+      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n+    \n+    String refreshUserToGroupsMappings \u003d \n+      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n+    \n+    String refreshSuperUserGroupsConfiguration \u003d \n+      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n+\n+    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n+                           \"\\t\\tnodes as reported by the Namenode\\n\";\n+    \n+    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n+                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n+                              \"\\t\\tstops serving the removed block-pools\\n\"+\n+                              \"\\t\\tand starts serving new block-pools\\n\";\n+    \n+    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n+                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n+                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n+                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n+                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n+                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n+                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n+                             \"\\t\\t service on a datanode.\\n\";\n+    \n+    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n+      \"\\t\\tis specified.\\n\";\n+\n+    if (\"report\".equals(cmd)) {\n+      System.out.println(report);\n+    } else if (\"safemode\".equals(cmd)) {\n+      System.out.println(safemode);\n+    } else if (\"saveNamespace\".equals(cmd)) {\n+      System.out.println(saveNamespace);\n+    } else if (\"restoreFailedStorage\".equals(cmd)) {\n+      System.out.println(restoreFailedStorage);\n+    } else if (\"refreshNodes\".equals(cmd)) {\n+      System.out.println(refreshNodes);\n+    } else if (\"finalizeUpgrade\".equals(cmd)) {\n+      System.out.println(finalizeUpgrade);\n+    } else if (\"upgradeProgress\".equals(cmd)) {\n+      System.out.println(upgradeProgress);\n+    } else if (\"metasave\".equals(cmd)) {\n+      System.out.println(metaSave);\n+    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n+      System.out.println(SetQuotaCommand.DESCRIPTION);\n+    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n+      System.out.println(ClearQuotaCommand.DESCRIPTION);\n+    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n+      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n+    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n+      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n+    } else if (\"refreshServiceAcl\".equals(cmd)) {\n+      System.out.println(refreshServiceAcl);\n+    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n+      System.out.println(refreshUserToGroupsMappings);\n+    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n+      System.out.println(refreshSuperUserGroupsConfiguration);\n+    } else if (\"printTopology\".equals(cmd)) {\n+      System.out.println(printTopology);\n+    } else if (\"refreshNamenodes\".equals(cmd)) {\n+      System.out.println(refreshNamenodes);\n+    } else if (\"deleteBlockPool\".equals(cmd)) {\n+      System.out.println(deleteBlockPool);\n+    } else if (\"help\".equals(cmd)) {\n+      System.out.println(help);\n+    } else {\n+      System.out.println(summary);\n+      System.out.println(report);\n+      System.out.println(safemode);\n+      System.out.println(saveNamespace);\n+      System.out.println(restoreFailedStorage);\n+      System.out.println(refreshNodes);\n+      System.out.println(finalizeUpgrade);\n+      System.out.println(upgradeProgress);\n+      System.out.println(metaSave);\n+      System.out.println(SetQuotaCommand.DESCRIPTION);\n+      System.out.println(ClearQuotaCommand.DESCRIPTION);\n+      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n+      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n+      System.out.println(refreshServiceAcl);\n+      System.out.println(refreshUserToGroupsMappings);\n+      System.out.println(refreshSuperUserGroupsConfiguration);\n+      System.out.println(printTopology);\n+      System.out.println(refreshNamenodes);\n+      System.out.println(deleteBlockPool);\n+      System.out.println(help);\n+      System.out.println();\n+      ToolRunner.printGenericCommandUsage(System.out);\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void printHelp(String cmd) {\n    String summary \u003d \"hadoop dfsadmin is the command to execute DFS administrative commands.\\n\" +\n      \"The full syntax is: \\n\\n\" +\n      \"hadoop dfsadmin [-report] [-safemode \u003center | leave | get | wait\u003e]\\n\" +\n      \"\\t[-saveNamespace]\\n\" +\n      \"\\t[-restoreFailedStorage true|false|check]\\n\" +\n      \"\\t[-refreshNodes]\\n\" +\n      \"\\t[\" + SetQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[\" + SetSpaceQuotaCommand.USAGE + \"]\\n\" +\n      \"\\t[\" + ClearSpaceQuotaCommand.USAGE +\"]\\n\" +\n      \"\\t[-refreshServiceAcl]\\n\" +\n      \"\\t[-refreshUserToGroupsMappings]\\n\" +\n      \"\\t[refreshSuperUserGroupsConfiguration]\\n\" +\n      \"\\t[-printTopology]\\n\" +\n      \"\\t[-refreshNamenodes datanodehost:port]\\n\"+\n      \"\\t[-deleteBlockPool datanodehost:port blockpoolId [force]]\\n\"+\n      \"\\t[-help [cmd]]\\n\";\n\n    String report \u003d\"-report: \\tReports basic filesystem information and statistics.\\n\";\n        \n    String safemode \u003d \"-safemode \u003center|leave|get|wait\u003e:  Safe mode maintenance command.\\n\" + \n      \"\\t\\tSafe mode is a Namenode state in which it\\n\" +\n      \"\\t\\t\\t1.  does not accept changes to the name space (read-only)\\n\" +\n      \"\\t\\t\\t2.  does not replicate or delete blocks.\\n\" +\n      \"\\t\\tSafe mode is entered automatically at Namenode startup, and\\n\" +\n      \"\\t\\tleaves safe mode automatically when the configured minimum\\n\" +\n      \"\\t\\tpercentage of blocks satisfies the minimum replication\\n\" +\n      \"\\t\\tcondition.  Safe mode can also be entered manually, but then\\n\" +\n      \"\\t\\tit can only be turned off manually as well.\\n\";\n\n    String saveNamespace \u003d \"-saveNamespace:\\t\" +\n    \"Save current namespace into storage directories and reset edits log.\\n\" +\n    \"\\t\\tRequires superuser permissions and safe mode.\\n\";\n\n    String restoreFailedStorage \u003d \"-restoreFailedStorage:\\t\" +\n    \"Set/Unset/Check flag to attempt restore of failed storage replicas if they become available.\\n\" +\n    \"\\t\\tRequires superuser permissions.\\n\";\n    \n    String refreshNodes \u003d \"-refreshNodes: \\tUpdates the namenode with the \" +\n      \"set of datanodes allowed to connect to the namenode.\\n\\n\" +\n      \"\\t\\tNamenode re-reads datanode hostnames from the file defined by \\n\" +\n      \"\\t\\tdfs.hosts, dfs.hosts.exclude configuration parameters.\\n\" +\n      \"\\t\\tHosts defined in dfs.hosts are the datanodes that are part of \\n\" +\n      \"\\t\\tthe cluster. If there are entries in dfs.hosts, only the hosts \\n\" +\n      \"\\t\\tin it are allowed to register with the namenode.\\n\\n\" +\n      \"\\t\\tEntries in dfs.hosts.exclude are datanodes that need to be \\n\" +\n      \"\\t\\tdecommissioned. Datanodes complete decommissioning when \\n\" + \n      \"\\t\\tall the replicas from them are replicated to other datanodes.\\n\" +\n      \"\\t\\tDecommissioned nodes are not automatically shutdown and \\n\" +\n      \"\\t\\tare not chosen for writing new replicas.\\n\";\n\n    String finalizeUpgrade \u003d \"-finalizeUpgrade: Finalize upgrade of HDFS.\\n\" +\n      \"\\t\\tDatanodes delete their previous version working directories,\\n\" +\n      \"\\t\\tfollowed by Namenode doing the same.\\n\" + \n      \"\\t\\tThis completes the upgrade process.\\n\";\n\n    String upgradeProgress \u003d \"-upgradeProgress \u003cstatus|details|force\u003e: \\n\" +\n      \"\\t\\trequest current distributed upgrade status, \\n\" +\n      \"\\t\\ta detailed status or force the upgrade to proceed.\\n\";\n\n    String metaSave \u003d \"-metasave \u003cfilename\u003e: \\tSave Namenode\u0027s primary data structures\\n\" +\n      \"\\t\\tto \u003cfilename\u003e in the directory specified by hadoop.log.dir property.\\n\" +\n      \"\\t\\t\u003cfilename\u003e will contain one line for each of the following\\n\" +\n      \"\\t\\t\\t1. Datanodes heart beating with Namenode\\n\" +\n      \"\\t\\t\\t2. Blocks waiting to be replicated\\n\" +\n      \"\\t\\t\\t3. Blocks currrently being replicated\\n\" +\n      \"\\t\\t\\t4. Blocks waiting to be deleted\\n\";\n\n    String refreshServiceAcl \u003d \"-refreshServiceAcl: Reload the service-level authorization policy file\\n\" +\n      \"\\t\\tNamenode will reload the authorization policy file.\\n\";\n    \n    String refreshUserToGroupsMappings \u003d \n      \"-refreshUserToGroupsMappings: Refresh user-to-groups mappings\\n\";\n    \n    String refreshSuperUserGroupsConfiguration \u003d \n      \"-refreshSuperUserGroupsConfiguration: Refresh superuser proxy groups mappings\\n\";\n\n    String printTopology \u003d \"-printTopology: Print a tree of the racks and their\\n\" +\n                           \"\\t\\tnodes as reported by the Namenode\\n\";\n    \n    String refreshNamenodes \u003d \"-refreshNamenodes: Takes a datanodehost:port as argument,\\n\"+\n                              \"\\t\\tFor the given datanode, reloads the configuration files,\\n\" +\n                              \"\\t\\tstops serving the removed block-pools\\n\"+\n                              \"\\t\\tand starts serving new block-pools\\n\";\n    \n    String deleteBlockPool \u003d \"-deleteBlockPool: Arguments are datanodehost:port, blockpool id\\n\"+\n                             \"\\t\\t and an optional argument \\\"force\\\". If force is passed,\\n\"+\n                             \"\\t\\t block pool directory for the given blockpool id on the given\\n\"+\n                             \"\\t\\t datanode is deleted along with its contents, otherwise\\n\"+\n                             \"\\t\\t the directory is deleted only if it is empty. The command\\n\" +\n                             \"\\t\\t will fail if datanode is still serving the block pool.\\n\" +\n                             \"\\t\\t   Refer to refreshNamenodes to shutdown a block pool\\n\" +\n                             \"\\t\\t service on a datanode.\\n\";\n    \n    String help \u003d \"-help [cmd]: \\tDisplays help for the given command or all commands if none\\n\" +\n      \"\\t\\tis specified.\\n\";\n\n    if (\"report\".equals(cmd)) {\n      System.out.println(report);\n    } else if (\"safemode\".equals(cmd)) {\n      System.out.println(safemode);\n    } else if (\"saveNamespace\".equals(cmd)) {\n      System.out.println(saveNamespace);\n    } else if (\"restoreFailedStorage\".equals(cmd)) {\n      System.out.println(restoreFailedStorage);\n    } else if (\"refreshNodes\".equals(cmd)) {\n      System.out.println(refreshNodes);\n    } else if (\"finalizeUpgrade\".equals(cmd)) {\n      System.out.println(finalizeUpgrade);\n    } else if (\"upgradeProgress\".equals(cmd)) {\n      System.out.println(upgradeProgress);\n    } else if (\"metasave\".equals(cmd)) {\n      System.out.println(metaSave);\n    } else if (SetQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n    } else if (ClearQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n    } else if (SetSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n    } else if (ClearSpaceQuotaCommand.matches(\"-\"+cmd)) {\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n    } else if (\"refreshServiceAcl\".equals(cmd)) {\n      System.out.println(refreshServiceAcl);\n    } else if (\"refreshUserToGroupsMappings\".equals(cmd)) {\n      System.out.println(refreshUserToGroupsMappings);\n    } else if (\"refreshSuperUserGroupsConfiguration\".equals(cmd)) {\n      System.out.println(refreshSuperUserGroupsConfiguration);\n    } else if (\"printTopology\".equals(cmd)) {\n      System.out.println(printTopology);\n    } else if (\"refreshNamenodes\".equals(cmd)) {\n      System.out.println(refreshNamenodes);\n    } else if (\"deleteBlockPool\".equals(cmd)) {\n      System.out.println(deleteBlockPool);\n    } else if (\"help\".equals(cmd)) {\n      System.out.println(help);\n    } else {\n      System.out.println(summary);\n      System.out.println(report);\n      System.out.println(safemode);\n      System.out.println(saveNamespace);\n      System.out.println(restoreFailedStorage);\n      System.out.println(refreshNodes);\n      System.out.println(finalizeUpgrade);\n      System.out.println(upgradeProgress);\n      System.out.println(metaSave);\n      System.out.println(SetQuotaCommand.DESCRIPTION);\n      System.out.println(ClearQuotaCommand.DESCRIPTION);\n      System.out.println(SetSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(ClearSpaceQuotaCommand.DESCRIPTION);\n      System.out.println(refreshServiceAcl);\n      System.out.println(refreshUserToGroupsMappings);\n      System.out.println(refreshSuperUserGroupsConfiguration);\n      System.out.println(printTopology);\n      System.out.println(refreshNamenodes);\n      System.out.println(deleteBlockPool);\n      System.out.println(help);\n      System.out.println();\n      ToolRunner.printGenericCommandUsage(System.out);\n    }\n\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java"
    }
  }
}