{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UsersManager.java",
  "functionName": "computeUserLimit",
  "functionId": "computeUserLimit___userName-String__clusterResource-Resource__nodePartition-String__schedulingMode-SchedulingMode__activeUser-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
  "functionStartLine": 688,
  "functionEndLine": 812,
  "numCommitsSeen": 595,
  "timeTaken": 17542,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "d52627a7cbddfd981db973e223aefffde1ebf82d",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "38c14ef8d8a094a7101917eb77d90f5e62324f61",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "444b2ea7afebf9f6c3d356154b71abfd0ea95b23",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
    "658097d6da1b1aac8e01db459f0c3b456e99652f",
    "18a594257e052e8f10a03e5594e6cc6901dc56be",
    "86358221fc85a7743052a0b4c1647353508bf308",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1",
    "5262b7ba4d018562d4e7d60772af4ddc3d770a23",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "d52627a7cbddfd981db973e223aefffde1ebf82d": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "38c14ef8d8a094a7101917eb77d90f5e62324f61": "Ybodychange",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": "Ybodychange",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ymultichange(Yparameterchange,Ybodychange)",
    "444b2ea7afebf9f6c3d356154b71abfd0ea95b23": "Ybodychange",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": "Ymultichange(Yparameterchange,Ybodychange)",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": "Ymultichange(Yparameterchange,Ybodychange)",
    "658097d6da1b1aac8e01db459f0c3b456e99652f": "Ybodychange",
    "18a594257e052e8f10a03e5594e6cc6901dc56be": "Ybodychange",
    "86358221fc85a7743052a0b4c1647353508bf308": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ymultichange(Yparameterchange,Ybodychange)",
    "519e5a7dd2bd540105434ec3c8939b68f6c024f8": "Ymultichange(Yparameterchange,Ybodychange)",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Yparameterchange",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": "Ybodychange",
    "5262b7ba4d018562d4e7d60772af4ddc3d770a23": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 375.5,
      "commitsBetweenForRepo": 2190,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   private Resource computeUserLimit(String userName, Resource clusterResource,\n       String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n     /*\n      * What is our current capacity?\n      * * It is equal to the max(required, queue-capacity) if we\u0027re running\n      * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n      * capacity (\u003c 1 slot) make progress\n      * * If we\u0027re running over capacity, then its (usedResources + required)\n      * (which extra resources we are allocating)\n      */\n     Resource queueCapacity \u003d lQueue.getEffectiveCapacity(nodePartition);\n \n     /*\n      * Assume we have required resource equals to minimumAllocation, this can\n      * make sure user limit can continuously increase till queueMaxResource\n      * reached.\n      */\n     Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n         queueCapacity, required);\n \n     /*\n      * We want to base the userLimit calculation on\n      * max(queueCapacity, usedResources+required). However, we want\n      * usedResources to be based on the combined ratios of all the users in the\n      * queue so we use consumedRatio to calculate such.\n      * The calculation is dependent on how the resourceCalculator calculates the\n      * ratio between two Resources. DRF Example: If usedResources is greater\n      * than queueCapacity and users have the following [mem,cpu] usages:\n      *\n      * User1: [10%,20%] - Dominant resource is 20%\n      * User2: [30%,10%] - Dominant resource is 30%\n      * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n      * larger than 100% but for the purposes of making sure all users are\n      * getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n         partitionResource, getUsageRatio(nodePartition),\n         lQueue.getMinimumAllocation());\n     Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n         partitionResource, consumed, queueCapacity)\n             ? queueCapacity\n             : Resources.add(consumed, required);\n \n     /*\n      * Never allow a single user to take more than the queue\u0027s configured\n      * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n      * should be higher than queue-hard-limit * ulMin\n      */\n     float usersSummedByWeight \u003d activeUsersTimesWeights;\n     Resource resourceUsed \u003d Resources.add(\n                             totalResUsageForActiveUsers.getUsed(nodePartition),\n                             required);\n \n     // For non-activeUser calculation, consider all users count.\n     if (!activeUser) {\n       resourceUsed \u003d currentCapacity;\n       usersSummedByWeight \u003d allUsersTimesWeights;\n     }\n \n     /*\n      * User limit resource is determined by: max(currentCapacity / #activeUsers,\n      * currentCapacity * user-limit-percentage%)\n      */\n     Resource userLimitResource \u003d Resources.max(resourceCalculator,\n         partitionResource,\n         Resources.divideAndCeil(resourceCalculator, resourceUsed,\n             usersSummedByWeight),\n         Resources.divideAndCeil(resourceCalculator,\n             Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n             100));\n \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor\n     // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n           getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d Resources\n         .roundUp(resourceCalculator,\n             Resources.min(resourceCalculator, partitionResource,\n                 userLimitResource, maxUserLimit),\n             lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"User limit computation for \" + userName\n-          + \",  in queue: \" + lQueue.getQueueName()\n+          + \",  in queue: \" + lQueue.getQueuePath()\n           + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n           + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n           + \",  required\u003d\" + required\n           + \",  consumed\u003d\" + consumed\n           + \",  user-limit-resource\u003d\" + userLimitResource\n           + \",  queueCapacity\u003d\" + queueCapacity\n           + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n           + \",  currentCapacity\u003d\" + currentCapacity\n           + \",  activeUsers\u003d\" + usersSummedByWeight\n           + \",  clusterCapacity\u003d\" + clusterResource\n           + \",  resourceByLabel\u003d\" + partitionResource\n           + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n           + \",  Partition\u003d\" + nodePartition\n           + \",  resourceUsed\u003d\" + resourceUsed\n           + \",  maxUserLimit\u003d\" + maxUserLimit\n           + \",  userWeight\u003d\" + getUser(userName).getWeight()\n       );\n     }\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d lQueue.getEffectiveCapacity(nodePartition);\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is greater\n     * than queueCapacity and users have the following [mem,cpu] usages:\n     *\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    float usersSummedByWeight \u003d activeUsersTimesWeights;\n    Resource resourceUsed \u003d Resources.add(\n                            totalResUsageForActiveUsers.getUsed(nodePartition),\n                            required);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersSummedByWeight \u003d allUsersTimesWeights;\n    }\n\n    /*\n     * User limit resource is determined by: max(currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersSummedByWeight),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName\n          + \",  in queue: \" + lQueue.getQueuePath()\n          + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n          + \",  required\u003d\" + required\n          + \",  consumed\u003d\" + consumed\n          + \",  user-limit-resource\u003d\" + userLimitResource\n          + \",  queueCapacity\u003d\" + queueCapacity\n          + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n          + \",  currentCapacity\u003d\" + currentCapacity\n          + \",  activeUsers\u003d\" + usersSummedByWeight\n          + \",  clusterCapacity\u003d\" + clusterResource\n          + \",  resourceByLabel\u003d\" + partitionResource\n          + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n          + \",  Partition\u003d\" + nodePartition\n          + \",  resourceUsed\u003d\" + resourceUsed\n          + \",  maxUserLimit\u003d\" + maxUserLimit\n          + \",  userWeight\u003d\" + getUser(userName).getWeight()\n      );\n    }\n    return userLimitResource;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "d52627a7cbddfd981db973e223aefffde1ebf82d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7254. UI and metrics changes related to absolute resource configuration. (Sunil G via wangda)\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "d52627a7cbddfd981db973e223aefffde1ebf82d",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   private Resource computeUserLimit(String userName, Resource clusterResource,\n       String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n     /*\n      * What is our current capacity?\n      * * It is equal to the max(required, queue-capacity) if we\u0027re running\n      * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n      * capacity (\u003c 1 slot) make progress\n      * * If we\u0027re running over capacity, then its (usedResources + required)\n      * (which extra resources we are allocating)\n      */\n-    Resource queueCapacity \u003d lQueue.getEffectiveCapacityUp(nodePartition);\n+    Resource queueCapacity \u003d lQueue.getEffectiveCapacity(nodePartition);\n \n     /*\n      * Assume we have required resource equals to minimumAllocation, this can\n      * make sure user limit can continuously increase till queueMaxResource\n      * reached.\n      */\n     Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n         queueCapacity, required);\n \n     /*\n      * We want to base the userLimit calculation on\n      * max(queueCapacity, usedResources+required). However, we want\n      * usedResources to be based on the combined ratios of all the users in the\n      * queue so we use consumedRatio to calculate such.\n      * The calculation is dependent on how the resourceCalculator calculates the\n      * ratio between two Resources. DRF Example: If usedResources is greater\n      * than queueCapacity and users have the following [mem,cpu] usages:\n      *\n      * User1: [10%,20%] - Dominant resource is 20%\n      * User2: [30%,10%] - Dominant resource is 30%\n      * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n      * larger than 100% but for the purposes of making sure all users are\n      * getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n         partitionResource, getUsageRatio(nodePartition),\n         lQueue.getMinimumAllocation());\n     Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n         partitionResource, consumed, queueCapacity)\n             ? queueCapacity\n             : Resources.add(consumed, required);\n \n     /*\n      * Never allow a single user to take more than the queue\u0027s configured\n      * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n      * should be higher than queue-hard-limit * ulMin\n      */\n     float usersSummedByWeight \u003d activeUsersTimesWeights;\n     Resource resourceUsed \u003d Resources.add(\n                             totalResUsageForActiveUsers.getUsed(nodePartition),\n                             required);\n \n     // For non-activeUser calculation, consider all users count.\n     if (!activeUser) {\n       resourceUsed \u003d currentCapacity;\n       usersSummedByWeight \u003d allUsersTimesWeights;\n     }\n \n     /*\n      * User limit resource is determined by: max(currentCapacity / #activeUsers,\n      * currentCapacity * user-limit-percentage%)\n      */\n     Resource userLimitResource \u003d Resources.max(resourceCalculator,\n         partitionResource,\n         Resources.divideAndCeil(resourceCalculator, resourceUsed,\n             usersSummedByWeight),\n         Resources.divideAndCeil(resourceCalculator,\n             Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n             100));\n \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor\n     // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n           getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d Resources\n         .roundUp(resourceCalculator,\n             Resources.min(resourceCalculator, partitionResource,\n                 userLimitResource, maxUserLimit),\n             lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"User limit computation for \" + userName\n           + \",  in queue: \" + lQueue.getQueueName()\n           + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n           + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n           + \",  required\u003d\" + required\n           + \",  consumed\u003d\" + consumed\n           + \",  user-limit-resource\u003d\" + userLimitResource\n           + \",  queueCapacity\u003d\" + queueCapacity\n           + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n           + \",  currentCapacity\u003d\" + currentCapacity\n           + \",  activeUsers\u003d\" + usersSummedByWeight\n           + \",  clusterCapacity\u003d\" + clusterResource\n           + \",  resourceByLabel\u003d\" + partitionResource\n           + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n           + \",  Partition\u003d\" + nodePartition\n           + \",  resourceUsed\u003d\" + resourceUsed\n           + \",  maxUserLimit\u003d\" + maxUserLimit\n           + \",  userWeight\u003d\" + getUser(userName).getWeight()\n       );\n     }\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d lQueue.getEffectiveCapacity(nodePartition);\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is greater\n     * than queueCapacity and users have the following [mem,cpu] usages:\n     *\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    float usersSummedByWeight \u003d activeUsersTimesWeights;\n    Resource resourceUsed \u003d Resources.add(\n                            totalResUsageForActiveUsers.getUsed(nodePartition),\n                            required);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersSummedByWeight \u003d allUsersTimesWeights;\n    }\n\n    /*\n     * User limit resource is determined by: max(currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersSummedByWeight),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName\n          + \",  in queue: \" + lQueue.getQueueName()\n          + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n          + \",  required\u003d\" + required\n          + \",  consumed\u003d\" + consumed\n          + \",  user-limit-resource\u003d\" + userLimitResource\n          + \",  queueCapacity\u003d\" + queueCapacity\n          + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n          + \",  currentCapacity\u003d\" + currentCapacity\n          + \",  activeUsers\u003d\" + usersSummedByWeight\n          + \",  clusterCapacity\u003d\" + clusterResource\n          + \",  resourceByLabel\u003d\" + partitionResource\n          + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n          + \",  Partition\u003d\" + nodePartition\n          + \",  resourceUsed\u003d\" + resourceUsed\n          + \",  maxUserLimit\u003d\" + maxUserLimit\n          + \",  userWeight\u003d\" + getUser(userName).getWeight()\n      );\n    }\n    return userLimitResource;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "15/09/17 9:29 PM",
      "commitNameOld": "38c14ef8d8a094a7101917eb77d90f5e62324f61",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 82.94,
      "commitsBetweenForRepo": 625,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,125 @@\n   private Resource computeUserLimit(String userName, Resource clusterResource,\n       String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n     /*\n      * What is our current capacity?\n      * * It is equal to the max(required, queue-capacity) if we\u0027re running\n      * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n      * capacity (\u003c 1 slot) make progress\n      * * If we\u0027re running over capacity, then its (usedResources + required)\n      * (which extra resources we are allocating)\n      */\n-    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n-        resourceCalculator, partitionResource,\n-        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n-        lQueue.getMinimumAllocation());\n+    Resource queueCapacity \u003d lQueue.getEffectiveCapacityUp(nodePartition);\n \n     /*\n      * Assume we have required resource equals to minimumAllocation, this can\n      * make sure user limit can continuously increase till queueMaxResource\n      * reached.\n      */\n     Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n         queueCapacity, required);\n \n     /*\n      * We want to base the userLimit calculation on\n      * max(queueCapacity, usedResources+required). However, we want\n      * usedResources to be based on the combined ratios of all the users in the\n      * queue so we use consumedRatio to calculate such.\n      * The calculation is dependent on how the resourceCalculator calculates the\n      * ratio between two Resources. DRF Example: If usedResources is greater\n      * than queueCapacity and users have the following [mem,cpu] usages:\n      *\n      * User1: [10%,20%] - Dominant resource is 20%\n      * User2: [30%,10%] - Dominant resource is 30%\n      * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n      * larger than 100% but for the purposes of making sure all users are\n      * getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n         partitionResource, getUsageRatio(nodePartition),\n         lQueue.getMinimumAllocation());\n     Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n         partitionResource, consumed, queueCapacity)\n             ? queueCapacity\n             : Resources.add(consumed, required);\n \n     /*\n      * Never allow a single user to take more than the queue\u0027s configured\n      * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n      * should be higher than queue-hard-limit * ulMin\n      */\n     float usersSummedByWeight \u003d activeUsersTimesWeights;\n     Resource resourceUsed \u003d Resources.add(\n                             totalResUsageForActiveUsers.getUsed(nodePartition),\n                             required);\n \n     // For non-activeUser calculation, consider all users count.\n     if (!activeUser) {\n       resourceUsed \u003d currentCapacity;\n       usersSummedByWeight \u003d allUsersTimesWeights;\n     }\n \n     /*\n      * User limit resource is determined by: max(currentCapacity / #activeUsers,\n      * currentCapacity * user-limit-percentage%)\n      */\n     Resource userLimitResource \u003d Resources.max(resourceCalculator,\n         partitionResource,\n         Resources.divideAndCeil(resourceCalculator, resourceUsed,\n             usersSummedByWeight),\n         Resources.divideAndCeil(resourceCalculator,\n             Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n             100));\n \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor\n     // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n           getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d Resources\n         .roundUp(resourceCalculator,\n             Resources.min(resourceCalculator, partitionResource,\n                 userLimitResource, maxUserLimit),\n             lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"User limit computation for \" + userName\n           + \",  in queue: \" + lQueue.getQueueName()\n           + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n           + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n           + \",  required\u003d\" + required\n           + \",  consumed\u003d\" + consumed\n           + \",  user-limit-resource\u003d\" + userLimitResource\n           + \",  queueCapacity\u003d\" + queueCapacity\n           + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n           + \",  currentCapacity\u003d\" + currentCapacity\n           + \",  activeUsers\u003d\" + usersSummedByWeight\n           + \",  clusterCapacity\u003d\" + clusterResource\n           + \",  resourceByLabel\u003d\" + partitionResource\n           + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n           + \",  Partition\u003d\" + nodePartition\n           + \",  resourceUsed\u003d\" + resourceUsed\n           + \",  maxUserLimit\u003d\" + maxUserLimit\n           + \",  userWeight\u003d\" + getUser(userName).getWeight()\n       );\n     }\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d lQueue.getEffectiveCapacityUp(nodePartition);\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is greater\n     * than queueCapacity and users have the following [mem,cpu] usages:\n     *\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    float usersSummedByWeight \u003d activeUsersTimesWeights;\n    Resource resourceUsed \u003d Resources.add(\n                            totalResUsageForActiveUsers.getUsed(nodePartition),\n                            required);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersSummedByWeight \u003d allUsersTimesWeights;\n    }\n\n    /*\n     * User limit resource is determined by: max(currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersSummedByWeight),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName\n          + \",  in queue: \" + lQueue.getQueueName()\n          + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n          + \",  required\u003d\" + required\n          + \",  consumed\u003d\" + consumed\n          + \",  user-limit-resource\u003d\" + userLimitResource\n          + \",  queueCapacity\u003d\" + queueCapacity\n          + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n          + \",  currentCapacity\u003d\" + currentCapacity\n          + \",  activeUsers\u003d\" + usersSummedByWeight\n          + \",  clusterCapacity\u003d\" + clusterResource\n          + \",  resourceByLabel\u003d\" + partitionResource\n          + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n          + \",  Partition\u003d\" + nodePartition\n          + \",  resourceUsed\u003d\" + resourceUsed\n          + \",  maxUserLimit\u003d\" + maxUserLimit\n          + \",  userWeight\u003d\" + getUser(userName).getWeight()\n      );\n    }\n    return userLimitResource;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "38c14ef8d8a094a7101917eb77d90f5e62324f61": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7149. Cross-queue preemption sometimes starves an underserved queue. (Eric Payne via wangda)\n\nChange-Id: Ib269991dbebce160378e8372ee6d24849c4a5ed6\n(cherry picked from commit 3dfa937a1fadfc62947755872515f549b3b15e6a)\n",
      "commitDate": "15/09/17 9:29 PM",
      "commitName": "38c14ef8d8a094a7101917eb77d90f5e62324f61",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "22/06/17 11:50 PM",
      "commitNameOld": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 84.9,
      "commitsBetweenForRepo": 662,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,128 @@\n   private Resource computeUserLimit(String userName, Resource clusterResource,\n       String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n     /*\n      * What is our current capacity?\n      * * It is equal to the max(required, queue-capacity) if we\u0027re running\n      * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n      * capacity (\u003c 1 slot) make progress\n      * * If we\u0027re running over capacity, then its (usedResources + required)\n      * (which extra resources we are allocating)\n      */\n     Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n         resourceCalculator, partitionResource,\n         lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n         lQueue.getMinimumAllocation());\n \n     /*\n      * Assume we have required resource equals to minimumAllocation, this can\n      * make sure user limit can continuously increase till queueMaxResource\n      * reached.\n      */\n     Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n         queueCapacity, required);\n \n     /*\n      * We want to base the userLimit calculation on\n      * max(queueCapacity, usedResources+required). However, we want\n      * usedResources to be based on the combined ratios of all the users in the\n      * queue so we use consumedRatio to calculate such.\n      * The calculation is dependent on how the resourceCalculator calculates the\n      * ratio between two Resources. DRF Example: If usedResources is greater\n      * than queueCapacity and users have the following [mem,cpu] usages:\n      *\n      * User1: [10%,20%] - Dominant resource is 20%\n      * User2: [30%,10%] - Dominant resource is 30%\n      * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n      * larger than 100% but for the purposes of making sure all users are\n      * getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n         partitionResource, getUsageRatio(nodePartition),\n         lQueue.getMinimumAllocation());\n     Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n         partitionResource, consumed, queueCapacity)\n             ? queueCapacity\n             : Resources.add(consumed, required);\n \n     /*\n      * Never allow a single user to take more than the queue\u0027s configured\n      * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n      * should be higher than queue-hard-limit * ulMin\n      */\n     float usersSummedByWeight \u003d activeUsersTimesWeights;\n-    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n+    Resource resourceUsed \u003d Resources.add(\n+                            totalResUsageForActiveUsers.getUsed(nodePartition),\n+                            required);\n \n     // For non-activeUser calculation, consider all users count.\n     if (!activeUser) {\n       resourceUsed \u003d currentCapacity;\n       usersSummedByWeight \u003d allUsersTimesWeights;\n     }\n \n     /*\n      * User limit resource is determined by: max(currentCapacity / #activeUsers,\n      * currentCapacity * user-limit-percentage%)\n      */\n     Resource userLimitResource \u003d Resources.max(resourceCalculator,\n         partitionResource,\n         Resources.divideAndCeil(resourceCalculator, resourceUsed,\n             usersSummedByWeight),\n         Resources.divideAndCeil(resourceCalculator,\n             Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n             100));\n \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor\n     // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n           getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d Resources\n         .roundUp(resourceCalculator,\n             Resources.min(resourceCalculator, partitionResource,\n                 userLimitResource, maxUserLimit),\n             lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"User limit computation for \" + userName\n           + \",  in queue: \" + lQueue.getQueueName()\n           + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n           + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n           + \",  required\u003d\" + required\n           + \",  consumed\u003d\" + consumed\n           + \",  user-limit-resource\u003d\" + userLimitResource\n           + \",  queueCapacity\u003d\" + queueCapacity\n           + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n           + \",  currentCapacity\u003d\" + currentCapacity\n           + \",  activeUsers\u003d\" + usersSummedByWeight\n           + \",  clusterCapacity\u003d\" + clusterResource\n           + \",  resourceByLabel\u003d\" + partitionResource\n           + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n           + \",  Partition\u003d\" + nodePartition\n           + \",  resourceUsed\u003d\" + resourceUsed\n           + \",  maxUserLimit\u003d\" + maxUserLimit\n           + \",  userWeight\u003d\" + getUser(userName).getWeight()\n       );\n     }\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n        resourceCalculator, partitionResource,\n        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n        lQueue.getMinimumAllocation());\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is greater\n     * than queueCapacity and users have the following [mem,cpu] usages:\n     *\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    float usersSummedByWeight \u003d activeUsersTimesWeights;\n    Resource resourceUsed \u003d Resources.add(\n                            totalResUsageForActiveUsers.getUsed(nodePartition),\n                            required);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersSummedByWeight \u003d allUsersTimesWeights;\n    }\n\n    /*\n     * User limit resource is determined by: max(currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersSummedByWeight),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName\n          + \",  in queue: \" + lQueue.getQueueName()\n          + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n          + \",  required\u003d\" + required\n          + \",  consumed\u003d\" + consumed\n          + \",  user-limit-resource\u003d\" + userLimitResource\n          + \",  queueCapacity\u003d\" + queueCapacity\n          + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n          + \",  currentCapacity\u003d\" + currentCapacity\n          + \",  activeUsers\u003d\" + usersSummedByWeight\n          + \",  clusterCapacity\u003d\" + clusterResource\n          + \",  resourceByLabel\u003d\" + partitionResource\n          + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n          + \",  Partition\u003d\" + nodePartition\n          + \",  resourceUsed\u003d\" + resourceUsed\n          + \",  maxUserLimit\u003d\" + maxUserLimit\n          + \",  userWeight\u003d\" + getUser(userName).getWeight()\n      );\n    }\n    return userLimitResource;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5892. Support user-specific minimum user limit percentage in Capacity Scheduler. Contributed by Eric Payne.\n",
      "commitDate": "22/06/17 11:50 PM",
      "commitName": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
      "commitAuthor": "Sunil G",
      "commitDateOld": "22/05/17 2:26 PM",
      "commitNameOld": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 31.39,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,126 @@\n   private Resource computeUserLimit(String userName, Resource clusterResource,\n       String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n     /*\n      * What is our current capacity?\n      * * It is equal to the max(required, queue-capacity) if we\u0027re running\n      * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n      * capacity (\u003c 1 slot) make progress\n      * * If we\u0027re running over capacity, then its (usedResources + required)\n      * (which extra resources we are allocating)\n      */\n     Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n         resourceCalculator, partitionResource,\n         lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n         lQueue.getMinimumAllocation());\n \n     /*\n      * Assume we have required resource equals to minimumAllocation, this can\n      * make sure user limit can continuously increase till queueMaxResource\n      * reached.\n      */\n     Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n         queueCapacity, required);\n \n     /*\n-     * We want to base the userLimit calculation on max(queueCapacity,\n-     * usedResources+required). However, we want usedResources to be based on\n-     * the combined ratios of all the users in the queue so we use consumedRatio\n-     * to calculate such. The calculation is dependent on how the\n-     * resourceCalculator calculates the ratio between two Resources. DRF\n-     * Example: If usedResources is greater than queueCapacity and users have\n-     * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is\n-     * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio\n-     * is then 20+30\u003d50%. Yes, this value can be larger than 100% but for the\n-     * purposes of making sure all users are getting their fair share, it works.\n+     * We want to base the userLimit calculation on\n+     * max(queueCapacity, usedResources+required). However, we want\n+     * usedResources to be based on the combined ratios of all the users in the\n+     * queue so we use consumedRatio to calculate such.\n+     * The calculation is dependent on how the resourceCalculator calculates the\n+     * ratio between two Resources. DRF Example: If usedResources is greater\n+     * than queueCapacity and users have the following [mem,cpu] usages:\n+     *\n+     * User1: [10%,20%] - Dominant resource is 20%\n+     * User2: [30%,10%] - Dominant resource is 30%\n+     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n+     * larger than 100% but for the purposes of making sure all users are\n+     * getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n         partitionResource, getUsageRatio(nodePartition),\n         lQueue.getMinimumAllocation());\n     Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n         partitionResource, consumed, queueCapacity)\n             ? queueCapacity\n             : Resources.add(consumed, required);\n \n     /*\n      * Never allow a single user to take more than the queue\u0027s configured\n      * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n      * should be higher than queue-hard-limit * ulMin\n      */\n-    int usersCount \u003d getNumActiveUsers();\n+    float usersSummedByWeight \u003d activeUsersTimesWeights;\n     Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n \n     // For non-activeUser calculation, consider all users count.\n     if (!activeUser) {\n       resourceUsed \u003d currentCapacity;\n-      usersCount \u003d users.size();\n+      usersSummedByWeight \u003d allUsersTimesWeights;\n     }\n \n     /*\n-     * User limit resource is determined by: max{currentCapacity / #activeUsers,\n+     * User limit resource is determined by: max(currentCapacity / #activeUsers,\n      * currentCapacity * user-limit-percentage%)\n      */\n     Resource userLimitResource \u003d Resources.max(resourceCalculator,\n         partitionResource,\n         Resources.divideAndCeil(resourceCalculator, resourceUsed,\n-            usersCount),\n+            usersSummedByWeight),\n         Resources.divideAndCeil(resourceCalculator,\n             Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n             100));\n \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor\n     // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n           getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d Resources\n         .roundUp(resourceCalculator,\n             Resources.min(resourceCalculator, partitionResource,\n                 userLimitResource, maxUserLimit),\n             lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"User limit computation for \" + userName + \" in queue \"\n-          + lQueue.getQueueName() + \" userLimitPercent\u003d\" + lQueue.getUserLimit()\n-          + \" userLimitFactor\u003d\" + lQueue.getUserLimitFactor() + \" required: \"\n-          + required + \" consumed: \" + consumed + \" user-limit-resource: \"\n-          + userLimitResource + \" queueCapacity: \" + queueCapacity\n-          + \" qconsumed: \" + lQueue.getQueueResourceUsage().getUsed()\n-          + \" currentCapacity: \" + currentCapacity + \" activeUsers: \"\n-          + usersCount + \" clusterCapacity: \" + clusterResource\n-          + \" resourceByLabel: \" + partitionResource + \" usageratio: \"\n-          + getUsageRatio(nodePartition) + \" Partition: \" + nodePartition);\n+      LOG.debug(\"User limit computation for \" + userName\n+          + \",  in queue: \" + lQueue.getQueueName()\n+          + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n+          + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n+          + \",  required\u003d\" + required\n+          + \",  consumed\u003d\" + consumed\n+          + \",  user-limit-resource\u003d\" + userLimitResource\n+          + \",  queueCapacity\u003d\" + queueCapacity\n+          + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n+          + \",  currentCapacity\u003d\" + currentCapacity\n+          + \",  activeUsers\u003d\" + usersSummedByWeight\n+          + \",  clusterCapacity\u003d\" + clusterResource\n+          + \",  resourceByLabel\u003d\" + partitionResource\n+          + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n+          + \",  Partition\u003d\" + nodePartition\n+          + \",  resourceUsed\u003d\" + resourceUsed\n+          + \",  maxUserLimit\u003d\" + maxUserLimit\n+          + \",  userWeight\u003d\" + getUser(userName).getWeight()\n+      );\n     }\n-    getUser(userName).setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n        resourceCalculator, partitionResource,\n        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n        lQueue.getMinimumAllocation());\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is greater\n     * than queueCapacity and users have the following [mem,cpu] usages:\n     *\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    float usersSummedByWeight \u003d activeUsersTimesWeights;\n    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersSummedByWeight \u003d allUsersTimesWeights;\n    }\n\n    /*\n     * User limit resource is determined by: max(currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersSummedByWeight),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName\n          + \",  in queue: \" + lQueue.getQueueName()\n          + \",  userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \",  userLimitFactor\u003d\" + lQueue.getUserLimitFactor()\n          + \",  required\u003d\" + required\n          + \",  consumed\u003d\" + consumed\n          + \",  user-limit-resource\u003d\" + userLimitResource\n          + \",  queueCapacity\u003d\" + queueCapacity\n          + \",  qconsumed\u003d\" + lQueue.getQueueResourceUsage().getUsed()\n          + \",  currentCapacity\u003d\" + currentCapacity\n          + \",  activeUsers\u003d\" + usersSummedByWeight\n          + \",  clusterCapacity\u003d\" + clusterResource\n          + \",  resourceByLabel\u003d\" + partitionResource\n          + \",  usageratio\u003d\" + getUsageRatio(nodePartition)\n          + \",  Partition\u003d\" + nodePartition\n          + \",  resourceUsed\u003d\" + resourceUsed\n          + \",  maxUserLimit\u003d\" + maxUserLimit\n          + \",  userWeight\u003d\" + getUser(userName).getWeight()\n      );\n    }\n    return userLimitResource;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "09/02/17 10:23 AM",
      "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
          "commitDate": "09/02/17 10:23 AM",
          "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/02/17 8:47 AM",
          "commitNameOld": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,115 @@\n-  private Resource computeUserLimit(String userName,\n-      Resource clusterResource, User user,\n-      String nodePartition, SchedulingMode schedulingMode) {\n+  private Resource computeUserLimit(String userName, Resource clusterResource,\n+      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n-    // What is our current capacity? \n-    // * It is equal to the max(required, queue-capacity) if\n-    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n-    //   with miniscule capacity (\u003c 1 slot) make progress\n-    // * If we\u0027re running over capacity, then its\n-    //   (usedResources + required) (which extra resources we are allocating)\n-    Resource queueCapacity \u003d\n-        Resources.multiplyAndNormalizeUp(resourceCalculator,\n-            partitionResource,\n-            queueCapacities.getAbsoluteCapacity(nodePartition),\n-            minimumAllocation);\n+    /*\n+     * What is our current capacity?\n+     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n+     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n+     * capacity (\u003c 1 slot) make progress\n+     * * If we\u0027re running over capacity, then its (usedResources + required)\n+     * (which extra resources we are allocating)\n+     */\n+    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n+        resourceCalculator, partitionResource,\n+        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n+        lQueue.getMinimumAllocation());\n \n-    // Assume we have required resource equals to minimumAllocation, this can\n-    // make sure user limit can continuously increase till queueMaxResource\n-    // reached.\n-    Resource required \u003d minimumAllocation;\n+    /*\n+     * Assume we have required resource equals to minimumAllocation, this can\n+     * make sure user limit can continuously increase till queueMaxResource\n+     * reached.\n+     */\n+    Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n-    queueCapacity \u003d\n-        Resources.max(\n-            resourceCalculator, partitionResource,\n-            queueCapacity, \n-            required);\n+    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n+        queueCapacity, required);\n \n-\n-    /* We want to base the userLimit calculation on\n-     * max(queueCapacity, usedResources+required). However, we want\n-     * usedResources to be based on the combined ratios of all the users in the\n-     * queue so we use consumedRatio to calculate such.\n-     * The calculation is dependent on how the resourceCalculator calculates the\n-     * ratio between two Resources. DRF Example: If usedResources is\n-     * greater than queueCapacity and users have the following [mem,cpu] usages:\n-     * User1: [10%,20%] - Dominant resource is 20%\n-     * User2: [30%,10%] - Dominant resource is 30%\n-     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n-     * larger than 100% but for the purposes of making sure all users are\n-     * getting their fair share, it works.\n+    /*\n+     * We want to base the userLimit calculation on max(queueCapacity,\n+     * usedResources+required). However, we want usedResources to be based on\n+     * the combined ratios of all the users in the queue so we use consumedRatio\n+     * to calculate such. The calculation is dependent on how the\n+     * resourceCalculator calculates the ratio between two Resources. DRF\n+     * Example: If usedResources is greater than queueCapacity and users have\n+     * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is\n+     * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio\n+     * is then 20+30\u003d50%. Yes, this value can be larger than 100% but for the\n+     * purposes of making sure all users are getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n-        partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n-        minimumAllocation);\n-    Resource currentCapacity \u003d\n-        Resources.lessThan(resourceCalculator, partitionResource, consumed,\n-            queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n-    // Never allow a single user to take more than the \n-    // queue\u0027s configured capacity * user-limit-factor.\n-    // Also, the queue\u0027s configured capacity should be higher than \n-    // queue-hard-limit * ulMin\n-    \n-    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n-    \n-    // User limit resource is determined by:\n-    // max{currentCapacity / #activeUsers, currentCapacity *\n-    // user-limit-percentage%)\n-    Resource userLimitResource \u003d Resources.max(\n-        resourceCalculator, partitionResource,\n-        Resources.divideAndCeil(\n-            resourceCalculator, currentCapacity, activeUsers),\n-        Resources.divideAndCeil(\n-            resourceCalculator, \n-            Resources.multiplyAndRoundDown(\n-                currentCapacity, userLimit), \n-            100)\n-        );\n-    \n+        partitionResource, getUsageRatio(nodePartition),\n+        lQueue.getMinimumAllocation());\n+    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n+        partitionResource, consumed, queueCapacity)\n+            ? queueCapacity\n+            : Resources.add(consumed, required);\n+\n+    /*\n+     * Never allow a single user to take more than the queue\u0027s configured\n+     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n+     * should be higher than queue-hard-limit * ulMin\n+     */\n+    int usersCount \u003d getNumActiveUsers();\n+    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n+\n+    // For non-activeUser calculation, consider all users count.\n+    if (!activeUser) {\n+      resourceUsed \u003d currentCapacity;\n+      usersCount \u003d users.size();\n+    }\n+\n+    /*\n+     * User limit resource is determined by: max{currentCapacity / #activeUsers,\n+     * currentCapacity * user-limit-percentage%)\n+     */\n+    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n+        partitionResource,\n+        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n+            usersCount),\n+        Resources.divideAndCeil(resourceCalculator,\n+            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n+            100));\n+\n     // User limit is capped by maxUserLimit\n-    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n+    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n+    // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n-      maxUserLimit \u003d\n-          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n+      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n+          getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n-    \n+\n     // Cap final user limit with maxUserLimit\n-    userLimitResource \u003d\n-        Resources.roundUp(\n-            resourceCalculator, \n-            Resources.min(\n-                resourceCalculator, partitionResource,\n-                  userLimitResource,\n-                  maxUserLimit\n-                ), \n-            minimumAllocation);\n+    userLimitResource \u003d Resources\n+        .roundUp(resourceCalculator,\n+            Resources.min(resourceCalculator, partitionResource,\n+                userLimitResource, maxUserLimit),\n+            lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"User limit computation for \" + userName +\n-          \" in queue \" + getQueueName() +\n-          \" userLimitPercent\u003d\" + userLimit +\n-          \" userLimitFactor\u003d\" + userLimitFactor +\n-          \" required: \" + required +\n-          \" consumed: \" + consumed +\n-          \" user-limit-resource: \" + userLimitResource +\n-          \" queueCapacity: \" + queueCapacity +\n-          \" qconsumed: \" + queueUsage.getUsed() +\n-          \" consumedRatio: \" + totalUserConsumedRatio +\n-          \" currentCapacity: \" + currentCapacity +\n-          \" activeUsers: \" + activeUsers +\n-          \" clusterCapacity: \" + clusterResource +\n-          \" resourceByLabel: \" + partitionResource +\n-          \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n-          \" Partition: \" + nodePartition\n-      );\n+      LOG.debug(\"User limit computation for \" + userName + \" in queue \"\n+          + lQueue.getQueueName() + \" userLimitPercent\u003d\" + lQueue.getUserLimit()\n+          + \" userLimitFactor\u003d\" + lQueue.getUserLimitFactor() + \" required: \"\n+          + required + \" consumed: \" + consumed + \" user-limit-resource: \"\n+          + userLimitResource + \" queueCapacity: \" + queueCapacity\n+          + \" qconsumed: \" + lQueue.getQueueResourceUsage().getUsed()\n+          + \" currentCapacity: \" + currentCapacity + \" activeUsers: \"\n+          + usersCount + \" clusterCapacity: \" + clusterResource\n+          + \" resourceByLabel: \" + partitionResource + \" usageratio: \"\n+          + getUsageRatio(nodePartition) + \" Partition: \" + nodePartition);\n     }\n-    user.setUserResourceLimit(userLimitResource);\n+    getUser(userName).setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n        resourceCalculator, partitionResource,\n        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n        lQueue.getMinimumAllocation());\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on max(queueCapacity,\n     * usedResources+required). However, we want usedResources to be based on\n     * the combined ratios of all the users in the queue so we use consumedRatio\n     * to calculate such. The calculation is dependent on how the\n     * resourceCalculator calculates the ratio between two Resources. DRF\n     * Example: If usedResources is greater than queueCapacity and users have\n     * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is\n     * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio\n     * is then 20+30\u003d50%. Yes, this value can be larger than 100% but for the\n     * purposes of making sure all users are getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    int usersCount \u003d getNumActiveUsers();\n    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersCount \u003d users.size();\n    }\n\n    /*\n     * User limit resource is determined by: max{currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersCount),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName + \" in queue \"\n          + lQueue.getQueueName() + \" userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \" userLimitFactor\u003d\" + lQueue.getUserLimitFactor() + \" required: \"\n          + required + \" consumed: \" + consumed + \" user-limit-resource: \"\n          + userLimitResource + \" queueCapacity: \" + queueCapacity\n          + \" qconsumed: \" + lQueue.getQueueResourceUsage().getUsed()\n          + \" currentCapacity: \" + currentCapacity + \" activeUsers: \"\n          + usersCount + \" clusterCapacity: \" + clusterResource\n          + \" resourceByLabel: \" + partitionResource + \" usageratio: \"\n          + getUsageRatio(nodePartition) + \" Partition: \" + nodePartition);\n    }\n    getUser(userName).setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
            "oldMethodName": "computeUserLimit",
            "newMethodName": "computeUserLimit"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
          "commitDate": "09/02/17 10:23 AM",
          "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/02/17 8:47 AM",
          "commitNameOld": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,115 @@\n-  private Resource computeUserLimit(String userName,\n-      Resource clusterResource, User user,\n-      String nodePartition, SchedulingMode schedulingMode) {\n+  private Resource computeUserLimit(String userName, Resource clusterResource,\n+      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n-    // What is our current capacity? \n-    // * It is equal to the max(required, queue-capacity) if\n-    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n-    //   with miniscule capacity (\u003c 1 slot) make progress\n-    // * If we\u0027re running over capacity, then its\n-    //   (usedResources + required) (which extra resources we are allocating)\n-    Resource queueCapacity \u003d\n-        Resources.multiplyAndNormalizeUp(resourceCalculator,\n-            partitionResource,\n-            queueCapacities.getAbsoluteCapacity(nodePartition),\n-            minimumAllocation);\n+    /*\n+     * What is our current capacity?\n+     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n+     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n+     * capacity (\u003c 1 slot) make progress\n+     * * If we\u0027re running over capacity, then its (usedResources + required)\n+     * (which extra resources we are allocating)\n+     */\n+    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n+        resourceCalculator, partitionResource,\n+        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n+        lQueue.getMinimumAllocation());\n \n-    // Assume we have required resource equals to minimumAllocation, this can\n-    // make sure user limit can continuously increase till queueMaxResource\n-    // reached.\n-    Resource required \u003d minimumAllocation;\n+    /*\n+     * Assume we have required resource equals to minimumAllocation, this can\n+     * make sure user limit can continuously increase till queueMaxResource\n+     * reached.\n+     */\n+    Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n-    queueCapacity \u003d\n-        Resources.max(\n-            resourceCalculator, partitionResource,\n-            queueCapacity, \n-            required);\n+    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n+        queueCapacity, required);\n \n-\n-    /* We want to base the userLimit calculation on\n-     * max(queueCapacity, usedResources+required). However, we want\n-     * usedResources to be based on the combined ratios of all the users in the\n-     * queue so we use consumedRatio to calculate such.\n-     * The calculation is dependent on how the resourceCalculator calculates the\n-     * ratio between two Resources. DRF Example: If usedResources is\n-     * greater than queueCapacity and users have the following [mem,cpu] usages:\n-     * User1: [10%,20%] - Dominant resource is 20%\n-     * User2: [30%,10%] - Dominant resource is 30%\n-     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n-     * larger than 100% but for the purposes of making sure all users are\n-     * getting their fair share, it works.\n+    /*\n+     * We want to base the userLimit calculation on max(queueCapacity,\n+     * usedResources+required). However, we want usedResources to be based on\n+     * the combined ratios of all the users in the queue so we use consumedRatio\n+     * to calculate such. The calculation is dependent on how the\n+     * resourceCalculator calculates the ratio between two Resources. DRF\n+     * Example: If usedResources is greater than queueCapacity and users have\n+     * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is\n+     * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio\n+     * is then 20+30\u003d50%. Yes, this value can be larger than 100% but for the\n+     * purposes of making sure all users are getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n-        partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n-        minimumAllocation);\n-    Resource currentCapacity \u003d\n-        Resources.lessThan(resourceCalculator, partitionResource, consumed,\n-            queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n-    // Never allow a single user to take more than the \n-    // queue\u0027s configured capacity * user-limit-factor.\n-    // Also, the queue\u0027s configured capacity should be higher than \n-    // queue-hard-limit * ulMin\n-    \n-    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n-    \n-    // User limit resource is determined by:\n-    // max{currentCapacity / #activeUsers, currentCapacity *\n-    // user-limit-percentage%)\n-    Resource userLimitResource \u003d Resources.max(\n-        resourceCalculator, partitionResource,\n-        Resources.divideAndCeil(\n-            resourceCalculator, currentCapacity, activeUsers),\n-        Resources.divideAndCeil(\n-            resourceCalculator, \n-            Resources.multiplyAndRoundDown(\n-                currentCapacity, userLimit), \n-            100)\n-        );\n-    \n+        partitionResource, getUsageRatio(nodePartition),\n+        lQueue.getMinimumAllocation());\n+    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n+        partitionResource, consumed, queueCapacity)\n+            ? queueCapacity\n+            : Resources.add(consumed, required);\n+\n+    /*\n+     * Never allow a single user to take more than the queue\u0027s configured\n+     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n+     * should be higher than queue-hard-limit * ulMin\n+     */\n+    int usersCount \u003d getNumActiveUsers();\n+    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n+\n+    // For non-activeUser calculation, consider all users count.\n+    if (!activeUser) {\n+      resourceUsed \u003d currentCapacity;\n+      usersCount \u003d users.size();\n+    }\n+\n+    /*\n+     * User limit resource is determined by: max{currentCapacity / #activeUsers,\n+     * currentCapacity * user-limit-percentage%)\n+     */\n+    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n+        partitionResource,\n+        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n+            usersCount),\n+        Resources.divideAndCeil(resourceCalculator,\n+            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n+            100));\n+\n     // User limit is capped by maxUserLimit\n-    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n+    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n+    // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n-      maxUserLimit \u003d\n-          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n+      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n+          getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n-    \n+\n     // Cap final user limit with maxUserLimit\n-    userLimitResource \u003d\n-        Resources.roundUp(\n-            resourceCalculator, \n-            Resources.min(\n-                resourceCalculator, partitionResource,\n-                  userLimitResource,\n-                  maxUserLimit\n-                ), \n-            minimumAllocation);\n+    userLimitResource \u003d Resources\n+        .roundUp(resourceCalculator,\n+            Resources.min(resourceCalculator, partitionResource,\n+                userLimitResource, maxUserLimit),\n+            lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"User limit computation for \" + userName +\n-          \" in queue \" + getQueueName() +\n-          \" userLimitPercent\u003d\" + userLimit +\n-          \" userLimitFactor\u003d\" + userLimitFactor +\n-          \" required: \" + required +\n-          \" consumed: \" + consumed +\n-          \" user-limit-resource: \" + userLimitResource +\n-          \" queueCapacity: \" + queueCapacity +\n-          \" qconsumed: \" + queueUsage.getUsed() +\n-          \" consumedRatio: \" + totalUserConsumedRatio +\n-          \" currentCapacity: \" + currentCapacity +\n-          \" activeUsers: \" + activeUsers +\n-          \" clusterCapacity: \" + clusterResource +\n-          \" resourceByLabel: \" + partitionResource +\n-          \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n-          \" Partition: \" + nodePartition\n-      );\n+      LOG.debug(\"User limit computation for \" + userName + \" in queue \"\n+          + lQueue.getQueueName() + \" userLimitPercent\u003d\" + lQueue.getUserLimit()\n+          + \" userLimitFactor\u003d\" + lQueue.getUserLimitFactor() + \" required: \"\n+          + required + \" consumed: \" + consumed + \" user-limit-resource: \"\n+          + userLimitResource + \" queueCapacity: \" + queueCapacity\n+          + \" qconsumed: \" + lQueue.getQueueResourceUsage().getUsed()\n+          + \" currentCapacity: \" + currentCapacity + \" activeUsers: \"\n+          + usersCount + \" clusterCapacity: \" + clusterResource\n+          + \" resourceByLabel: \" + partitionResource + \" usageratio: \"\n+          + getUsageRatio(nodePartition) + \" Partition: \" + nodePartition);\n     }\n-    user.setUserResourceLimit(userLimitResource);\n+    getUser(userName).setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n        resourceCalculator, partitionResource,\n        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n        lQueue.getMinimumAllocation());\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on max(queueCapacity,\n     * usedResources+required). However, we want usedResources to be based on\n     * the combined ratios of all the users in the queue so we use consumedRatio\n     * to calculate such. The calculation is dependent on how the\n     * resourceCalculator calculates the ratio between two Resources. DRF\n     * Example: If usedResources is greater than queueCapacity and users have\n     * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is\n     * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio\n     * is then 20+30\u003d50%. Yes, this value can be larger than 100% but for the\n     * purposes of making sure all users are getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    int usersCount \u003d getNumActiveUsers();\n    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersCount \u003d users.size();\n    }\n\n    /*\n     * User limit resource is determined by: max{currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersCount),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName + \" in queue \"\n          + lQueue.getQueueName() + \" userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \" userLimitFactor\u003d\" + lQueue.getUserLimitFactor() + \" required: \"\n          + required + \" consumed: \" + consumed + \" user-limit-resource: \"\n          + userLimitResource + \" queueCapacity: \" + queueCapacity\n          + \" qconsumed: \" + lQueue.getQueueResourceUsage().getUsed()\n          + \" currentCapacity: \" + currentCapacity + \" activeUsers: \"\n          + usersCount + \" clusterCapacity: \" + clusterResource\n          + \" resourceByLabel: \" + partitionResource + \" usageratio: \"\n          + getUsageRatio(nodePartition) + \" Partition: \" + nodePartition);\n    }\n    getUser(userName).setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
          "commitDate": "09/02/17 10:23 AM",
          "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/02/17 8:47 AM",
          "commitNameOld": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,115 @@\n-  private Resource computeUserLimit(String userName,\n-      Resource clusterResource, User user,\n-      String nodePartition, SchedulingMode schedulingMode) {\n+  private Resource computeUserLimit(String userName, Resource clusterResource,\n+      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n-    // What is our current capacity? \n-    // * It is equal to the max(required, queue-capacity) if\n-    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n-    //   with miniscule capacity (\u003c 1 slot) make progress\n-    // * If we\u0027re running over capacity, then its\n-    //   (usedResources + required) (which extra resources we are allocating)\n-    Resource queueCapacity \u003d\n-        Resources.multiplyAndNormalizeUp(resourceCalculator,\n-            partitionResource,\n-            queueCapacities.getAbsoluteCapacity(nodePartition),\n-            minimumAllocation);\n+    /*\n+     * What is our current capacity?\n+     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n+     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n+     * capacity (\u003c 1 slot) make progress\n+     * * If we\u0027re running over capacity, then its (usedResources + required)\n+     * (which extra resources we are allocating)\n+     */\n+    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n+        resourceCalculator, partitionResource,\n+        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n+        lQueue.getMinimumAllocation());\n \n-    // Assume we have required resource equals to minimumAllocation, this can\n-    // make sure user limit can continuously increase till queueMaxResource\n-    // reached.\n-    Resource required \u003d minimumAllocation;\n+    /*\n+     * Assume we have required resource equals to minimumAllocation, this can\n+     * make sure user limit can continuously increase till queueMaxResource\n+     * reached.\n+     */\n+    Resource required \u003d lQueue.getMinimumAllocation();\n \n     // Allow progress for queues with miniscule capacity\n-    queueCapacity \u003d\n-        Resources.max(\n-            resourceCalculator, partitionResource,\n-            queueCapacity, \n-            required);\n+    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n+        queueCapacity, required);\n \n-\n-    /* We want to base the userLimit calculation on\n-     * max(queueCapacity, usedResources+required). However, we want\n-     * usedResources to be based on the combined ratios of all the users in the\n-     * queue so we use consumedRatio to calculate such.\n-     * The calculation is dependent on how the resourceCalculator calculates the\n-     * ratio between two Resources. DRF Example: If usedResources is\n-     * greater than queueCapacity and users have the following [mem,cpu] usages:\n-     * User1: [10%,20%] - Dominant resource is 20%\n-     * User2: [30%,10%] - Dominant resource is 30%\n-     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n-     * larger than 100% but for the purposes of making sure all users are\n-     * getting their fair share, it works.\n+    /*\n+     * We want to base the userLimit calculation on max(queueCapacity,\n+     * usedResources+required). However, we want usedResources to be based on\n+     * the combined ratios of all the users in the queue so we use consumedRatio\n+     * to calculate such. The calculation is dependent on how the\n+     * resourceCalculator calculates the ratio between two Resources. DRF\n+     * Example: If usedResources is greater than queueCapacity and users have\n+     * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is\n+     * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio\n+     * is then 20+30\u003d50%. Yes, this value can be larger than 100% but for the\n+     * purposes of making sure all users are getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n-        partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n-        minimumAllocation);\n-    Resource currentCapacity \u003d\n-        Resources.lessThan(resourceCalculator, partitionResource, consumed,\n-            queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n-    // Never allow a single user to take more than the \n-    // queue\u0027s configured capacity * user-limit-factor.\n-    // Also, the queue\u0027s configured capacity should be higher than \n-    // queue-hard-limit * ulMin\n-    \n-    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n-    \n-    // User limit resource is determined by:\n-    // max{currentCapacity / #activeUsers, currentCapacity *\n-    // user-limit-percentage%)\n-    Resource userLimitResource \u003d Resources.max(\n-        resourceCalculator, partitionResource,\n-        Resources.divideAndCeil(\n-            resourceCalculator, currentCapacity, activeUsers),\n-        Resources.divideAndCeil(\n-            resourceCalculator, \n-            Resources.multiplyAndRoundDown(\n-                currentCapacity, userLimit), \n-            100)\n-        );\n-    \n+        partitionResource, getUsageRatio(nodePartition),\n+        lQueue.getMinimumAllocation());\n+    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n+        partitionResource, consumed, queueCapacity)\n+            ? queueCapacity\n+            : Resources.add(consumed, required);\n+\n+    /*\n+     * Never allow a single user to take more than the queue\u0027s configured\n+     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n+     * should be higher than queue-hard-limit * ulMin\n+     */\n+    int usersCount \u003d getNumActiveUsers();\n+    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n+\n+    // For non-activeUser calculation, consider all users count.\n+    if (!activeUser) {\n+      resourceUsed \u003d currentCapacity;\n+      usersCount \u003d users.size();\n+    }\n+\n+    /*\n+     * User limit resource is determined by: max{currentCapacity / #activeUsers,\n+     * currentCapacity * user-limit-percentage%)\n+     */\n+    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n+        partitionResource,\n+        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n+            usersCount),\n+        Resources.divideAndCeil(resourceCalculator,\n+            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n+            100));\n+\n     // User limit is capped by maxUserLimit\n-    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n+    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n+    // (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n-      maxUserLimit \u003d\n-          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n+      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n+          getUserLimitFactor());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n-    \n+\n     // Cap final user limit with maxUserLimit\n-    userLimitResource \u003d\n-        Resources.roundUp(\n-            resourceCalculator, \n-            Resources.min(\n-                resourceCalculator, partitionResource,\n-                  userLimitResource,\n-                  maxUserLimit\n-                ), \n-            minimumAllocation);\n+    userLimitResource \u003d Resources\n+        .roundUp(resourceCalculator,\n+            Resources.min(resourceCalculator, partitionResource,\n+                userLimitResource, maxUserLimit),\n+            lQueue.getMinimumAllocation());\n \n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"User limit computation for \" + userName +\n-          \" in queue \" + getQueueName() +\n-          \" userLimitPercent\u003d\" + userLimit +\n-          \" userLimitFactor\u003d\" + userLimitFactor +\n-          \" required: \" + required +\n-          \" consumed: \" + consumed +\n-          \" user-limit-resource: \" + userLimitResource +\n-          \" queueCapacity: \" + queueCapacity +\n-          \" qconsumed: \" + queueUsage.getUsed() +\n-          \" consumedRatio: \" + totalUserConsumedRatio +\n-          \" currentCapacity: \" + currentCapacity +\n-          \" activeUsers: \" + activeUsers +\n-          \" clusterCapacity: \" + clusterResource +\n-          \" resourceByLabel: \" + partitionResource +\n-          \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n-          \" Partition: \" + nodePartition\n-      );\n+      LOG.debug(\"User limit computation for \" + userName + \" in queue \"\n+          + lQueue.getQueueName() + \" userLimitPercent\u003d\" + lQueue.getUserLimit()\n+          + \" userLimitFactor\u003d\" + lQueue.getUserLimitFactor() + \" required: \"\n+          + required + \" consumed: \" + consumed + \" user-limit-resource: \"\n+          + userLimitResource + \" queueCapacity: \" + queueCapacity\n+          + \" qconsumed: \" + lQueue.getQueueResourceUsage().getUsed()\n+          + \" currentCapacity: \" + currentCapacity + \" activeUsers: \"\n+          + usersCount + \" clusterCapacity: \" + clusterResource\n+          + \" resourceByLabel: \" + partitionResource + \" usageratio: \"\n+          + getUsageRatio(nodePartition) + \" Partition: \" + nodePartition);\n     }\n-    user.setUserResourceLimit(userLimitResource);\n+    getUser(userName).setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we\u0027re running\n     * below capacity. The \u0027max\u0027 ensures that jobs in queues with miniscule\n     * capacity (\u003c 1 slot) make progress\n     * * If we\u0027re running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity \u003d Resources.multiplyAndNormalizeUp(\n        resourceCalculator, partitionResource,\n        lQueue.getQueueCapacities().getAbsoluteCapacity(nodePartition),\n        lQueue.getMinimumAllocation());\n\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required \u003d lQueue.getMinimumAllocation();\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n\n    /*\n     * We want to base the userLimit calculation on max(queueCapacity,\n     * usedResources+required). However, we want usedResources to be based on\n     * the combined ratios of all the users in the queue so we use consumedRatio\n     * to calculate such. The calculation is dependent on how the\n     * resourceCalculator calculates the ratio between two Resources. DRF\n     * Example: If usedResources is greater than queueCapacity and users have\n     * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is\n     * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio\n     * is then 20+30\u003d50%. Yes, this value can be larger than 100% but for the\n     * purposes of making sure all users are getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity \u003d Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n\n    /*\n     * Never allow a single user to take more than the queue\u0027s configured\n     * capacity * user-limit-factor. Also, the queue\u0027s configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    int usersCount \u003d getNumActiveUsers();\n    Resource resourceUsed \u003d totalResUsageForActiveUsers.getUsed(nodePartition);\n\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed \u003d currentCapacity;\n      usersCount \u003d users.size();\n    }\n\n    /*\n     * User limit resource is determined by: max{currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource \u003d Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersCount),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n\n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName + \" in queue \"\n          + lQueue.getQueueName() + \" userLimitPercent\u003d\" + lQueue.getUserLimit()\n          + \" userLimitFactor\u003d\" + lQueue.getUserLimitFactor() + \" required: \"\n          + required + \" consumed: \" + consumed + \" user-limit-resource: \"\n          + userLimitResource + \" queueCapacity: \" + queueCapacity\n          + \" qconsumed: \" + lQueue.getQueueResourceUsage().getUsed()\n          + \" currentCapacity: \" + currentCapacity + \" activeUsers: \"\n          + usersCount + \" clusterCapacity: \" + clusterResource\n          + \" resourceByLabel: \" + partitionResource + \" usageratio: \"\n          + getUsageRatio(nodePartition) + \" Partition: \" + nodePartition);\n    }\n    getUser(userName).setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
          "extendedDetails": {
            "oldValue": "[userName-String, clusterResource-Resource, user-User, nodePartition-String, schedulingMode-SchedulingMode]",
            "newValue": "[userName-String, clusterResource-Resource, nodePartition-String, schedulingMode-SchedulingMode, activeUser-boolean]"
          }
        }
      ]
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
          "commitDate": "31/10/16 3:18 PM",
          "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "29/10/16 1:17 AM",
          "commitNameOld": "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f",
          "commitAuthorOld": "Varun Saxena",
          "daysBetweenCommits": 2.58,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,121 @@\n-  private Resource computeUserLimit(FiCaSchedulerApp application,\n+  private Resource computeUserLimit(String userName,\n       Resource clusterResource, User user,\n       String nodePartition, SchedulingMode schedulingMode) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d\n         Resources.multiplyAndNormalizeUp(resourceCalculator,\n             partitionResource,\n             queueCapacities.getAbsoluteCapacity(nodePartition),\n             minimumAllocation);\n \n     // Assume we have required resource equals to minimumAllocation, this can\n     // make sure user limit can continuously increase till queueMaxResource\n     // reached.\n     Resource required \u003d minimumAllocation;\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, partitionResource,\n             queueCapacity, \n             required);\n \n \n     /* We want to base the userLimit calculation on\n      * max(queueCapacity, usedResources+required). However, we want\n      * usedResources to be based on the combined ratios of all the users in the\n      * queue so we use consumedRatio to calculate such.\n      * The calculation is dependent on how the resourceCalculator calculates the\n      * ratio between two Resources. DRF Example: If usedResources is\n      * greater than queueCapacity and users have the following [mem,cpu] usages:\n      * User1: [10%,20%] - Dominant resource is 20%\n      * User2: [30%,10%] - Dominant resource is 30%\n      * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n      * larger than 100% but for the purposes of making sure all users are\n      * getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n         partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n         minimumAllocation);\n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, partitionResource, consumed,\n             queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n     \n     // User limit resource is determined by:\n     // max{currentCapacity / #activeUsers, currentCapacity *\n     // user-limit-percentage%)\n     Resource userLimitResource \u003d Resources.max(\n         resourceCalculator, partitionResource,\n         Resources.divideAndCeil(\n             resourceCalculator, currentCapacity, activeUsers),\n         Resources.divideAndCeil(\n             resourceCalculator, \n             Resources.multiplyAndRoundDown(\n                 currentCapacity, userLimit), \n             100)\n         );\n     \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d\n           Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n     \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, partitionResource,\n                   userLimitResource,\n                   maxUserLimit\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n-      String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName +\n           \" in queue \" + getQueueName() +\n           \" userLimitPercent\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required +\n           \" consumed: \" + consumed +\n           \" user-limit-resource: \" + userLimitResource +\n           \" queueCapacity: \" + queueCapacity +\n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" consumedRatio: \" + totalUserConsumedRatio +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource +\n           \" resourceByLabel: \" + partitionResource +\n           \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n           \" Partition: \" + nodePartition\n       );\n     }\n     user.setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(String userName,\n      Resource clusterResource, User user,\n      String nodePartition, SchedulingMode schedulingMode) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d\n        Resources.multiplyAndNormalizeUp(resourceCalculator,\n            partitionResource,\n            queueCapacities.getAbsoluteCapacity(nodePartition),\n            minimumAllocation);\n\n    // Assume we have required resource equals to minimumAllocation, this can\n    // make sure user limit can continuously increase till queueMaxResource\n    // reached.\n    Resource required \u003d minimumAllocation;\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, partitionResource,\n            queueCapacity, \n            required);\n\n\n    /* We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is\n     * greater than queueCapacity and users have the following [mem,cpu] usages:\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n        minimumAllocation);\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, partitionResource, consumed,\n            queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n    \n    // User limit resource is determined by:\n    // max{currentCapacity / #activeUsers, currentCapacity *\n    // user-limit-percentage%)\n    Resource userLimitResource \u003d Resources.max(\n        resourceCalculator, partitionResource,\n        Resources.divideAndCeil(\n            resourceCalculator, currentCapacity, activeUsers),\n        Resources.divideAndCeil(\n            resourceCalculator, \n            Resources.multiplyAndRoundDown(\n                currentCapacity, userLimit), \n            100)\n        );\n    \n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n    \n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, partitionResource,\n                  userLimitResource,\n                  maxUserLimit\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName +\n          \" in queue \" + getQueueName() +\n          \" userLimitPercent\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required +\n          \" consumed: \" + consumed +\n          \" user-limit-resource: \" + userLimitResource +\n          \" queueCapacity: \" + queueCapacity +\n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" consumedRatio: \" + totalUserConsumedRatio +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource +\n          \" resourceByLabel: \" + partitionResource +\n          \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n          \" Partition: \" + nodePartition\n      );\n    }\n    user.setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, user-User, nodePartition-String, schedulingMode-SchedulingMode]",
            "newValue": "[userName-String, clusterResource-Resource, user-User, nodePartition-String, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
          "commitDate": "31/10/16 3:18 PM",
          "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "29/10/16 1:17 AM",
          "commitNameOld": "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f",
          "commitAuthorOld": "Varun Saxena",
          "daysBetweenCommits": 2.58,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,121 @@\n-  private Resource computeUserLimit(FiCaSchedulerApp application,\n+  private Resource computeUserLimit(String userName,\n       Resource clusterResource, User user,\n       String nodePartition, SchedulingMode schedulingMode) {\n     Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n         clusterResource);\n \n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d\n         Resources.multiplyAndNormalizeUp(resourceCalculator,\n             partitionResource,\n             queueCapacities.getAbsoluteCapacity(nodePartition),\n             minimumAllocation);\n \n     // Assume we have required resource equals to minimumAllocation, this can\n     // make sure user limit can continuously increase till queueMaxResource\n     // reached.\n     Resource required \u003d minimumAllocation;\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, partitionResource,\n             queueCapacity, \n             required);\n \n \n     /* We want to base the userLimit calculation on\n      * max(queueCapacity, usedResources+required). However, we want\n      * usedResources to be based on the combined ratios of all the users in the\n      * queue so we use consumedRatio to calculate such.\n      * The calculation is dependent on how the resourceCalculator calculates the\n      * ratio between two Resources. DRF Example: If usedResources is\n      * greater than queueCapacity and users have the following [mem,cpu] usages:\n      * User1: [10%,20%] - Dominant resource is 20%\n      * User2: [30%,10%] - Dominant resource is 30%\n      * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n      * larger than 100% but for the purposes of making sure all users are\n      * getting their fair share, it works.\n      */\n     Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n         partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n         minimumAllocation);\n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, partitionResource, consumed,\n             queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n     \n     // User limit resource is determined by:\n     // max{currentCapacity / #activeUsers, currentCapacity *\n     // user-limit-percentage%)\n     Resource userLimitResource \u003d Resources.max(\n         resourceCalculator, partitionResource,\n         Resources.divideAndCeil(\n             resourceCalculator, currentCapacity, activeUsers),\n         Resources.divideAndCeil(\n             resourceCalculator, \n             Resources.multiplyAndRoundDown(\n                 currentCapacity, userLimit), \n             100)\n         );\n     \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d\n           Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d partitionResource;\n     }\n     \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, partitionResource,\n                   userLimitResource,\n                   maxUserLimit\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n-      String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName +\n           \" in queue \" + getQueueName() +\n           \" userLimitPercent\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required +\n           \" consumed: \" + consumed +\n           \" user-limit-resource: \" + userLimitResource +\n           \" queueCapacity: \" + queueCapacity +\n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" consumedRatio: \" + totalUserConsumedRatio +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource +\n           \" resourceByLabel: \" + partitionResource +\n           \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n           \" Partition: \" + nodePartition\n       );\n     }\n     user.setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(String userName,\n      Resource clusterResource, User user,\n      String nodePartition, SchedulingMode schedulingMode) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d\n        Resources.multiplyAndNormalizeUp(resourceCalculator,\n            partitionResource,\n            queueCapacities.getAbsoluteCapacity(nodePartition),\n            minimumAllocation);\n\n    // Assume we have required resource equals to minimumAllocation, this can\n    // make sure user limit can continuously increase till queueMaxResource\n    // reached.\n    Resource required \u003d minimumAllocation;\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, partitionResource,\n            queueCapacity, \n            required);\n\n\n    /* We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is\n     * greater than queueCapacity and users have the following [mem,cpu] usages:\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n        minimumAllocation);\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, partitionResource, consumed,\n            queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n    \n    // User limit resource is determined by:\n    // max{currentCapacity / #activeUsers, currentCapacity *\n    // user-limit-percentage%)\n    Resource userLimitResource \u003d Resources.max(\n        resourceCalculator, partitionResource,\n        Resources.divideAndCeil(\n            resourceCalculator, currentCapacity, activeUsers),\n        Resources.divideAndCeil(\n            resourceCalculator, \n            Resources.multiplyAndRoundDown(\n                currentCapacity, userLimit), \n            100)\n        );\n    \n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n    \n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, partitionResource,\n                  userLimitResource,\n                  maxUserLimit\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName +\n          \" in queue \" + getQueueName() +\n          \" userLimitPercent\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required +\n          \" consumed: \" + consumed +\n          \" user-limit-resource: \" + userLimitResource +\n          \" queueCapacity: \" + queueCapacity +\n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" consumedRatio: \" + totalUserConsumedRatio +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource +\n          \" resourceByLabel: \" + partitionResource +\n          \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n          \" Partition: \" + nodePartition\n      );\n    }\n    user.setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "444b2ea7afebf9f6c3d356154b71abfd0ea95b23": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3388. Allocation in LeafQueue could get stuck because DRF calculator isn\u0027t well supported when computing user-limit. (Nathan Roberts via wangda)\n",
      "commitDate": "19/08/16 4:28 PM",
      "commitName": "444b2ea7afebf9f6c3d356154b71abfd0ea95b23",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "19/08/16 5:00 AM",
      "commitNameOld": "091dd19e8636b8bd5668dbb3bcd8bbce7c952274",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 0.48,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,122 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n       Resource clusterResource, User user,\n       String nodePartition, SchedulingMode schedulingMode) {\n+    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n+        clusterResource);\n+\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d\n         Resources.multiplyAndNormalizeUp(resourceCalculator,\n-            labelManager.getResourceByLabel(nodePartition, clusterResource),\n+            partitionResource,\n             queueCapacities.getAbsoluteCapacity(nodePartition),\n             minimumAllocation);\n \n     // Assume we have required resource equals to minimumAllocation, this can\n     // make sure user limit can continuously increase till queueMaxResource\n     // reached.\n     Resource required \u003d minimumAllocation;\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n-            resourceCalculator, clusterResource, \n+            resourceCalculator, partitionResource,\n             queueCapacity, \n             required);\n \n+\n+    /* We want to base the userLimit calculation on\n+     * max(queueCapacity, usedResources+required). However, we want\n+     * usedResources to be based on the combined ratios of all the users in the\n+     * queue so we use consumedRatio to calculate such.\n+     * The calculation is dependent on how the resourceCalculator calculates the\n+     * ratio between two Resources. DRF Example: If usedResources is\n+     * greater than queueCapacity and users have the following [mem,cpu] usages:\n+     * User1: [10%,20%] - Dominant resource is 20%\n+     * User2: [30%,10%] - Dominant resource is 30%\n+     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n+     * larger than 100% but for the purposes of making sure all users are\n+     * getting their fair share, it works.\n+     */\n+    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n+        partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n+        minimumAllocation);\n     Resource currentCapacity \u003d\n-        Resources.lessThan(resourceCalculator, clusterResource,\n-            queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n-            : Resources.add(queueUsage.getUsed(nodePartition), required);\n-    \n+        Resources.lessThan(resourceCalculator, partitionResource, consumed,\n+            queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n     \n     // User limit resource is determined by:\n-    // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n+    // max{currentCapacity / #activeUsers, currentCapacity *\n+    // user-limit-percentage%)\n     Resource userLimitResource \u003d Resources.max(\n-        resourceCalculator, clusterResource, \n+        resourceCalculator, partitionResource,\n         Resources.divideAndCeil(\n             resourceCalculator, currentCapacity, activeUsers),\n         Resources.divideAndCeil(\n             resourceCalculator, \n             Resources.multiplyAndRoundDown(\n                 currentCapacity, userLimit), \n             100)\n         );\n     \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d\n           Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n-      maxUserLimit \u003d\n-          labelManager.getResourceByLabel(nodePartition, clusterResource);\n+      maxUserLimit \u003d partitionResource;\n     }\n     \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n-                resourceCalculator, clusterResource,   \n+                resourceCalculator, partitionResource,\n                   userLimitResource,\n                   maxUserLimit\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n-      LOG.debug(\"User limit computation for \" + userName + \n+      LOG.debug(\"User limit computation for \" + userName +\n           \" in queue \" + getQueueName() +\n           \" userLimitPercent\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n-          \" required: \" + required + \n-          \" consumed: \" + user.getUsed() + \n+          \" required: \" + required +\n+          \" consumed: \" + consumed +\n           \" user-limit-resource: \" + userLimitResource +\n-          \" queueCapacity: \" + queueCapacity + \n+          \" queueCapacity: \" + queueCapacity +\n           \" qconsumed: \" + queueUsage.getUsed() +\n+          \" consumedRatio: \" + totalUserConsumedRatio +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n-          \" clusterCapacity: \" + clusterResource\n+          \" clusterCapacity: \" + clusterResource +\n+          \" resourceByLabel: \" + partitionResource +\n+          \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n+          \" Partition: \" + nodePartition\n       );\n     }\n     user.setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, User user,\n      String nodePartition, SchedulingMode schedulingMode) {\n    Resource partitionResource \u003d labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d\n        Resources.multiplyAndNormalizeUp(resourceCalculator,\n            partitionResource,\n            queueCapacities.getAbsoluteCapacity(nodePartition),\n            minimumAllocation);\n\n    // Assume we have required resource equals to minimumAllocation, this can\n    // make sure user limit can continuously increase till queueMaxResource\n    // reached.\n    Resource required \u003d minimumAllocation;\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, partitionResource,\n            queueCapacity, \n            required);\n\n\n    /* We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is\n     * greater than queueCapacity and users have the following [mem,cpu] usages:\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30\u003d50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed \u003d Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, qUsageRatios.getUsageRatio(nodePartition),\n        minimumAllocation);\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, partitionResource, consumed,\n            queueCapacity) ? queueCapacity : Resources.add(consumed, required);\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n    \n    // User limit resource is determined by:\n    // max{currentCapacity / #activeUsers, currentCapacity *\n    // user-limit-percentage%)\n    Resource userLimitResource \u003d Resources.max(\n        resourceCalculator, partitionResource,\n        Resources.divideAndCeil(\n            resourceCalculator, currentCapacity, activeUsers),\n        Resources.divideAndCeil(\n            resourceCalculator, \n            Resources.multiplyAndRoundDown(\n                currentCapacity, userLimit), \n            100)\n        );\n    \n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d partitionResource;\n    }\n    \n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, partitionResource,\n                  userLimitResource,\n                  maxUserLimit\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName +\n          \" in queue \" + getQueueName() +\n          \" userLimitPercent\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required +\n          \" consumed: \" + consumed +\n          \" user-limit-resource: \" + userLimitResource +\n          \" queueCapacity: \" + queueCapacity +\n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" consumedRatio: \" + totalUserConsumedRatio +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource +\n          \" resourceByLabel: \" + partitionResource +\n          \" usageratio: \" + qUsageRatios.getUsageRatio(nodePartition) +\n          \" Partition: \" + nodePartition\n      );\n    }\n    user.setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
      "commitDate": "24/07/15 2:00 PM",
      "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "24/07/15 2:00 PM",
          "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
          "commitAuthor": "Jian He",
          "commitDateOld": "22/07/15 11:54 AM",
          "commitNameOld": "76ec26de8099dc48ce3812c595b7ab857a600442",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 2.09,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,100 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n-      Resource clusterResource, Resource required, User user,\n+      Resource clusterResource, User user,\n       String nodePartition, SchedulingMode schedulingMode) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d\n         Resources.multiplyAndNormalizeUp(resourceCalculator,\n             labelManager.getResourceByLabel(nodePartition, clusterResource),\n             queueCapacities.getAbsoluteCapacity(nodePartition),\n             minimumAllocation);\n \n+    // Assume we have required resource equals to minimumAllocation, this can\n+    // make sure user limit can continuously increase till queueMaxResource\n+    // reached.\n+    Resource required \u003d minimumAllocation;\n+\n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource,\n             queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n             : Resources.add(queueUsage.getUsed(nodePartition), required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n     \n     // User limit resource is determined by:\n     // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n     Resource userLimitResource \u003d Resources.max(\n         resourceCalculator, clusterResource, \n         Resources.divideAndCeil(\n             resourceCalculator, currentCapacity, activeUsers),\n         Resources.divideAndCeil(\n             resourceCalculator, \n             Resources.multiplyAndRoundDown(\n                 currentCapacity, userLimit), \n             100)\n         );\n     \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d\n           Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d\n           labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n     \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                   userLimitResource,\n                   maxUserLimit\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimitPercent\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + user.getUsed() + \n           \" user-limit-resource: \" + userLimitResource +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n     user.setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, User user,\n      String nodePartition, SchedulingMode schedulingMode) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d\n        Resources.multiplyAndNormalizeUp(resourceCalculator,\n            labelManager.getResourceByLabel(nodePartition, clusterResource),\n            queueCapacities.getAbsoluteCapacity(nodePartition),\n            minimumAllocation);\n\n    // Assume we have required resource equals to minimumAllocation, this can\n    // make sure user limit can continuously increase till queueMaxResource\n    // reached.\n    Resource required \u003d minimumAllocation;\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource,\n            queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n            : Resources.add(queueUsage.getUsed(nodePartition), required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n    \n    // User limit resource is determined by:\n    // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n    Resource userLimitResource \u003d Resources.max(\n        resourceCalculator, clusterResource, \n        Resources.divideAndCeil(\n            resourceCalculator, currentCapacity, activeUsers),\n        Resources.divideAndCeil(\n            resourceCalculator, \n            Resources.multiplyAndRoundDown(\n                currentCapacity, userLimit), \n            100)\n        );\n    \n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                  userLimitResource,\n                  maxUserLimit\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimitPercent\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getUsed() + \n          \" user-limit-resource: \" + userLimitResource +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n    user.setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, user-User, nodePartition-String, schedulingMode-SchedulingMode]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, user-User, nodePartition-String, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "24/07/15 2:00 PM",
          "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
          "commitAuthor": "Jian He",
          "commitDateOld": "22/07/15 11:54 AM",
          "commitNameOld": "76ec26de8099dc48ce3812c595b7ab857a600442",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 2.09,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,100 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n-      Resource clusterResource, Resource required, User user,\n+      Resource clusterResource, User user,\n       String nodePartition, SchedulingMode schedulingMode) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d\n         Resources.multiplyAndNormalizeUp(resourceCalculator,\n             labelManager.getResourceByLabel(nodePartition, clusterResource),\n             queueCapacities.getAbsoluteCapacity(nodePartition),\n             minimumAllocation);\n \n+    // Assume we have required resource equals to minimumAllocation, this can\n+    // make sure user limit can continuously increase till queueMaxResource\n+    // reached.\n+    Resource required \u003d minimumAllocation;\n+\n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource,\n             queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n             : Resources.add(queueUsage.getUsed(nodePartition), required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n     \n     // User limit resource is determined by:\n     // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n     Resource userLimitResource \u003d Resources.max(\n         resourceCalculator, clusterResource, \n         Resources.divideAndCeil(\n             resourceCalculator, currentCapacity, activeUsers),\n         Resources.divideAndCeil(\n             resourceCalculator, \n             Resources.multiplyAndRoundDown(\n                 currentCapacity, userLimit), \n             100)\n         );\n     \n     // User limit is capped by maxUserLimit\n     // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n     // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n     //\n     // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n     // partition, its guaranteed resource on that partition is 0. And\n     // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n     // we will not cap user-limit as well as used resource when doing\n     // IGNORE_PARTITION_EXCLUSIVITY allocation.\n     Resource maxUserLimit \u003d Resources.none();\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d\n           Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       maxUserLimit \u003d\n           labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n     \n     // Cap final user limit with maxUserLimit\n     userLimitResource \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                   userLimitResource,\n                   maxUserLimit\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimitPercent\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + user.getUsed() + \n           \" user-limit-resource: \" + userLimitResource +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n     user.setUserResourceLimit(userLimitResource);\n     return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, User user,\n      String nodePartition, SchedulingMode schedulingMode) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d\n        Resources.multiplyAndNormalizeUp(resourceCalculator,\n            labelManager.getResourceByLabel(nodePartition, clusterResource),\n            queueCapacities.getAbsoluteCapacity(nodePartition),\n            minimumAllocation);\n\n    // Assume we have required resource equals to minimumAllocation, this can\n    // make sure user limit can continuously increase till queueMaxResource\n    // reached.\n    Resource required \u003d minimumAllocation;\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource,\n            queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n            : Resources.add(queueUsage.getUsed(nodePartition), required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n    \n    // User limit resource is determined by:\n    // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n    Resource userLimitResource \u003d Resources.max(\n        resourceCalculator, clusterResource, \n        Resources.divideAndCeil(\n            resourceCalculator, currentCapacity, activeUsers),\n        Resources.divideAndCeil(\n            resourceCalculator, \n            Resources.multiplyAndRoundDown(\n                currentCapacity, userLimit), \n            100)\n        );\n    \n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                  userLimitResource,\n                  maxUserLimit\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimitPercent\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getUsed() + \n          \" user-limit-resource: \" + userLimitResource +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n    user.setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
      "commitDate": "14/04/15 11:45 AM",
      "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,95 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, User user,\n-      Set\u003cString\u003e requestedLabels) {\n+      String nodePartition, SchedulingMode schedulingMode) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n-    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n-    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n-      // if we have multiple labels to request, we will choose to use the first\n-      // label\n-      String firstLabel \u003d requestedLabels.iterator().next();\n-      queueCapacity \u003d\n-          Resources\n-              .max(resourceCalculator, clusterResource, queueCapacity,\n-                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n-                      labelManager.getResourceByLabel(firstLabel,\n-                          clusterResource),\n-                      queueCapacities.getAbsoluteCapacity(firstLabel),\n-                      minimumAllocation));\n-    } else {\n-      // else there\u0027s no label on request, just to use absolute capacity as\n-      // capacity for nodes without label\n-      queueCapacity \u003d\n-          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n-                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n-              queueCapacities.getAbsoluteCapacity(), minimumAllocation);\n-    }\n+    Resource queueCapacity \u003d\n+        Resources.multiplyAndNormalizeUp(resourceCalculator,\n+            labelManager.getResourceByLabel(nodePartition, clusterResource),\n+            queueCapacities.getAbsoluteCapacity(nodePartition),\n+            minimumAllocation);\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n-        Resources.lessThan(resourceCalculator, clusterResource, \n-            queueUsage.getUsed(), queueCapacity) ?\n-            queueCapacity : Resources.add(queueUsage.getUsed(), required);\n+        Resources.lessThan(resourceCalculator, clusterResource,\n+            queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n+            : Resources.add(queueUsage.getUsed(nodePartition), required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n-    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n-    \t\t\n-    Resource limit \u003d\n+    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n+    \n+    // User limit resource is determined by:\n+    // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n+    Resource userLimitResource \u003d Resources.max(\n+        resourceCalculator, clusterResource, \n+        Resources.divideAndCeil(\n+            resourceCalculator, currentCapacity, activeUsers),\n+        Resources.divideAndCeil(\n+            resourceCalculator, \n+            Resources.multiplyAndRoundDown(\n+                currentCapacity, userLimit), \n+            100)\n+        );\n+    \n+    // User limit is capped by maxUserLimit\n+    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n+    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n+    //\n+    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n+    // partition, its guaranteed resource on that partition is 0. And\n+    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n+    // we will not cap user-limit as well as used resource when doing\n+    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n+    Resource maxUserLimit \u003d Resources.none();\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n+      maxUserLimit \u003d\n+          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n+    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n+      maxUserLimit \u003d\n+          labelManager.getResourceByLabel(nodePartition, clusterResource);\n+    }\n+    \n+    // Cap final user limit with maxUserLimit\n+    userLimitResource \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n-                Resources.max(\n-                    resourceCalculator, clusterResource, \n-                    Resources.divideAndCeil(\n-                        resourceCalculator, currentCapacity, activeUsers),\n-                    Resources.divideAndCeil(\n-                        resourceCalculator, \n-                        Resources.multiplyAndRoundDown(\n-                            currentCapacity, userLimit), \n-                        100)\n-                    ), \n-                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n+                  userLimitResource,\n+                  maxUserLimit\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n-          \" userLimit\u003d\" + userLimit +\n+          \" userLimitPercent\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + user.getUsed() + \n-          \" limit: \" + limit +\n+          \" user-limit-resource: \" + userLimitResource +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n-    user.setUserResourceLimit(limit);\n-    return limit;\n+    user.setUserResourceLimit(userLimitResource);\n+    return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, User user,\n      String nodePartition, SchedulingMode schedulingMode) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d\n        Resources.multiplyAndNormalizeUp(resourceCalculator,\n            labelManager.getResourceByLabel(nodePartition, clusterResource),\n            queueCapacities.getAbsoluteCapacity(nodePartition),\n            minimumAllocation);\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource,\n            queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n            : Resources.add(queueUsage.getUsed(nodePartition), required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n    \n    // User limit resource is determined by:\n    // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n    Resource userLimitResource \u003d Resources.max(\n        resourceCalculator, clusterResource, \n        Resources.divideAndCeil(\n            resourceCalculator, currentCapacity, activeUsers),\n        Resources.divideAndCeil(\n            resourceCalculator, \n            Resources.multiplyAndRoundDown(\n                currentCapacity, userLimit), \n            100)\n        );\n    \n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                  userLimitResource,\n                  maxUserLimit\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimitPercent\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getUsed() + \n          \" user-limit-resource: \" + userLimitResource +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n    user.setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, user-User, requestedLabels-Set\u003cString\u003e]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, user-User, nodePartition-String, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,95 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, User user,\n-      Set\u003cString\u003e requestedLabels) {\n+      String nodePartition, SchedulingMode schedulingMode) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n-    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n-    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n-      // if we have multiple labels to request, we will choose to use the first\n-      // label\n-      String firstLabel \u003d requestedLabels.iterator().next();\n-      queueCapacity \u003d\n-          Resources\n-              .max(resourceCalculator, clusterResource, queueCapacity,\n-                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n-                      labelManager.getResourceByLabel(firstLabel,\n-                          clusterResource),\n-                      queueCapacities.getAbsoluteCapacity(firstLabel),\n-                      minimumAllocation));\n-    } else {\n-      // else there\u0027s no label on request, just to use absolute capacity as\n-      // capacity for nodes without label\n-      queueCapacity \u003d\n-          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n-                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n-              queueCapacities.getAbsoluteCapacity(), minimumAllocation);\n-    }\n+    Resource queueCapacity \u003d\n+        Resources.multiplyAndNormalizeUp(resourceCalculator,\n+            labelManager.getResourceByLabel(nodePartition, clusterResource),\n+            queueCapacities.getAbsoluteCapacity(nodePartition),\n+            minimumAllocation);\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n-        Resources.lessThan(resourceCalculator, clusterResource, \n-            queueUsage.getUsed(), queueCapacity) ?\n-            queueCapacity : Resources.add(queueUsage.getUsed(), required);\n+        Resources.lessThan(resourceCalculator, clusterResource,\n+            queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n+            : Resources.add(queueUsage.getUsed(nodePartition), required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n-    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n-    \t\t\n-    Resource limit \u003d\n+    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n+    \n+    // User limit resource is determined by:\n+    // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n+    Resource userLimitResource \u003d Resources.max(\n+        resourceCalculator, clusterResource, \n+        Resources.divideAndCeil(\n+            resourceCalculator, currentCapacity, activeUsers),\n+        Resources.divideAndCeil(\n+            resourceCalculator, \n+            Resources.multiplyAndRoundDown(\n+                currentCapacity, userLimit), \n+            100)\n+        );\n+    \n+    // User limit is capped by maxUserLimit\n+    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n+    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n+    //\n+    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n+    // partition, its guaranteed resource on that partition is 0. And\n+    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n+    // we will not cap user-limit as well as used resource when doing\n+    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n+    Resource maxUserLimit \u003d Resources.none();\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n+      maxUserLimit \u003d\n+          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n+    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n+      maxUserLimit \u003d\n+          labelManager.getResourceByLabel(nodePartition, clusterResource);\n+    }\n+    \n+    // Cap final user limit with maxUserLimit\n+    userLimitResource \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n-                Resources.max(\n-                    resourceCalculator, clusterResource, \n-                    Resources.divideAndCeil(\n-                        resourceCalculator, currentCapacity, activeUsers),\n-                    Resources.divideAndCeil(\n-                        resourceCalculator, \n-                        Resources.multiplyAndRoundDown(\n-                            currentCapacity, userLimit), \n-                        100)\n-                    ), \n-                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n+                  userLimitResource,\n+                  maxUserLimit\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n-          \" userLimit\u003d\" + userLimit +\n+          \" userLimitPercent\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + user.getUsed() + \n-          \" limit: \" + limit +\n+          \" user-limit-resource: \" + userLimitResource +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n-    user.setUserResourceLimit(limit);\n-    return limit;\n+    user.setUserResourceLimit(userLimitResource);\n+    return userLimitResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, User user,\n      String nodePartition, SchedulingMode schedulingMode) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d\n        Resources.multiplyAndNormalizeUp(resourceCalculator,\n            labelManager.getResourceByLabel(nodePartition, clusterResource),\n            queueCapacities.getAbsoluteCapacity(nodePartition),\n            minimumAllocation);\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource,\n            queueUsage.getUsed(nodePartition), queueCapacity) ? queueCapacity\n            : Resources.add(queueUsage.getUsed(nodePartition), required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();\n    \n    // User limit resource is determined by:\n    // max{currentCapacity / #activeUsers, currentCapacity * user-limit-percentage%)\n    Resource userLimitResource \u003d Resources.max(\n        resourceCalculator, clusterResource, \n        Resources.divideAndCeil(\n            resourceCalculator, currentCapacity, activeUsers),\n        Resources.divideAndCeil(\n            resourceCalculator, \n            Resources.multiplyAndRoundDown(\n                currentCapacity, userLimit), \n            100)\n        );\n    \n    // User limit is capped by maxUserLimit\n    // - maxUserLimit \u003d queueCapacity * user-limit-factor (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit \u003d total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue\u0027s guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit \u003d Resources.none();\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor);\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit \u003d\n          labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    // Cap final user limit with maxUserLimit\n    userLimitResource \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                  userLimitResource,\n                  maxUserLimit\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimitPercent\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getUsed() + \n          \" user-limit-resource: \" + userLimitResource +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n    user.setUserResourceLimit(userLimitResource);\n    return userLimitResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "658097d6da1b1aac8e01db459f0c3b456e99652f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3273. Improve scheduler UI to facilitate scheduling analysis and debugging. Contributed Rohith Sharmaks\n",
      "commitDate": "17/03/15 9:30 PM",
      "commitName": "658097d6da1b1aac8e01db459f0c3b456e99652f",
      "commitAuthor": "Jian He",
      "commitDateOld": "17/03/15 10:24 AM",
      "commitNameOld": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, User user,\n       Set\u003cString\u003e requestedLabels) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d Resource.newInstance(0, 0);\n     if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n       // if we have multiple labels to request, we will choose to use the first\n       // label\n       String firstLabel \u003d requestedLabels.iterator().next();\n       queueCapacity \u003d\n           Resources\n               .max(resourceCalculator, clusterResource, queueCapacity,\n                   Resources.multiplyAndNormalizeUp(resourceCalculator,\n                       labelManager.getResourceByLabel(firstLabel,\n                           clusterResource),\n                       queueCapacities.getAbsoluteCapacity(firstLabel),\n                       minimumAllocation));\n     } else {\n       // else there\u0027s no label on request, just to use absolute capacity as\n       // capacity for nodes without label\n       queueCapacity \u003d\n           Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                 .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n               queueCapacities.getAbsoluteCapacity(), minimumAllocation);\n     }\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource, \n             queueUsage.getUsed(), queueCapacity) ?\n             queueCapacity : Resources.add(queueUsage.getUsed(), required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n     \t\t\n     Resource limit \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                 Resources.max(\n                     resourceCalculator, clusterResource, \n                     Resources.divideAndCeil(\n                         resourceCalculator, currentCapacity, activeUsers),\n                     Resources.divideAndCeil(\n                         resourceCalculator, \n                         Resources.multiplyAndRoundDown(\n                             currentCapacity, userLimit), \n                         100)\n                     ), \n                 Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + user.getUsed() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n-\n+    user.setUserResourceLimit(limit);\n     return limit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, User user,\n      Set\u003cString\u003e requestedLabels) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n      // if we have multiple labels to request, we will choose to use the first\n      // label\n      String firstLabel \u003d requestedLabels.iterator().next();\n      queueCapacity \u003d\n          Resources\n              .max(resourceCalculator, clusterResource, queueCapacity,\n                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n                      labelManager.getResourceByLabel(firstLabel,\n                          clusterResource),\n                      queueCapacities.getAbsoluteCapacity(firstLabel),\n                      minimumAllocation));\n    } else {\n      // else there\u0027s no label on request, just to use absolute capacity as\n      // capacity for nodes without label\n      queueCapacity \u003d\n          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n              queueCapacities.getAbsoluteCapacity(), minimumAllocation);\n    }\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            queueUsage.getUsed(), queueCapacity) ?\n            queueCapacity : Resources.add(queueUsage.getUsed(), required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getUsed() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n    user.setUserResourceLimit(limit);\n    return limit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "18a594257e052e8f10a03e5594e6cc6901dc56be": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
      "commitDate": "12/02/15 2:58 PM",
      "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/02/15 8:34 PM",
      "commitNameOld": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, User user,\n       Set\u003cString\u003e requestedLabels) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d Resource.newInstance(0, 0);\n     if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n       // if we have multiple labels to request, we will choose to use the first\n       // label\n       String firstLabel \u003d requestedLabels.iterator().next();\n       queueCapacity \u003d\n           Resources\n               .max(resourceCalculator, clusterResource, queueCapacity,\n                   Resources.multiplyAndNormalizeUp(resourceCalculator,\n                       labelManager.getResourceByLabel(firstLabel,\n                           clusterResource),\n-                      getAbsoluteCapacityByNodeLabel(firstLabel),\n+                      queueCapacities.getAbsoluteCapacity(firstLabel),\n                       minimumAllocation));\n     } else {\n       // else there\u0027s no label on request, just to use absolute capacity as\n       // capacity for nodes without label\n       queueCapacity \u003d\n           Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                 .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n-              absoluteCapacity, minimumAllocation);\n+              queueCapacities.getAbsoluteCapacity(), minimumAllocation);\n     }\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource, \n             queueUsage.getUsed(), queueCapacity) ?\n             queueCapacity : Resources.add(queueUsage.getUsed(), required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n     \t\t\n     Resource limit \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                 Resources.max(\n                     resourceCalculator, clusterResource, \n                     Resources.divideAndCeil(\n                         resourceCalculator, currentCapacity, activeUsers),\n                     Resources.divideAndCeil(\n                         resourceCalculator, \n                         Resources.multiplyAndRoundDown(\n                             currentCapacity, userLimit), \n                         100)\n                     ), \n                 Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + user.getUsed() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + queueUsage.getUsed() +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n \n     return limit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, User user,\n      Set\u003cString\u003e requestedLabels) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n      // if we have multiple labels to request, we will choose to use the first\n      // label\n      String firstLabel \u003d requestedLabels.iterator().next();\n      queueCapacity \u003d\n          Resources\n              .max(resourceCalculator, clusterResource, queueCapacity,\n                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n                      labelManager.getResourceByLabel(firstLabel,\n                          clusterResource),\n                      queueCapacities.getAbsoluteCapacity(firstLabel),\n                      minimumAllocation));\n    } else {\n      // else there\u0027s no label on request, just to use absolute capacity as\n      // capacity for nodes without label\n      queueCapacity \u003d\n          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n              queueCapacities.getAbsoluteCapacity(), minimumAllocation);\n    }\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            queueUsage.getUsed(), queueCapacity) ?\n            queueCapacity : Resources.add(queueUsage.getUsed(), required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getUsed() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n\n    return limit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "86358221fc85a7743052a0b4c1647353508bf308": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3099. Capacity Scheduler LeafQueue/ParentQueue should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "30/01/15 3:15 PM",
      "commitName": "86358221fc85a7743052a0b4c1647353508bf308",
      "commitAuthor": "Jian He",
      "commitDateOld": "27/01/15 3:36 PM",
      "commitNameOld": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, User user,\n       Set\u003cString\u003e requestedLabels) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n     Resource queueCapacity \u003d Resource.newInstance(0, 0);\n     if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n       // if we have multiple labels to request, we will choose to use the first\n       // label\n       String firstLabel \u003d requestedLabels.iterator().next();\n       queueCapacity \u003d\n           Resources\n               .max(resourceCalculator, clusterResource, queueCapacity,\n                   Resources.multiplyAndNormalizeUp(resourceCalculator,\n                       labelManager.getResourceByLabel(firstLabel,\n                           clusterResource),\n                       getAbsoluteCapacityByNodeLabel(firstLabel),\n                       minimumAllocation));\n     } else {\n       // else there\u0027s no label on request, just to use absolute capacity as\n       // capacity for nodes without label\n       queueCapacity \u003d\n           Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                 .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n               absoluteCapacity, minimumAllocation);\n     }\n \n     // Allow progress for queues with miniscule capacity\n     queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource, \n-            usedResources, queueCapacity) ?\n-            queueCapacity : Resources.add(usedResources, required);\n+            queueUsage.getUsed(), queueCapacity) ?\n+            queueCapacity : Resources.add(queueUsage.getUsed(), required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n     \t\t\n     Resource limit \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                 Resources.max(\n                     resourceCalculator, clusterResource, \n                     Resources.divideAndCeil(\n                         resourceCalculator, currentCapacity, activeUsers),\n                     Resources.divideAndCeil(\n                         resourceCalculator, \n                         Resources.multiplyAndRoundDown(\n                             currentCapacity, userLimit), \n                         100)\n                     ), \n                 Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n-          \" consumed: \" + user.getTotalConsumedResources() + \n+          \" consumed: \" + user.getUsed() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n-          \" qconsumed: \" + usedResources +\n+          \" qconsumed: \" + queueUsage.getUsed() +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n \n     return limit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, User user,\n      Set\u003cString\u003e requestedLabels) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n      // if we have multiple labels to request, we will choose to use the first\n      // label\n      String firstLabel \u003d requestedLabels.iterator().next();\n      queueCapacity \u003d\n          Resources\n              .max(resourceCalculator, clusterResource, queueCapacity,\n                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n                      labelManager.getResourceByLabel(firstLabel,\n                          clusterResource),\n                      getAbsoluteCapacityByNodeLabel(firstLabel),\n                      minimumAllocation));\n    } else {\n      // else there\u0027s no label on request, just to use absolute capacity as\n      // capacity for nodes without label\n      queueCapacity \u003d\n          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n              absoluteCapacity, minimumAllocation);\n    }\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            queueUsage.getUsed(), queueCapacity) ?\n            queueCapacity : Resources.add(queueUsage.getUsed(), required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getUsed() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + queueUsage.getUsed() +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n\n    return limit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,88 @@\n-  private Resource computeUserLimit(FiCaSchedulerApp application, \n-      Resource clusterResource, Resource required, User user) {\n+  private Resource computeUserLimit(FiCaSchedulerApp application,\n+      Resource clusterResource, Resource required, User user,\n+      Set\u003cString\u003e requestedLabels) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n+    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n+    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n+      // if we have multiple labels to request, we will choose to use the first\n+      // label\n+      String firstLabel \u003d requestedLabels.iterator().next();\n+      queueCapacity \u003d\n+          Resources\n+              .max(resourceCalculator, clusterResource, queueCapacity,\n+                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n+                      labelManager.getResourceByLabel(firstLabel,\n+                          clusterResource),\n+                      getAbsoluteCapacityByNodeLabel(firstLabel),\n+                      minimumAllocation));\n+    } else {\n+      // else there\u0027s no label on request, just to use absolute capacity as\n+      // capacity for nodes without label\n+      queueCapacity \u003d\n+          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n+                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n+              absoluteCapacity, minimumAllocation);\n+    }\n \n     // Allow progress for queues with miniscule capacity\n-    final Resource queueCapacity \u003d\n+    queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n-            Resources.multiplyAndNormalizeUp(\n-                resourceCalculator, \n-                clusterResource, \n-                absoluteCapacity, \n-                minimumAllocation), \n+            queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource, \n             usedResources, queueCapacity) ?\n             queueCapacity : Resources.add(usedResources, required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n     \t\t\n     Resource limit \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                 Resources.max(\n                     resourceCalculator, clusterResource, \n                     Resources.divideAndCeil(\n                         resourceCalculator, currentCapacity, activeUsers),\n                     Resources.divideAndCeil(\n                         resourceCalculator, \n                         Resources.multiplyAndRoundDown(\n                             currentCapacity, userLimit), \n                         100)\n                     ), \n                 Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n-          \" consumed: \" + user.getConsumedResources() + \n+          \" consumed: \" + user.getTotalConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + usedResources +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n \n     return limit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, User user,\n      Set\u003cString\u003e requestedLabels) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n      // if we have multiple labels to request, we will choose to use the first\n      // label\n      String firstLabel \u003d requestedLabels.iterator().next();\n      queueCapacity \u003d\n          Resources\n              .max(resourceCalculator, clusterResource, queueCapacity,\n                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n                      labelManager.getResourceByLabel(firstLabel,\n                          clusterResource),\n                      getAbsoluteCapacityByNodeLabel(firstLabel),\n                      minimumAllocation));\n    } else {\n      // else there\u0027s no label on request, just to use absolute capacity as\n      // capacity for nodes without label\n      queueCapacity \u003d\n          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n              absoluteCapacity, minimumAllocation);\n    }\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            usedResources, queueCapacity) ?\n            queueCapacity : Resources.add(usedResources, required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getTotalConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + usedResources +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n\n    return limit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, user-User]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, user-User, requestedLabels-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,88 @@\n-  private Resource computeUserLimit(FiCaSchedulerApp application, \n-      Resource clusterResource, Resource required, User user) {\n+  private Resource computeUserLimit(FiCaSchedulerApp application,\n+      Resource clusterResource, Resource required, User user,\n+      Set\u003cString\u003e requestedLabels) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n+    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n+    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n+      // if we have multiple labels to request, we will choose to use the first\n+      // label\n+      String firstLabel \u003d requestedLabels.iterator().next();\n+      queueCapacity \u003d\n+          Resources\n+              .max(resourceCalculator, clusterResource, queueCapacity,\n+                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n+                      labelManager.getResourceByLabel(firstLabel,\n+                          clusterResource),\n+                      getAbsoluteCapacityByNodeLabel(firstLabel),\n+                      minimumAllocation));\n+    } else {\n+      // else there\u0027s no label on request, just to use absolute capacity as\n+      // capacity for nodes without label\n+      queueCapacity \u003d\n+          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n+                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n+              absoluteCapacity, minimumAllocation);\n+    }\n \n     // Allow progress for queues with miniscule capacity\n-    final Resource queueCapacity \u003d\n+    queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n-            Resources.multiplyAndNormalizeUp(\n-                resourceCalculator, \n-                clusterResource, \n-                absoluteCapacity, \n-                minimumAllocation), \n+            queueCapacity, \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource, \n             usedResources, queueCapacity) ?\n             queueCapacity : Resources.add(usedResources, required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n     \t\t\n     Resource limit \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                 Resources.max(\n                     resourceCalculator, clusterResource, \n                     Resources.divideAndCeil(\n                         resourceCalculator, currentCapacity, activeUsers),\n                     Resources.divideAndCeil(\n                         resourceCalculator, \n                         Resources.multiplyAndRoundDown(\n                             currentCapacity, userLimit), \n                         100)\n                     ), \n                 Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n-          \" consumed: \" + user.getConsumedResources() + \n+          \" consumed: \" + user.getTotalConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + usedResources +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n \n     return limit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, User user,\n      Set\u003cString\u003e requestedLabels) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n    Resource queueCapacity \u003d Resource.newInstance(0, 0);\n    if (requestedLabels !\u003d null \u0026\u0026 !requestedLabels.isEmpty()) {\n      // if we have multiple labels to request, we will choose to use the first\n      // label\n      String firstLabel \u003d requestedLabels.iterator().next();\n      queueCapacity \u003d\n          Resources\n              .max(resourceCalculator, clusterResource, queueCapacity,\n                  Resources.multiplyAndNormalizeUp(resourceCalculator,\n                      labelManager.getResourceByLabel(firstLabel,\n                          clusterResource),\n                      getAbsoluteCapacityByNodeLabel(firstLabel),\n                      minimumAllocation));\n    } else {\n      // else there\u0027s no label on request, just to use absolute capacity as\n      // capacity for nodes without label\n      queueCapacity \u003d\n          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager\n                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),\n              absoluteCapacity, minimumAllocation);\n    }\n\n    // Allow progress for queues with miniscule capacity\n    queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            queueCapacity, \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            usedResources, queueCapacity) ?\n            queueCapacity : Resources.add(usedResources, required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getTotalConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + usedResources +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n\n    return limit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "519e5a7dd2bd540105434ec3c8939b68f6c024f8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2644. Fixed CapacityScheduler to return up-to-date headroom when AM allocates. Contributed by Craig Welch\n",
      "commitDate": "06/10/14 3:48 PM",
      "commitName": "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2644. Fixed CapacityScheduler to return up-to-date headroom when AM allocates. Contributed by Craig Welch\n",
          "commitDate": "06/10/14 3:48 PM",
          "commitName": "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/14 5:09 PM",
          "commitNameOld": "c8212bacb1b2a7e6ee83cc56f72297465ce99390",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 2.94,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,70 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application, \n-      Resource clusterResource, Resource required) {\n+      Resource clusterResource, Resource required, User user) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n \n     // Allow progress for queues with miniscule capacity\n     final Resource queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             Resources.multiplyAndNormalizeUp(\n                 resourceCalculator, \n                 clusterResource, \n                 absoluteCapacity, \n                 minimumAllocation), \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource, \n             usedResources, queueCapacity) ?\n             queueCapacity : Resources.add(usedResources, required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n     \t\t\n     Resource limit \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                 Resources.max(\n                     resourceCalculator, clusterResource, \n                     Resources.divideAndCeil(\n                         resourceCalculator, currentCapacity, activeUsers),\n                     Resources.divideAndCeil(\n                         resourceCalculator, \n                         Resources.multiplyAndRoundDown(\n                             currentCapacity, userLimit), \n                         100)\n                     ), \n                 Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n-          \" consumed: \" + getUser(userName).getConsumedResources() + \n+          \" consumed: \" + user.getConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + usedResources +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n \n     return limit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application, \n      Resource clusterResource, Resource required, User user) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final Resource queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            Resources.multiplyAndNormalizeUp(\n                resourceCalculator, \n                clusterResource, \n                absoluteCapacity, \n                minimumAllocation), \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            usedResources, queueCapacity) ?\n            queueCapacity : Resources.add(usedResources, required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + usedResources +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n\n    return limit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, user-User]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2644. Fixed CapacityScheduler to return up-to-date headroom when AM allocates. Contributed by Craig Welch\n",
          "commitDate": "06/10/14 3:48 PM",
          "commitName": "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/14 5:09 PM",
          "commitNameOld": "c8212bacb1b2a7e6ee83cc56f72297465ce99390",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 2.94,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,70 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application, \n-      Resource clusterResource, Resource required) {\n+      Resource clusterResource, Resource required, User user) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n \n     // Allow progress for queues with miniscule capacity\n     final Resource queueCapacity \u003d\n         Resources.max(\n             resourceCalculator, clusterResource, \n             Resources.multiplyAndNormalizeUp(\n                 resourceCalculator, \n                 clusterResource, \n                 absoluteCapacity, \n                 minimumAllocation), \n             required);\n \n     Resource currentCapacity \u003d\n         Resources.lessThan(resourceCalculator, clusterResource, \n             usedResources, queueCapacity) ?\n             queueCapacity : Resources.add(usedResources, required);\n     \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n     \t\t\n     Resource limit \u003d\n         Resources.roundUp(\n             resourceCalculator, \n             Resources.min(\n                 resourceCalculator, clusterResource,   \n                 Resources.max(\n                     resourceCalculator, clusterResource, \n                     Resources.divideAndCeil(\n                         resourceCalculator, currentCapacity, activeUsers),\n                     Resources.divideAndCeil(\n                         resourceCalculator, \n                         Resources.multiplyAndRoundDown(\n                             currentCapacity, userLimit), \n                         100)\n                     ), \n                 Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                 ), \n             minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n-          \" consumed: \" + getUser(userName).getConsumedResources() + \n+          \" consumed: \" + user.getConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + usedResources +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource\n       );\n     }\n \n     return limit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application, \n      Resource clusterResource, Resource required, User user) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final Resource queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            Resources.multiplyAndNormalizeUp(\n                resourceCalculator, \n                clusterResource, \n                absoluteCapacity, \n                minimumAllocation), \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            usedResources, queueCapacity) ?\n            queueCapacity : Resources.add(usedResources, required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + usedResources +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n\n    return limit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/11/12 1:56 PM",
      "commitNameOld": "fb5b96dfc324f999e8b3698288c110a1c3b71c30",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 62.3,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,70 @@\n   private Resource computeUserLimit(FiCaSchedulerApp application, \n       Resource clusterResource, Resource required) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n \n     // Allow progress for queues with miniscule capacity\n-    final int queueCapacity \u003d \n-      Math.max(\n-          CSQueueUtils.roundUp(\n-              minimumAllocation, \n-              (int)(absoluteCapacity * clusterResource.getMemory())), \n-          required.getMemory()\n-          );\n+    final Resource queueCapacity \u003d\n+        Resources.max(\n+            resourceCalculator, clusterResource, \n+            Resources.multiplyAndNormalizeUp(\n+                resourceCalculator, \n+                clusterResource, \n+                absoluteCapacity, \n+                minimumAllocation), \n+            required);\n \n-    final int consumed \u003d usedResources.getMemory();\n-    final int currentCapacity \u003d \n-      (consumed \u003c queueCapacity) ? \n-          queueCapacity : (consumed + required.getMemory());\n-\n+    Resource currentCapacity \u003d\n+        Resources.lessThan(resourceCalculator, clusterResource, \n+            usedResources, queueCapacity) ?\n+            queueCapacity : Resources.add(usedResources, required);\n+    \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n-\n-    int limit \u003d \n-      CSQueueUtils.roundUp(\n-          minimumAllocation,\n-          Math.min(\n-              Math.max(divideAndCeil(currentCapacity, activeUsers), \n-                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n-              (int)(queueCapacity * userLimitFactor)\n-              )\n-          );\n+    \t\t\n+    Resource limit \u003d\n+        Resources.roundUp(\n+            resourceCalculator, \n+            Resources.min(\n+                resourceCalculator, clusterResource,   \n+                Resources.max(\n+                    resourceCalculator, clusterResource, \n+                    Resources.divideAndCeil(\n+                        resourceCalculator, currentCapacity, activeUsers),\n+                    Resources.divideAndCeil(\n+                        resourceCalculator, \n+                        Resources.multiplyAndRoundDown(\n+                            currentCapacity, userLimit), \n+                        100)\n+                    ), \n+                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n+                ), \n+            minimumAllocation);\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + getUser(userName).getConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n-          \" qconsumed: \" + consumed +\n+          \" qconsumed: \" + usedResources +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n-          \" clusterCapacity: \" + clusterResource.getMemory()\n+          \" clusterCapacity: \" + clusterResource\n       );\n     }\n \n-    return Resources.createResource(limit);\n+    return limit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application, \n      Resource clusterResource, Resource required) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final Resource queueCapacity \u003d\n        Resources.max(\n            resourceCalculator, clusterResource, \n            Resources.multiplyAndNormalizeUp(\n                resourceCalculator, \n                clusterResource, \n                absoluteCapacity, \n                minimumAllocation), \n            required);\n\n    Resource currentCapacity \u003d\n        Resources.lessThan(resourceCalculator, clusterResource, \n            usedResources, queueCapacity) ?\n            queueCapacity : Resources.add(usedResources, required);\n    \n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n    \t\t\n    Resource limit \u003d\n        Resources.roundUp(\n            resourceCalculator, \n            Resources.min(\n                resourceCalculator, clusterResource,   \n                Resources.max(\n                    resourceCalculator, clusterResource, \n                    Resources.divideAndCeil(\n                        resourceCalculator, currentCapacity, activeUsers),\n                    Resources.divideAndCeil(\n                        resourceCalculator, \n                        Resources.multiplyAndRoundDown(\n                            currentCapacity, userLimit), \n                        100)\n                    ), \n                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)\n                ), \n            minimumAllocation);\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + getUser(userName).getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + usedResources +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource\n      );\n    }\n\n    return limit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application, \n      Resource clusterResource, Resource required) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final int queueCapacity \u003d \n      Math.max(\n          CSQueueUtils.roundUp(\n              minimumAllocation, \n              (int)(absoluteCapacity * clusterResource.getMemory())), \n          required.getMemory()\n          );\n\n    final int consumed \u003d usedResources.getMemory();\n    final int currentCapacity \u003d \n      (consumed \u003c queueCapacity) ? \n          queueCapacity : (consumed + required.getMemory());\n\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n\n    int limit \u003d \n      CSQueueUtils.roundUp(\n          minimumAllocation,\n          Math.min(\n              Math.max(divideAndCeil(currentCapacity, activeUsers), \n                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n              (int)(queueCapacity * userLimitFactor)\n              )\n          );\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + getUser(userName).getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + consumed +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource.getMemory()\n      );\n    }\n\n    return Resources.createResource(limit);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Yparameterchange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "10/07/12 2:26 PM",
      "commitNameOld": "3bfb26ad3b5ac46f992a632541c97ca2bc897638",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  private Resource computeUserLimit(SchedulerApp application, \n+  private Resource computeUserLimit(FiCaSchedulerApp application, \n       Resource clusterResource, Resource required) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n \n     // Allow progress for queues with miniscule capacity\n     final int queueCapacity \u003d \n       Math.max(\n           CSQueueUtils.roundUp(\n               minimumAllocation, \n               (int)(absoluteCapacity * clusterResource.getMemory())), \n           required.getMemory()\n           );\n \n     final int consumed \u003d usedResources.getMemory();\n     final int currentCapacity \u003d \n       (consumed \u003c queueCapacity) ? \n           queueCapacity : (consumed + required.getMemory());\n \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n \n     int limit \u003d \n       CSQueueUtils.roundUp(\n           minimumAllocation,\n           Math.min(\n               Math.max(divideAndCeil(currentCapacity, activeUsers), \n                        divideAndCeil((int)userLimit*currentCapacity, 100)),\n               (int)(queueCapacity * userLimitFactor)\n               )\n           );\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + getUser(userName).getConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + consumed +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource.getMemory()\n       );\n     }\n \n     return Resources.createResource(limit);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(FiCaSchedulerApp application, \n      Resource clusterResource, Resource required) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final int queueCapacity \u003d \n      Math.max(\n          CSQueueUtils.roundUp(\n              minimumAllocation, \n              (int)(absoluteCapacity * clusterResource.getMemory())), \n          required.getMemory()\n          );\n\n    final int consumed \u003d usedResources.getMemory();\n    final int currentCapacity \u003d \n      (consumed \u003c queueCapacity) ? \n          queueCapacity : (consumed + required.getMemory());\n\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n\n    int limit \u003d \n      CSQueueUtils.roundUp(\n          minimumAllocation,\n          Math.min(\n              Math.max(divideAndCeil(currentCapacity, activeUsers), \n                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n              (int)(queueCapacity * userLimitFactor)\n              )\n          );\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + getUser(userName).getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + consumed +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource.getMemory()\n      );\n    }\n\n    return Resources.createResource(limit);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldValue": "[application-SchedulerApp, clusterResource-Resource, required-Resource]",
        "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource]"
      }
    },
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3747. Initialize queue metrics upfront and added start/finish time to RM Web-UI. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240886 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/02/12 7:38 PM",
      "commitName": "c7007a8a3508a24a6f023302516fe8fbe270eab1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "02/02/12 5:16 PM",
      "commitNameOld": "a5c46c91655acebccd1367706b05946eff90f744",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,59 @@\n   private Resource computeUserLimit(SchedulerApp application, \n       Resource clusterResource, Resource required) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n \n     // Allow progress for queues with miniscule capacity\n     final int queueCapacity \u003d \n       Math.max(\n-          roundUp((int)(absoluteCapacity * clusterResource.getMemory())), \n-          required.getMemory());\n+          CSQueueUtils.roundUp(\n+              minimumAllocation, \n+              (int)(absoluteCapacity * clusterResource.getMemory())), \n+          required.getMemory()\n+          );\n \n     final int consumed \u003d usedResources.getMemory();\n     final int currentCapacity \u003d \n       (consumed \u003c queueCapacity) ? \n           queueCapacity : (consumed + required.getMemory());\n \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n     \n     final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n \n     int limit \u003d \n-      roundUp(\n+      CSQueueUtils.roundUp(\n+          minimumAllocation,\n           Math.min(\n               Math.max(divideAndCeil(currentCapacity, activeUsers), \n                        divideAndCeil((int)userLimit*currentCapacity, 100)),\n               (int)(queueCapacity * userLimitFactor)\n               )\n           );\n \n     if (LOG.isDebugEnabled()) {\n       String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n           \" consumed: \" + getUser(userName).getConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + consumed +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource.getMemory()\n       );\n     }\n \n     return Resources.createResource(limit);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(SchedulerApp application, \n      Resource clusterResource, Resource required) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final int queueCapacity \u003d \n      Math.max(\n          CSQueueUtils.roundUp(\n              minimumAllocation, \n              (int)(absoluteCapacity * clusterResource.getMemory())), \n          required.getMemory()\n          );\n\n    final int consumed \u003d usedResources.getMemory();\n    final int currentCapacity \u003d \n      (consumed \u003c queueCapacity) ? \n          queueCapacity : (consumed + required.getMemory());\n\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n\n    int limit \u003d \n      CSQueueUtils.roundUp(\n          minimumAllocation,\n          Math.min(\n              Math.max(divideAndCeil(currentCapacity, activeUsers), \n                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n              (int)(queueCapacity * userLimitFactor)\n              )\n          );\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + getUser(userName).getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + consumed +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource.getMemory()\n      );\n    }\n\n    return Resources.createResource(limit);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "5262b7ba4d018562d4e7d60772af4ddc3d770a23": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3732. Modified CapacityScheduler to use only users with pending requests for computing user-limits. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236953 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/01/12 5:32 PM",
      "commitName": "5262b7ba4d018562d4e7d60772af4ddc3d770a23",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/01/12 3:31 PM",
      "commitNameOld": "21c9116309d8482e7e28522cd7386e65415b15e9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.08,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,55 @@\n   private Resource computeUserLimit(SchedulerApp application, \n       Resource clusterResource, Resource required) {\n     // What is our current capacity? \n     // * It is equal to the max(required, queue-capacity) if\n     //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n     //   with miniscule capacity (\u003c 1 slot) make progress\n     // * If we\u0027re running over capacity, then its\n     //   (usedResources + required) (which extra resources we are allocating)\n \n     // Allow progress for queues with miniscule capacity\n     final int queueCapacity \u003d \n       Math.max(\n           roundUp((int)(absoluteCapacity * clusterResource.getMemory())), \n           required.getMemory());\n \n     final int consumed \u003d usedResources.getMemory();\n     final int currentCapacity \u003d \n       (consumed \u003c queueCapacity) ? \n           queueCapacity : (consumed + required.getMemory());\n \n     // Never allow a single user to take more than the \n     // queue\u0027s configured capacity * user-limit-factor.\n     // Also, the queue\u0027s configured capacity should be higher than \n     // queue-hard-limit * ulMin\n-\n-    String userName \u003d application.getUser();\n     \n-    final int activeUsers \u003d users.size();  \n-    User user \u003d getUser(userName);\n+    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n \n     int limit \u003d \n       roundUp(\n           Math.min(\n               Math.max(divideAndCeil(currentCapacity, activeUsers), \n                        divideAndCeil((int)userLimit*currentCapacity, 100)),\n               (int)(queueCapacity * userLimitFactor)\n               )\n           );\n \n     if (LOG.isDebugEnabled()) {\n+      String userName \u003d application.getUser();\n       LOG.debug(\"User limit computation for \" + userName + \n           \" in queue \" + getQueueName() +\n           \" userLimit\u003d\" + userLimit +\n           \" userLimitFactor\u003d\" + userLimitFactor +\n           \" required: \" + required + \n-          \" consumed: \" + user.getConsumedResources() + \n+          \" consumed: \" + getUser(userName).getConsumedResources() + \n           \" limit: \" + limit +\n           \" queueCapacity: \" + queueCapacity + \n           \" qconsumed: \" + consumed +\n           \" currentCapacity: \" + currentCapacity +\n           \" activeUsers: \" + activeUsers +\n           \" clusterCapacity: \" + clusterResource.getMemory()\n       );\n     }\n \n     return Resources.createResource(limit);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(SchedulerApp application, \n      Resource clusterResource, Resource required) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final int queueCapacity \u003d \n      Math.max(\n          roundUp((int)(absoluteCapacity * clusterResource.getMemory())), \n          required.getMemory());\n\n    final int consumed \u003d usedResources.getMemory();\n    final int currentCapacity \u003d \n      (consumed \u003c queueCapacity) ? \n          queueCapacity : (consumed + required.getMemory());\n\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n    \n    final int activeUsers \u003d activeUsersManager.getNumActiveUsers();  \n\n    int limit \u003d \n      roundUp(\n          Math.min(\n              Math.max(divideAndCeil(currentCapacity, activeUsers), \n                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n              (int)(queueCapacity * userLimitFactor)\n              )\n          );\n\n    if (LOG.isDebugEnabled()) {\n      String userName \u003d application.getUser();\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + getUser(userName).getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + consumed +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource.getMemory()\n      );\n    }\n\n    return Resources.createResource(limit);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private Resource computeUserLimit(SchedulerApp application, \n      Resource clusterResource, Resource required) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final int queueCapacity \u003d \n      Math.max(\n          roundUp((int)(absoluteCapacity * clusterResource.getMemory())), \n          required.getMemory());\n\n    final int consumed \u003d usedResources.getMemory();\n    final int currentCapacity \u003d \n      (consumed \u003c queueCapacity) ? \n          queueCapacity : (consumed + required.getMemory());\n\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n\n    String userName \u003d application.getUser();\n    \n    final int activeUsers \u003d users.size();  \n    User user \u003d getUser(userName);\n\n    int limit \u003d \n      roundUp(\n          Math.min(\n              Math.max(divideAndCeil(currentCapacity, activeUsers), \n                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n              (int)(queueCapacity * userLimitFactor)\n              )\n          );\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + consumed +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource.getMemory()\n      );\n    }\n\n    return Resources.createResource(limit);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,57 @@\n+  private Resource computeUserLimit(SchedulerApp application, \n+      Resource clusterResource, Resource required) {\n+    // What is our current capacity? \n+    // * It is equal to the max(required, queue-capacity) if\n+    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n+    //   with miniscule capacity (\u003c 1 slot) make progress\n+    // * If we\u0027re running over capacity, then its\n+    //   (usedResources + required) (which extra resources we are allocating)\n+\n+    // Allow progress for queues with miniscule capacity\n+    final int queueCapacity \u003d \n+      Math.max(\n+          roundUp((int)(absoluteCapacity * clusterResource.getMemory())), \n+          required.getMemory());\n+\n+    final int consumed \u003d usedResources.getMemory();\n+    final int currentCapacity \u003d \n+      (consumed \u003c queueCapacity) ? \n+          queueCapacity : (consumed + required.getMemory());\n+\n+    // Never allow a single user to take more than the \n+    // queue\u0027s configured capacity * user-limit-factor.\n+    // Also, the queue\u0027s configured capacity should be higher than \n+    // queue-hard-limit * ulMin\n+\n+    String userName \u003d application.getUser();\n+    \n+    final int activeUsers \u003d users.size();  \n+    User user \u003d getUser(userName);\n+\n+    int limit \u003d \n+      roundUp(\n+          Math.min(\n+              Math.max(divideAndCeil(currentCapacity, activeUsers), \n+                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n+              (int)(queueCapacity * userLimitFactor)\n+              )\n+          );\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"User limit computation for \" + userName + \n+          \" in queue \" + getQueueName() +\n+          \" userLimit\u003d\" + userLimit +\n+          \" userLimitFactor\u003d\" + userLimitFactor +\n+          \" required: \" + required + \n+          \" consumed: \" + user.getConsumedResources() + \n+          \" limit: \" + limit +\n+          \" queueCapacity: \" + queueCapacity + \n+          \" qconsumed: \" + consumed +\n+          \" currentCapacity: \" + currentCapacity +\n+          \" activeUsers: \" + activeUsers +\n+          \" clusterCapacity: \" + clusterResource.getMemory()\n+      );\n+    }\n+\n+    return Resources.createResource(limit);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimit(SchedulerApp application, \n      Resource clusterResource, Resource required) {\n    // What is our current capacity? \n    // * It is equal to the max(required, queue-capacity) if\n    //   we\u0027re running below capacity. The \u0027max\u0027 ensures that jobs in queues\n    //   with miniscule capacity (\u003c 1 slot) make progress\n    // * If we\u0027re running over capacity, then its\n    //   (usedResources + required) (which extra resources we are allocating)\n\n    // Allow progress for queues with miniscule capacity\n    final int queueCapacity \u003d \n      Math.max(\n          roundUp((int)(absoluteCapacity * clusterResource.getMemory())), \n          required.getMemory());\n\n    final int consumed \u003d usedResources.getMemory();\n    final int currentCapacity \u003d \n      (consumed \u003c queueCapacity) ? \n          queueCapacity : (consumed + required.getMemory());\n\n    // Never allow a single user to take more than the \n    // queue\u0027s configured capacity * user-limit-factor.\n    // Also, the queue\u0027s configured capacity should be higher than \n    // queue-hard-limit * ulMin\n\n    String userName \u003d application.getUser();\n    \n    final int activeUsers \u003d users.size();  \n    User user \u003d getUser(userName);\n\n    int limit \u003d \n      roundUp(\n          Math.min(\n              Math.max(divideAndCeil(currentCapacity, activeUsers), \n                       divideAndCeil((int)userLimit*currentCapacity, 100)),\n              (int)(queueCapacity * userLimitFactor)\n              )\n          );\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName + \n          \" in queue \" + getQueueName() +\n          \" userLimit\u003d\" + userLimit +\n          \" userLimitFactor\u003d\" + userLimitFactor +\n          \" required: \" + required + \n          \" consumed: \" + user.getConsumedResources() + \n          \" limit: \" + limit +\n          \" queueCapacity: \" + queueCapacity + \n          \" qconsumed: \" + consumed +\n          \" currentCapacity: \" + currentCapacity +\n          \" activeUsers: \" + activeUsers +\n          \" clusterCapacity: \" + clusterResource.getMemory()\n      );\n    }\n\n    return Resources.createResource(limit);\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
    }
  }
}