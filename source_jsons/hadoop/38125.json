{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReservedContainerCandidatesSelector.java",
  "functionName": "getPreemptionCandidatesOnNode",
  "functionId": "getPreemptionCandidatesOnNode___node-FiCaSchedulerNode__queueToPreemptableResourceByPartition-Map__String,Map__String,Resource______selectedCandidates-Map__ApplicationAttemptId,Set__RMContainer______totalPreemptionAllowed-Resource__readOnly-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
  "functionStartLine": 167,
  "functionEndLine": 272,
  "numCommitsSeen": 6,
  "timeTaken": 4520,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": "Ymultichange(Yparameterchange,Ybodychange)",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,106 @@\n   private NodeForPreemption getPreemptionCandidatesOnNode(\n       FiCaSchedulerNode node,\n       Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource totalPreemptionAllowed, boolean readOnly) {\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     Resource available \u003d Resources.clone(node.getUnallocatedResource());\n     Resource totalSelected \u003d Resources.createResource(0);\n     List\u003cRMContainer\u003e sortedRunningContainers \u003d\n         node.getCopiedListOfRunningContainers();\n     List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n     Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n         node.getKillableContainers();\n \n     // Sort running container by launch time, we preferred to preempt recent\n     // launched preempt container\n     Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n       @Override public int compare(RMContainer o1, RMContainer o2) {\n         return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n \n     // First check: can we preempt containers to allocate the\n     // reservedContainer?\n     boolean canAllocateReservedContainer \u003d false;\n \n     // At least, we can get available + killable resources from this node\n     Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n     String partition \u003d node.getPartition();\n \n     // Avoid preempt any container if required \u003c\u003d available + killable\n     if (Resources.fitsIn(rc, reservedContainer.getReservedResource(), cur)) {\n       return null;\n     }\n \n     // Extra cost of am container preemption\n     float amPreemptionCost \u003d 0f;\n \n     for (RMContainer c : sortedRunningContainers) {\n       String containerQueueName \u003d c.getQueueName();\n \n       // Skip container if it is already marked killable\n       if (killableContainers.containsKey(c.getContainerId())) {\n         continue;\n       }\n \n       // An alternative approach is add a \"penalty cost\" if AM container is\n       // selected. Here for safety, avoid preempt AM container in any cases\n       if (c.isAMContainer()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Skip selecting AM container on host\u003d\" + node.getNodeID()\n-              + \" AM container\u003d\" + c.getContainerId());\n-        }\n+        LOG.debug(\"Skip selecting AM container on host\u003d{} AM container\u003d{}\",\n+            node.getNodeID(), c.getContainerId());\n+\n         continue;\n       }\n \n       // Can we preempt container c?\n       // Check if we have quota to preempt this container\n       boolean canPreempt \u003d tryToPreemptFromQueue(containerQueueName, partition,\n           queueToPreemptableResourceByPartition, c.getAllocatedResource(),\n           totalPreemptionAllowed, readOnly);\n \n       // If we can, add to selected container, and change resource accordingly.\n       if (canPreempt) {\n         if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n             selectedCandidates)) {\n           if (!readOnly) {\n             selectedContainers.add(c);\n           }\n           Resources.addTo(totalSelected, c.getAllocatedResource());\n         }\n         Resources.addTo(cur, c.getAllocatedResource());\n         if (Resources.fitsIn(rc,\n             reservedContainer.getReservedResource(), cur)) {\n           canAllocateReservedContainer \u003d true;\n           break;\n         }\n       }\n     }\n \n     if (!canAllocateReservedContainer) {\n       if (!readOnly) {\n         // Revert queue preemption quotas\n         for (RMContainer c : selectedContainers) {\n           Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n               queueToPreemptableResourceByPartition);\n           if (null \u003d\u003d res) {\n             // This shouldn\u0027t happen in normal cases, one possible cause is\n             // container moved to different queue while executing preemption logic.\n             // Ignore such failures.\n             continue;\n           }\n           Resources.addTo(res, c.getAllocatedResource());\n         }\n       }\n       return null;\n     }\n \n     float ratio \u003d Resources.ratio(rc, totalSelected,\n         reservedContainer.getReservedResource());\n \n     // Compute preemption score\n     NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n         node, selectedContainers);\n \n     return nfp;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private NodeForPreemption getPreemptionCandidatesOnNode(\n      FiCaSchedulerNode node,\n      Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource totalPreemptionAllowed, boolean readOnly) {\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    Resource available \u003d Resources.clone(node.getUnallocatedResource());\n    Resource totalSelected \u003d Resources.createResource(0);\n    List\u003cRMContainer\u003e sortedRunningContainers \u003d\n        node.getCopiedListOfRunningContainers();\n    List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n    Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n        node.getKillableContainers();\n\n    // Sort running container by launch time, we preferred to preempt recent\n    // launched preempt container\n    Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n      @Override public int compare(RMContainer o1, RMContainer o2) {\n        return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n\n    // First check: can we preempt containers to allocate the\n    // reservedContainer?\n    boolean canAllocateReservedContainer \u003d false;\n\n    // At least, we can get available + killable resources from this node\n    Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n    String partition \u003d node.getPartition();\n\n    // Avoid preempt any container if required \u003c\u003d available + killable\n    if (Resources.fitsIn(rc, reservedContainer.getReservedResource(), cur)) {\n      return null;\n    }\n\n    // Extra cost of am container preemption\n    float amPreemptionCost \u003d 0f;\n\n    for (RMContainer c : sortedRunningContainers) {\n      String containerQueueName \u003d c.getQueueName();\n\n      // Skip container if it is already marked killable\n      if (killableContainers.containsKey(c.getContainerId())) {\n        continue;\n      }\n\n      // An alternative approach is add a \"penalty cost\" if AM container is\n      // selected. Here for safety, avoid preempt AM container in any cases\n      if (c.isAMContainer()) {\n        LOG.debug(\"Skip selecting AM container on host\u003d{} AM container\u003d{}\",\n            node.getNodeID(), c.getContainerId());\n\n        continue;\n      }\n\n      // Can we preempt container c?\n      // Check if we have quota to preempt this container\n      boolean canPreempt \u003d tryToPreemptFromQueue(containerQueueName, partition,\n          queueToPreemptableResourceByPartition, c.getAllocatedResource(),\n          totalPreemptionAllowed, readOnly);\n\n      // If we can, add to selected container, and change resource accordingly.\n      if (canPreempt) {\n        if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n            selectedCandidates)) {\n          if (!readOnly) {\n            selectedContainers.add(c);\n          }\n          Resources.addTo(totalSelected, c.getAllocatedResource());\n        }\n        Resources.addTo(cur, c.getAllocatedResource());\n        if (Resources.fitsIn(rc,\n            reservedContainer.getReservedResource(), cur)) {\n          canAllocateReservedContainer \u003d true;\n          break;\n        }\n      }\n    }\n\n    if (!canAllocateReservedContainer) {\n      if (!readOnly) {\n        // Revert queue preemption quotas\n        for (RMContainer c : selectedContainers) {\n          Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n              queueToPreemptableResourceByPartition);\n          if (null \u003d\u003d res) {\n            // This shouldn\u0027t happen in normal cases, one possible cause is\n            // container moved to different queue while executing preemption logic.\n            // Ignore such failures.\n            continue;\n          }\n          Resources.addTo(res, c.getAllocatedResource());\n        }\n      }\n      return null;\n    }\n\n    float ratio \u003d Resources.ratio(rc, totalSelected,\n        reservedContainer.getReservedResource());\n\n    // Compute preemption score\n    NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n        node, selectedContainers);\n\n    return nfp;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
      "extendedDetails": {}
    },
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
      "commitDate": "17/09/17 9:20 PM",
      "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
          "commitDate": "17/09/17 9:20 PM",
          "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "05/05/16 12:56 PM",
          "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 500.35,
          "commitsBetweenForRepo": 3345,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,108 +1,107 @@\n   private NodeForPreemption getPreemptionCandidatesOnNode(\n-      FiCaSchedulerNode node, Resource cluster,\n+      FiCaSchedulerNode node,\n       Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource totalPreemptionAllowed, boolean readOnly) {\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     Resource available \u003d Resources.clone(node.getUnallocatedResource());\n     Resource totalSelected \u003d Resources.createResource(0);\n     List\u003cRMContainer\u003e sortedRunningContainers \u003d\n         node.getCopiedListOfRunningContainers();\n     List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n     Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n         node.getKillableContainers();\n \n     // Sort running container by launch time, we preferred to preempt recent\n     // launched preempt container\n     Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n       @Override public int compare(RMContainer o1, RMContainer o2) {\n         return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n \n     // First check: can we preempt containers to allocate the\n     // reservedContainer?\n     boolean canAllocateReservedContainer \u003d false;\n \n     // At least, we can get available + killable resources from this node\n     Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n     String partition \u003d node.getPartition();\n \n     // Avoid preempt any container if required \u003c\u003d available + killable\n-    if (Resources.fitsIn(rc, cluster, reservedContainer.getReservedResource(),\n-        cur)) {\n+    if (Resources.fitsIn(rc, reservedContainer.getReservedResource(), cur)) {\n       return null;\n     }\n \n     // Extra cost of am container preemption\n     float amPreemptionCost \u003d 0f;\n \n     for (RMContainer c : sortedRunningContainers) {\n       String containerQueueName \u003d c.getQueueName();\n \n       // Skip container if it is already marked killable\n       if (killableContainers.containsKey(c.getContainerId())) {\n         continue;\n       }\n \n       // An alternative approach is add a \"penalty cost\" if AM container is\n       // selected. Here for safety, avoid preempt AM container in any cases\n       if (c.isAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip selecting AM container on host\u003d\" + node.getNodeID()\n               + \" AM container\u003d\" + c.getContainerId());\n         }\n         continue;\n       }\n \n       // Can we preempt container c?\n       // Check if we have quota to preempt this container\n-      boolean canPreempt \u003d tryToPreemptFromQueue(cluster, containerQueueName,\n-          partition, queueToPreemptableResourceByPartition,\n-          c.getAllocatedResource(), totalPreemptionAllowed, readOnly);\n+      boolean canPreempt \u003d tryToPreemptFromQueue(containerQueueName, partition,\n+          queueToPreemptableResourceByPartition, c.getAllocatedResource(),\n+          totalPreemptionAllowed, readOnly);\n \n       // If we can, add to selected container, and change resource accordingly.\n       if (canPreempt) {\n         if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n             selectedCandidates)) {\n           if (!readOnly) {\n             selectedContainers.add(c);\n           }\n           Resources.addTo(totalSelected, c.getAllocatedResource());\n         }\n         Resources.addTo(cur, c.getAllocatedResource());\n-        if (Resources.fitsIn(rc, cluster,\n+        if (Resources.fitsIn(rc,\n             reservedContainer.getReservedResource(), cur)) {\n           canAllocateReservedContainer \u003d true;\n           break;\n         }\n       }\n     }\n \n     if (!canAllocateReservedContainer) {\n       if (!readOnly) {\n         // Revert queue preemption quotas\n         for (RMContainer c : selectedContainers) {\n           Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n               queueToPreemptableResourceByPartition);\n           if (null \u003d\u003d res) {\n             // This shouldn\u0027t happen in normal cases, one possible cause is\n             // container moved to different queue while executing preemption logic.\n             // Ignore such failures.\n             continue;\n           }\n           Resources.addTo(res, c.getAllocatedResource());\n         }\n       }\n       return null;\n     }\n \n     float ratio \u003d Resources.ratio(rc, totalSelected,\n         reservedContainer.getReservedResource());\n \n     // Compute preemption score\n     NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n         node, selectedContainers);\n \n     return nfp;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private NodeForPreemption getPreemptionCandidatesOnNode(\n      FiCaSchedulerNode node,\n      Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource totalPreemptionAllowed, boolean readOnly) {\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    Resource available \u003d Resources.clone(node.getUnallocatedResource());\n    Resource totalSelected \u003d Resources.createResource(0);\n    List\u003cRMContainer\u003e sortedRunningContainers \u003d\n        node.getCopiedListOfRunningContainers();\n    List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n    Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n        node.getKillableContainers();\n\n    // Sort running container by launch time, we preferred to preempt recent\n    // launched preempt container\n    Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n      @Override public int compare(RMContainer o1, RMContainer o2) {\n        return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n\n    // First check: can we preempt containers to allocate the\n    // reservedContainer?\n    boolean canAllocateReservedContainer \u003d false;\n\n    // At least, we can get available + killable resources from this node\n    Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n    String partition \u003d node.getPartition();\n\n    // Avoid preempt any container if required \u003c\u003d available + killable\n    if (Resources.fitsIn(rc, reservedContainer.getReservedResource(), cur)) {\n      return null;\n    }\n\n    // Extra cost of am container preemption\n    float amPreemptionCost \u003d 0f;\n\n    for (RMContainer c : sortedRunningContainers) {\n      String containerQueueName \u003d c.getQueueName();\n\n      // Skip container if it is already marked killable\n      if (killableContainers.containsKey(c.getContainerId())) {\n        continue;\n      }\n\n      // An alternative approach is add a \"penalty cost\" if AM container is\n      // selected. Here for safety, avoid preempt AM container in any cases\n      if (c.isAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip selecting AM container on host\u003d\" + node.getNodeID()\n              + \" AM container\u003d\" + c.getContainerId());\n        }\n        continue;\n      }\n\n      // Can we preempt container c?\n      // Check if we have quota to preempt this container\n      boolean canPreempt \u003d tryToPreemptFromQueue(containerQueueName, partition,\n          queueToPreemptableResourceByPartition, c.getAllocatedResource(),\n          totalPreemptionAllowed, readOnly);\n\n      // If we can, add to selected container, and change resource accordingly.\n      if (canPreempt) {\n        if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n            selectedCandidates)) {\n          if (!readOnly) {\n            selectedContainers.add(c);\n          }\n          Resources.addTo(totalSelected, c.getAllocatedResource());\n        }\n        Resources.addTo(cur, c.getAllocatedResource());\n        if (Resources.fitsIn(rc,\n            reservedContainer.getReservedResource(), cur)) {\n          canAllocateReservedContainer \u003d true;\n          break;\n        }\n      }\n    }\n\n    if (!canAllocateReservedContainer) {\n      if (!readOnly) {\n        // Revert queue preemption quotas\n        for (RMContainer c : selectedContainers) {\n          Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n              queueToPreemptableResourceByPartition);\n          if (null \u003d\u003d res) {\n            // This shouldn\u0027t happen in normal cases, one possible cause is\n            // container moved to different queue while executing preemption logic.\n            // Ignore such failures.\n            continue;\n          }\n          Resources.addTo(res, c.getAllocatedResource());\n        }\n      }\n      return null;\n    }\n\n    float ratio \u003d Resources.ratio(rc, totalSelected,\n        reservedContainer.getReservedResource());\n\n    // Compute preemption score\n    NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n        node, selectedContainers);\n\n    return nfp;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
          "extendedDetails": {
            "oldValue": "[node-FiCaSchedulerNode, cluster-Resource, queueToPreemptableResourceByPartition-Map\u003cString,Map\u003cString,Resource\u003e\u003e, selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource, readOnly-boolean]",
            "newValue": "[node-FiCaSchedulerNode, queueToPreemptableResourceByPartition-Map\u003cString,Map\u003cString,Resource\u003e\u003e, selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource, readOnly-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
          "commitDate": "17/09/17 9:20 PM",
          "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "05/05/16 12:56 PM",
          "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 500.35,
          "commitsBetweenForRepo": 3345,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,108 +1,107 @@\n   private NodeForPreemption getPreemptionCandidatesOnNode(\n-      FiCaSchedulerNode node, Resource cluster,\n+      FiCaSchedulerNode node,\n       Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource totalPreemptionAllowed, boolean readOnly) {\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     Resource available \u003d Resources.clone(node.getUnallocatedResource());\n     Resource totalSelected \u003d Resources.createResource(0);\n     List\u003cRMContainer\u003e sortedRunningContainers \u003d\n         node.getCopiedListOfRunningContainers();\n     List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n     Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n         node.getKillableContainers();\n \n     // Sort running container by launch time, we preferred to preempt recent\n     // launched preempt container\n     Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n       @Override public int compare(RMContainer o1, RMContainer o2) {\n         return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n \n     // First check: can we preempt containers to allocate the\n     // reservedContainer?\n     boolean canAllocateReservedContainer \u003d false;\n \n     // At least, we can get available + killable resources from this node\n     Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n     String partition \u003d node.getPartition();\n \n     // Avoid preempt any container if required \u003c\u003d available + killable\n-    if (Resources.fitsIn(rc, cluster, reservedContainer.getReservedResource(),\n-        cur)) {\n+    if (Resources.fitsIn(rc, reservedContainer.getReservedResource(), cur)) {\n       return null;\n     }\n \n     // Extra cost of am container preemption\n     float amPreemptionCost \u003d 0f;\n \n     for (RMContainer c : sortedRunningContainers) {\n       String containerQueueName \u003d c.getQueueName();\n \n       // Skip container if it is already marked killable\n       if (killableContainers.containsKey(c.getContainerId())) {\n         continue;\n       }\n \n       // An alternative approach is add a \"penalty cost\" if AM container is\n       // selected. Here for safety, avoid preempt AM container in any cases\n       if (c.isAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip selecting AM container on host\u003d\" + node.getNodeID()\n               + \" AM container\u003d\" + c.getContainerId());\n         }\n         continue;\n       }\n \n       // Can we preempt container c?\n       // Check if we have quota to preempt this container\n-      boolean canPreempt \u003d tryToPreemptFromQueue(cluster, containerQueueName,\n-          partition, queueToPreemptableResourceByPartition,\n-          c.getAllocatedResource(), totalPreemptionAllowed, readOnly);\n+      boolean canPreempt \u003d tryToPreemptFromQueue(containerQueueName, partition,\n+          queueToPreemptableResourceByPartition, c.getAllocatedResource(),\n+          totalPreemptionAllowed, readOnly);\n \n       // If we can, add to selected container, and change resource accordingly.\n       if (canPreempt) {\n         if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n             selectedCandidates)) {\n           if (!readOnly) {\n             selectedContainers.add(c);\n           }\n           Resources.addTo(totalSelected, c.getAllocatedResource());\n         }\n         Resources.addTo(cur, c.getAllocatedResource());\n-        if (Resources.fitsIn(rc, cluster,\n+        if (Resources.fitsIn(rc,\n             reservedContainer.getReservedResource(), cur)) {\n           canAllocateReservedContainer \u003d true;\n           break;\n         }\n       }\n     }\n \n     if (!canAllocateReservedContainer) {\n       if (!readOnly) {\n         // Revert queue preemption quotas\n         for (RMContainer c : selectedContainers) {\n           Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n               queueToPreemptableResourceByPartition);\n           if (null \u003d\u003d res) {\n             // This shouldn\u0027t happen in normal cases, one possible cause is\n             // container moved to different queue while executing preemption logic.\n             // Ignore such failures.\n             continue;\n           }\n           Resources.addTo(res, c.getAllocatedResource());\n         }\n       }\n       return null;\n     }\n \n     float ratio \u003d Resources.ratio(rc, totalSelected,\n         reservedContainer.getReservedResource());\n \n     // Compute preemption score\n     NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n         node, selectedContainers);\n \n     return nfp;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private NodeForPreemption getPreemptionCandidatesOnNode(\n      FiCaSchedulerNode node,\n      Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource totalPreemptionAllowed, boolean readOnly) {\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    Resource available \u003d Resources.clone(node.getUnallocatedResource());\n    Resource totalSelected \u003d Resources.createResource(0);\n    List\u003cRMContainer\u003e sortedRunningContainers \u003d\n        node.getCopiedListOfRunningContainers();\n    List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n    Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n        node.getKillableContainers();\n\n    // Sort running container by launch time, we preferred to preempt recent\n    // launched preempt container\n    Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n      @Override public int compare(RMContainer o1, RMContainer o2) {\n        return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n\n    // First check: can we preempt containers to allocate the\n    // reservedContainer?\n    boolean canAllocateReservedContainer \u003d false;\n\n    // At least, we can get available + killable resources from this node\n    Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n    String partition \u003d node.getPartition();\n\n    // Avoid preempt any container if required \u003c\u003d available + killable\n    if (Resources.fitsIn(rc, reservedContainer.getReservedResource(), cur)) {\n      return null;\n    }\n\n    // Extra cost of am container preemption\n    float amPreemptionCost \u003d 0f;\n\n    for (RMContainer c : sortedRunningContainers) {\n      String containerQueueName \u003d c.getQueueName();\n\n      // Skip container if it is already marked killable\n      if (killableContainers.containsKey(c.getContainerId())) {\n        continue;\n      }\n\n      // An alternative approach is add a \"penalty cost\" if AM container is\n      // selected. Here for safety, avoid preempt AM container in any cases\n      if (c.isAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip selecting AM container on host\u003d\" + node.getNodeID()\n              + \" AM container\u003d\" + c.getContainerId());\n        }\n        continue;\n      }\n\n      // Can we preempt container c?\n      // Check if we have quota to preempt this container\n      boolean canPreempt \u003d tryToPreemptFromQueue(containerQueueName, partition,\n          queueToPreemptableResourceByPartition, c.getAllocatedResource(),\n          totalPreemptionAllowed, readOnly);\n\n      // If we can, add to selected container, and change resource accordingly.\n      if (canPreempt) {\n        if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n            selectedCandidates)) {\n          if (!readOnly) {\n            selectedContainers.add(c);\n          }\n          Resources.addTo(totalSelected, c.getAllocatedResource());\n        }\n        Resources.addTo(cur, c.getAllocatedResource());\n        if (Resources.fitsIn(rc,\n            reservedContainer.getReservedResource(), cur)) {\n          canAllocateReservedContainer \u003d true;\n          break;\n        }\n      }\n    }\n\n    if (!canAllocateReservedContainer) {\n      if (!readOnly) {\n        // Revert queue preemption quotas\n        for (RMContainer c : selectedContainers) {\n          Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n              queueToPreemptableResourceByPartition);\n          if (null \u003d\u003d res) {\n            // This shouldn\u0027t happen in normal cases, one possible cause is\n            // container moved to different queue while executing preemption logic.\n            // Ignore such failures.\n            continue;\n          }\n          Resources.addTo(res, c.getAllocatedResource());\n        }\n      }\n      return null;\n    }\n\n    float ratio \u003d Resources.ratio(rc, totalSelected,\n        reservedContainer.getReservedResource());\n\n    // Compute preemption score\n    NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n        node, selectedContainers);\n\n    return nfp;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
          "extendedDetails": {}
        }
      ]
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,108 @@\n+  private NodeForPreemption getPreemptionCandidatesOnNode(\n+      FiCaSchedulerNode node, Resource cluster,\n+      Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Resource totalPreemptionAllowed, boolean readOnly) {\n+    RMContainer reservedContainer \u003d node.getReservedContainer();\n+    Resource available \u003d Resources.clone(node.getUnallocatedResource());\n+    Resource totalSelected \u003d Resources.createResource(0);\n+    List\u003cRMContainer\u003e sortedRunningContainers \u003d\n+        node.getCopiedListOfRunningContainers();\n+    List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n+    Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n+        node.getKillableContainers();\n+\n+    // Sort running container by launch time, we preferred to preempt recent\n+    // launched preempt container\n+    Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n+      @Override public int compare(RMContainer o1, RMContainer o2) {\n+        return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n+      }\n+    });\n+\n+    // First check: can we preempt containers to allocate the\n+    // reservedContainer?\n+    boolean canAllocateReservedContainer \u003d false;\n+\n+    // At least, we can get available + killable resources from this node\n+    Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n+    String partition \u003d node.getPartition();\n+\n+    // Avoid preempt any container if required \u003c\u003d available + killable\n+    if (Resources.fitsIn(rc, cluster, reservedContainer.getReservedResource(),\n+        cur)) {\n+      return null;\n+    }\n+\n+    // Extra cost of am container preemption\n+    float amPreemptionCost \u003d 0f;\n+\n+    for (RMContainer c : sortedRunningContainers) {\n+      String containerQueueName \u003d c.getQueueName();\n+\n+      // Skip container if it is already marked killable\n+      if (killableContainers.containsKey(c.getContainerId())) {\n+        continue;\n+      }\n+\n+      // An alternative approach is add a \"penalty cost\" if AM container is\n+      // selected. Here for safety, avoid preempt AM container in any cases\n+      if (c.isAMContainer()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Skip selecting AM container on host\u003d\" + node.getNodeID()\n+              + \" AM container\u003d\" + c.getContainerId());\n+        }\n+        continue;\n+      }\n+\n+      // Can we preempt container c?\n+      // Check if we have quota to preempt this container\n+      boolean canPreempt \u003d tryToPreemptFromQueue(cluster, containerQueueName,\n+          partition, queueToPreemptableResourceByPartition,\n+          c.getAllocatedResource(), totalPreemptionAllowed, readOnly);\n+\n+      // If we can, add to selected container, and change resource accordingly.\n+      if (canPreempt) {\n+        if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+            selectedCandidates)) {\n+          if (!readOnly) {\n+            selectedContainers.add(c);\n+          }\n+          Resources.addTo(totalSelected, c.getAllocatedResource());\n+        }\n+        Resources.addTo(cur, c.getAllocatedResource());\n+        if (Resources.fitsIn(rc, cluster,\n+            reservedContainer.getReservedResource(), cur)) {\n+          canAllocateReservedContainer \u003d true;\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (!canAllocateReservedContainer) {\n+      if (!readOnly) {\n+        // Revert queue preemption quotas\n+        for (RMContainer c : selectedContainers) {\n+          Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n+              queueToPreemptableResourceByPartition);\n+          if (null \u003d\u003d res) {\n+            // This shouldn\u0027t happen in normal cases, one possible cause is\n+            // container moved to different queue while executing preemption logic.\n+            // Ignore such failures.\n+            continue;\n+          }\n+          Resources.addTo(res, c.getAllocatedResource());\n+        }\n+      }\n+      return null;\n+    }\n+\n+    float ratio \u003d Resources.ratio(rc, totalSelected,\n+        reservedContainer.getReservedResource());\n+\n+    // Compute preemption score\n+    NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n+        node, selectedContainers);\n+\n+    return nfp;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private NodeForPreemption getPreemptionCandidatesOnNode(\n      FiCaSchedulerNode node, Resource cluster,\n      Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource totalPreemptionAllowed, boolean readOnly) {\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    Resource available \u003d Resources.clone(node.getUnallocatedResource());\n    Resource totalSelected \u003d Resources.createResource(0);\n    List\u003cRMContainer\u003e sortedRunningContainers \u003d\n        node.getCopiedListOfRunningContainers();\n    List\u003cRMContainer\u003e selectedContainers \u003d new ArrayList\u003c\u003e();\n    Map\u003cContainerId, RMContainer\u003e killableContainers \u003d\n        node.getKillableContainers();\n\n    // Sort running container by launch time, we preferred to preempt recent\n    // launched preempt container\n    Collections.sort(sortedRunningContainers, new Comparator\u003cRMContainer\u003e() {\n      @Override public int compare(RMContainer o1, RMContainer o2) {\n        return -1 * o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n\n    // First check: can we preempt containers to allocate the\n    // reservedContainer?\n    boolean canAllocateReservedContainer \u003d false;\n\n    // At least, we can get available + killable resources from this node\n    Resource cur \u003d Resources.add(available, node.getTotalKillableResources());\n    String partition \u003d node.getPartition();\n\n    // Avoid preempt any container if required \u003c\u003d available + killable\n    if (Resources.fitsIn(rc, cluster, reservedContainer.getReservedResource(),\n        cur)) {\n      return null;\n    }\n\n    // Extra cost of am container preemption\n    float amPreemptionCost \u003d 0f;\n\n    for (RMContainer c : sortedRunningContainers) {\n      String containerQueueName \u003d c.getQueueName();\n\n      // Skip container if it is already marked killable\n      if (killableContainers.containsKey(c.getContainerId())) {\n        continue;\n      }\n\n      // An alternative approach is add a \"penalty cost\" if AM container is\n      // selected. Here for safety, avoid preempt AM container in any cases\n      if (c.isAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip selecting AM container on host\u003d\" + node.getNodeID()\n              + \" AM container\u003d\" + c.getContainerId());\n        }\n        continue;\n      }\n\n      // Can we preempt container c?\n      // Check if we have quota to preempt this container\n      boolean canPreempt \u003d tryToPreemptFromQueue(cluster, containerQueueName,\n          partition, queueToPreemptableResourceByPartition,\n          c.getAllocatedResource(), totalPreemptionAllowed, readOnly);\n\n      // If we can, add to selected container, and change resource accordingly.\n      if (canPreempt) {\n        if (!CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n            selectedCandidates)) {\n          if (!readOnly) {\n            selectedContainers.add(c);\n          }\n          Resources.addTo(totalSelected, c.getAllocatedResource());\n        }\n        Resources.addTo(cur, c.getAllocatedResource());\n        if (Resources.fitsIn(rc, cluster,\n            reservedContainer.getReservedResource(), cur)) {\n          canAllocateReservedContainer \u003d true;\n          break;\n        }\n      }\n    }\n\n    if (!canAllocateReservedContainer) {\n      if (!readOnly) {\n        // Revert queue preemption quotas\n        for (RMContainer c : selectedContainers) {\n          Resource res \u003d getPreemptableResource(c.getQueueName(), partition,\n              queueToPreemptableResourceByPartition);\n          if (null \u003d\u003d res) {\n            // This shouldn\u0027t happen in normal cases, one possible cause is\n            // container moved to different queue while executing preemption logic.\n            // Ignore such failures.\n            continue;\n          }\n          Resources.addTo(res, c.getAllocatedResource());\n        }\n      }\n      return null;\n    }\n\n    float ratio \u003d Resources.ratio(rc, totalSelected,\n        reservedContainer.getReservedResource());\n\n    // Compute preemption score\n    NodeForPreemption nfp \u003d new NodeForPreemption(ratio + amPreemptionCost,\n        node, selectedContainers);\n\n    return nfp;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java"
    }
  }
}