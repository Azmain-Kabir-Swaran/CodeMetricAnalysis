{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TaskImpl.java",
  "functionName": "recover",
  "functionId": "recover___taskInfo-TaskInfo__committer-OutputCommitter__recoverTaskOutput-boolean",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskImpl.java",
  "functionStartLine": 784,
  "functionEndLine": 882,
  "numCommitsSeen": 44,
  "timeTaken": 1799,
  "changeHistory": [
    "092fead5d9875fb3760206bcdd76cdafec5e9481",
    "6a1c41111edcdc58c846fc50e53554fbba230171"
  ],
  "changeHistoryShort": {
    "092fead5d9875fb3760206bcdd76cdafec5e9481": "Ybodychange",
    "6a1c41111edcdc58c846fc50e53554fbba230171": "Yintroduced"
  },
  "changeHistoryDetails": {
    "092fead5d9875fb3760206bcdd76cdafec5e9481": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5792. Adopt the id prefix for YARN, MR, and DS entities. Contributed by Varun Saxena.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "092fead5d9875fb3760206bcdd76cdafec5e9481",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "02/12/16 9:22 AM",
      "commitNameOld": "0cfd7ad21f4457513ed3416e5d77f3123bfe9da0",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 270.53,
      "commitsBetweenForRepo": 1498,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,99 @@\n   private TaskStateInternal recover(TaskInfo taskInfo,\n       OutputCommitter committer, boolean recoverTaskOutput) {\n     LOG.info(\"Recovering task \" + taskId\n         + \" from prior app attempt, status was \" + taskInfo.getTaskStatus());\n \n     scheduledTime \u003d taskInfo.getStartTime();\n     sendTaskStartedEvent();\n     Collection\u003cTaskAttemptInfo\u003e attemptInfos \u003d\n         taskInfo.getAllTaskAttempts().values();\n \n     if (attemptInfos.size() \u003e 0) {\n       metrics.launchedTask(this);\n     }\n \n     // recover the attempts for this task in the order they finished\n     // so task attempt completion events are ordered properly\n     int savedNextAttemptNumber \u003d nextAttemptNumber;\n     ArrayList\u003cTaskAttemptInfo\u003e taInfos \u003d\n         new ArrayList\u003cTaskAttemptInfo\u003e(taskInfo.getAllTaskAttempts().values());\n     Collections.sort(taInfos, TA_INFO_COMPARATOR);\n     for (TaskAttemptInfo taInfo : taInfos) {\n       nextAttemptNumber \u003d taInfo.getAttemptId().getId();\n       TaskAttemptImpl attempt \u003d addAttempt(Avataar.VIRGIN);\n       // handle the recovery inline so attempts complete before task does\n       attempt.handle(new TaskAttemptRecoverEvent(attempt.getID(), taInfo,\n           committer, recoverTaskOutput));\n       finishedAttempts.add(attempt.getID());\n       TaskAttemptCompletionEventStatus taces \u003d null;\n       TaskAttemptState attemptState \u003d attempt.getState();\n       switch (attemptState) {\n       case FAILED:\n         taces \u003d TaskAttemptCompletionEventStatus.FAILED;\n         break;\n       case KILLED:\n         taces \u003d TaskAttemptCompletionEventStatus.KILLED;\n         break;\n       case SUCCEEDED:\n         taces \u003d TaskAttemptCompletionEventStatus.SUCCEEDED;\n         break;\n       default:\n         throw new IllegalStateException(\n             \"Unexpected attempt state during recovery: \" + attemptState);\n       }\n       if (attemptState \u003d\u003d TaskAttemptState.FAILED) {\n         failedAttempts.add(attempt.getID());\n         if (failedAttempts.size() \u003e\u003d maxAttempts) {\n           taces \u003d TaskAttemptCompletionEventStatus.TIPFAILED;\n         }\n       }\n \n       // don\u0027t clobber the successful attempt completion event\n       // TODO: this shouldn\u0027t be necessary after MAPREDUCE-4330\n       if (successfulAttempt \u003d\u003d null) {\n         handleTaskAttemptCompletion(attempt.getID(), taces);\n         if (attemptState \u003d\u003d TaskAttemptState.SUCCEEDED) {\n           successfulAttempt \u003d attempt.getID();\n         }\n       }\n     }\n     nextAttemptNumber \u003d savedNextAttemptNumber;\n \n     TaskStateInternal taskState \u003d TaskStateInternal.valueOf(\n         taskInfo.getTaskStatus());\n     switch (taskState) {\n     case SUCCEEDED:\n       if (successfulAttempt !\u003d null) {\n         sendTaskSucceededEvents();\n       } else {\n         LOG.info(\"Missing successful attempt for task \" + taskId\n             + \", recovering as RUNNING\");\n         // there must have been a fetch failure and the retry wasn\u0027t complete\n         taskState \u003d TaskStateInternal.RUNNING;\n         metrics.runningTask(this);\n         addAndScheduleAttempt(Avataar.VIRGIN);\n       }\n       break;\n     case FAILED:\n     case KILLED:\n     {\n       if (taskState \u003d\u003d TaskStateInternal.KILLED \u0026\u0026 attemptInfos.size() \u003d\u003d 0) {\n         metrics.endWaitingTask(this);\n       }\n       TaskFailedEvent tfe \u003d new TaskFailedEvent(taskInfo.getTaskId(),\n           taskInfo.getFinishTime(), taskInfo.getTaskType(),\n           taskInfo.getError(), taskInfo.getTaskStatus(),\n-          taskInfo.getFailedDueToAttemptId(), taskInfo.getCounters());\n+          taskInfo.getFailedDueToAttemptId(), taskInfo.getCounters(),\n+          launchTime);\n       eventHandler.handle(new JobHistoryEvent(taskId.getJobId(), tfe));\n       eventHandler.handle(\n           new JobTaskEvent(taskId, getExternalState(taskState)));\n       break;\n     }\n     default:\n       throw new java.lang.AssertionError(\"Unexpected recovered task state: \"\n           + taskState);\n     }\n \n     return taskState;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TaskStateInternal recover(TaskInfo taskInfo,\n      OutputCommitter committer, boolean recoverTaskOutput) {\n    LOG.info(\"Recovering task \" + taskId\n        + \" from prior app attempt, status was \" + taskInfo.getTaskStatus());\n\n    scheduledTime \u003d taskInfo.getStartTime();\n    sendTaskStartedEvent();\n    Collection\u003cTaskAttemptInfo\u003e attemptInfos \u003d\n        taskInfo.getAllTaskAttempts().values();\n\n    if (attemptInfos.size() \u003e 0) {\n      metrics.launchedTask(this);\n    }\n\n    // recover the attempts for this task in the order they finished\n    // so task attempt completion events are ordered properly\n    int savedNextAttemptNumber \u003d nextAttemptNumber;\n    ArrayList\u003cTaskAttemptInfo\u003e taInfos \u003d\n        new ArrayList\u003cTaskAttemptInfo\u003e(taskInfo.getAllTaskAttempts().values());\n    Collections.sort(taInfos, TA_INFO_COMPARATOR);\n    for (TaskAttemptInfo taInfo : taInfos) {\n      nextAttemptNumber \u003d taInfo.getAttemptId().getId();\n      TaskAttemptImpl attempt \u003d addAttempt(Avataar.VIRGIN);\n      // handle the recovery inline so attempts complete before task does\n      attempt.handle(new TaskAttemptRecoverEvent(attempt.getID(), taInfo,\n          committer, recoverTaskOutput));\n      finishedAttempts.add(attempt.getID());\n      TaskAttemptCompletionEventStatus taces \u003d null;\n      TaskAttemptState attemptState \u003d attempt.getState();\n      switch (attemptState) {\n      case FAILED:\n        taces \u003d TaskAttemptCompletionEventStatus.FAILED;\n        break;\n      case KILLED:\n        taces \u003d TaskAttemptCompletionEventStatus.KILLED;\n        break;\n      case SUCCEEDED:\n        taces \u003d TaskAttemptCompletionEventStatus.SUCCEEDED;\n        break;\n      default:\n        throw new IllegalStateException(\n            \"Unexpected attempt state during recovery: \" + attemptState);\n      }\n      if (attemptState \u003d\u003d TaskAttemptState.FAILED) {\n        failedAttempts.add(attempt.getID());\n        if (failedAttempts.size() \u003e\u003d maxAttempts) {\n          taces \u003d TaskAttemptCompletionEventStatus.TIPFAILED;\n        }\n      }\n\n      // don\u0027t clobber the successful attempt completion event\n      // TODO: this shouldn\u0027t be necessary after MAPREDUCE-4330\n      if (successfulAttempt \u003d\u003d null) {\n        handleTaskAttemptCompletion(attempt.getID(), taces);\n        if (attemptState \u003d\u003d TaskAttemptState.SUCCEEDED) {\n          successfulAttempt \u003d attempt.getID();\n        }\n      }\n    }\n    nextAttemptNumber \u003d savedNextAttemptNumber;\n\n    TaskStateInternal taskState \u003d TaskStateInternal.valueOf(\n        taskInfo.getTaskStatus());\n    switch (taskState) {\n    case SUCCEEDED:\n      if (successfulAttempt !\u003d null) {\n        sendTaskSucceededEvents();\n      } else {\n        LOG.info(\"Missing successful attempt for task \" + taskId\n            + \", recovering as RUNNING\");\n        // there must have been a fetch failure and the retry wasn\u0027t complete\n        taskState \u003d TaskStateInternal.RUNNING;\n        metrics.runningTask(this);\n        addAndScheduleAttempt(Avataar.VIRGIN);\n      }\n      break;\n    case FAILED:\n    case KILLED:\n    {\n      if (taskState \u003d\u003d TaskStateInternal.KILLED \u0026\u0026 attemptInfos.size() \u003d\u003d 0) {\n        metrics.endWaitingTask(this);\n      }\n      TaskFailedEvent tfe \u003d new TaskFailedEvent(taskInfo.getTaskId(),\n          taskInfo.getFinishTime(), taskInfo.getTaskType(),\n          taskInfo.getError(), taskInfo.getTaskStatus(),\n          taskInfo.getFailedDueToAttemptId(), taskInfo.getCounters(),\n          launchTime);\n      eventHandler.handle(new JobHistoryEvent(taskId.getJobId(), tfe));\n      eventHandler.handle(\n          new JobTaskEvent(taskId, getExternalState(taskState)));\n      break;\n    }\n    default:\n      throw new java.lang.AssertionError(\"Unexpected recovered task state: \"\n          + taskState);\n    }\n\n    return taskState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskImpl.java",
      "extendedDetails": {}
    },
    "6a1c41111edcdc58c846fc50e53554fbba230171": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5079. Changes job recovery to restore state directly from job history, instaed of simulating state machine events. Contributed by Jason Lowe and Robert Parker.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466767 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 9:52 PM",
      "commitName": "6a1c41111edcdc58c846fc50e53554fbba230171",
      "commitAuthor": "Siddharth Seth",
      "diff": "@@ -0,0 +1,98 @@\n+  private TaskStateInternal recover(TaskInfo taskInfo,\n+      OutputCommitter committer, boolean recoverTaskOutput) {\n+    LOG.info(\"Recovering task \" + taskId\n+        + \" from prior app attempt, status was \" + taskInfo.getTaskStatus());\n+\n+    scheduledTime \u003d taskInfo.getStartTime();\n+    sendTaskStartedEvent();\n+    Collection\u003cTaskAttemptInfo\u003e attemptInfos \u003d\n+        taskInfo.getAllTaskAttempts().values();\n+\n+    if (attemptInfos.size() \u003e 0) {\n+      metrics.launchedTask(this);\n+    }\n+\n+    // recover the attempts for this task in the order they finished\n+    // so task attempt completion events are ordered properly\n+    int savedNextAttemptNumber \u003d nextAttemptNumber;\n+    ArrayList\u003cTaskAttemptInfo\u003e taInfos \u003d\n+        new ArrayList\u003cTaskAttemptInfo\u003e(taskInfo.getAllTaskAttempts().values());\n+    Collections.sort(taInfos, TA_INFO_COMPARATOR);\n+    for (TaskAttemptInfo taInfo : taInfos) {\n+      nextAttemptNumber \u003d taInfo.getAttemptId().getId();\n+      TaskAttemptImpl attempt \u003d addAttempt(Avataar.VIRGIN);\n+      // handle the recovery inline so attempts complete before task does\n+      attempt.handle(new TaskAttemptRecoverEvent(attempt.getID(), taInfo,\n+          committer, recoverTaskOutput));\n+      finishedAttempts.add(attempt.getID());\n+      TaskAttemptCompletionEventStatus taces \u003d null;\n+      TaskAttemptState attemptState \u003d attempt.getState();\n+      switch (attemptState) {\n+      case FAILED:\n+        taces \u003d TaskAttemptCompletionEventStatus.FAILED;\n+        break;\n+      case KILLED:\n+        taces \u003d TaskAttemptCompletionEventStatus.KILLED;\n+        break;\n+      case SUCCEEDED:\n+        taces \u003d TaskAttemptCompletionEventStatus.SUCCEEDED;\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Unexpected attempt state during recovery: \" + attemptState);\n+      }\n+      if (attemptState \u003d\u003d TaskAttemptState.FAILED) {\n+        failedAttempts.add(attempt.getID());\n+        if (failedAttempts.size() \u003e\u003d maxAttempts) {\n+          taces \u003d TaskAttemptCompletionEventStatus.TIPFAILED;\n+        }\n+      }\n+\n+      // don\u0027t clobber the successful attempt completion event\n+      // TODO: this shouldn\u0027t be necessary after MAPREDUCE-4330\n+      if (successfulAttempt \u003d\u003d null) {\n+        handleTaskAttemptCompletion(attempt.getID(), taces);\n+        if (attemptState \u003d\u003d TaskAttemptState.SUCCEEDED) {\n+          successfulAttempt \u003d attempt.getID();\n+        }\n+      }\n+    }\n+    nextAttemptNumber \u003d savedNextAttemptNumber;\n+\n+    TaskStateInternal taskState \u003d TaskStateInternal.valueOf(\n+        taskInfo.getTaskStatus());\n+    switch (taskState) {\n+    case SUCCEEDED:\n+      if (successfulAttempt !\u003d null) {\n+        sendTaskSucceededEvents();\n+      } else {\n+        LOG.info(\"Missing successful attempt for task \" + taskId\n+            + \", recovering as RUNNING\");\n+        // there must have been a fetch failure and the retry wasn\u0027t complete\n+        taskState \u003d TaskStateInternal.RUNNING;\n+        metrics.runningTask(this);\n+        addAndScheduleAttempt(Avataar.VIRGIN);\n+      }\n+      break;\n+    case FAILED:\n+    case KILLED:\n+    {\n+      if (taskState \u003d\u003d TaskStateInternal.KILLED \u0026\u0026 attemptInfos.size() \u003d\u003d 0) {\n+        metrics.endWaitingTask(this);\n+      }\n+      TaskFailedEvent tfe \u003d new TaskFailedEvent(taskInfo.getTaskId(),\n+          taskInfo.getFinishTime(), taskInfo.getTaskType(),\n+          taskInfo.getError(), taskInfo.getTaskStatus(),\n+          taskInfo.getFailedDueToAttemptId(), taskInfo.getCounters());\n+      eventHandler.handle(new JobHistoryEvent(taskId.getJobId(), tfe));\n+      eventHandler.handle(\n+          new JobTaskEvent(taskId, getExternalState(taskState)));\n+      break;\n+    }\n+    default:\n+      throw new java.lang.AssertionError(\"Unexpected recovered task state: \"\n+          + taskState);\n+    }\n+\n+    return taskState;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private TaskStateInternal recover(TaskInfo taskInfo,\n      OutputCommitter committer, boolean recoverTaskOutput) {\n    LOG.info(\"Recovering task \" + taskId\n        + \" from prior app attempt, status was \" + taskInfo.getTaskStatus());\n\n    scheduledTime \u003d taskInfo.getStartTime();\n    sendTaskStartedEvent();\n    Collection\u003cTaskAttemptInfo\u003e attemptInfos \u003d\n        taskInfo.getAllTaskAttempts().values();\n\n    if (attemptInfos.size() \u003e 0) {\n      metrics.launchedTask(this);\n    }\n\n    // recover the attempts for this task in the order they finished\n    // so task attempt completion events are ordered properly\n    int savedNextAttemptNumber \u003d nextAttemptNumber;\n    ArrayList\u003cTaskAttemptInfo\u003e taInfos \u003d\n        new ArrayList\u003cTaskAttemptInfo\u003e(taskInfo.getAllTaskAttempts().values());\n    Collections.sort(taInfos, TA_INFO_COMPARATOR);\n    for (TaskAttemptInfo taInfo : taInfos) {\n      nextAttemptNumber \u003d taInfo.getAttemptId().getId();\n      TaskAttemptImpl attempt \u003d addAttempt(Avataar.VIRGIN);\n      // handle the recovery inline so attempts complete before task does\n      attempt.handle(new TaskAttemptRecoverEvent(attempt.getID(), taInfo,\n          committer, recoverTaskOutput));\n      finishedAttempts.add(attempt.getID());\n      TaskAttemptCompletionEventStatus taces \u003d null;\n      TaskAttemptState attemptState \u003d attempt.getState();\n      switch (attemptState) {\n      case FAILED:\n        taces \u003d TaskAttemptCompletionEventStatus.FAILED;\n        break;\n      case KILLED:\n        taces \u003d TaskAttemptCompletionEventStatus.KILLED;\n        break;\n      case SUCCEEDED:\n        taces \u003d TaskAttemptCompletionEventStatus.SUCCEEDED;\n        break;\n      default:\n        throw new IllegalStateException(\n            \"Unexpected attempt state during recovery: \" + attemptState);\n      }\n      if (attemptState \u003d\u003d TaskAttemptState.FAILED) {\n        failedAttempts.add(attempt.getID());\n        if (failedAttempts.size() \u003e\u003d maxAttempts) {\n          taces \u003d TaskAttemptCompletionEventStatus.TIPFAILED;\n        }\n      }\n\n      // don\u0027t clobber the successful attempt completion event\n      // TODO: this shouldn\u0027t be necessary after MAPREDUCE-4330\n      if (successfulAttempt \u003d\u003d null) {\n        handleTaskAttemptCompletion(attempt.getID(), taces);\n        if (attemptState \u003d\u003d TaskAttemptState.SUCCEEDED) {\n          successfulAttempt \u003d attempt.getID();\n        }\n      }\n    }\n    nextAttemptNumber \u003d savedNextAttemptNumber;\n\n    TaskStateInternal taskState \u003d TaskStateInternal.valueOf(\n        taskInfo.getTaskStatus());\n    switch (taskState) {\n    case SUCCEEDED:\n      if (successfulAttempt !\u003d null) {\n        sendTaskSucceededEvents();\n      } else {\n        LOG.info(\"Missing successful attempt for task \" + taskId\n            + \", recovering as RUNNING\");\n        // there must have been a fetch failure and the retry wasn\u0027t complete\n        taskState \u003d TaskStateInternal.RUNNING;\n        metrics.runningTask(this);\n        addAndScheduleAttempt(Avataar.VIRGIN);\n      }\n      break;\n    case FAILED:\n    case KILLED:\n    {\n      if (taskState \u003d\u003d TaskStateInternal.KILLED \u0026\u0026 attemptInfos.size() \u003d\u003d 0) {\n        metrics.endWaitingTask(this);\n      }\n      TaskFailedEvent tfe \u003d new TaskFailedEvent(taskInfo.getTaskId(),\n          taskInfo.getFinishTime(), taskInfo.getTaskType(),\n          taskInfo.getError(), taskInfo.getTaskStatus(),\n          taskInfo.getFailedDueToAttemptId(), taskInfo.getCounters());\n      eventHandler.handle(new JobHistoryEvent(taskId.getJobId(), tfe));\n      eventHandler.handle(\n          new JobTaskEvent(taskId, getExternalState(taskState)));\n      break;\n    }\n    default:\n      throw new java.lang.AssertionError(\"Unexpected recovered task state: \"\n          + taskState);\n    }\n\n    return taskState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskImpl.java"
    }
  }
}