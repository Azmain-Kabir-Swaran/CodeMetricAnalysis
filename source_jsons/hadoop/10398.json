{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataXceiver.java",
  "functionName": "requestShortCircuitShm",
  "functionId": "requestShortCircuitShm___clientName-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
  "functionStartLine": 495,
  "functionEndLine": 559,
  "numCommitsSeen": 151,
  "timeTaken": 4205,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "778146eaae5b1e17928a1f26fb1e46536a6ee510",
    "a0e0a63209b5eb17dca5cc503be36aa52defeabd",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
    "4551da302d94cffea0313eac79479ab6f9b7cb34",
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "778146eaae5b1e17928a1f26fb1e46536a6ee510": "Ybodychange",
    "a0e0a63209b5eb17dca5cc503be36aa52defeabd": "Ybodychange",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "4551da302d94cffea0313eac79479ab6f9b7cb34": "Ybodychange",
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f": "Ybodychange"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/11/17 1:41 AM",
      "commitNameOld": "56b88b06705441f6f171eec7fb2fa77946ca204b",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 105.32,
      "commitsBetweenForRepo": 696,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   public void requestShortCircuitShm(String clientName) throws IOException {\n     NewShmInfo shmInfo \u003d null;\n     boolean success \u003d false;\n     DomainSocket sock \u003d peer.getDomainSocket();\n     try {\n       if (sock \u003d\u003d null) {\n         sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n             peer + \": must request a shared \" +\n             \"memory segment over a UNIX domain socket.\");\n         return;\n       }\n       try {\n         shmInfo \u003d datanode.shortCircuitRegistry.\n             createNewMemorySegment(clientName, sock);\n         // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n         // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n         releaseSocket();\n       } catch (UnsupportedOperationException e) {\n         sendShmErrorResponse(ERROR_UNSUPPORTED, \n             \"This datanode has not been configured to support \" +\n             \"short-circuit shared memory segments.\");\n         return;\n       } catch (IOException e) {\n         sendShmErrorResponse(ERROR,\n             \"Failed to create shared file descriptor: \" + e.getMessage());\n         return;\n       }\n       sendShmSuccessResponse(sock, shmInfo);\n       success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         if (success) {\n           BlockSender.ClientTraceLog.info(String.format(\n               \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n               \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n               \" shmId: %016x%016x, srvID: %s, success: true\",\n               clientName, shmInfo.getShmId().getHi(),\n               shmInfo.getShmId().getLo(),\n               datanode.getDatanodeUuid()));\n         } else {\n           BlockSender.ClientTraceLog.info(String.format(\n               \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n               \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n               \"shmId: n/a, srvID: %s, success: false\",\n               clientName, datanode.getDatanodeUuid()));\n         }\n       }\n       if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n         // The socket is now managed by the DomainSocketWatcher.  However,\n         // we failed to pass it to the client.  We call shutdown() on the\n         // UNIX domain socket now.  This will trigger the DomainSocketWatcher\n         // callback.  The callback will close the domain socket.\n         // We don\u0027t want to close the socket here, since that might lead to\n         // bad behavior inside the poll() call.  See HADOOP-11802 for details.\n         try {\n-          LOG.warn(\"Failed to send success response back to the client.  \" +\n-              \"Shutting down socket for \" + shmInfo.getShmId() + \".\");\n+          LOG.warn(\"Failed to send success response back to the client. \" +\n+              \"Shutting down socket for {}\", shmInfo.getShmId());\n           sock.shutdown();\n         } catch (IOException e) {\n           LOG.warn(\"Failed to shut down socket in error handler\", e);\n         }\n       }\n       IOUtils.cleanup(null, shmInfo);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitShm(String clientName) throws IOException {\n    NewShmInfo shmInfo \u003d null;\n    boolean success \u003d false;\n    DomainSocket sock \u003d peer.getDomainSocket();\n    try {\n      if (sock \u003d\u003d null) {\n        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n            peer + \": must request a shared \" +\n            \"memory segment over a UNIX domain socket.\");\n        return;\n      }\n      try {\n        shmInfo \u003d datanode.shortCircuitRegistry.\n            createNewMemorySegment(clientName, sock);\n        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n        releaseSocket();\n      } catch (UnsupportedOperationException e) {\n        sendShmErrorResponse(ERROR_UNSUPPORTED, \n            \"This datanode has not been configured to support \" +\n            \"short-circuit shared memory segments.\");\n        return;\n      } catch (IOException e) {\n        sendShmErrorResponse(ERROR,\n            \"Failed to create shared file descriptor: \" + e.getMessage());\n        return;\n      }\n      sendShmSuccessResponse(sock, shmInfo);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        if (success) {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n              \" shmId: %016x%016x, srvID: %s, success: true\",\n              clientName, shmInfo.getShmId().getHi(),\n              shmInfo.getShmId().getLo(),\n              datanode.getDatanodeUuid()));\n        } else {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n              \"shmId: n/a, srvID: %s, success: false\",\n              clientName, datanode.getDatanodeUuid()));\n        }\n      }\n      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n        // The socket is now managed by the DomainSocketWatcher.  However,\n        // we failed to pass it to the client.  We call shutdown() on the\n        // UNIX domain socket now.  This will trigger the DomainSocketWatcher\n        // callback.  The callback will close the domain socket.\n        // We don\u0027t want to close the socket here, since that might lead to\n        // bad behavior inside the poll() call.  See HADOOP-11802 for details.\n        try {\n          LOG.warn(\"Failed to send success response back to the client. \" +\n              \"Shutting down socket for {}\", shmInfo.getShmId());\n          sock.shutdown();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to shut down socket in error handler\", e);\n        }\n      }\n      IOUtils.cleanup(null, shmInfo);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "778146eaae5b1e17928a1f26fb1e46536a6ee510": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12658. Clear javadoc and check style issues around DomainSocket. Contributed by Kai Zheng\n",
      "commitDate": "04/01/16 2:32 PM",
      "commitName": "778146eaae5b1e17928a1f26fb1e46536a6ee510",
      "commitAuthor": "Uma Mahesh",
      "commitDateOld": "17/12/15 2:04 PM",
      "commitNameOld": "03bab8dea163a9ee45d09d2a0483d45cf6fe57c9",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 18.02,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,65 @@\n   public void requestShortCircuitShm(String clientName) throws IOException {\n     NewShmInfo shmInfo \u003d null;\n     boolean success \u003d false;\n     DomainSocket sock \u003d peer.getDomainSocket();\n     try {\n       if (sock \u003d\u003d null) {\n         sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n             peer + \": must request a shared \" +\n             \"memory segment over a UNIX domain socket.\");\n         return;\n       }\n       try {\n         shmInfo \u003d datanode.shortCircuitRegistry.\n             createNewMemorySegment(clientName, sock);\n         // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n         // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n         releaseSocket();\n       } catch (UnsupportedOperationException e) {\n         sendShmErrorResponse(ERROR_UNSUPPORTED, \n             \"This datanode has not been configured to support \" +\n             \"short-circuit shared memory segments.\");\n         return;\n       } catch (IOException e) {\n         sendShmErrorResponse(ERROR,\n             \"Failed to create shared file descriptor: \" + e.getMessage());\n         return;\n       }\n       sendShmSuccessResponse(sock, shmInfo);\n       success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         if (success) {\n           BlockSender.ClientTraceLog.info(String.format(\n               \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n               \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n               \" shmId: %016x%016x, srvID: %s, success: true\",\n-              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n+              clientName, shmInfo.getShmId().getHi(),\n+              shmInfo.getShmId().getLo(),\n               datanode.getDatanodeUuid()));\n         } else {\n           BlockSender.ClientTraceLog.info(String.format(\n               \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n               \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n               \"shmId: n/a, srvID: %s, success: false\",\n               clientName, datanode.getDatanodeUuid()));\n         }\n       }\n       if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n         // The socket is now managed by the DomainSocketWatcher.  However,\n         // we failed to pass it to the client.  We call shutdown() on the\n         // UNIX domain socket now.  This will trigger the DomainSocketWatcher\n         // callback.  The callback will close the domain socket.\n         // We don\u0027t want to close the socket here, since that might lead to\n         // bad behavior inside the poll() call.  See HADOOP-11802 for details.\n         try {\n           LOG.warn(\"Failed to send success response back to the client.  \" +\n-              \"Shutting down socket for \" + shmInfo.shmId + \".\");\n+              \"Shutting down socket for \" + shmInfo.getShmId() + \".\");\n           sock.shutdown();\n         } catch (IOException e) {\n           LOG.warn(\"Failed to shut down socket in error handler\", e);\n         }\n       }\n       IOUtils.cleanup(null, shmInfo);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitShm(String clientName) throws IOException {\n    NewShmInfo shmInfo \u003d null;\n    boolean success \u003d false;\n    DomainSocket sock \u003d peer.getDomainSocket();\n    try {\n      if (sock \u003d\u003d null) {\n        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n            peer + \": must request a shared \" +\n            \"memory segment over a UNIX domain socket.\");\n        return;\n      }\n      try {\n        shmInfo \u003d datanode.shortCircuitRegistry.\n            createNewMemorySegment(clientName, sock);\n        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n        releaseSocket();\n      } catch (UnsupportedOperationException e) {\n        sendShmErrorResponse(ERROR_UNSUPPORTED, \n            \"This datanode has not been configured to support \" +\n            \"short-circuit shared memory segments.\");\n        return;\n      } catch (IOException e) {\n        sendShmErrorResponse(ERROR,\n            \"Failed to create shared file descriptor: \" + e.getMessage());\n        return;\n      }\n      sendShmSuccessResponse(sock, shmInfo);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        if (success) {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n              \" shmId: %016x%016x, srvID: %s, success: true\",\n              clientName, shmInfo.getShmId().getHi(),\n              shmInfo.getShmId().getLo(),\n              datanode.getDatanodeUuid()));\n        } else {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n              \"shmId: n/a, srvID: %s, success: false\",\n              clientName, datanode.getDatanodeUuid()));\n        }\n      }\n      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n        // The socket is now managed by the DomainSocketWatcher.  However,\n        // we failed to pass it to the client.  We call shutdown() on the\n        // UNIX domain socket now.  This will trigger the DomainSocketWatcher\n        // callback.  The callback will close the domain socket.\n        // We don\u0027t want to close the socket here, since that might lead to\n        // bad behavior inside the poll() call.  See HADOOP-11802 for details.\n        try {\n          LOG.warn(\"Failed to send success response back to the client.  \" +\n              \"Shutting down socket for \" + shmInfo.getShmId() + \".\");\n          sock.shutdown();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to shut down socket in error handler\", e);\n        }\n      }\n      IOUtils.cleanup(null, shmInfo);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a0e0a63209b5eb17dca5cc503be36aa52defeabd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11802. DomainSocketWatcher thread terminates sometimes after there is an I/O error during requestShortCircuitShm (cmccabe)\n",
      "commitDate": "23/04/15 7:00 PM",
      "commitName": "a0e0a63209b5eb17dca5cc503be36aa52defeabd",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "10/04/15 4:36 PM",
      "commitNameOld": "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 13.1,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,64 @@\n   public void requestShortCircuitShm(String clientName) throws IOException {\n     NewShmInfo shmInfo \u003d null;\n     boolean success \u003d false;\n     DomainSocket sock \u003d peer.getDomainSocket();\n     try {\n       if (sock \u003d\u003d null) {\n         sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n             peer + \": must request a shared \" +\n             \"memory segment over a UNIX domain socket.\");\n         return;\n       }\n       try {\n         shmInfo \u003d datanode.shortCircuitRegistry.\n             createNewMemorySegment(clientName, sock);\n         // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n         // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n         releaseSocket();\n       } catch (UnsupportedOperationException e) {\n         sendShmErrorResponse(ERROR_UNSUPPORTED, \n             \"This datanode has not been configured to support \" +\n             \"short-circuit shared memory segments.\");\n         return;\n       } catch (IOException e) {\n         sendShmErrorResponse(ERROR,\n             \"Failed to create shared file descriptor: \" + e.getMessage());\n         return;\n       }\n       sendShmSuccessResponse(sock, shmInfo);\n       success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         if (success) {\n           BlockSender.ClientTraceLog.info(String.format(\n               \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n               \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n               \" shmId: %016x%016x, srvID: %s, success: true\",\n               clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n               datanode.getDatanodeUuid()));\n         } else {\n           BlockSender.ClientTraceLog.info(String.format(\n               \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n               \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n               \"shmId: n/a, srvID: %s, success: false\",\n               clientName, datanode.getDatanodeUuid()));\n         }\n       }\n       if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n-        // If we failed to pass the shared memory segment to the client,\n-        // close the UNIX domain socket now.  This will trigger the \n-        // DomainSocketWatcher callback, cleaning up the segment.\n-        IOUtils.cleanup(null, sock);\n+        // The socket is now managed by the DomainSocketWatcher.  However,\n+        // we failed to pass it to the client.  We call shutdown() on the\n+        // UNIX domain socket now.  This will trigger the DomainSocketWatcher\n+        // callback.  The callback will close the domain socket.\n+        // We don\u0027t want to close the socket here, since that might lead to\n+        // bad behavior inside the poll() call.  See HADOOP-11802 for details.\n+        try {\n+          LOG.warn(\"Failed to send success response back to the client.  \" +\n+              \"Shutting down socket for \" + shmInfo.shmId + \".\");\n+          sock.shutdown();\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to shut down socket in error handler\", e);\n+        }\n       }\n       IOUtils.cleanup(null, shmInfo);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitShm(String clientName) throws IOException {\n    NewShmInfo shmInfo \u003d null;\n    boolean success \u003d false;\n    DomainSocket sock \u003d peer.getDomainSocket();\n    try {\n      if (sock \u003d\u003d null) {\n        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n            peer + \": must request a shared \" +\n            \"memory segment over a UNIX domain socket.\");\n        return;\n      }\n      try {\n        shmInfo \u003d datanode.shortCircuitRegistry.\n            createNewMemorySegment(clientName, sock);\n        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n        releaseSocket();\n      } catch (UnsupportedOperationException e) {\n        sendShmErrorResponse(ERROR_UNSUPPORTED, \n            \"This datanode has not been configured to support \" +\n            \"short-circuit shared memory segments.\");\n        return;\n      } catch (IOException e) {\n        sendShmErrorResponse(ERROR,\n            \"Failed to create shared file descriptor: \" + e.getMessage());\n        return;\n      }\n      sendShmSuccessResponse(sock, shmInfo);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        if (success) {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n              \" shmId: %016x%016x, srvID: %s, success: true\",\n              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n              datanode.getDatanodeUuid()));\n        } else {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n              \"shmId: n/a, srvID: %s, success: false\",\n              clientName, datanode.getDatanodeUuid()));\n        }\n      }\n      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n        // The socket is now managed by the DomainSocketWatcher.  However,\n        // we failed to pass it to the client.  We call shutdown() on the\n        // UNIX domain socket now.  This will trigger the DomainSocketWatcher\n        // callback.  The callback will close the domain socket.\n        // We don\u0027t want to close the socket here, since that might lead to\n        // bad behavior inside the poll() call.  See HADOOP-11802 for details.\n        try {\n          LOG.warn(\"Failed to send success response back to the client.  \" +\n              \"Shutting down socket for \" + shmInfo.shmId + \".\");\n          sock.shutdown();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to shut down socket in error handler\", e);\n        }\n      }\n      IOUtils.cleanup(null, shmInfo);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/14 7:58 PM",
      "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public void requestShortCircuitFds(final ExtendedBlock blk,\n-      final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n-    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n-    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n-    FileInputStream fis[] \u003d null;\n+  public void requestShortCircuitShm(String clientName) throws IOException {\n+    NewShmInfo shmInfo \u003d null;\n+    boolean success \u003d false;\n+    DomainSocket sock \u003d peer.getDomainSocket();\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n+      if (sock \u003d\u003d null) {\n+        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n+            peer + \": must request a shared \" +\n+            \"memory segment over a UNIX domain socket.\");\n+        return;\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n-      bld.build().writeDelimitedTo(socketOut);\n-      if (fis !\u003d null) {\n-        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n-        for (int i \u003d 0; i \u003c fds.length; i++) {\n-          fds[i] \u003d fis[i].getFD();\n-        }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n+      try {\n+        shmInfo \u003d datanode.shortCircuitRegistry.\n+            createNewMemorySegment(clientName, sock);\n+        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n+        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n+        releaseSocket();\n+      } catch (UnsupportedOperationException e) {\n+        sendShmErrorResponse(ERROR_UNSUPPORTED, \n+            \"This datanode has not been configured to support \" +\n+            \"short-circuit shared memory segments.\");\n+        return;\n+      } catch (IOException e) {\n+        sendShmErrorResponse(ERROR,\n+            \"Failed to create shared file descriptor: \" + e.getMessage());\n+        return;\n       }\n+      sendShmSuccessResponse(sock, shmInfo);\n+      success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n-        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n-            .getBlockPoolId());\n-        BlockSender.ClientTraceLog.info(String.format(\n-            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n-            \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n+        if (success) {\n+          BlockSender.ClientTraceLog.info(String.format(\n+              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n+              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n+              \" shmId: %016x%016x, srvID: %s, success: true\",\n+              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n+              datanode.getDatanodeUuid()));\n+        } else {\n+          BlockSender.ClientTraceLog.info(String.format(\n+              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n+              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n+              \"shmId: n/a, srvID: %s, success: false\",\n+              clientName, datanode.getDatanodeUuid()));\n+        }\n       }\n-      if (fis !\u003d null) {\n-        IOUtils.cleanup(LOG, fis);\n+      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n+        // If we failed to pass the shared memory segment to the client,\n+        // close the UNIX domain socket now.  This will trigger the \n+        // DomainSocketWatcher callback, cleaning up the segment.\n+        IOUtils.cleanup(null, sock);\n       }\n+      IOUtils.cleanup(null, shmInfo);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitShm(String clientName) throws IOException {\n    NewShmInfo shmInfo \u003d null;\n    boolean success \u003d false;\n    DomainSocket sock \u003d peer.getDomainSocket();\n    try {\n      if (sock \u003d\u003d null) {\n        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n            peer + \": must request a shared \" +\n            \"memory segment over a UNIX domain socket.\");\n        return;\n      }\n      try {\n        shmInfo \u003d datanode.shortCircuitRegistry.\n            createNewMemorySegment(clientName, sock);\n        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n        releaseSocket();\n      } catch (UnsupportedOperationException e) {\n        sendShmErrorResponse(ERROR_UNSUPPORTED, \n            \"This datanode has not been configured to support \" +\n            \"short-circuit shared memory segments.\");\n        return;\n      } catch (IOException e) {\n        sendShmErrorResponse(ERROR,\n            \"Failed to create shared file descriptor: \" + e.getMessage());\n        return;\n      }\n      sendShmSuccessResponse(sock, shmInfo);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        if (success) {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n              \" shmId: %016x%016x, srvID: %s, success: true\",\n              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n              datanode.getDatanodeUuid()));\n        } else {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n              \"shmId: n/a, srvID: %s, success: false\",\n              clientName, datanode.getDatanodeUuid()));\n        }\n      }\n      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n        // If we failed to pass the shared memory segment to the client,\n        // close the UNIX domain socket now.  This will trigger the \n        // DomainSocketWatcher callback, cleaning up the segment.\n        IOUtils.cleanup(null, sock);\n      }\n      IOUtils.cleanup(null, shmInfo);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "requestShortCircuitFds",
            "newValue": "requestShortCircuitShm"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public void requestShortCircuitFds(final ExtendedBlock blk,\n-      final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n-    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n-    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n-    FileInputStream fis[] \u003d null;\n+  public void requestShortCircuitShm(String clientName) throws IOException {\n+    NewShmInfo shmInfo \u003d null;\n+    boolean success \u003d false;\n+    DomainSocket sock \u003d peer.getDomainSocket();\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n+      if (sock \u003d\u003d null) {\n+        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n+            peer + \": must request a shared \" +\n+            \"memory segment over a UNIX domain socket.\");\n+        return;\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n-      bld.build().writeDelimitedTo(socketOut);\n-      if (fis !\u003d null) {\n-        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n-        for (int i \u003d 0; i \u003c fds.length; i++) {\n-          fds[i] \u003d fis[i].getFD();\n-        }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n+      try {\n+        shmInfo \u003d datanode.shortCircuitRegistry.\n+            createNewMemorySegment(clientName, sock);\n+        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n+        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n+        releaseSocket();\n+      } catch (UnsupportedOperationException e) {\n+        sendShmErrorResponse(ERROR_UNSUPPORTED, \n+            \"This datanode has not been configured to support \" +\n+            \"short-circuit shared memory segments.\");\n+        return;\n+      } catch (IOException e) {\n+        sendShmErrorResponse(ERROR,\n+            \"Failed to create shared file descriptor: \" + e.getMessage());\n+        return;\n       }\n+      sendShmSuccessResponse(sock, shmInfo);\n+      success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n-        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n-            .getBlockPoolId());\n-        BlockSender.ClientTraceLog.info(String.format(\n-            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n-            \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n+        if (success) {\n+          BlockSender.ClientTraceLog.info(String.format(\n+              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n+              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n+              \" shmId: %016x%016x, srvID: %s, success: true\",\n+              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n+              datanode.getDatanodeUuid()));\n+        } else {\n+          BlockSender.ClientTraceLog.info(String.format(\n+              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n+              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n+              \"shmId: n/a, srvID: %s, success: false\",\n+              clientName, datanode.getDatanodeUuid()));\n+        }\n       }\n-      if (fis !\u003d null) {\n-        IOUtils.cleanup(LOG, fis);\n+      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n+        // If we failed to pass the shared memory segment to the client,\n+        // close the UNIX domain socket now.  This will trigger the \n+        // DomainSocketWatcher callback, cleaning up the segment.\n+        IOUtils.cleanup(null, sock);\n       }\n+      IOUtils.cleanup(null, shmInfo);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitShm(String clientName) throws IOException {\n    NewShmInfo shmInfo \u003d null;\n    boolean success \u003d false;\n    DomainSocket sock \u003d peer.getDomainSocket();\n    try {\n      if (sock \u003d\u003d null) {\n        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n            peer + \": must request a shared \" +\n            \"memory segment over a UNIX domain socket.\");\n        return;\n      }\n      try {\n        shmInfo \u003d datanode.shortCircuitRegistry.\n            createNewMemorySegment(clientName, sock);\n        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n        releaseSocket();\n      } catch (UnsupportedOperationException e) {\n        sendShmErrorResponse(ERROR_UNSUPPORTED, \n            \"This datanode has not been configured to support \" +\n            \"short-circuit shared memory segments.\");\n        return;\n      } catch (IOException e) {\n        sendShmErrorResponse(ERROR,\n            \"Failed to create shared file descriptor: \" + e.getMessage());\n        return;\n      }\n      sendShmSuccessResponse(sock, shmInfo);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        if (success) {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n              \" shmId: %016x%016x, srvID: %s, success: true\",\n              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n              datanode.getDatanodeUuid()));\n        } else {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n              \"shmId: n/a, srvID: %s, success: false\",\n              clientName, datanode.getDatanodeUuid()));\n        }\n      }\n      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n        // If we failed to pass the shared memory segment to the client,\n        // close the UNIX domain socket now.  This will trigger the \n        // DomainSocketWatcher callback, cleaning up the segment.\n        IOUtils.cleanup(null, sock);\n      }\n      IOUtils.cleanup(null, shmInfo);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), maxVersion-int]",
            "newValue": "[clientName-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public void requestShortCircuitFds(final ExtendedBlock blk,\n-      final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n-    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n-    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n-    FileInputStream fis[] \u003d null;\n+  public void requestShortCircuitShm(String clientName) throws IOException {\n+    NewShmInfo shmInfo \u003d null;\n+    boolean success \u003d false;\n+    DomainSocket sock \u003d peer.getDomainSocket();\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n+      if (sock \u003d\u003d null) {\n+        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n+            peer + \": must request a shared \" +\n+            \"memory segment over a UNIX domain socket.\");\n+        return;\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n-      bld.build().writeDelimitedTo(socketOut);\n-      if (fis !\u003d null) {\n-        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n-        for (int i \u003d 0; i \u003c fds.length; i++) {\n-          fds[i] \u003d fis[i].getFD();\n-        }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n+      try {\n+        shmInfo \u003d datanode.shortCircuitRegistry.\n+            createNewMemorySegment(clientName, sock);\n+        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n+        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n+        releaseSocket();\n+      } catch (UnsupportedOperationException e) {\n+        sendShmErrorResponse(ERROR_UNSUPPORTED, \n+            \"This datanode has not been configured to support \" +\n+            \"short-circuit shared memory segments.\");\n+        return;\n+      } catch (IOException e) {\n+        sendShmErrorResponse(ERROR,\n+            \"Failed to create shared file descriptor: \" + e.getMessage());\n+        return;\n       }\n+      sendShmSuccessResponse(sock, shmInfo);\n+      success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n-        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n-            .getBlockPoolId());\n-        BlockSender.ClientTraceLog.info(String.format(\n-            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n-            \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n+        if (success) {\n+          BlockSender.ClientTraceLog.info(String.format(\n+              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n+              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n+              \" shmId: %016x%016x, srvID: %s, success: true\",\n+              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n+              datanode.getDatanodeUuid()));\n+        } else {\n+          BlockSender.ClientTraceLog.info(String.format(\n+              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n+              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n+              \"shmId: n/a, srvID: %s, success: false\",\n+              clientName, datanode.getDatanodeUuid()));\n+        }\n       }\n-      if (fis !\u003d null) {\n-        IOUtils.cleanup(LOG, fis);\n+      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n+        // If we failed to pass the shared memory segment to the client,\n+        // close the UNIX domain socket now.  This will trigger the \n+        // DomainSocketWatcher callback, cleaning up the segment.\n+        IOUtils.cleanup(null, sock);\n       }\n+      IOUtils.cleanup(null, shmInfo);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitShm(String clientName) throws IOException {\n    NewShmInfo shmInfo \u003d null;\n    boolean success \u003d false;\n    DomainSocket sock \u003d peer.getDomainSocket();\n    try {\n      if (sock \u003d\u003d null) {\n        sendShmErrorResponse(ERROR_INVALID, \"Bad request from \" +\n            peer + \": must request a shared \" +\n            \"memory segment over a UNIX domain socket.\");\n        return;\n      }\n      try {\n        shmInfo \u003d datanode.shortCircuitRegistry.\n            createNewMemorySegment(clientName, sock);\n        // After calling #{ShortCircuitRegistry#createNewMemorySegment}, the\n        // socket is managed by the DomainSocketWatcher, not the DataXceiver.\n        releaseSocket();\n      } catch (UnsupportedOperationException e) {\n        sendShmErrorResponse(ERROR_UNSUPPORTED, \n            \"This datanode has not been configured to support \" +\n            \"short-circuit shared memory segments.\");\n        return;\n      } catch (IOException e) {\n        sendShmErrorResponse(ERROR,\n            \"Failed to create shared file descriptor: \" + e.getMessage());\n        return;\n      }\n      sendShmSuccessResponse(sock, shmInfo);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        if (success) {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM,\" +\n              \" shmId: %016x%016x, srvID: %s, success: true\",\n              clientName, shmInfo.shmId.getHi(), shmInfo.shmId.getLo(),\n              datanode.getDatanodeUuid()));\n        } else {\n          BlockSender.ClientTraceLog.info(String.format(\n              \"cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, \" +\n              \"op: REQUEST_SHORT_CIRCUIT_SHM, \" +\n              \"shmId: n/a, srvID: %s, success: false\",\n              clientName, datanode.getDatanodeUuid()));\n        }\n      }\n      if ((!success) \u0026\u0026 (peer \u003d\u003d null)) {\n        // If we failed to pass the shared memory segment to the client,\n        // close the UNIX domain socket now.  This will trigger the \n        // DomainSocketWatcher callback, cleaning up the segment.\n        IOUtils.cleanup(null, sock);\n      }\n      IOUtils.cleanup(null, shmInfo);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "4551da302d94cffea0313eac79479ab6f9b7cb34": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5233. Use Datanode UUID to identify Datanodes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1525407 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/09/13 11:03 AM",
      "commitName": "4551da302d94cffea0313eac79479ab6f9b7cb34",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/07/13 11:15 AM",
      "commitNameOld": "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 61.99,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n       fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n+            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n           ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4661. A few little code cleanups of some HDFS-347-related code. Contributed by Colin Patrick McCabe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480839 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 5:03 PM",
      "commitName": "a18fd620d070cf8e84aaf80d93807ac9ee207a0f",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "23/01/13 10:38 AM",
      "commitNameOld": "d12f465c674b3bb5102671b6d6c2746261602d7e",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 106.23,
      "commitsBetweenForRepo": 615,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,54 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n       fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n-          String.format(\n-            \"src: %s, dest: %s, op: %s, blockid: %s, srvID: %s, \" +\n-              \"success: %b\",\n-            \"127.0.0.1\",                   // src IP\n-            \"127.0.0.1\",                   // dst IP\n-            \"REQUEST_SHORT_CIRCUIT_FDS\",   // operation\n-            blk.getBlockId(),             // block id\n-            dnR.getStorageID(),\n-            (fis !\u003d null)\n-          )));\n+            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n+            \" blockid: %s, srvID: %s, success: %b\",\n+            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n+          ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    }
  }
}