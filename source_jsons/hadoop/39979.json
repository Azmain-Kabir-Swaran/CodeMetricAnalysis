{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacitySchedulerQueueManager.java",
  "functionName": "parseQueue",
  "functionId": "parseQueue___csContext-CapacitySchedulerContext__conf-CapacitySchedulerConfiguration__parent-CSQueue__queueName-String__queues-CSQueueStore__oldQueues-CSQueueStore__hook-QueueHook",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
  "functionStartLine": 217,
  "functionEndLine": 301,
  "numCommitsSeen": 222,
  "timeTaken": 14913,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
    "4d4ad0ebb76198c90c5317f19ce85a6696132c8f",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
    "6da6d87872de518bb2583f65c9595f2090c855d7",
    "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
    "eb3e40b833b9d82c1556843f960194dc42e482f3",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "ec87e163d418b3fc3d9456e844143d6c61c80a48",
    "1f46b991da9b91585608a0babd3eda39485dce09",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ymultichange(Yparameterchange,Ybodychange)",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ybodychange",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Ybodychange",
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9": "Ybodychange",
    "4d4ad0ebb76198c90c5317f19ce85a6696132c8f": "Ybodychange",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": "Ymultichange(Ymovefromfile,Ybodychange)",
    "6da6d87872de518bb2583f65c9595f2090c855d7": "Ybodychange",
    "5e10a13bb4759984494c6a870c7f08fb6693c9c0": "Ybodychange",
    "eb3e40b833b9d82c1556843f960194dc42e482f3": "Ybodychange",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ymultichange(Yparameterchange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Yparameterchange",
    "ec87e163d418b3fc3d9456e844143d6c61c80a48": "Ymultichange(Yexceptionschange,Ybodychange)",
    "1f46b991da9b91585608a0babd3eda39485dce09": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
          "commitDate": "25/03/20 4:20 AM",
          "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
          "commitAuthor": "Sunil G",
          "commitDateOld": "28/01/20 9:46 AM",
          "commitNameOld": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
          "commitAuthorOld": "Prabhu Joseph",
          "daysBetweenCommits": 56.73,
          "commitsBetweenForRepo": 185,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,85 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n-      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n-      Map\u003cString, CSQueue\u003e oldQueues,\n+      CSQueue parent, String queueName,\n+      CSQueueStore queues,\n+      CSQueueStore oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d (parent \u003d\u003d null) ?\n         queueName :\n         (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n         fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d new PlanQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n \n         //initializing the \"internal\" default queue, for SLS compatibility\n         String defReservationId \u003d\n             queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n \n         List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n         ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n             defReservationId, (PlanQueue) queue);\n         try {\n           resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n         } catch (SchedulerDynamicEditException e) {\n           throw new IllegalStateException(e);\n         }\n         childQueues.add(resQueue);\n         ((PlanQueue) queue).setChildQueues(childQueues);\n-        queues.put(defReservationId, resQueue);\n+        queues.add(resQueue);\n \n       } else if (isAutoCreateEnabled) {\n         queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n \n       } else{\n         queue \u003d new LeafQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else{\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n-            \"Only Leaf Queues can be reservable for \" + queueName);\n+            \"Only Leaf Queues can be reservable for \" + fullQueueName);\n       }\n \n       ParentQueue parentQueue;\n       if (isAutoCreateEnabled) {\n         parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n       } else{\n         parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n       }\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n             queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n \n     }\n \n-    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName) \u0026\u0026 queues\n-        .get(queueName) instanceof LeafQueue) {\n-      throw new IOException(\"Two leaf queues were named \" + queueName\n-          + \". Leaf queue names must be distinct\");\n-    }\n-    queues.put(queueName, queue);\n+    queues.add(queue);\n \n-    LOG.info(\"Initialized queue: \" + queue);\n+    LOG.info(\"Initialized queue: \" + fullQueueName);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName,\n      CSQueueStore queues,\n      CSQueueStore oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d (parent \u003d\u003d null) ?\n        queueName :\n        (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n        fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d new PlanQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n\n        //initializing the \"internal\" default queue, for SLS compatibility\n        String defReservationId \u003d\n            queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n\n        List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n        ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n            defReservationId, (PlanQueue) queue);\n        try {\n          resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n        } catch (SchedulerDynamicEditException e) {\n          throw new IllegalStateException(e);\n        }\n        childQueues.add(resQueue);\n        ((PlanQueue) queue).setChildQueues(childQueues);\n        queues.add(resQueue);\n\n      } else if (isAutoCreateEnabled) {\n        queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n\n      } else{\n        queue \u003d new LeafQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else{\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + fullQueueName);\n      }\n\n      ParentQueue parentQueue;\n      if (isAutoCreateEnabled) {\n        parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n      } else{\n        parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n      }\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n            queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n\n    }\n\n    queues.add(queue);\n\n    LOG.info(\"Initialized queue: \" + fullQueueName);\n    return queue;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {
            "oldValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-CSQueue, queueName-String, queues-Map\u003cString,CSQueue\u003e, oldQueues-Map\u003cString,CSQueue\u003e, hook-QueueHook]",
            "newValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-CSQueue, queueName-String, queues-CSQueueStore, oldQueues-CSQueueStore, hook-QueueHook]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
          "commitDate": "25/03/20 4:20 AM",
          "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
          "commitAuthor": "Sunil G",
          "commitDateOld": "28/01/20 9:46 AM",
          "commitNameOld": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
          "commitAuthorOld": "Prabhu Joseph",
          "daysBetweenCommits": 56.73,
          "commitsBetweenForRepo": 185,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,85 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n-      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n-      Map\u003cString, CSQueue\u003e oldQueues,\n+      CSQueue parent, String queueName,\n+      CSQueueStore queues,\n+      CSQueueStore oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d (parent \u003d\u003d null) ?\n         queueName :\n         (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n         fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d new PlanQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n \n         //initializing the \"internal\" default queue, for SLS compatibility\n         String defReservationId \u003d\n             queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n \n         List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n         ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n             defReservationId, (PlanQueue) queue);\n         try {\n           resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n         } catch (SchedulerDynamicEditException e) {\n           throw new IllegalStateException(e);\n         }\n         childQueues.add(resQueue);\n         ((PlanQueue) queue).setChildQueues(childQueues);\n-        queues.put(defReservationId, resQueue);\n+        queues.add(resQueue);\n \n       } else if (isAutoCreateEnabled) {\n         queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n \n       } else{\n         queue \u003d new LeafQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else{\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n-            \"Only Leaf Queues can be reservable for \" + queueName);\n+            \"Only Leaf Queues can be reservable for \" + fullQueueName);\n       }\n \n       ParentQueue parentQueue;\n       if (isAutoCreateEnabled) {\n         parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n       } else{\n         parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n-            oldQueues.get(queueName));\n+            oldQueues.get(fullQueueName));\n       }\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n             queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n \n     }\n \n-    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName) \u0026\u0026 queues\n-        .get(queueName) instanceof LeafQueue) {\n-      throw new IOException(\"Two leaf queues were named \" + queueName\n-          + \". Leaf queue names must be distinct\");\n-    }\n-    queues.put(queueName, queue);\n+    queues.add(queue);\n \n-    LOG.info(\"Initialized queue: \" + queue);\n+    LOG.info(\"Initialized queue: \" + fullQueueName);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName,\n      CSQueueStore queues,\n      CSQueueStore oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d (parent \u003d\u003d null) ?\n        queueName :\n        (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n        fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d new PlanQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n\n        //initializing the \"internal\" default queue, for SLS compatibility\n        String defReservationId \u003d\n            queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n\n        List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n        ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n            defReservationId, (PlanQueue) queue);\n        try {\n          resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n        } catch (SchedulerDynamicEditException e) {\n          throw new IllegalStateException(e);\n        }\n        childQueues.add(resQueue);\n        ((PlanQueue) queue).setChildQueues(childQueues);\n        queues.add(resQueue);\n\n      } else if (isAutoCreateEnabled) {\n        queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n\n      } else{\n        queue \u003d new LeafQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else{\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + fullQueueName);\n      }\n\n      ParentQueue parentQueue;\n      if (isAutoCreateEnabled) {\n        parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n      } else{\n        parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n            oldQueues.get(fullQueueName));\n      }\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n            queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n\n    }\n\n    queues.add(queue);\n\n    LOG.info(\"Initialized queue: \" + fullQueueName);\n    return queue;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/11/17 11:25 AM",
      "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 22.16,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,89 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d (parent \u003d\u003d null) ?\n         queueName :\n         (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n         fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d new PlanQueue(csContext, queueName, parent,\n             oldQueues.get(queueName));\n \n         //initializing the \"internal\" default queue, for SLS compatibility\n         String defReservationId \u003d\n             queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n \n         List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n-        AutoCreatedLeafQueue resQueue \u003d new AutoCreatedLeafQueue(csContext,\n+        ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n             defReservationId, (PlanQueue) queue);\n         try {\n           resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n         } catch (SchedulerDynamicEditException e) {\n           throw new IllegalStateException(e);\n         }\n         childQueues.add(resQueue);\n         ((PlanQueue) queue).setChildQueues(childQueues);\n         queues.put(defReservationId, resQueue);\n \n       } else if (isAutoCreateEnabled) {\n         queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n             oldQueues.get(queueName));\n \n       } else{\n         queue \u003d new LeafQueue(csContext, queueName, parent,\n             oldQueues.get(queueName));\n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else{\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n \n       ParentQueue parentQueue;\n       if (isAutoCreateEnabled) {\n         parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n             oldQueues.get(queueName));\n       } else{\n         parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n             oldQueues.get(queueName));\n       }\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n             queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n \n     }\n \n     if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName) \u0026\u0026 queues\n         .get(queueName) instanceof LeafQueue) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n           + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d (parent \u003d\u003d null) ?\n        queueName :\n        (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n        fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d new PlanQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n\n        //initializing the \"internal\" default queue, for SLS compatibility\n        String defReservationId \u003d\n            queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n\n        List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n        ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n            defReservationId, (PlanQueue) queue);\n        try {\n          resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n        } catch (SchedulerDynamicEditException e) {\n          throw new IllegalStateException(e);\n        }\n        childQueues.add(resQueue);\n        ((PlanQueue) queue).setChildQueues(childQueues);\n        queues.put(defReservationId, resQueue);\n\n      } else if (isAutoCreateEnabled) {\n        queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n\n      } else{\n        queue \u003d new LeafQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else{\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n\n      ParentQueue parentQueue;\n      if (isAutoCreateEnabled) {\n        parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n      } else{\n        parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n      }\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n            queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n\n    }\n\n    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName) \u0026\u0026 queues\n        .get(queueName) instanceof LeafQueue) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n          + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "06/11/17 9:38 PM",
      "commitNameOld": "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.57,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,89 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n-    String fullQueueName \u003d\n-        (parent \u003d\u003d null) ? queueName\n-            : (parent.getQueuePath() + \".\" + queueName);\n+    String fullQueueName \u003d (parent \u003d\u003d null) ?\n+        queueName :\n+        (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n+    boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n+        fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n-        queue \u003d\n-            new PlanQueue(csContext, queueName, parent,\n-                oldQueues.get(queueName));\n+        queue \u003d new PlanQueue(csContext, queueName, parent,\n+            oldQueues.get(queueName));\n \n         //initializing the \"internal\" default queue, for SLS compatibility\n         String defReservationId \u003d\n             queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n \n         List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n         AutoCreatedLeafQueue resQueue \u003d new AutoCreatedLeafQueue(csContext,\n             defReservationId, (PlanQueue) queue);\n         try {\n           resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n         } catch (SchedulerDynamicEditException e) {\n           throw new IllegalStateException(e);\n         }\n         childQueues.add(resQueue);\n         ((PlanQueue) queue).setChildQueues(childQueues);\n         queues.put(defReservationId, resQueue);\n \n-      } else {\n-        queue \u003d\n-            new LeafQueue(csContext, queueName, parent,\n-                oldQueues.get(queueName));\n+      } else if (isAutoCreateEnabled) {\n+        queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n+            oldQueues.get(queueName));\n \n+      } else{\n+        queue \u003d new LeafQueue(csContext, queueName, parent,\n+            oldQueues.get(queueName));\n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n-    } else {\n+    } else{\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n-      ParentQueue parentQueue \u003d\n-          new ParentQueue(csContext, queueName, parent,\n-              oldQueues.get(queueName));\n+\n+      ParentQueue parentQueue;\n+      if (isAutoCreateEnabled) {\n+        parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n+            oldQueues.get(queueName));\n+      } else{\n+        parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n+            oldQueues.get(queueName));\n+      }\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n-        CSQueue childQueue \u003d\n-            parseQueue(csContext, conf, queue, childQueueName,\n-              queues, oldQueues, hook);\n+        CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n+            queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n+\n     }\n \n-    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n-        \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n+    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName) \u0026\u0026 queues\n+        .get(queueName) instanceof LeafQueue) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n           + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d (parent \u003d\u003d null) ?\n        queueName :\n        (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    boolean isAutoCreateEnabled \u003d conf.isAutoCreateChildQueueEnabled(\n        fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d new PlanQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n\n        //initializing the \"internal\" default queue, for SLS compatibility\n        String defReservationId \u003d\n            queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n\n        List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n        AutoCreatedLeafQueue resQueue \u003d new AutoCreatedLeafQueue(csContext,\n            defReservationId, (PlanQueue) queue);\n        try {\n          resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n        } catch (SchedulerDynamicEditException e) {\n          throw new IllegalStateException(e);\n        }\n        childQueues.add(resQueue);\n        ((PlanQueue) queue).setChildQueues(childQueues);\n        queues.put(defReservationId, resQueue);\n\n      } else if (isAutoCreateEnabled) {\n        queue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n\n      } else{\n        queue \u003d new LeafQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else{\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n\n      ParentQueue parentQueue;\n      if (isAutoCreateEnabled) {\n        parentQueue \u003d new ManagedParentQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n      } else{\n        parentQueue \u003d new ParentQueue(csContext, queueName, parent,\n            oldQueues.get(queueName));\n      }\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d parseQueue(csContext, conf, queue, childQueueName,\n            queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n\n    }\n\n    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName) \u0026\u0026 queues\n        .get(queueName) instanceof LeafQueue) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n          + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7394. Merge code paths for Reservation/Plan queues and Auto Created queues. (Suma Shivaprasad via wangda)\n",
      "commitDate": "06/11/17 9:38 PM",
      "commitName": "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "1d36b53ab6d9bb1d9144101e424c24371343c5bf",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 28.48,
      "commitsBetweenForRepo": 280,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d\n         (parent \u003d\u003d null) ? queueName\n             : (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d\n             new PlanQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n \n         //initializing the \"internal\" default queue, for SLS compatibility\n         String defReservationId \u003d\n             queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n \n         List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n-        ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n+        AutoCreatedLeafQueue resQueue \u003d new AutoCreatedLeafQueue(csContext,\n             defReservationId, (PlanQueue) queue);\n         try {\n           resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n         } catch (SchedulerDynamicEditException e) {\n           throw new IllegalStateException(e);\n         }\n         childQueues.add(resQueue);\n         ((PlanQueue) queue).setChildQueues(childQueues);\n         queues.put(defReservationId, resQueue);\n \n       } else {\n         queue \u003d\n             new LeafQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n \n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else {\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n       ParentQueue parentQueue \u003d\n           new ParentQueue(csContext, queueName, parent,\n               oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d\n             parseQueue(csContext, conf, queue, childQueueName,\n               queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n         \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n           + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d\n        (parent \u003d\u003d null) ? queueName\n            : (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d\n            new PlanQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        //initializing the \"internal\" default queue, for SLS compatibility\n        String defReservationId \u003d\n            queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n\n        List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n        AutoCreatedLeafQueue resQueue \u003d new AutoCreatedLeafQueue(csContext,\n            defReservationId, (PlanQueue) queue);\n        try {\n          resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n        } catch (SchedulerDynamicEditException e) {\n          throw new IllegalStateException(e);\n        }\n        childQueues.add(resQueue);\n        ((PlanQueue) queue).setChildQueues(childQueues);\n        queues.put(defReservationId, resQueue);\n\n      } else {\n        queue \u003d\n            new LeafQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else {\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n      ParentQueue parentQueue \u003d\n          new ParentQueue(csContext, queueName, parent,\n              oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d\n            parseQueue(csContext, conf, queue, childQueueName,\n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n        \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n          + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "4d4ad0ebb76198c90c5317f19ce85a6696132c8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6439. Fix ReservationSystem creation of default ReservationQueue. (Carlo Curino via wangda)\n",
      "commitDate": "11/04/17 2:56 PM",
      "commitName": "4d4ad0ebb76198c90c5317f19ce85a6696132c8f",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "04/04/17 2:39 PM",
      "commitNameOld": "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 7.01,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,80 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d\n         (parent \u003d\u003d null) ? queueName\n             : (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d\n             new PlanQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n+\n+        //initializing the \"internal\" default queue, for SLS compatibility\n+        String defReservationId \u003d\n+            queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n+\n+        List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n+        ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n+            defReservationId, (PlanQueue) queue);\n+        try {\n+          resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n+        } catch (SchedulerDynamicEditException e) {\n+          throw new IllegalStateException(e);\n+        }\n+        childQueues.add(resQueue);\n+        ((PlanQueue) queue).setChildQueues(childQueues);\n+        queues.put(defReservationId, resQueue);\n+\n       } else {\n         queue \u003d\n             new LeafQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n \n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else {\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n       ParentQueue parentQueue \u003d\n           new ParentQueue(csContext, queueName, parent,\n               oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d\n             parseQueue(csContext, conf, queue, childQueueName,\n               queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n         \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n           + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d\n        (parent \u003d\u003d null) ? queueName\n            : (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d\n            new PlanQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        //initializing the \"internal\" default queue, for SLS compatibility\n        String defReservationId \u003d\n            queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n\n        List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n        ReservationQueue resQueue \u003d new ReservationQueue(csContext,\n            defReservationId, (PlanQueue) queue);\n        try {\n          resQueue.setEntitlement(new QueueEntitlement(1.0f, 1.0f));\n        } catch (SchedulerDynamicEditException e) {\n          throw new IllegalStateException(e);\n        }\n        childQueues.add(resQueue);\n        ((PlanQueue) queue).setChildQueues(childQueues);\n        queues.put(defReservationId, resQueue);\n\n      } else {\n        queue \u003d\n            new LeafQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else {\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n      ParentQueue parentQueue \u003d\n          new ParentQueue(csContext, queueName, parent,\n              oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d\n            parseQueue(csContext, conf, queue, childQueueName,\n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n        \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n          + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
      "extendedDetails": {}
    },
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
      "commitDate": "30/11/16 1:38 PM",
      "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
      "commitAuthor": "Li Lu",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
          "commitDate": "30/11/16 1:38 PM",
          "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
          "commitAuthor": "Li Lu",
          "commitDateOld": "30/11/16 1:01 PM",
          "commitNameOld": "3fd844b99fdfae6be6e5e261f371d175aad14229",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,63 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d\n         (parent \u003d\u003d null) ? queueName\n             : (parent.getQueuePath() + \".\" + queueName);\n-    String[] childQueueNames \u003d\n-      conf.getQueues(fullQueueName);\n+    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d\n             new PlanQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n       } else {\n         queue \u003d\n             new LeafQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n \n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else {\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n       ParentQueue parentQueue \u003d\n-        new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n+          new ParentQueue(csContext, queueName, parent,\n+              oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n-      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n+      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d\n-          parseQueue(csContext, conf, queue, childQueueName,\n+            parseQueue(csContext, conf, queue, childQueueName,\n               queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n         \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n           + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d\n        (parent \u003d\u003d null) ? queueName\n            : (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d\n            new PlanQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n      } else {\n        queue \u003d\n            new LeafQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else {\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n      ParentQueue parentQueue \u003d\n          new ParentQueue(csContext, queueName, parent,\n              oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d\n            parseQueue(csContext, conf, queue, childQueueName,\n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n        \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n          + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
            "oldMethodName": "parseQueue",
            "newMethodName": "parseQueue"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
          "commitDate": "30/11/16 1:38 PM",
          "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
          "commitAuthor": "Li Lu",
          "commitDateOld": "30/11/16 1:01 PM",
          "commitNameOld": "3fd844b99fdfae6be6e5e261f371d175aad14229",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,63 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf,\n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d\n         (parent \u003d\u003d null) ? queueName\n             : (parent.getQueuePath() + \".\" + queueName);\n-    String[] childQueueNames \u003d\n-      conf.getQueues(fullQueueName);\n+    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d\n             new PlanQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n       } else {\n         queue \u003d\n             new LeafQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n \n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else {\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n       ParentQueue parentQueue \u003d\n-        new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n+          new ParentQueue(csContext, queueName, parent,\n+              oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n-      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n+      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d\n-          parseQueue(csContext, conf, queue, childQueueName,\n+            parseQueue(csContext, conf, queue, childQueueName,\n               queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n         \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n           + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf,\n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d\n        (parent \u003d\u003d null) ? queueName\n            : (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d\n            new PlanQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n      } else {\n        queue \u003d\n            new LeafQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else {\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n      ParentQueue parentQueue \u003d\n          new ParentQueue(csContext, queueName, parent,\n              oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003c\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d\n            parseQueue(csContext, conf, queue, childQueueName,\n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n        \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n          + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerQueueManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "6da6d87872de518bb2583f65c9595f2090c855d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4535. Fix checkstyle error in CapacityScheduler.java (Naganarasimha G R via rohithsharmaks)\n",
      "commitDate": "04/01/16 10:39 PM",
      "commitName": "6da6d87872de518bb2583f65c9595f2090c855d7",
      "commitAuthor": "rohithsharmaks",
      "commitDateOld": "14/12/15 10:52 AM",
      "commitNameOld": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 21.49,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext,\n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d\n         (parent \u003d\u003d null) ? queueName\n             : (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d \n       conf.getQueues(fullQueueName);\n     boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d\n             new PlanQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n       } else {\n         queue \u003d\n             new LeafQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n \n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else {\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n-    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n-      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n+    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n+        \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n-        + \". Leaf queue names must be distinct\");\n+          + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext,\n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d\n        (parent \u003d\u003d null) ? queueName\n            : (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d \n      conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d\n            new PlanQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n      } else {\n        queue \u003d\n            new LeafQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else {\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if (queue instanceof LeafQueue \u0026\u0026 queues.containsKey(queueName)\n        \u0026\u0026 queues.get(queueName) instanceof LeafQueue) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n          + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "5e10a13bb4759984494c6a870c7f08fb6693c9c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2576. Making test patch pass in branch. Contributed by Subru Krishnan and Carlo Curino.\n(cherry picked from commit 90ac0be86b898aefec5471db4027554c8e1b310c)\n",
      "commitDate": "03/10/14 3:43 PM",
      "commitName": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
      "commitAuthor": "subru",
      "commitDateOld": "03/10/14 3:41 PM",
      "commitNameOld": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthorOld": "carlo curino",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String fullQueueName \u003d\n         (parent \u003d\u003d null) ? queueName\n             : (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d \n       conf.getQueues(fullQueueName);\n-    boolean isReservableQueue \u003d conf.isReservableQueue(fullQueueName);\n+    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       // Check if the queue will be dynamically managed by the Reservation\n       // system\n       if (isReservableQueue) {\n         queue \u003d\n             new PlanQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n       } else {\n         queue \u003d\n             new LeafQueue(csContext, queueName, parent,\n                 oldQueues.get(queueName));\n \n         // Used only for unit tests\n         queue \u003d hook.hook(queue);\n       }\n     } else {\n       if (isReservableQueue) {\n         throw new IllegalStateException(\n             \"Only Leaf Queues can be reservable for \" + queueName);\n       }\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n       \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n         + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d\n        (parent \u003d\u003d null) ? queueName\n            : (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d \n      conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservable(fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d\n            new PlanQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n      } else {\n        queue \u003d\n            new LeafQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else {\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "eb3e40b833b9d82c1556843f960194dc42e482f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1707. Introduce APIs to add/remove/resize queues in the CapacityScheduler. Contributed by Carlo Curino and Subru Krishnan\n(cherry picked from commit aac47fda7fecda9fc18ade34d633eca895865a70)\n\nConflicts:\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthor": "carlo curino",
      "commitDateOld": "02/10/14 3:13 PM",
      "commitNameOld": "054f28552687e9b9859c0126e16a2066e20ead3f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,63 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n       QueueHook hook) throws IOException {\n     CSQueue queue;\n+    String fullQueueName \u003d\n+        (parent \u003d\u003d null) ? queueName\n+            : (parent.getQueuePath() + \".\" + queueName);\n     String[] childQueueNames \u003d \n-      conf.getQueues((parent \u003d\u003d null) ? \n-          queueName : (parent.getQueuePath()+\".\"+queueName));\n+      conf.getQueues(fullQueueName);\n+    boolean isReservableQueue \u003d conf.isReservableQueue(fullQueueName);\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n-      queue \u003d \n-          new LeafQueue(csContext, queueName, parent, oldQueues.get(queueName));\n-      \n-      // Used only for unit tests\n-      queue \u003d hook.hook(queue);\n+      // Check if the queue will be dynamically managed by the Reservation\n+      // system\n+      if (isReservableQueue) {\n+        queue \u003d\n+            new PlanQueue(csContext, queueName, parent,\n+                oldQueues.get(queueName));\n+      } else {\n+        queue \u003d\n+            new LeafQueue(csContext, queueName, parent,\n+                oldQueues.get(queueName));\n+\n+        // Used only for unit tests\n+        queue \u003d hook.hook(queue);\n+      }\n     } else {\n+      if (isReservableQueue) {\n+        throw new IllegalStateException(\n+            \"Only Leaf Queues can be reservable for \" + queueName);\n+      }\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n-      \n+\n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n       \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n         + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String fullQueueName \u003d\n        (parent \u003d\u003d null) ? queueName\n            : (parent.getQueuePath() + \".\" + queueName);\n    String[] childQueueNames \u003d \n      conf.getQueues(fullQueueName);\n    boolean isReservableQueue \u003d conf.isReservableQueue(fullQueueName);\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      // Check if the queue will be dynamically managed by the Reservation\n      // system\n      if (isReservableQueue) {\n        queue \u003d\n            new PlanQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n      } else {\n        queue \u003d\n            new LeafQueue(csContext, queueName, parent,\n                oldQueues.get(queueName));\n\n        // Used only for unit tests\n        queue \u003d hook.hook(queue);\n      }\n    } else {\n      if (isReservableQueue) {\n        throw new IllegalStateException(\n            \"Only Leaf Queues can be reservable for \" + queueName);\n      }\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, parent, oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n\n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/01/13 9:08 PM",
          "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "28/11/12 5:56 PM",
          "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 41.13,
          "commitsBetweenForRepo": 152,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,47 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n-      Comparator\u003cCSQueue\u003e queueComparator,\n-      Comparator\u003cFiCaSchedulerApp\u003e applicationComparator,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n-      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n-                            oldQueues.get(queueName));\n+      queue \u003d \n+          new LeafQueue(csContext, queueName, parent,oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n-        new ParentQueue(csContext, queueName, queueComparator, parent,\n-                        oldQueues.get(queueName));\n+        new ParentQueue(csContext, queueName, parent,oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n-              queues, oldQueues, queueComparator, applicationComparator, hook);\n+              queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n       \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n         + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d \n          new LeafQueue(csContext, queueName, parent,oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, parent,oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-CSQueue, queueName-String, queues-Map\u003cString,CSQueue\u003e, oldQueues-Map\u003cString,CSQueue\u003e, queueComparator-Comparator\u003cCSQueue\u003e, applicationComparator-Comparator\u003cFiCaSchedulerApp\u003e, hook-QueueHook]",
            "newValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-CSQueue, queueName-String, queues-Map\u003cString,CSQueue\u003e, oldQueues-Map\u003cString,CSQueue\u003e, hook-QueueHook]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/01/13 9:08 PM",
          "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "28/11/12 5:56 PM",
          "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 41.13,
          "commitsBetweenForRepo": 152,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,47 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n-      Comparator\u003cCSQueue\u003e queueComparator,\n-      Comparator\u003cFiCaSchedulerApp\u003e applicationComparator,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n-      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n-                            oldQueues.get(queueName));\n+      queue \u003d \n+          new LeafQueue(csContext, queueName, parent,oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n-        new ParentQueue(csContext, queueName, queueComparator, parent,\n-                        oldQueues.get(queueName));\n+        new ParentQueue(csContext, queueName, parent,oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n-              queues, oldQueues, queueComparator, applicationComparator, hook);\n+              queues, oldQueues, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n       \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n         + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d \n          new LeafQueue(csContext, queueName, parent,oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, parent,oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      Comparator\u003cCSQueue\u003e queueComparator,\n      Comparator\u003cFiCaSchedulerApp\u003e applicationComparator,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Yparameterchange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "09/03/12 3:34 PM",
      "commitNameOld": "ed4c222d5c0aeb4a46a2dd8a6342c85e88f31d3b",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 129.09,
      "commitsBetweenForRepo": 802,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n       Comparator\u003cCSQueue\u003e queueComparator,\n-      Comparator\u003cSchedulerApp\u003e applicationComparator,\n+      Comparator\u003cFiCaSchedulerApp\u003e applicationComparator,\n       QueueHook hook) throws IOException {\n     CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                             oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, queueComparator, parent,\n                         oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, queueComparator, applicationComparator, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n       \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n       throw new IOException(\"Two leaf queues were named \" + queueName\n         + \". Leaf queue names must be distinct\");\n     }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      Comparator\u003cCSQueue\u003e queueComparator,\n      Comparator\u003cFiCaSchedulerApp\u003e applicationComparator,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-CSQueue, queueName-String, queues-Map\u003cString,CSQueue\u003e, oldQueues-Map\u003cString,CSQueue\u003e, queueComparator-Comparator\u003cCSQueue\u003e, applicationComparator-Comparator\u003cSchedulerApp\u003e, hook-QueueHook]",
        "newValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-CSQueue, queueName-String, queues-Map\u003cString,CSQueue\u003e, oldQueues-Map\u003cString,CSQueue\u003e, queueComparator-Comparator\u003cCSQueue\u003e, applicationComparator-Comparator\u003cFiCaSchedulerApp\u003e, hook-QueueHook]"
      }
    },
    "ec87e163d418b3fc3d9456e844143d6c61c80a48": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3147. Handle leaf queues with the same name properly. (Ravi Prakash via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1211243 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/12/11 4:29 PM",
      "commitName": "ec87e163d418b3fc3d9456e844143d6c61c80a48",
      "commitAuthor": "Mahadev Konar",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "MAPREDUCE-3147. Handle leaf queues with the same name properly. (Ravi Prakash via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1211243 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/12/11 4:29 PM",
          "commitName": "ec87e163d418b3fc3d9456e844143d6c61c80a48",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "19/10/11 1:37 PM",
          "commitNameOld": "e549ac93694f768f2e26706a54a1b45dea6d2844",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 48.16,
          "commitsBetweenForRepo": 326,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,50 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n       Comparator\u003cCSQueue\u003e queueComparator,\n       Comparator\u003cSchedulerApp\u003e applicationComparator,\n-      QueueHook hook) {\n+      QueueHook hook) throws IOException {\n     CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                             oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, queueComparator, parent,\n                         oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, queueComparator, applicationComparator, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n+    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n+      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n+      throw new IOException(\"Two leaf queues were named \" + queueName\n+        + \". Leaf queue names must be distinct\");\n+    }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      Comparator\u003cCSQueue\u003e queueComparator,\n      Comparator\u003cSchedulerApp\u003e applicationComparator,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3147. Handle leaf queues with the same name properly. (Ravi Prakash via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1211243 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/12/11 4:29 PM",
          "commitName": "ec87e163d418b3fc3d9456e844143d6c61c80a48",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "19/10/11 1:37 PM",
          "commitNameOld": "e549ac93694f768f2e26706a54a1b45dea6d2844",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 48.16,
          "commitsBetweenForRepo": 326,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,50 @@\n   static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n       CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n       Map\u003cString, CSQueue\u003e oldQueues, \n       Comparator\u003cCSQueue\u003e queueComparator,\n       Comparator\u003cSchedulerApp\u003e applicationComparator,\n-      QueueHook hook) {\n+      QueueHook hook) throws IOException {\n     CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                             oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, queueComparator, parent,\n                         oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n       List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n         CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, queueComparator, applicationComparator, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n+    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n+      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n+      throw new IOException(\"Two leaf queues were named \" + queueName\n+        + \". Leaf queue names must be distinct\");\n+    }\n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      Comparator\u003cCSQueue\u003e queueComparator,\n      Comparator\u003cSchedulerApp\u003e applicationComparator,\n      QueueHook hook) throws IOException {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    if(queue instanceof LeafQueue \u003d\u003d true \u0026\u0026 queues.containsKey(queueName)\n      \u0026\u0026 queues.get(queueName) instanceof LeafQueue \u003d\u003d true) {\n      throw new IOException(\"Two leaf queues were named \" + queueName\n        + \". Leaf queue names must be distinct\");\n    }\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "1f46b991da9b91585608a0babd3eda39485dce09": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 11:26 AM",
      "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/09/11 11:26 AM",
          "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "06/09/11 10:54 PM",
          "commitNameOld": "0ecba04727b5c31182d29511646c8d3e6441300f",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 1.52,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-  static Queue parseQueue(\n+  static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n-      Queue parent, String queueName, Map\u003cString, Queue\u003e queues,\n-      Map\u003cString, Queue\u003e oldQueues, \n-      Comparator\u003cQueue\u003e queueComparator,\n+      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n+      Map\u003cString, CSQueue\u003e oldQueues, \n+      Comparator\u003cCSQueue\u003e queueComparator,\n       Comparator\u003cSchedulerApp\u003e applicationComparator,\n       QueueHook hook) {\n-    Queue queue;\n+    CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                             oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, queueComparator, parent,\n                         oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n-      List\u003cQueue\u003e childQueues \u003d new ArrayList\u003cQueue\u003e();\n+      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n-        Queue childQueue \u003d \n+        CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, queueComparator, applicationComparator, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      Comparator\u003cCSQueue\u003e queueComparator,\n      Comparator\u003cSchedulerApp\u003e applicationComparator,\n      QueueHook hook) {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-Queue, queueName-String, queues-Map\u003cString,Queue\u003e, oldQueues-Map\u003cString,Queue\u003e, queueComparator-Comparator\u003cQueue\u003e, applicationComparator-Comparator\u003cSchedulerApp\u003e, hook-QueueHook]",
            "newValue": "[csContext-CapacitySchedulerContext, conf-CapacitySchedulerConfiguration, parent-CSQueue, queueName-String, queues-Map\u003cString,CSQueue\u003e, oldQueues-Map\u003cString,CSQueue\u003e, queueComparator-Comparator\u003cCSQueue\u003e, applicationComparator-Comparator\u003cSchedulerApp\u003e, hook-QueueHook]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/09/11 11:26 AM",
          "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "06/09/11 10:54 PM",
          "commitNameOld": "0ecba04727b5c31182d29511646c8d3e6441300f",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 1.52,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-  static Queue parseQueue(\n+  static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n-      Queue parent, String queueName, Map\u003cString, Queue\u003e queues,\n-      Map\u003cString, Queue\u003e oldQueues, \n-      Comparator\u003cQueue\u003e queueComparator,\n+      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n+      Map\u003cString, CSQueue\u003e oldQueues, \n+      Comparator\u003cCSQueue\u003e queueComparator,\n       Comparator\u003cSchedulerApp\u003e applicationComparator,\n       QueueHook hook) {\n-    Queue queue;\n+    CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                             oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, queueComparator, parent,\n                         oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n-      List\u003cQueue\u003e childQueues \u003d new ArrayList\u003cQueue\u003e();\n+      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n-        Queue childQueue \u003d \n+        CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, queueComparator, applicationComparator, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      Comparator\u003cCSQueue\u003e queueComparator,\n      Comparator\u003cSchedulerApp\u003e applicationComparator,\n      QueueHook hook) {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "Queue",
            "newValue": "CSQueue"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/09/11 11:26 AM",
          "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "06/09/11 10:54 PM",
          "commitNameOld": "0ecba04727b5c31182d29511646c8d3e6441300f",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 1.52,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-  static Queue parseQueue(\n+  static CSQueue parseQueue(\n       CapacitySchedulerContext csContext, \n       CapacitySchedulerConfiguration conf, \n-      Queue parent, String queueName, Map\u003cString, Queue\u003e queues,\n-      Map\u003cString, Queue\u003e oldQueues, \n-      Comparator\u003cQueue\u003e queueComparator,\n+      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n+      Map\u003cString, CSQueue\u003e oldQueues, \n+      Comparator\u003cCSQueue\u003e queueComparator,\n       Comparator\u003cSchedulerApp\u003e applicationComparator,\n       QueueHook hook) {\n-    Queue queue;\n+    CSQueue queue;\n     String[] childQueueNames \u003d \n       conf.getQueues((parent \u003d\u003d null) ? \n           queueName : (parent.getQueuePath()+\".\"+queueName));\n     if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n       if (null \u003d\u003d parent) {\n         throw new IllegalStateException(\n             \"Queue configuration missing child queue names for \" + queueName);\n       }\n       queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                             oldQueues.get(queueName));\n       \n       // Used only for unit tests\n       queue \u003d hook.hook(queue);\n     } else {\n       ParentQueue parentQueue \u003d \n         new ParentQueue(csContext, queueName, queueComparator, parent,\n                         oldQueues.get(queueName));\n \n       // Used only for unit tests\n       queue \u003d hook.hook(parentQueue);\n       \n-      List\u003cQueue\u003e childQueues \u003d new ArrayList\u003cQueue\u003e();\n+      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n       for (String childQueueName : childQueueNames) {\n-        Queue childQueue \u003d \n+        CSQueue childQueue \u003d \n           parseQueue(csContext, conf, queue, childQueueName, \n               queues, oldQueues, queueComparator, applicationComparator, hook);\n         childQueues.add(childQueue);\n       }\n       parentQueue.setChildQueues(childQueues);\n     }\n \n     queues.put(queueName, queue);\n \n     LOG.info(\"Initialized queue: \" + queue);\n     return queue;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static CSQueue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      CSQueue parent, String queueName, Map\u003cString, CSQueue\u003e queues,\n      Map\u003cString, CSQueue\u003e oldQueues, \n      Comparator\u003cCSQueue\u003e queueComparator,\n      Comparator\u003cSchedulerApp\u003e applicationComparator,\n      QueueHook hook) {\n    CSQueue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cCSQueue\u003e childQueues \u003d new ArrayList\u003cCSQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        CSQueue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  static Queue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      Queue parent, String queueName, Map\u003cString, Queue\u003e queues,\n      Map\u003cString, Queue\u003e oldQueues, \n      Comparator\u003cQueue\u003e queueComparator,\n      Comparator\u003cSchedulerApp\u003e applicationComparator,\n      QueueHook hook) {\n    Queue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cQueue\u003e childQueues \u003d new ArrayList\u003cQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        Queue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,45 @@\n+  static Queue parseQueue(\n+      CapacitySchedulerContext csContext, \n+      CapacitySchedulerConfiguration conf, \n+      Queue parent, String queueName, Map\u003cString, Queue\u003e queues,\n+      Map\u003cString, Queue\u003e oldQueues, \n+      Comparator\u003cQueue\u003e queueComparator,\n+      Comparator\u003cSchedulerApp\u003e applicationComparator,\n+      QueueHook hook) {\n+    Queue queue;\n+    String[] childQueueNames \u003d \n+      conf.getQueues((parent \u003d\u003d null) ? \n+          queueName : (parent.getQueuePath()+\".\"+queueName));\n+    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n+      if (null \u003d\u003d parent) {\n+        throw new IllegalStateException(\n+            \"Queue configuration missing child queue names for \" + queueName);\n+      }\n+      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n+                            oldQueues.get(queueName));\n+      \n+      // Used only for unit tests\n+      queue \u003d hook.hook(queue);\n+    } else {\n+      ParentQueue parentQueue \u003d \n+        new ParentQueue(csContext, queueName, queueComparator, parent,\n+                        oldQueues.get(queueName));\n+\n+      // Used only for unit tests\n+      queue \u003d hook.hook(parentQueue);\n+      \n+      List\u003cQueue\u003e childQueues \u003d new ArrayList\u003cQueue\u003e();\n+      for (String childQueueName : childQueueNames) {\n+        Queue childQueue \u003d \n+          parseQueue(csContext, conf, queue, childQueueName, \n+              queues, oldQueues, queueComparator, applicationComparator, hook);\n+        childQueues.add(childQueue);\n+      }\n+      parentQueue.setChildQueues(childQueues);\n+    }\n+\n+    queues.put(queueName, queue);\n+\n+    LOG.info(\"Initialized queue: \" + queue);\n+    return queue;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static Queue parseQueue(\n      CapacitySchedulerContext csContext, \n      CapacitySchedulerConfiguration conf, \n      Queue parent, String queueName, Map\u003cString, Queue\u003e queues,\n      Map\u003cString, Queue\u003e oldQueues, \n      Comparator\u003cQueue\u003e queueComparator,\n      Comparator\u003cSchedulerApp\u003e applicationComparator,\n      QueueHook hook) {\n    Queue queue;\n    String[] childQueueNames \u003d \n      conf.getQueues((parent \u003d\u003d null) ? \n          queueName : (parent.getQueuePath()+\".\"+queueName));\n    if (childQueueNames \u003d\u003d null || childQueueNames.length \u003d\u003d 0) {\n      if (null \u003d\u003d parent) {\n        throw new IllegalStateException(\n            \"Queue configuration missing child queue names for \" + queueName);\n      }\n      queue \u003d new LeafQueue(csContext, queueName, parent, applicationComparator,\n                            oldQueues.get(queueName));\n      \n      // Used only for unit tests\n      queue \u003d hook.hook(queue);\n    } else {\n      ParentQueue parentQueue \u003d \n        new ParentQueue(csContext, queueName, queueComparator, parent,\n                        oldQueues.get(queueName));\n\n      // Used only for unit tests\n      queue \u003d hook.hook(parentQueue);\n      \n      List\u003cQueue\u003e childQueues \u003d new ArrayList\u003cQueue\u003e();\n      for (String childQueueName : childQueueNames) {\n        Queue childQueue \u003d \n          parseQueue(csContext, conf, queue, childQueueName, \n              queues, oldQueues, queueComparator, applicationComparator, hook);\n        childQueues.add(childQueue);\n      }\n      parentQueue.setChildQueues(childQueues);\n    }\n\n    queues.put(queueName, queue);\n\n    LOG.info(\"Initialized queue: \" + queue);\n    return queue;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}