{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReaderFactory.java",
  "functionName": "getLegacyBlockReaderLocal",
  "functionId": "getLegacyBlockReaderLocal",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
  "functionStartLine": 428,
  "functionEndLine": 465,
  "numCommitsSeen": 103,
  "timeTaken": 6202,
  "changeHistory": [
    "5d748bd056a32f2c6922514cd0c5b31d866a9919",
    "f308561f1d885491b88db73ac63003202056d661",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "892ade689f9bcce76daae8f66fc00a49bee8548e",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
    "7e971b7315fa2942b4db7ba11ed513766957b777",
    "c992bcf9c136d3df686655a80e636bb7bb0664da",
    "ed72daa5df97669906234e8ac9a406d78136b206",
    "463aec11718e47d4aabb86a7a539cb973460aae6",
    "225569ece229cec32f852f831fd337a139c44b1e",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
    "c68b1d1b31e304c27e419e810ded0fc97e435ea6",
    "bbb24fbf5d220fbe137d43651ba3802a9806b1a3",
    "694a6721316aea14c1244447974231abc8dff0cb"
  ],
  "changeHistoryShort": {
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": "Ybodychange",
    "f308561f1d885491b88db73ac63003202056d661": "Yfilerename",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "892ade689f9bcce76daae8f66fc00a49bee8548e": "Ybodychange",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": "Yfilerename",
    "7e971b7315fa2942b4db7ba11ed513766957b777": "Ybodychange",
    "c992bcf9c136d3df686655a80e636bb7bb0664da": "Ybodychange",
    "ed72daa5df97669906234e8ac9a406d78136b206": "Ybodychange",
    "463aec11718e47d4aabb86a7a539cb973460aae6": "Ybodychange",
    "225569ece229cec32f852f831fd337a139c44b1e": "Ybodychange",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": "Ymultichange(Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange)",
    "c68b1d1b31e304c27e419e810ded0fc97e435ea6": "Ymultichange(Yparameterchange,Ybodychange)",
    "bbb24fbf5d220fbe137d43651ba3802a9806b1a3": "Ymultichange(Yparameterchange,Ybodychange)",
    "694a6721316aea14c1244447974231abc8dff0cb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13702. Remove HTrace hooks from DFSClient to reduce CPU usage. Contributed by Todd Lipcon.\n",
      "commitDate": "02/07/18 3:11 AM",
      "commitName": "5d748bd056a32f2c6922514cd0c5b31d866a9919",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "18/06/18 10:17 AM",
      "commitNameOld": "fba9d7cd746cd7b659d2fd9d2bfa23266be9009b",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 13.7,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n     LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n     if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n       LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n           + \"{} is not local\", this, inetSocketAddress);\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n       PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n           \"BlockReaderLocalLegacy because \" +\n           \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n     IOException ioe;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n-          datanode, startOffset, length, storageType, tracer);\n+          datanode, startOffset, length, storageType);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n          + \"{} is not local\", this, inetSocketAddress);\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n          \"BlockReaderLocalLegacy because \" +\n          \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "f308561f1d885491b88db73ac63003202056d661": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8057 Move BlockReader implementation to the client implementation package.  Contributed by Takanobu Asanuma\n",
      "commitDate": "25/04/16 12:01 PM",
      "commitName": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "25/04/16 9:38 AM",
      "commitNameOld": "10f0f7851a3255caab775777e8fb6c2781d97062",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n          + \"{} is not local\", this, inetSocketAddress);\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n          \"BlockReaderLocalLegacy because \" +\n          \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType, tracer);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java"
      }
    },
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,38 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n-    }\n+    LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n     if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n-            \"the address \" + inetSocketAddress + \" is not local\");\n-      }\n+      LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n+          + \"{} is not local\", this, inetSocketAddress);\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n         PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n             \"BlockReaderLocalLegacy because \" +\n             \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n     IOException ioe;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n           datanode, startOffset, length, storageType, tracer);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n          + \"{} is not local\", this, inetSocketAddress);\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType, tracer);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,42 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n-    LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n+    }\n     if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n-      LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n-          + \"{} is not local\", this, inetSocketAddress);\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"the address \" + inetSocketAddress + \" is not local\");\n+      }\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n         PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n             \"BlockReaderLocalLegacy because \" +\n             \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n     IOException ioe;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n           datanode, startOffset, length, storageType, tracer);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType, tracer);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/09/15 1:39 PM",
      "commitNameOld": "e5992ef4df63fbc6a6b8e357b32c647e7837c662",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,38 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n-    }\n+    LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n     if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n-            \"the address \" + inetSocketAddress + \" is not local\");\n-      }\n+      LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n+          + \"{} is not local\", this, inetSocketAddress);\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n         PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n             \"BlockReaderLocalLegacy because \" +\n             \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n     IOException ioe;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n           datanode, startOffset, length, storageType, tracer);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct BlockReaderLocalLegacy\", this);\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      LOG.trace(\"{}: can\u0027t construct BlockReaderLocalLegacy because the address\"\n          + \"{} is not local\", this, inetSocketAddress);\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType, tracer);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "892ade689f9bcce76daae8f66fc00a49bee8548e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9080. Update htrace version to 4.0.1 (cmccabe)\n",
      "commitDate": "28/09/15 7:42 AM",
      "commitName": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "26/09/15 11:08 AM",
      "commitNameOld": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.86,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n     if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n             \"the address \" + inetSocketAddress + \" is not local\");\n       }\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n         PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n             \"BlockReaderLocalLegacy because \" +\n             \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n     IOException ioe;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n-          datanode, startOffset, length, storageType);\n+          datanode, startOffset, length, storageType, tracer);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType, tracer);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8053. Move DFSIn/OutputStream and related classes to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/09/15 11:08 AM",
      "commitName": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "26/09/15 9:06 AM",
      "commitNameOld": "861b52db242f238d7e36ad75c158025be959a696",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
      }
    },
    "7e971b7315fa2942b4db7ba11ed513766957b777": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8962. Clean up checkstyle warnings in o.a.h.hdfs.DfsClientConf. Contributed by Mingliang Liu.\n",
      "commitDate": "27/08/15 9:02 AM",
      "commitName": "7e971b7315fa2942b4db7ba11ed513766957b777",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "26/08/15 2:02 PM",
      "commitNameOld": "c992bcf9c136d3df686655a80e636bb7bb0664da",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n     if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n             \"the address \" + inetSocketAddress + \" is not local\");\n       }\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n         PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n             \"BlockReaderLocalLegacy because \" +\n             \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n-    IOException ioe \u003d null;\n+    IOException ioe;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n           datanode, startOffset, length, storageType);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "c992bcf9c136d3df686655a80e636bb7bb0664da": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8951. Move the shortcircuit package to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/08/15 2:02 PM",
      "commitName": "c992bcf9c136d3df686655a80e636bb7bb0664da",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/08/15 1:31 PM",
      "commitNameOld": "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 4.02,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n-    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n+    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n             \"the address \" + inetSocketAddress + \" is not local\");\n       }\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n         PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n             \"BlockReaderLocalLegacy because \" +\n             \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n     IOException ioe \u003d null;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n           datanode, startOffset, length, storageType);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSUtilClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "ed72daa5df97669906234e8ac9a406d78136b206": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7978. Add LOG.isDebugEnabled() guard for some LOG.debug(..). Contributed by Walter Su.\n",
      "commitDate": "01/04/15 12:54 PM",
      "commitName": "ed72daa5df97669906234e8ac9a406d78136b206",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "14/03/15 10:36 PM",
      "commitNameOld": "bc9cb3e271b22069a15ca110cd60c860250aaab2",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 17.6,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n     if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n             \"the address \" + inetSocketAddress + \" is not local\");\n       }\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n-      PerformanceAdvisory.LOG.debug(this + \": can\u0027t construct \" +\n-          \"BlockReaderLocalLegacy because \" +\n-          \"disableLegacyBlockReaderLocal is set.\");\n+        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n+            \"BlockReaderLocalLegacy because \" +\n+            \"disableLegacyBlockReaderLocal is set.\", this);\n       return null;\n     }\n     IOException ioe \u003d null;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n           datanode, startOffset, length, storageType);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n        PerformanceAdvisory.LOG.debug(\"{}: can\u0027t construct \" +\n            \"BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\", this);\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "463aec11718e47d4aabb86a7a539cb973460aae6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6934. Move checksum computation off the hot path when writing to RAM disk. Contributed by Chris Nauroth.\n",
      "commitDate": "27/10/14 9:38 AM",
      "commitName": "463aec11718e47d4aabb86a7a539cb973460aae6",
      "commitAuthor": "cnauroth",
      "commitDateOld": "27/08/14 1:39 PM",
      "commitNameOld": "225569ece229cec32f852f831fd337a139c44b1e",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 60.83,
      "commitsBetweenForRepo": 616,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n     if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n             \"the address \" + inetSocketAddress + \" is not local\");\n       }\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n       PerformanceAdvisory.LOG.debug(this + \": can\u0027t construct \" +\n           \"BlockReaderLocalLegacy because \" +\n           \"disableLegacyBlockReaderLocal is set.\");\n       return null;\n     }\n     IOException ioe \u003d null;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n-          datanode, startOffset, length);\n+          datanode, startOffset, length, storageType);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      PerformanceAdvisory.LOG.debug(this + \": can\u0027t construct \" +\n          \"BlockReaderLocalLegacy because \" +\n          \"disableLegacyBlockReaderLocal is set.\");\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length, storageType);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "225569ece229cec32f852f831fd337a139c44b1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4486. Add log category for long-running DFSClient notices.  Contributed by Zhe Zhang.\n",
      "commitDate": "27/08/14 1:39 PM",
      "commitName": "225569ece229cec32f852f831fd337a139c44b1e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "14/07/14 11:10 AM",
      "commitNameOld": "3b54223c0f32d42a84436c670d80b791a8e9696d",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 44.1,
      "commitsBetweenForRepo": 375,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,42 @@\n   private BlockReader getLegacyBlockReaderLocal() throws IOException {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n     if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n             \"the address \" + inetSocketAddress + \" is not local\");\n       }\n       return null;\n     }\n     if (clientContext.getDisableLegacyBlockReaderLocal()) {\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n-            \"disableLegacyBlockReaderLocal is set.\");\n-      }\n+      PerformanceAdvisory.LOG.debug(this + \": can\u0027t construct \" +\n+          \"BlockReaderLocalLegacy because \" +\n+          \"disableLegacyBlockReaderLocal is set.\");\n       return null;\n     }\n     IOException ioe \u003d null;\n     try {\n       return BlockReaderLocalLegacy.newBlockReader(conf,\n           userGroupInformation, configuration, fileName, block, token,\n           datanode, startOffset, length);\n     } catch (RemoteException remoteException) {\n       ioe \u003d remoteException.unwrapRemoteException(\n                 InvalidToken.class, AccessControlException.class);\n     } catch (IOException e) {\n       ioe \u003d e;\n     }\n     if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n         isSecurityException(ioe)) {\n       // Handle security exceptions.\n       // We do not handle AccessControlException here, since\n       // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n       // that the user is not in dfs.block.local-path-access.user, a condition\n       // which requires us to disable legacy SCR.\n       throw ioe;\n     }\n     LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n         \"Disabling legacy local reads.\", ioe);\n     clientContext.setDisableLegacyBlockReaderLocal();\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      PerformanceAdvisory.LOG.debug(this + \": can\u0027t construct \" +\n          \"BlockReaderLocalLegacy because \" +\n          \"disableLegacyBlockReaderLocal is set.\");\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 11:08 AM",
      "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/02/14 11:08 AM",
          "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "17/12/13 12:57 PM",
          "commitNameOld": "124e507674c0d396f8494585e64226957199097b",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 56.92,
          "commitsBetweenForRepo": 308,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,43 @@\n-  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n-      String src, ExtendedBlock blk,\n-      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n-      long offsetIntoBlock) throws InvalidToken, IOException {\n-    try {\n-      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n-      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n-          accessToken, chosenNode, offsetIntoBlock, length);\n-    } catch (RemoteException re) {\n-      throw re.unwrapRemoteException(InvalidToken.class,\n-          AccessControlException.class);\n+  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n+    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"the address \" + inetSocketAddress + \" is not local\");\n+      }\n+      return null;\n+    }\n+    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"disableLegacyBlockReaderLocal is set.\");\n+      }\n+      return null;\n+    }\n+    IOException ioe \u003d null;\n+    try {\n+      return BlockReaderLocalLegacy.newBlockReader(conf,\n+          userGroupInformation, configuration, fileName, block, token,\n+          datanode, startOffset, length);\n+    } catch (RemoteException remoteException) {\n+      ioe \u003d remoteException.unwrapRemoteException(\n+                InvalidToken.class, AccessControlException.class);\n+    } catch (IOException e) {\n+      ioe \u003d e;\n+    }\n+    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n+        isSecurityException(ioe)) {\n+      // Handle security exceptions.\n+      // We do not handle AccessControlException here, since\n+      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n+      // that the user is not in dfs.block.local-path-access.user, a condition\n+      // which requires us to disable legacy SCR.\n+      throw ioe;\n+    }\n+    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n+        \"Disabling legacy local reads.\", ioe);\n+    clientContext.setDisableLegacyBlockReaderLocal();\n+    return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\");\n      }\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {
            "oldValue": "[dfsClient-DFSClient, src-String, blk-ExtendedBlock, accessToken-Token\u003cBlockTokenIdentifier\u003e, chosenNode-DatanodeInfo, offsetIntoBlock-long]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/02/14 11:08 AM",
          "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "17/12/13 12:57 PM",
          "commitNameOld": "124e507674c0d396f8494585e64226957199097b",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 56.92,
          "commitsBetweenForRepo": 308,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,43 @@\n-  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n-      String src, ExtendedBlock blk,\n-      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n-      long offsetIntoBlock) throws InvalidToken, IOException {\n-    try {\n-      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n-      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n-          accessToken, chosenNode, offsetIntoBlock, length);\n-    } catch (RemoteException re) {\n-      throw re.unwrapRemoteException(InvalidToken.class,\n-          AccessControlException.class);\n+  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n+    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"the address \" + inetSocketAddress + \" is not local\");\n+      }\n+      return null;\n+    }\n+    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"disableLegacyBlockReaderLocal is set.\");\n+      }\n+      return null;\n+    }\n+    IOException ioe \u003d null;\n+    try {\n+      return BlockReaderLocalLegacy.newBlockReader(conf,\n+          userGroupInformation, configuration, fileName, block, token,\n+          datanode, startOffset, length);\n+    } catch (RemoteException remoteException) {\n+      ioe \u003d remoteException.unwrapRemoteException(\n+                InvalidToken.class, AccessControlException.class);\n+    } catch (IOException e) {\n+      ioe \u003d e;\n+    }\n+    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n+        isSecurityException(ioe)) {\n+      // Handle security exceptions.\n+      // We do not handle AccessControlException here, since\n+      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n+      // that the user is not in dfs.block.local-path-access.user, a condition\n+      // which requires us to disable legacy SCR.\n+      throw ioe;\n+    }\n+    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n+        \"Disabling legacy local reads.\", ioe);\n+    clientContext.setDisableLegacyBlockReaderLocal();\n+    return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\");\n      }\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {
            "oldValue": "[static]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/02/14 11:08 AM",
          "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "17/12/13 12:57 PM",
          "commitNameOld": "124e507674c0d396f8494585e64226957199097b",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 56.92,
          "commitsBetweenForRepo": 308,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,43 @@\n-  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n-      String src, ExtendedBlock blk,\n-      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n-      long offsetIntoBlock) throws InvalidToken, IOException {\n-    try {\n-      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n-      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n-          accessToken, chosenNode, offsetIntoBlock, length);\n-    } catch (RemoteException re) {\n-      throw re.unwrapRemoteException(InvalidToken.class,\n-          AccessControlException.class);\n+  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n+    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"the address \" + inetSocketAddress + \" is not local\");\n+      }\n+      return null;\n+    }\n+    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"disableLegacyBlockReaderLocal is set.\");\n+      }\n+      return null;\n+    }\n+    IOException ioe \u003d null;\n+    try {\n+      return BlockReaderLocalLegacy.newBlockReader(conf,\n+          userGroupInformation, configuration, fileName, block, token,\n+          datanode, startOffset, length);\n+    } catch (RemoteException remoteException) {\n+      ioe \u003d remoteException.unwrapRemoteException(\n+                InvalidToken.class, AccessControlException.class);\n+    } catch (IOException e) {\n+      ioe \u003d e;\n+    }\n+    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n+        isSecurityException(ioe)) {\n+      // Handle security exceptions.\n+      // We do not handle AccessControlException here, since\n+      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n+      // that the user is not in dfs.block.local-path-access.user, a condition\n+      // which requires us to disable legacy SCR.\n+      throw ioe;\n+    }\n+    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n+        \"Disabling legacy local reads.\", ioe);\n+    clientContext.setDisableLegacyBlockReaderLocal();\n+    return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\");\n      }\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {
            "oldValue": "[InvalidToken, IOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/02/14 11:08 AM",
          "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "17/12/13 12:57 PM",
          "commitNameOld": "124e507674c0d396f8494585e64226957199097b",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 56.92,
          "commitsBetweenForRepo": 308,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,43 @@\n-  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n-      String src, ExtendedBlock blk,\n-      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n-      long offsetIntoBlock) throws InvalidToken, IOException {\n-    try {\n-      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n-      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n-          accessToken, chosenNode, offsetIntoBlock, length);\n-    } catch (RemoteException re) {\n-      throw re.unwrapRemoteException(InvalidToken.class,\n-          AccessControlException.class);\n+  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n     }\n+    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"the address \" + inetSocketAddress + \" is not local\");\n+      }\n+      return null;\n+    }\n+    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n+            \"disableLegacyBlockReaderLocal is set.\");\n+      }\n+      return null;\n+    }\n+    IOException ioe \u003d null;\n+    try {\n+      return BlockReaderLocalLegacy.newBlockReader(conf,\n+          userGroupInformation, configuration, fileName, block, token,\n+          datanode, startOffset, length);\n+    } catch (RemoteException remoteException) {\n+      ioe \u003d remoteException.unwrapRemoteException(\n+                InvalidToken.class, AccessControlException.class);\n+    } catch (IOException e) {\n+      ioe \u003d e;\n+    }\n+    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n+        isSecurityException(ioe)) {\n+      // Handle security exceptions.\n+      // We do not handle AccessControlException here, since\n+      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n+      // that the user is not in dfs.block.local-path-access.user, a condition\n+      // which requires us to disable legacy SCR.\n+      throw ioe;\n+    }\n+    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n+        \"Disabling legacy local reads.\", ioe);\n+    clientContext.setDisableLegacyBlockReaderLocal();\n+    return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockReader getLegacyBlockReaderLocal() throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct BlockReaderLocalLegacy\");\n    }\n    if (!DFSClient.isLocalAddress(inetSocketAddress)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"the address \" + inetSocketAddress + \" is not local\");\n      }\n      return null;\n    }\n    if (clientContext.getDisableLegacyBlockReaderLocal()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": can\u0027t construct BlockReaderLocalLegacy because \" +\n            \"disableLegacyBlockReaderLocal is set.\");\n      }\n      return null;\n    }\n    IOException ioe \u003d null;\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf,\n          userGroupInformation, configuration, fileName, block, token,\n          datanode, startOffset, length);\n    } catch (RemoteException remoteException) {\n      ioe \u003d remoteException.unwrapRemoteException(\n                InvalidToken.class, AccessControlException.class);\n    } catch (IOException e) {\n      ioe \u003d e;\n    }\n    if ((!(ioe instanceof AccessControlException)) \u0026\u0026\n        isSecurityException(ioe)) {\n      // Handle security exceptions.\n      // We do not handle AccessControlException here, since\n      // BlockReaderLocalLegacy#newBlockReader uses that exception to indicate\n      // that the user is not in dfs.block.local-path-access.user, a condition\n      // which requires us to disable legacy SCR.\n      throw ioe;\n    }\n    LOG.warn(this + \": error creating legacy BlockReaderLocal.  \" +\n        \"Disabling legacy local reads.\", ioe);\n    clientContext.setDisableLegacyBlockReaderLocal();\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {}
        }
      ]
    },
    "c68b1d1b31e304c27e419e810ded0fc97e435ea6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-4914. Use DFSClient.Conf instead of Configuration.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494854 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/06/13 9:43 PM",
      "commitName": "c68b1d1b31e304c27e419e810ded0fc97e435ea6",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-4914. Use DFSClient.Conf instead of Configuration.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494854 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/06/13 9:43 PM",
          "commitName": "c68b1d1b31e304c27e419e810ded0fc97e435ea6",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "09/05/13 5:03 PM",
          "commitNameOld": "a18fd620d070cf8e84aaf80d93807ac9ee207a0f",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 41.19,
          "commitsBetweenForRepo": 285,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,13 @@\n-  static BlockReader getLegacyBlockReaderLocal(UserGroupInformation ugi,\n-      Configuration conf, String src, ExtendedBlock blk,\n+  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n+      String src, ExtendedBlock blk,\n       Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n-      int socketTimeout, long offsetIntoBlock,\n-      boolean connectToDnViaHostname) throws InvalidToken, IOException {\n+      long offsetIntoBlock) throws InvalidToken, IOException {\n     try {\n-      return BlockReaderLocalLegacy.newBlockReader(ugi, conf, src,\n-          blk, accessToken, chosenNode, socketTimeout, offsetIntoBlock,\n-          blk.getNumBytes() - offsetIntoBlock, connectToDnViaHostname);\n+      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n+      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n+          accessToken, chosenNode, offsetIntoBlock, length);\n     } catch (RemoteException re) {\n       throw re.unwrapRemoteException(InvalidToken.class,\n           AccessControlException.class);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n      String src, ExtendedBlock blk,\n      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n      long offsetIntoBlock) throws InvalidToken, IOException {\n    try {\n      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n          accessToken, chosenNode, offsetIntoBlock, length);\n    } catch (RemoteException re) {\n      throw re.unwrapRemoteException(InvalidToken.class,\n          AccessControlException.class);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation, conf-Configuration, src-String, blk-ExtendedBlock, accessToken-Token\u003cBlockTokenIdentifier\u003e, chosenNode-DatanodeInfo, socketTimeout-int, offsetIntoBlock-long, connectToDnViaHostname-boolean]",
            "newValue": "[dfsClient-DFSClient, src-String, blk-ExtendedBlock, accessToken-Token\u003cBlockTokenIdentifier\u003e, chosenNode-DatanodeInfo, offsetIntoBlock-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4914. Use DFSClient.Conf instead of Configuration.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494854 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/06/13 9:43 PM",
          "commitName": "c68b1d1b31e304c27e419e810ded0fc97e435ea6",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "09/05/13 5:03 PM",
          "commitNameOld": "a18fd620d070cf8e84aaf80d93807ac9ee207a0f",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 41.19,
          "commitsBetweenForRepo": 285,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,13 @@\n-  static BlockReader getLegacyBlockReaderLocal(UserGroupInformation ugi,\n-      Configuration conf, String src, ExtendedBlock blk,\n+  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n+      String src, ExtendedBlock blk,\n       Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n-      int socketTimeout, long offsetIntoBlock,\n-      boolean connectToDnViaHostname) throws InvalidToken, IOException {\n+      long offsetIntoBlock) throws InvalidToken, IOException {\n     try {\n-      return BlockReaderLocalLegacy.newBlockReader(ugi, conf, src,\n-          blk, accessToken, chosenNode, socketTimeout, offsetIntoBlock,\n-          blk.getNumBytes() - offsetIntoBlock, connectToDnViaHostname);\n+      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n+      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n+          accessToken, chosenNode, offsetIntoBlock, length);\n     } catch (RemoteException re) {\n       throw re.unwrapRemoteException(InvalidToken.class,\n           AccessControlException.class);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockReader getLegacyBlockReaderLocal(DFSClient dfsClient,\n      String src, ExtendedBlock blk,\n      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n      long offsetIntoBlock) throws InvalidToken, IOException {\n    try {\n      final long length \u003d blk.getNumBytes() - offsetIntoBlock;\n      return BlockReaderLocalLegacy.newBlockReader(dfsClient, src, blk,\n          accessToken, chosenNode, offsetIntoBlock, length);\n    } catch (RemoteException re) {\n      throw re.unwrapRemoteException(InvalidToken.class,\n          AccessControlException.class);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {}
        }
      ]
    },
    "bbb24fbf5d220fbe137d43651ba3802a9806b1a3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Merge trunk into branch.\n\nConflicts resolved:\nC       hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/TestShortCircuitLocalRead.java\n!     C hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/SocketCache.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSClient.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java\n\n(thanks to Colin for help resolving)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1462652 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/03/13 2:33 PM",
      "commitName": "bbb24fbf5d220fbe137d43651ba3802a9806b1a3",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Merge trunk into branch.\n\nConflicts resolved:\nC       hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/TestShortCircuitLocalRead.java\n!     C hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/SocketCache.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSClient.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java\n\n(thanks to Colin for help resolving)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1462652 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/03/13 2:33 PM",
          "commitName": "bbb24fbf5d220fbe137d43651ba3802a9806b1a3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "27/03/13 12:28 PM",
          "commitNameOld": "694a6721316aea14c1244447974231abc8dff0cb",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 2.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,14 @@\n-  static BlockReader getLegacyBlockReaderLocal(Configuration conf,\n-      String src, ExtendedBlock blk, Token\u003cBlockTokenIdentifier\u003e accessToken,\n-      DatanodeInfo chosenNode, int socketTimeout, long offsetIntoBlock,\n+  static BlockReader getLegacyBlockReaderLocal(UserGroupInformation ugi,\n+      Configuration conf, String src, ExtendedBlock blk,\n+      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n+      int socketTimeout, long offsetIntoBlock,\n       boolean connectToDnViaHostname) throws InvalidToken, IOException {\n     try {\n-      return BlockReaderLocalLegacy.newBlockReader(conf, src, blk, accessToken,\n-          chosenNode, socketTimeout, offsetIntoBlock, blk.getNumBytes()\n-              - offsetIntoBlock, connectToDnViaHostname);\n+      return BlockReaderLocalLegacy.newBlockReader(ugi, conf, src,\n+          blk, accessToken, chosenNode, socketTimeout, offsetIntoBlock,\n+          blk.getNumBytes() - offsetIntoBlock, connectToDnViaHostname);\n     } catch (RemoteException re) {\n       throw re.unwrapRemoteException(InvalidToken.class,\n           AccessControlException.class);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockReader getLegacyBlockReaderLocal(UserGroupInformation ugi,\n      Configuration conf, String src, ExtendedBlock blk,\n      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n      int socketTimeout, long offsetIntoBlock,\n      boolean connectToDnViaHostname) throws InvalidToken, IOException {\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(ugi, conf, src,\n          blk, accessToken, chosenNode, socketTimeout, offsetIntoBlock,\n          blk.getNumBytes() - offsetIntoBlock, connectToDnViaHostname);\n    } catch (RemoteException re) {\n      throw re.unwrapRemoteException(InvalidToken.class,\n          AccessControlException.class);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {
            "oldValue": "[conf-Configuration, src-String, blk-ExtendedBlock, accessToken-Token\u003cBlockTokenIdentifier\u003e, chosenNode-DatanodeInfo, socketTimeout-int, offsetIntoBlock-long, connectToDnViaHostname-boolean]",
            "newValue": "[ugi-UserGroupInformation, conf-Configuration, src-String, blk-ExtendedBlock, accessToken-Token\u003cBlockTokenIdentifier\u003e, chosenNode-DatanodeInfo, socketTimeout-int, offsetIntoBlock-long, connectToDnViaHostname-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Merge trunk into branch.\n\nConflicts resolved:\nC       hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/TestShortCircuitLocalRead.java\n!     C hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/SocketCache.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSClient.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java\nC       hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java\n\n(thanks to Colin for help resolving)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1462652 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/03/13 2:33 PM",
          "commitName": "bbb24fbf5d220fbe137d43651ba3802a9806b1a3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "27/03/13 12:28 PM",
          "commitNameOld": "694a6721316aea14c1244447974231abc8dff0cb",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 2.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,14 @@\n-  static BlockReader getLegacyBlockReaderLocal(Configuration conf,\n-      String src, ExtendedBlock blk, Token\u003cBlockTokenIdentifier\u003e accessToken,\n-      DatanodeInfo chosenNode, int socketTimeout, long offsetIntoBlock,\n+  static BlockReader getLegacyBlockReaderLocal(UserGroupInformation ugi,\n+      Configuration conf, String src, ExtendedBlock blk,\n+      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n+      int socketTimeout, long offsetIntoBlock,\n       boolean connectToDnViaHostname) throws InvalidToken, IOException {\n     try {\n-      return BlockReaderLocalLegacy.newBlockReader(conf, src, blk, accessToken,\n-          chosenNode, socketTimeout, offsetIntoBlock, blk.getNumBytes()\n-              - offsetIntoBlock, connectToDnViaHostname);\n+      return BlockReaderLocalLegacy.newBlockReader(ugi, conf, src,\n+          blk, accessToken, chosenNode, socketTimeout, offsetIntoBlock,\n+          blk.getNumBytes() - offsetIntoBlock, connectToDnViaHostname);\n     } catch (RemoteException re) {\n       throw re.unwrapRemoteException(InvalidToken.class,\n           AccessControlException.class);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockReader getLegacyBlockReaderLocal(UserGroupInformation ugi,\n      Configuration conf, String src, ExtendedBlock blk,\n      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeInfo chosenNode,\n      int socketTimeout, long offsetIntoBlock,\n      boolean connectToDnViaHostname) throws InvalidToken, IOException {\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(ugi, conf, src,\n          blk, accessToken, chosenNode, socketTimeout, offsetIntoBlock,\n          blk.getNumBytes() - offsetIntoBlock, connectToDnViaHostname);\n    } catch (RemoteException re) {\n      throw re.unwrapRemoteException(InvalidToken.class,\n          AccessControlException.class);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {}
        }
      ]
    },
    "694a6721316aea14c1244447974231abc8dff0cb": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4538. Allow use of legacy blockreader. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1461818 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/03/13 12:28 PM",
      "commitName": "694a6721316aea14c1244447974231abc8dff0cb",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,13 @@\n+  static BlockReader getLegacyBlockReaderLocal(Configuration conf,\n+      String src, ExtendedBlock blk, Token\u003cBlockTokenIdentifier\u003e accessToken,\n+      DatanodeInfo chosenNode, int socketTimeout, long offsetIntoBlock,\n+      boolean connectToDnViaHostname) throws InvalidToken, IOException {\n+    try {\n+      return BlockReaderLocalLegacy.newBlockReader(conf, src, blk, accessToken,\n+          chosenNode, socketTimeout, offsetIntoBlock, blk.getNumBytes()\n+              - offsetIntoBlock, connectToDnViaHostname);\n+    } catch (RemoteException re) {\n+      throw re.unwrapRemoteException(InvalidToken.class,\n+          AccessControlException.class);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static BlockReader getLegacyBlockReaderLocal(Configuration conf,\n      String src, ExtendedBlock blk, Token\u003cBlockTokenIdentifier\u003e accessToken,\n      DatanodeInfo chosenNode, int socketTimeout, long offsetIntoBlock,\n      boolean connectToDnViaHostname) throws InvalidToken, IOException {\n    try {\n      return BlockReaderLocalLegacy.newBlockReader(conf, src, blk, accessToken,\n          chosenNode, socketTimeout, offsetIntoBlock, blk.getNumBytes()\n              - offsetIntoBlock, connectToDnViaHostname);\n    } catch (RemoteException re) {\n      throw re.unwrapRemoteException(InvalidToken.class,\n          AccessControlException.class);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
    }
  }
}