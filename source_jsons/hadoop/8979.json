{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystem.java",
  "functionName": "stopActiveServices",
  "functionId": "stopActiveServices",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
  "functionStartLine": 1427,
  "functionEndLine": 1476,
  "numCommitsSeen": 873,
  "timeTaken": 51117,
  "changeHistory": [
    "39ed3a66dbb01383ed16b141183fc48bfd2e613d",
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
    "4402f3f8557527d5c6cdad6f5bdcbd707b8cbf52",
    "7ea24fc06c081e2ba6f5f66d212abb14b80c9064",
    "0e820f16af309cc8476edba448dd548686431133",
    "11a08a7e8f727449f17d1e31855996353b2975fe",
    "681d2804c95e5a569ffb8d9ceafaf5a4f8be2b88",
    "1000a2af04b24c123a3b08168f36b4e90420cab7",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893",
    "e3bb38d62567eafe57d16b78deeba1b71c58e41c",
    "715b9c649982bff91d1f9eae656ba3b82178e1a3",
    "d45aa7647b1fecf81860ec7b563085be2af99a0b",
    "2e987148e02d0087fc70ce5b1ce571d3324bf1dd",
    "9ca79e8d327e95845ef9794396afd43a52bc3d40",
    "ac23a55547716df29b3e25c98a113399e184d9d1",
    "f36f0dde8866e2233dad26b38a8d432d2302a51a",
    "d85c017d0488930d806f267141057fc73e68c728",
    "788fca4124ecac818a20bfc2607676849cf0d94f",
    "3c591aa442d342bdd4a0c4abe9a43c64d8ef3e65",
    "3b91b7dece84b563a4b7cf66c245b7c5ee094578",
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
    "b98e26af58b78d0cfb233b2b596ebf71b3e148fb"
  ],
  "changeHistoryShort": {
    "39ed3a66dbb01383ed16b141183fc48bfd2e613d": "Ybodychange",
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d": "Ybodychange",
    "4402f3f8557527d5c6cdad6f5bdcbd707b8cbf52": "Ybodychange",
    "7ea24fc06c081e2ba6f5f66d212abb14b80c9064": "Ybodychange",
    "0e820f16af309cc8476edba448dd548686431133": "Ybodychange",
    "11a08a7e8f727449f17d1e31855996353b2975fe": "Ybodychange",
    "681d2804c95e5a569ffb8d9ceafaf5a4f8be2b88": "Ybodychange",
    "1000a2af04b24c123a3b08168f36b4e90420cab7": "Ybodychange",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": "Ybodychange",
    "e3bb38d62567eafe57d16b78deeba1b71c58e41c": "Ybodychange",
    "715b9c649982bff91d1f9eae656ba3b82178e1a3": "Ybodychange",
    "d45aa7647b1fecf81860ec7b563085be2af99a0b": "Ybodychange",
    "2e987148e02d0087fc70ce5b1ce571d3324bf1dd": "Ybodychange",
    "9ca79e8d327e95845ef9794396afd43a52bc3d40": "Ybodychange",
    "ac23a55547716df29b3e25c98a113399e184d9d1": "Ybodychange",
    "f36f0dde8866e2233dad26b38a8d432d2302a51a": "Ybodychange",
    "d85c017d0488930d806f267141057fc73e68c728": "Ybodychange",
    "788fca4124ecac818a20bfc2607676849cf0d94f": "Ybodychange",
    "3c591aa442d342bdd4a0c4abe9a43c64d8ef3e65": "Ybodychange",
    "3b91b7dece84b563a4b7cf66c245b7c5ee094578": "Ybodychange",
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a": "Ybodychange",
    "b98e26af58b78d0cfb233b2b596ebf71b3e148fb": "Ybodychange"
  },
  "changeHistoryDetails": {
    "39ed3a66dbb01383ed16b141183fc48bfd2e613d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13076: [SPS]: Cleanup work for HDFS-10285 merge. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "39ed3a66dbb01383ed16b141183fc48bfd2e613d",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "66e8f9b31529226309c924226a53dead3e6fcf11",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,50 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       if (blockManager !\u003d null \u0026\u0026 blockManager.getSPSManager() !\u003d null) {\n         blockManager.getSPSManager().stop();\n       }\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (dir !\u003d null) {\n         dir.ezManager.stopReencryptThread();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n-        if (blockManager.getSPSManager() !\u003d null) {\n-          blockManager.getSPSManager().stopGracefully();\n-        }\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      if (blockManager !\u003d null \u0026\u0026 blockManager.getSPSManager() !\u003d null) {\n        blockManager.getSPSManager().stop();\n      }\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13165: [SPS]: Collects successfully moved block details via IBR. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "4402f3f8557527d5c6cdad6f5bdcbd707b8cbf52",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,53 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n-      if (blockManager !\u003d null) {\n+      if (blockManager !\u003d null \u0026\u0026 blockManager.getSPSManager() !\u003d null) {\n         blockManager.getSPSManager().stop();\n       }\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (dir !\u003d null) {\n         dir.ezManager.stopReencryptThread();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n-        blockManager.getSPSManager().stopGracefully();\n+        if (blockManager.getSPSManager() !\u003d null) {\n+          blockManager.getSPSManager().stopGracefully();\n+        }\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      if (blockManager !\u003d null \u0026\u0026 blockManager.getSPSManager() !\u003d null) {\n        blockManager.getSPSManager().stop();\n      }\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n        if (blockManager.getSPSManager() !\u003d null) {\n          blockManager.getSPSManager().stopGracefully();\n        }\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "4402f3f8557527d5c6cdad6f5bdcbd707b8cbf52": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13097: [SPS]: Fix the branch review comments(Part1). Contributed by Surendra Singh.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "4402f3f8557527d5c6cdad6f5bdcbd707b8cbf52",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "d3de4fb2a084cbadab8ef91f11aa7732d3b0f308",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       if (blockManager !\u003d null) {\n-        blockManager.stopSPS(false);\n+        blockManager.getSPSManager().stop();\n       }\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (dir !\u003d null) {\n         dir.ezManager.stopReencryptThread();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n-        blockManager.stopSPSGracefully();\n+        blockManager.getSPSManager().stopGracefully();\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      if (blockManager !\u003d null) {\n        blockManager.getSPSManager().stop();\n      }\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n        blockManager.getSPSManager().stopGracefully();\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "7ea24fc06c081e2ba6f5f66d212abb14b80c9064": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12225: [SPS]: Optimize extended attributes for tracking SPS movements. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "7ea24fc06c081e2ba6f5f66d212abb14b80c9064",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "0e820f16af309cc8476edba448dd548686431133",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       if (blockManager !\u003d null) {\n-        blockManager.stopSPS(true);\n+        blockManager.stopSPS(false);\n       }\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (dir !\u003d null) {\n         dir.ezManager.stopReencryptThread();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n         blockManager.stopSPSGracefully();\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      if (blockManager !\u003d null) {\n        blockManager.stopSPS(false);\n      }\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n        blockManager.stopSPSGracefully();\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "0e820f16af309cc8476edba448dd548686431133": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12214: [SPS]: Fix review comments of StoragePolicySatisfier feature. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "0e820f16af309cc8476edba448dd548686431133",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "5ce332dc9a072f8850ab71ba16898faf8e866c06",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       if (blockManager !\u003d null) {\n-        blockManager.deactivateSPS();\n+        blockManager.stopSPS(true);\n       }\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (dir !\u003d null) {\n         dir.ezManager.stopReencryptThread();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n         blockManager.stopSPSGracefully();\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      if (blockManager !\u003d null) {\n        blockManager.stopSPS(true);\n      }\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n        blockManager.stopSPSGracefully();\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "11a08a7e8f727449f17d1e31855996353b2975fe": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11338: [SPS]: Fix timeout issue in unit tests caused by longger NN down time. Contributed by Wei Zhou and Rakesh R\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "11a08a7e8f727449f17d1e31855996353b2975fe",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "9b15f5418dbb49de57922f00858cb6fb0b61826e",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       if (blockManager !\u003d null) {\n         blockManager.deactivateSPS();\n       }\n-\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (dir !\u003d null) {\n         dir.ezManager.stopReencryptThread();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n+        blockManager.stopSPSGracefully();\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      if (blockManager !\u003d null) {\n        blockManager.deactivateSPS();\n      }\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n        blockManager.stopSPSGracefully();\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "681d2804c95e5a569ffb8d9ceafaf5a4f8be2b88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11186. [SPS]: Daemon thread of SPS should start only in Active NN. Contributed by Wei Zhou\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "681d2804c95e5a569ffb8d9ceafaf5a4f8be2b88",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "6215e35bb633706753a464ad3e8633366e6a10b2",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,51 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n+      if (blockManager !\u003d null) {\n+        blockManager.deactivateSPS();\n+      }\n+\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (dir !\u003d null) {\n         dir.ezManager.stopReencryptThread();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      if (blockManager !\u003d null) {\n        blockManager.deactivateSPS();\n      }\n\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1000a2af04b24c123a3b08168f36b4e90420cab7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10899. Add functionality to re-encrypt EDEKs.\n",
      "commitDate": "23/08/17 5:06 PM",
      "commitName": "1000a2af04b24c123a3b08168f36b4e90420cab7",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "16/08/17 9:20 PM",
      "commitNameOld": "08aaa4b36fab44c3f47878b3c487db3b373ffccf",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 6.82,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,47 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n+      if (dir !\u003d null) {\n+        dir.ezManager.stopReencryptThread();\n+      }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n       }\n     } finally {\n       writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (dir !\u003d null) {\n        dir.ezManager.stopReencryptThread();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
      "commitDate": "14/11/16 11:05 AM",
      "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "08/11/16 6:17 PM",
      "commitNameOld": "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (edekCacheLoader !\u003d null) {\n         edekCacheLoader.shutdownNow();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n       }\n     } finally {\n-      writeUnlock();\n+      writeUnlock(\"stopActiveServices\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n      }\n    } finally {\n      writeUnlock(\"stopActiveServices\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "e3bb38d62567eafe57d16b78deeba1b71c58e41c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9405. Warmup NameNode EDEK caches in background thread. Contributed by Xiao Chen.\n",
      "commitDate": "21/03/16 11:39 AM",
      "commitName": "e3bb38d62567eafe57d16b78deeba1b71c58e41c",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "04/03/16 3:29 PM",
      "commitNameOld": "2759689d7d23001f007cb0dbe2521de90734dd5c",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 16.8,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,44 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n+      if (edekCacheLoader !\u003d null) {\n+        edekCacheLoader.shutdownNow();\n+      }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n         blockManager.setInitializedReplQueues(false);\n       }\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (edekCacheLoader !\u003d null) {\n        edekCacheLoader.shutdownNow();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n      }\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "715b9c649982bff91d1f9eae656ba3b82178e1a3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8984. Move replication queues related methods in FSNamesystem to BlockManager. Contributed by Haohui Mai.\n",
      "commitDate": "04/09/15 11:45 AM",
      "commitName": "715b9c649982bff91d1f9eae656ba3b82178e1a3",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "04/09/15 11:42 AM",
      "commitNameOld": "8928729c80af0a154524e06fb13ed9b191986a78",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       if (blockManager !\u003d null) {\n         blockManager.getDatanodeManager().clearPendingCachingCommands();\n         blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n         // Don\u0027t want to keep replication queues when not in Active.\n         blockManager.clearQueues();\n+        blockManager.setInitializedReplQueues(false);\n       }\n-      initializedReplQueues \u003d false;\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n        blockManager.setInitializedReplQueues(false);\n      }\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "d45aa7647b1fecf81860ec7b563085be2af99a0b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6666. Abort NameNode and DataNode startup if security is enabled but block access token is not enabled. Contributed by Vijay Bhat.\n",
      "commitDate": "14/04/15 9:59 AM",
      "commitName": "d45aa7647b1fecf81860ec7b563085be2af99a0b",
      "commitAuthor": "cnauroth",
      "commitDateOld": "10/04/15 4:36 PM",
      "commitNameOld": "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.72,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,41 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (lazyPersistFileScrubber !\u003d null) {\n         ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n         lazyPersistFileScrubber.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n-      blockManager.getDatanodeManager().clearPendingCachingCommands();\n-      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n-      // Don\u0027t want to keep replication queues when not in Active.\n-      blockManager.clearQueues();\n+      if (blockManager !\u003d null) {\n+        blockManager.getDatanodeManager().clearPendingCachingCommands();\n+        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n+        // Don\u0027t want to keep replication queues when not in Active.\n+        blockManager.clearQueues();\n+      }\n       initializedReplQueues \u003d false;\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      if (blockManager !\u003d null) {\n        blockManager.getDatanodeManager().clearPendingCachingCommands();\n        blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n        // Don\u0027t want to keep replication queues when not in Active.\n        blockManager.clearQueues();\n      }\n      initializedReplQueues \u003d false;\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2e987148e02d0087fc70ce5b1ce571d3324bf1dd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6929. NN periodically unlinks lazy persist files with missing replicas from namespace. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "2e987148e02d0087fc70ce5b1ce571d3324bf1dd",
      "commitAuthor": "arp",
      "commitDateOld": "27/08/14 9:47 PM",
      "commitNameOld": "042b33f20b01aadb5cd03da731ae7a3d94026aac",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,39 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n+      if (lazyPersistFileScrubber !\u003d null) {\n+        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n+        lazyPersistFileScrubber.interrupt();\n+      }\n       if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n         if (getFSImage().editLog !\u003d null) {\n           getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       blockManager.getDatanodeManager().clearPendingCachingCommands();\n       blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n       // Don\u0027t want to keep replication queues when not in Active.\n       blockManager.clearQueues();\n       initializedReplQueues \u003d false;\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (lazyPersistFileScrubber !\u003d null) {\n        ((LazyPersistFileScrubber) lazyPersistFileScrubber.getRunnable()).stop();\n        lazyPersistFileScrubber.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      blockManager.getDatanodeManager().clearPendingCachingCommands();\n      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n      // Don\u0027t want to keep replication queues when not in Active.\n      blockManager.clearQueues();\n      initializedReplQueues \u003d false;\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "9ca79e8d327e95845ef9794396afd43a52bc3d40": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6557. Move the reference of fsimage to FSNamesystem. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1604242 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/06/14 11:54 AM",
      "commitName": "9ca79e8d327e95845ef9794396afd43a52bc3d40",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "20/06/14 11:25 AM",
      "commitNameOld": "d9eb18bb2e6c25ecc3acaaa2f7e53aff1d795edd",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n-      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n-        if (dir.fsImage.editLog !\u003d null) {\n-          dir.fsImage.editLog.close();\n+      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n+        if (getFSImage().editLog !\u003d null) {\n+          getFSImage().editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n-        dir.fsImage.updateLastAppliedTxIdFromWritten();\n+        getFSImage().updateLastAppliedTxIdFromWritten();\n       }\n       if (cacheManager !\u003d null) {\n         cacheManager.stopMonitorThread();\n         cacheManager.clearDirectiveStats();\n       }\n       blockManager.getDatanodeManager().clearPendingCachingCommands();\n       blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n       // Don\u0027t want to keep replication queues when not in Active.\n       blockManager.clearQueues();\n       initializedReplQueues \u003d false;\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 getFSImage() !\u003d null) {\n        if (getFSImage().editLog !\u003d null) {\n          getFSImage().editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        getFSImage().updateLastAppliedTxIdFromWritten();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      blockManager.getDatanodeManager().clearPendingCachingCommands();\n      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n      // Don\u0027t want to keep replication queues when not in Active.\n      blockManager.clearQueues();\n      initializedReplQueues \u003d false;\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ac23a55547716df29b3e25c98a113399e184d9d1": {
      "type": "Ybodychange",
      "commitMessage": "Merge HDFS-2006 HDFS XAttrs branch to Trunk\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596575 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 6:57 AM",
      "commitName": "ac23a55547716df29b3e25c98a113399e184d9d1",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "18/05/14 10:24 PM",
      "commitNameOld": "9a0ed1c4afd95827c6ff27490f33d0b86851e551",
      "commitAuthorOld": "Konstantin Boudnik",
      "daysBetweenCommits": 2.36,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,35 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n-      cacheManager.stopMonitorThread();\n-      cacheManager.clearDirectiveStats();\n+      if (cacheManager !\u003d null) {\n+        cacheManager.stopMonitorThread();\n+        cacheManager.clearDirectiveStats();\n+      }\n       blockManager.getDatanodeManager().clearPendingCachingCommands();\n       blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n       // Don\u0027t want to keep replication queues when not in Active.\n       blockManager.clearQueues();\n       initializedReplQueues \u003d false;\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n      if (cacheManager !\u003d null) {\n        cacheManager.stopMonitorThread();\n        cacheManager.clearDirectiveStats();\n      }\n      blockManager.getDatanodeManager().clearPendingCachingCommands();\n      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n      // Don\u0027t want to keep replication queues when not in Active.\n      blockManager.clearQueues();\n      initializedReplQueues \u003d false;\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "f36f0dde8866e2233dad26b38a8d432d2302a51a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6276. Remove unnecessary conditions and null check. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1589586 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/14 10:05 PM",
      "commitName": "f36f0dde8866e2233dad26b38a8d432d2302a51a",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "23/04/14 1:13 PM",
      "commitNameOld": "876fd8ab7913a259ff9f69c16cc2d9af46ad3f9b",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,33 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n-      if (leaseManager !\u003d null) {\n-        leaseManager.stopMonitor();\n-      }\n+      leaseManager.stopMonitor();\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n       cacheManager.stopMonitorThread();\n       cacheManager.clearDirectiveStats();\n       blockManager.getDatanodeManager().clearPendingCachingCommands();\n       blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n       // Don\u0027t want to keep replication queues when not in Active.\n       blockManager.clearQueues();\n       initializedReplQueues \u003d false;\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      leaseManager.stopMonitor();\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n      cacheManager.stopMonitorThread();\n      cacheManager.clearDirectiveStats();\n      blockManager.getDatanodeManager().clearPendingCachingCommands();\n      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n      // Don\u0027t want to keep replication queues when not in Active.\n      blockManager.clearQueues();\n      initializedReplQueues \u003d false;\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "d85c017d0488930d806f267141057fc73e68c728": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5651. Remove dfs.namenode.caching.enabled and improve CRM locking. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1555002 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 6:45 PM",
      "commitName": "d85c017d0488930d806f267141057fc73e68c728",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "20/12/13 8:05 AM",
      "commitNameOld": "04d139e2a0e61a62471556255fc9a65792fa373c",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 13.45,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,32 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       if (leaseManager !\u003d null) {\n         leaseManager.stopMonitor();\n       }\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n-      cacheManager.deactivate();\n+      cacheManager.stopMonitorThread();\n+      cacheManager.clearDirectiveStats();\n+      blockManager.getDatanodeManager().clearPendingCachingCommands();\n       blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      if (leaseManager !\u003d null) {\n        leaseManager.stopMonitor();\n      }\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n      cacheManager.stopMonitorThread();\n      cacheManager.clearDirectiveStats();\n      blockManager.getDatanodeManager().clearPendingCachingCommands();\n      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "788fca4124ecac818a20bfc2607676849cf0d94f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5496. Make replication queue initialization asynchronous. Contributed by Vinay.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1552109 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/12/13 1:30 PM",
      "commitName": "788fca4124ecac818a20bfc2607676849cf0d94f",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/12/13 10:17 PM",
      "commitNameOld": "4c87a27ad851ffaa3cc3e2074a9ef7073b5a164a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 11.63,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,33 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       if (leaseManager !\u003d null) {\n         leaseManager.stopMonitor();\n       }\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n       cacheManager.deactivate();\n       blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n+      // Don\u0027t want to keep replication queues when not in Active.\n+      blockManager.clearQueues();\n+      initializedReplQueues \u003d false;\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      if (leaseManager !\u003d null) {\n        leaseManager.stopMonitor();\n      }\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n      cacheManager.deactivate();\n      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n      // Don\u0027t want to keep replication queues when not in Active.\n      blockManager.clearQueues();\n      initializedReplQueues \u003d false;\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "3c591aa442d342bdd4a0c4abe9a43c64d8ef3e65": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5366. recaching improvements (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1541647 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/13 10:18 AM",
      "commitName": "3c591aa442d342bdd4a0c4abe9a43c64d8ef3e65",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "12/11/13 2:10 PM",
      "commitNameOld": "8162fdcdbc23d749fdb188ae8419e173c59cb1ed",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       if (leaseManager !\u003d null) {\n         leaseManager.stopMonitor();\n       }\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (nnEditLogRoller !\u003d null) {\n         ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n         nnEditLogRoller.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n       cacheManager.deactivate();\n-      blockManager.getDatanodeManager().setSendCachingCommands(false);\n+      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      if (leaseManager !\u003d null) {\n        leaseManager.stopMonitor();\n      }\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n      cacheManager.deactivate();\n      blockManager.getDatanodeManager().setShouldSendCachingCommands(false);\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "3b91b7dece84b563a4b7cf66c245b7c5ee094578": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5037. Active NN should trigger its own edit log rolls. Contributed by Andrew Wang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1538059 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/11/13 1:49 PM",
      "commitName": "3b91b7dece84b563a4b7cf66c245b7c5ee094578",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "30/10/13 10:27 AM",
      "commitNameOld": "75a162ff92d365d88ed253335b52aaa3709f6365",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.14,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,30 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       if (leaseManager !\u003d null) {\n         leaseManager.stopMonitor();\n       }\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n+      if (nnEditLogRoller !\u003d null) {\n+        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n+        nnEditLogRoller.interrupt();\n+      }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n       cacheManager.deactivate();\n       blockManager.getDatanodeManager().setSendCachingCommands(false);\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      if (leaseManager !\u003d null) {\n        leaseManager.stopMonitor();\n      }\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (nnEditLogRoller !\u003d null) {\n        ((NameNodeEditLogRoller)nnEditLogRoller.getRunnable()).stop();\n        nnEditLogRoller.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n      cacheManager.deactivate();\n      blockManager.getDatanodeManager().setSendCachingCommands(false);\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/10/13 3:15 PM",
      "commitName": "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "09/10/13 2:30 PM",
      "commitNameOld": "3fc8792b5c75fca9fc4f6cf4b95fb2927c62e624",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,26 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       if (leaseManager !\u003d null) {\n         leaseManager.stopMonitor();\n       }\n       if (nnrmthread !\u003d null) {\n         ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n         nnrmthread.interrupt();\n       }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n+      cacheManager.deactivate();\n+      blockManager.getDatanodeManager().setSendCachingCommands(false);\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      if (leaseManager !\u003d null) {\n        leaseManager.stopMonitor();\n      }\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n      cacheManager.deactivate();\n      blockManager.getDatanodeManager().setSendCachingCommands(false);\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "b98e26af58b78d0cfb233b2b596ebf71b3e148fb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2914. HA: Standby should not enter safemode when resources are low. Contributed by Vinay.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1347895 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/06/12 11:57 PM",
      "commitName": "b98e26af58b78d0cfb233b2b596ebf71b3e148fb",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "31/05/12 2:02 PM",
      "commitNameOld": "675a7e4acba1417a80e1403b468c32efe597ba90",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 7.41,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,24 @@\n   void stopActiveServices() {\n     LOG.info(\"Stopping services started for active state\");\n     writeLock();\n     try {\n       stopSecretManager();\n       if (leaseManager !\u003d null) {\n         leaseManager.stopMonitor();\n       }\n+      if (nnrmthread !\u003d null) {\n+        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n+        nnrmthread.interrupt();\n+      }\n       if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n         if (dir.fsImage.editLog !\u003d null) {\n           dir.fsImage.editLog.close();\n         }\n         // Update the fsimage with the last txid that we wrote\n         // so that the tailer starts from the right spot.\n         dir.fsImage.updateLastAppliedTxIdFromWritten();\n       }\n     } finally {\n       writeUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void stopActiveServices() {\n    LOG.info(\"Stopping services started for active state\");\n    writeLock();\n    try {\n      stopSecretManager();\n      if (leaseManager !\u003d null) {\n        leaseManager.stopMonitor();\n      }\n      if (nnrmthread !\u003d null) {\n        ((NameNodeResourceMonitor) nnrmthread.getRunnable()).stopMonitor();\n        nnrmthread.interrupt();\n      }\n      if (dir !\u003d null \u0026\u0026 dir.fsImage !\u003d null) {\n        if (dir.fsImage.editLog !\u003d null) {\n          dir.fsImage.editLog.close();\n        }\n        // Update the fsimage with the last txid that we wrote\n        // so that the tailer starts from the right spot.\n        dir.fsImage.updateLastAppliedTxIdFromWritten();\n      }\n    } finally {\n      writeUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    }
  }
}