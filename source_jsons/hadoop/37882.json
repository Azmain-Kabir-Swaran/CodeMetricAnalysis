{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AppNameMappingPlacementRule.java",
  "functionName": "initialize",
  "functionId": "initialize___scheduler-ResourceScheduler",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/AppNameMappingPlacementRule.java",
  "functionStartLine": 65,
  "functionEndLine": 155,
  "numCommitsSeen": 8,
  "timeTaken": 4473,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "a68d766e876631d7ee2e1a6504d4120ba628d178",
    "a2e49f41a8bcc03ce0a85b294d0b86fee7e86f31",
    "a90471b3e65326cc18ed31fe21aef654833b5883"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "a68d766e876631d7ee2e1a6504d4120ba628d178": "Ymultichange(Yparameterchange,Ybodychange)",
    "a2e49f41a8bcc03ce0a85b294d0b86fee7e86f31": "Ybodychange",
    "a90471b3e65326cc18ed31fe21aef654833b5883": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "11/08/19 10:14 PM",
      "commitNameOld": "8fbf8b2eb09448e49297c0e93a6e10ae489e8745",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 226.25,
      "commitsBetweenForRepo": 1122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n   public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n     if (!(scheduler instanceof CapacityScheduler)) {\n       throw new IOException(\n           \"AppNameMappingPlacementRule can be configured only for \"\n               + \"CapacityScheduler\");\n     }\n     CapacitySchedulerContext schedulerContext \u003d\n         (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMappingEntity\u003e queueMappings \u003d\n         conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n \n     // Get new user mappings\n     List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n-    CapacitySchedulerQueueManager queueManager \u003d\n-        schedulerContext.getCapacitySchedulerQueueManager();\n+    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMappingEntity mapping : queueMappings) {\n+      QueuePath queuePath \u003d mapping.getQueuePath();\n \n-      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n-        //Try getting queue by its leaf queue name\n-        // without splitting into parent/leaf queues\n-        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n-        if (ifQueueDoesNotExist(queue)) {\n-          //Try getting the queue by extracting leaf and parent queue names\n-          //Assuming its a potential auto created leaf queue\n-          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n+        //at this point mapping.getQueueName() return only the queue name, since\n+        //the config parsing have been changed making QueueMapping more\n+        //consistent\n \n-          if (ifQueueDoesNotExist(queue)) {\n-            //if leaf queue does not exist,\n-            // this could be a potential auto created leaf queue\n-            //validate if parent queue is specified,\n-            // then it should exist and\n-            // be an instance of AutoCreateEnabledParentQueue\n-            QueueMappingEntity newMapping \u003d\n-                validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n-                    queuePath);\n-            if (newMapping \u003d\u003d null) {\n-              throw new IOException(\n-                  \"mapping contains invalid or non-leaf queue \" + mapping\n-                      .getQueue());\n-            }\n-            newMappings.add(newMapping);\n-          } else{\n-            QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n-                queueManager, queue, mapping, queuePath);\n-            newMappings.add(newMapping);\n+        CSQueue queue \u003d queueManager.getQueue(mapping.getFullPath());\n+        if (ifQueueDoesNotExist(queue)) {\n+          //Try getting queue by its full path name, if it exists it is a static\n+          //leaf queue indeed, without any auto creation magic\n+\n+          if (queueManager.isAmbiguous(queuePath.getFullPath())) {\n+            throw new IOException(\n+              \"mapping contains ambiguous leaf queue reference \" + mapping\n+                .getFullPath());\n           }\n-        } else{\n+\n+          //if leaf queue does not exist,\n+          // this could be a potential auto created leaf queue\n+          //validate if parent queue is specified,\n+          // then it should exist and\n+          // be an instance of AutoCreateEnabledParentQueue\n+          QueueMappingEntity newMapping \u003d\n+              validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n+                  queuePath);\n+          if (newMapping \u003d\u003d null) {\n+            throw new IOException(\n+                \"mapping contains invalid or non-leaf queue \" + mapping\n+                    .getQueue());\n+          }\n+          newMappings.add(newMapping);\n+        } else {\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n               queueManager, queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n-      } else{\n+      } else {\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     if (newMappings.size() \u003e 0) {\n       this.mappings \u003d newMappings;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       LOG.info(\"get valid queue mapping from app name config: \" +\n           newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"AppNameMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMappingEntity\u003e queueMappings \u003d\n        conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n\n    // Get new user mappings\n    List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMappingEntity mapping : queueMappings) {\n      QueuePath queuePath \u003d mapping.getQueuePath();\n\n      if (isStaticQueueMapping(mapping)) {\n        //at this point mapping.getQueueName() return only the queue name, since\n        //the config parsing have been changed making QueueMapping more\n        //consistent\n\n        CSQueue queue \u003d queueManager.getQueue(mapping.getFullPath());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting queue by its full path name, if it exists it is a static\n          //leaf queue indeed, without any auto creation magic\n\n          if (queueManager.isAmbiguous(queuePath.getFullPath())) {\n            throw new IOException(\n              \"mapping contains ambiguous leaf queue reference \" + mapping\n                .getFullPath());\n          }\n\n          //if leaf queue does not exist,\n          // this could be a potential auto created leaf queue\n          //validate if parent queue is specified,\n          // then it should exist and\n          // be an instance of AutoCreateEnabledParentQueue\n          QueueMappingEntity newMapping \u003d\n              validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                  queuePath);\n          if (newMapping \u003d\u003d null) {\n            throw new IOException(\n                \"mapping contains invalid or non-leaf queue \" + mapping\n                    .getQueue());\n          }\n          newMappings.add(newMapping);\n        } else {\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n              queueManager, queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else {\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      LOG.info(\"get valid queue mapping from app name config: \" +\n          newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/AppNameMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "a68d766e876631d7ee2e1a6504d4120ba628d178": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8948. PlacementRule interface should be for all YarnSchedulers. Contributed by Bibin A Chundatt.\n",
      "commitDate": "29/11/18 8:13 AM",
      "commitName": "a68d766e876631d7ee2e1a6504d4120ba628d178",
      "commitAuthor": "bibinchundatt",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8948. PlacementRule interface should be for all YarnSchedulers. Contributed by Bibin A Chundatt.\n",
          "commitDate": "29/11/18 8:13 AM",
          "commitName": "a68d766e876631d7ee2e1a6504d4120ba628d178",
          "commitAuthor": "bibinchundatt",
          "commitDateOld": "16/07/18 10:57 AM",
          "commitNameOld": "a2e49f41a8bcc03ce0a85b294d0b86fee7e86f31",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 135.93,
          "commitsBetweenForRepo": 1175,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,91 @@\n-  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+  public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n+    if (!(scheduler instanceof CapacityScheduler)) {\n+      throw new IOException(\n+          \"AppNameMappingPlacementRule can be configured only for \"\n+              + \"CapacityScheduler\");\n+    }\n+    CapacitySchedulerContext schedulerContext \u003d\n+        (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMappingEntity\u003e queueMappings \u003d\n         conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n \n     // Get new user mappings\n     List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMappingEntity mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMappingEntity newMapping \u003d\n                 validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                     queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n                 queueManager, queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n               queueManager, queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     if (newMappings.size() \u003e 0) {\n       this.mappings \u003d newMappings;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       LOG.info(\"get valid queue mapping from app name config: \" +\n           newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"AppNameMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMappingEntity\u003e queueMappings \u003d\n        conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n\n    // Get new user mappings\n    List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMappingEntity mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMappingEntity newMapping \u003d\n                validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                    queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n                queueManager, queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n              queueManager, queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      LOG.info(\"get valid queue mapping from app name config: \" +\n          newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/AppNameMappingPlacementRule.java",
          "extendedDetails": {
            "oldValue": "[schedulerContext-CapacitySchedulerContext]",
            "newValue": "[scheduler-ResourceScheduler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8948. PlacementRule interface should be for all YarnSchedulers. Contributed by Bibin A Chundatt.\n",
          "commitDate": "29/11/18 8:13 AM",
          "commitName": "a68d766e876631d7ee2e1a6504d4120ba628d178",
          "commitAuthor": "bibinchundatt",
          "commitDateOld": "16/07/18 10:57 AM",
          "commitNameOld": "a2e49f41a8bcc03ce0a85b294d0b86fee7e86f31",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 135.93,
          "commitsBetweenForRepo": 1175,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,91 @@\n-  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+  public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n+    if (!(scheduler instanceof CapacityScheduler)) {\n+      throw new IOException(\n+          \"AppNameMappingPlacementRule can be configured only for \"\n+              + \"CapacityScheduler\");\n+    }\n+    CapacitySchedulerContext schedulerContext \u003d\n+        (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMappingEntity\u003e queueMappings \u003d\n         conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n \n     // Get new user mappings\n     List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMappingEntity mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMappingEntity newMapping \u003d\n                 validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                     queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n                 queueManager, queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n               queueManager, queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     if (newMappings.size() \u003e 0) {\n       this.mappings \u003d newMappings;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       LOG.info(\"get valid queue mapping from app name config: \" +\n           newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"AppNameMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMappingEntity\u003e queueMappings \u003d\n        conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n\n    // Get new user mappings\n    List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMappingEntity mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMappingEntity newMapping \u003d\n                validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                    queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n                queueManager, queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n              queueManager, queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      LOG.info(\"get valid queue mapping from app name config: \" +\n          newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/AppNameMappingPlacementRule.java",
          "extendedDetails": {}
        }
      ]
    },
    "a2e49f41a8bcc03ce0a85b294d0b86fee7e86f31": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8361. Change App Name Placement Rule to use App Name instead of App Id for configuration. (Zian Chen via wangda)\n\nChange-Id: I17e5021f8f611a9c5e3bd4b38f25e08585afc6b1\n",
      "commitDate": "16/07/18 10:57 AM",
      "commitName": "a2e49f41a8bcc03ce0a85b294d0b86fee7e86f31",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/03/18 4:43 PM",
      "commitNameOld": "a90471b3e65326cc18ed31fe21aef654833b5883",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 114.76,
      "commitsBetweenForRepo": 1291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,84 @@\n   public boolean initialize(CapacitySchedulerContext schedulerContext)\n       throws IOException {\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n-        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n+        \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMappingEntity\u003e queueMappings \u003d\n         conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n \n     // Get new user mappings\n     List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMappingEntity mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMappingEntity newMapping \u003d\n                 validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                     queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n                 queueManager, queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n               queueManager, queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     if (newMappings.size() \u003e 0) {\n       this.mappings \u003d newMappings;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n+      LOG.info(\"get valid queue mapping from app name config: \" +\n+          newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(CapacitySchedulerContext schedulerContext)\n      throws IOException {\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized App Name queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMappingEntity\u003e queueMappings \u003d\n        conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n\n    // Get new user mappings\n    List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMappingEntity mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMappingEntity newMapping \u003d\n                validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                    queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n                queueManager, queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n              queueManager, queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      LOG.info(\"get valid queue mapping from app name config: \" +\n          newMappings.toString() + \", override: \" + overrideWithQueueMappings);\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/AppNameMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "a90471b3e65326cc18ed31fe21aef654833b5883": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8016. Refine PlacementRule interface and add a app-name queue mapping rule as an example. (Zian Chen via wangda)\n\nChange-Id: I35caf1480e0f76f5f3a53528af09312e39414bbb\n",
      "commitDate": "23/03/18 4:43 PM",
      "commitName": "a90471b3e65326cc18ed31fe21aef654833b5883",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,82 @@\n+  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+      throws IOException {\n+    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n+    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n+    LOG.info(\n+        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n+\n+    List\u003cQueueMappingEntity\u003e queueMappings \u003d\n+        conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n+\n+    // Get new user mappings\n+    List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n+\n+    CapacitySchedulerQueueManager queueManager \u003d\n+        schedulerContext.getCapacitySchedulerQueueManager();\n+\n+    // check if mappings refer to valid queues\n+    for (QueueMappingEntity mapping : queueMappings) {\n+\n+      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n+      if (isStaticQueueMapping(mapping)) {\n+        //Try getting queue by its leaf queue name\n+        // without splitting into parent/leaf queues\n+        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n+        if (ifQueueDoesNotExist(queue)) {\n+          //Try getting the queue by extracting leaf and parent queue names\n+          //Assuming its a potential auto created leaf queue\n+          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n+\n+          if (ifQueueDoesNotExist(queue)) {\n+            //if leaf queue does not exist,\n+            // this could be a potential auto created leaf queue\n+            //validate if parent queue is specified,\n+            // then it should exist and\n+            // be an instance of AutoCreateEnabledParentQueue\n+            QueueMappingEntity newMapping \u003d\n+                validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n+                    queuePath);\n+            if (newMapping \u003d\u003d null) {\n+              throw new IOException(\n+                  \"mapping contains invalid or non-leaf queue \" + mapping\n+                      .getQueue());\n+            }\n+            newMappings.add(newMapping);\n+          } else{\n+            QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n+                queueManager, queue, mapping, queuePath);\n+            newMappings.add(newMapping);\n+          }\n+        } else{\n+          // if queue exists, validate\n+          //   if its an instance of leaf queue\n+          //   if its an instance of auto created leaf queue,\n+          // then extract parent queue name and update queue mapping\n+          QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n+              queueManager, queue, mapping, queuePath);\n+          newMappings.add(newMapping);\n+        }\n+      } else{\n+        //If it is a dynamic queue mapping,\n+        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n+        // validate\n+        // if parent queue is specified, then\n+        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n+        //\n+        QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n+            queueManager, mapping, queuePath);\n+        if (newMapping !\u003d null) {\n+          newMappings.add(newMapping);\n+        } else{\n+          newMappings.add(mapping);\n+        }\n+      }\n+    }\n+\n+    if (newMappings.size() \u003e 0) {\n+      this.mappings \u003d newMappings;\n+      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n+      return true;\n+    }\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(CapacitySchedulerContext schedulerContext)\n      throws IOException {\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMappingEntity\u003e queueMappings \u003d\n        conf.getQueueMappingEntity(QUEUE_MAPPING_NAME);\n\n    // Get new user mappings\n    List\u003cQueueMappingEntity\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMappingEntity mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMappingEntity newMapping \u003d\n                validateAndGetAutoCreatedQueueMapping(queueManager, mapping,\n                    queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n                queueManager, queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMappingEntity newMapping \u003d validateAndGetQueueMapping(\n              queueManager, queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMappingEntity newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/AppNameMappingPlacementRule.java"
    }
  }
}