{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NMContainerTokenSecretManager.java",
  "functionName": "retrievePassword",
  "functionId": "retrievePassword___identifier-ContainerTokenIdentifier",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/security/NMContainerTokenSecretManager.java",
  "functionStartLine": 158,
  "functionEndLine": 192,
  "numCommitsSeen": 9,
  "timeTaken": 1756,
  "changeHistory": [
    "8b9c1e68ab33b8d7720dbca9d9de9e92f9b6b447",
    "243bcd367ff3130d74676280233041f88aca62a5",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e"
  ],
  "changeHistoryShort": {
    "8b9c1e68ab33b8d7720dbca9d9de9e92f9b6b447": "Ybodychange",
    "243bcd367ff3130d74676280233041f88aca62a5": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8b9c1e68ab33b8d7720dbca9d9de9e92f9b6b447": {
      "type": "Ybodychange",
      "commitMessage": "YARN-62. Modified NodeManagers to avoid AMs from abusing container tokens for repetitive container launches. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503986 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 9:24 PM",
      "commitName": "8b9c1e68ab33b8d7720dbca9d9de9e92f9b6b447",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/06/13 4:19 PM",
      "commitNameOld": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 28.21,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,35 @@\n   public synchronized byte[] retrievePassword(\n       ContainerTokenIdentifier identifier) throws SecretManager.InvalidToken {\n     int keyId \u003d identifier.getMasterKeyId();\n-    ContainerId containerId \u003d identifier.getContainerID();\n-    ApplicationId appId \u003d\n-        containerId.getApplicationAttemptId().getApplicationId();\n \n     MasterKeyData masterKeyToUse \u003d null;\n     if (this.previousMasterKey !\u003d null\n         \u0026\u0026 keyId \u003d\u003d this.previousMasterKey.getMasterKey().getKeyId()) {\n       // A container-launch has come in with a token generated off the last\n       // master-key\n       masterKeyToUse \u003d this.previousMasterKey;\n     } else if (keyId \u003d\u003d super.currentMasterKey.getMasterKey().getKeyId()) {\n       // A container-launch has come in with a token generated off the current\n       // master-key\n       masterKeyToUse \u003d super.currentMasterKey;\n-    } else if (this.oldMasterKeys.containsKey(appId)\n-        \u0026\u0026 this.oldMasterKeys.get(appId).containsKey(containerId)) {\n-      // This means on the following happened:\n-      // (1) a stopContainer() or a getStatus() happened for a container with\n-      // token generated off a master-key that is neither current nor the\n-      // previous one.\n-      // (2) a container-relaunch has come in with a token generated off a\n-      // master-key that is neither current nor the previous one.\n-      // This basically lets stop and getStatus() calls with old-tokens to pass\n-      // through without any issue, i.e. (1).\n-      // Start-calls for repetitive launches (2) also pass through RPC here, but\n-      // get thwarted at the app-layer as part of startContainer() call.\n-      masterKeyToUse \u003d this.oldMasterKeys.get(appId).get(containerId);\n     }\n \n     if (nodeHostAddr !\u003d null\n         \u0026\u0026 !identifier.getNmHostAddress().equals(nodeHostAddr)) {\n       // Valid container token used for incorrect node.\n       throw new SecretManager.InvalidToken(\"Given Container \"\n           + identifier.getContainerID().toString()\n           + \" identifier is not valid for current Node manager. Expected : \"\n           + nodeHostAddr + \" Found : \" + identifier.getNmHostAddress());\n     }\n     \n     if (masterKeyToUse !\u003d null) {\n       return retrievePasswordInternal(identifier, masterKeyToUse);\n     }\n \n     // Invalid request. Like startContainer() with token generated off\n     // old-master-keys.\n     throw new SecretManager.InvalidToken(\"Given Container \"\n         + identifier.getContainerID().toString()\n         + \" seems to have an illegally generated token.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized byte[] retrievePassword(\n      ContainerTokenIdentifier identifier) throws SecretManager.InvalidToken {\n    int keyId \u003d identifier.getMasterKeyId();\n\n    MasterKeyData masterKeyToUse \u003d null;\n    if (this.previousMasterKey !\u003d null\n        \u0026\u0026 keyId \u003d\u003d this.previousMasterKey.getMasterKey().getKeyId()) {\n      // A container-launch has come in with a token generated off the last\n      // master-key\n      masterKeyToUse \u003d this.previousMasterKey;\n    } else if (keyId \u003d\u003d super.currentMasterKey.getMasterKey().getKeyId()) {\n      // A container-launch has come in with a token generated off the current\n      // master-key\n      masterKeyToUse \u003d super.currentMasterKey;\n    }\n\n    if (nodeHostAddr !\u003d null\n        \u0026\u0026 !identifier.getNmHostAddress().equals(nodeHostAddr)) {\n      // Valid container token used for incorrect node.\n      throw new SecretManager.InvalidToken(\"Given Container \"\n          + identifier.getContainerID().toString()\n          + \" identifier is not valid for current Node manager. Expected : \"\n          + nodeHostAddr + \" Found : \" + identifier.getNmHostAddress());\n    }\n    \n    if (masterKeyToUse !\u003d null) {\n      return retrievePasswordInternal(identifier, masterKeyToUse);\n    }\n\n    // Invalid request. Like startContainer() with token generated off\n    // old-master-keys.\n    throw new SecretManager.InvalidToken(\"Given Container \"\n        + identifier.getContainerID().toString()\n        + \" seems to have an illegally generated token.\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/security/NMContainerTokenSecretManager.java",
      "extendedDetails": {}
    },
    "243bcd367ff3130d74676280233041f88aca62a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-694. Starting to use NMTokens to authenticate all communication with NodeManagers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494369 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/13 4:19 PM",
      "commitName": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 5:06 PM",
      "commitNameOld": "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,51 @@\n   public synchronized byte[] retrievePassword(\n       ContainerTokenIdentifier identifier) throws SecretManager.InvalidToken {\n     int keyId \u003d identifier.getMasterKeyId();\n     ContainerId containerId \u003d identifier.getContainerID();\n     ApplicationId appId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n \n     MasterKeyData masterKeyToUse \u003d null;\n     if (this.previousMasterKey !\u003d null\n         \u0026\u0026 keyId \u003d\u003d this.previousMasterKey.getMasterKey().getKeyId()) {\n       // A container-launch has come in with a token generated off the last\n       // master-key\n       masterKeyToUse \u003d this.previousMasterKey;\n     } else if (keyId \u003d\u003d super.currentMasterKey.getMasterKey().getKeyId()) {\n       // A container-launch has come in with a token generated off the current\n       // master-key\n       masterKeyToUse \u003d super.currentMasterKey;\n     } else if (this.oldMasterKeys.containsKey(appId)\n         \u0026\u0026 this.oldMasterKeys.get(appId).containsKey(containerId)) {\n       // This means on the following happened:\n       // (1) a stopContainer() or a getStatus() happened for a container with\n       // token generated off a master-key that is neither current nor the\n       // previous one.\n       // (2) a container-relaunch has come in with a token generated off a\n       // master-key that is neither current nor the previous one.\n       // This basically lets stop and getStatus() calls with old-tokens to pass\n       // through without any issue, i.e. (1).\n       // Start-calls for repetitive launches (2) also pass through RPC here, but\n       // get thwarted at the app-layer as part of startContainer() call.\n       masterKeyToUse \u003d this.oldMasterKeys.get(appId).get(containerId);\n     }\n \n+    if (nodeHostAddr !\u003d null\n+        \u0026\u0026 !identifier.getNmHostAddress().equals(nodeHostAddr)) {\n+      // Valid container token used for incorrect node.\n+      throw new SecretManager.InvalidToken(\"Given Container \"\n+          + identifier.getContainerID().toString()\n+          + \" identifier is not valid for current Node manager. Expected : \"\n+          + nodeHostAddr + \" Found : \" + identifier.getNmHostAddress());\n+    }\n+    \n     if (masterKeyToUse !\u003d null) {\n       return retrievePasswordInternal(identifier, masterKeyToUse);\n     }\n \n     // Invalid request. Like startContainer() with token generated off\n     // old-master-keys.\n     throw new SecretManager.InvalidToken(\"Given Container \"\n         + identifier.getContainerID().toString()\n         + \" seems to have an illegally generated token.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized byte[] retrievePassword(\n      ContainerTokenIdentifier identifier) throws SecretManager.InvalidToken {\n    int keyId \u003d identifier.getMasterKeyId();\n    ContainerId containerId \u003d identifier.getContainerID();\n    ApplicationId appId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n\n    MasterKeyData masterKeyToUse \u003d null;\n    if (this.previousMasterKey !\u003d null\n        \u0026\u0026 keyId \u003d\u003d this.previousMasterKey.getMasterKey().getKeyId()) {\n      // A container-launch has come in with a token generated off the last\n      // master-key\n      masterKeyToUse \u003d this.previousMasterKey;\n    } else if (keyId \u003d\u003d super.currentMasterKey.getMasterKey().getKeyId()) {\n      // A container-launch has come in with a token generated off the current\n      // master-key\n      masterKeyToUse \u003d super.currentMasterKey;\n    } else if (this.oldMasterKeys.containsKey(appId)\n        \u0026\u0026 this.oldMasterKeys.get(appId).containsKey(containerId)) {\n      // This means on the following happened:\n      // (1) a stopContainer() or a getStatus() happened for a container with\n      // token generated off a master-key that is neither current nor the\n      // previous one.\n      // (2) a container-relaunch has come in with a token generated off a\n      // master-key that is neither current nor the previous one.\n      // This basically lets stop and getStatus() calls with old-tokens to pass\n      // through without any issue, i.e. (1).\n      // Start-calls for repetitive launches (2) also pass through RPC here, but\n      // get thwarted at the app-layer as part of startContainer() call.\n      masterKeyToUse \u003d this.oldMasterKeys.get(appId).get(containerId);\n    }\n\n    if (nodeHostAddr !\u003d null\n        \u0026\u0026 !identifier.getNmHostAddress().equals(nodeHostAddr)) {\n      // Valid container token used for incorrect node.\n      throw new SecretManager.InvalidToken(\"Given Container \"\n          + identifier.getContainerID().toString()\n          + \" identifier is not valid for current Node manager. Expected : \"\n          + nodeHostAddr + \" Found : \" + identifier.getNmHostAddress());\n    }\n    \n    if (masterKeyToUse !\u003d null) {\n      return retrievePasswordInternal(identifier, masterKeyToUse);\n    }\n\n    // Invalid request. Like startContainer() with token generated off\n    // old-master-keys.\n    throw new SecretManager.InvalidToken(\"Given Container \"\n        + identifier.getContainerID().toString()\n        + \" seems to have an illegally generated token.\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/security/NMContainerTokenSecretManager.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "diff": "@@ -0,0 +1,43 @@\n+  public synchronized byte[] retrievePassword(\n+      ContainerTokenIdentifier identifier) throws SecretManager.InvalidToken {\n+    int keyId \u003d identifier.getMasterKeyId();\n+    ContainerId containerId \u003d identifier.getContainerID();\n+    ApplicationId appId \u003d\n+        containerId.getApplicationAttemptId().getApplicationId();\n+\n+    MasterKeyData masterKeyToUse \u003d null;\n+\n+    if (this.previousMasterKey !\u003d null\n+        \u0026\u0026 keyId \u003d\u003d this.previousMasterKey.getMasterKey().getKeyId()) {\n+      // A container-launch has come in with a token generated off the last\n+      // master-key\n+      masterKeyToUse \u003d this.previousMasterKey;\n+    } else if (keyId \u003d\u003d super.currentMasterKey.getMasterKey().getKeyId()) {\n+      // A container-launch has come in with a token generated off the current\n+      // master-key\n+      masterKeyToUse \u003d super.currentMasterKey;\n+    } else if (this.oldMasterKeys.containsKey(appId)\n+        \u0026\u0026 this.oldMasterKeys.get(appId).containsKey(containerId)) {\n+      // This means on the following happened:\n+      // (1) a stopContainer() or a getStatus() happened for a container with\n+      // token generated off a master-key that is neither current nor the\n+      // previous one.\n+      // (2) a container-relaunch has come in with a token generated off a\n+      // master-key that is neither current nor the previous one.\n+      // This basically lets stop and getStatus() calls with old-tokens to pass\n+      // through without any issue, i.e. (1).\n+      // Start-calls for repetitive launches (2) also pass through RPC here, but\n+      // get thwarted at the app-layer as part of startContainer() call.\n+      masterKeyToUse \u003d this.oldMasterKeys.get(appId).get(containerId);\n+    }\n+\n+    if (masterKeyToUse !\u003d null) {\n+      return retrievePasswordInternal(identifier, masterKeyToUse);\n+    }\n+\n+    // Invalid request. Like startContainer() with token generated off\n+    // old-master-keys.\n+    throw new SecretManager.InvalidToken(\"Given Container \"\n+        + identifier.getContainerID().toString()\n+        + \" seems to have an illegally generated token.\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized byte[] retrievePassword(\n      ContainerTokenIdentifier identifier) throws SecretManager.InvalidToken {\n    int keyId \u003d identifier.getMasterKeyId();\n    ContainerId containerId \u003d identifier.getContainerID();\n    ApplicationId appId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n\n    MasterKeyData masterKeyToUse \u003d null;\n\n    if (this.previousMasterKey !\u003d null\n        \u0026\u0026 keyId \u003d\u003d this.previousMasterKey.getMasterKey().getKeyId()) {\n      // A container-launch has come in with a token generated off the last\n      // master-key\n      masterKeyToUse \u003d this.previousMasterKey;\n    } else if (keyId \u003d\u003d super.currentMasterKey.getMasterKey().getKeyId()) {\n      // A container-launch has come in with a token generated off the current\n      // master-key\n      masterKeyToUse \u003d super.currentMasterKey;\n    } else if (this.oldMasterKeys.containsKey(appId)\n        \u0026\u0026 this.oldMasterKeys.get(appId).containsKey(containerId)) {\n      // This means on the following happened:\n      // (1) a stopContainer() or a getStatus() happened for a container with\n      // token generated off a master-key that is neither current nor the\n      // previous one.\n      // (2) a container-relaunch has come in with a token generated off a\n      // master-key that is neither current nor the previous one.\n      // This basically lets stop and getStatus() calls with old-tokens to pass\n      // through without any issue, i.e. (1).\n      // Start-calls for repetitive launches (2) also pass through RPC here, but\n      // get thwarted at the app-layer as part of startContainer() call.\n      masterKeyToUse \u003d this.oldMasterKeys.get(appId).get(containerId);\n    }\n\n    if (masterKeyToUse !\u003d null) {\n      return retrievePasswordInternal(identifier, masterKeyToUse);\n    }\n\n    // Invalid request. Like startContainer() with token generated off\n    // old-master-keys.\n    throw new SecretManager.InvalidToken(\"Given Container \"\n        + identifier.getContainerID().toString()\n        + \" seems to have an illegally generated token.\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/security/NMContainerTokenSecretManager.java"
    }
  }
}