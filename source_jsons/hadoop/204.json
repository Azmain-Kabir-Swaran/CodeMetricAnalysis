{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OpenFileCtx.java",
  "functionName": "receivedNewWriteInternal",
  "functionId": "receivedNewWriteInternal___dfsClient-DFSClient__request-WRITE3Request__channel-Channel__xid-int__asyncDataService-AsyncDataService__iug-IdMappingServiceProvider",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
  "functionStartLine": 642,
  "functionEndLine": 684,
  "numCommitsSeen": 62,
  "timeTaken": 2907,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
    "72a556d3b0def0ab4e4509528cc513f6df06b084",
    "d71d40a63d198991077d5babd70be5e9787a53f1",
    "875aa797caee96572162ff59bc50cf97d1195348",
    "5c02d2f6225144772dcb975d3144b057b71d6476",
    "28e3d09230971b32f74284311931525cb7ad1b7c",
    "5e18410e06dd63113c49029894007e0878312903",
    "a56a4b6ef06602312144783b7507bf2b82821e4f",
    "58d75576c4d2a03d4954174bc223ed0334b34fee",
    "37f587563a943a827fbff865f5302bac6d202415"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": "Ybodychange",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": "Ybodychange",
    "72a556d3b0def0ab4e4509528cc513f6df06b084": "Yparameterchange",
    "d71d40a63d198991077d5babd70be5e9787a53f1": "Ybodychange",
    "875aa797caee96572162ff59bc50cf97d1195348": "Ybodychange",
    "5c02d2f6225144772dcb975d3144b057b71d6476": "Ybodychange",
    "28e3d09230971b32f74284311931525cb7ad1b7c": "Ybodychange",
    "5e18410e06dd63113c49029894007e0878312903": "Ybodychange",
    "a56a4b6ef06602312144783b7507bf2b82821e4f": "Ybodychange",
    "58d75576c4d2a03d4954174bc223ed0334b34fee": "Ybodychange",
    "37f587563a943a827fbff865f5302bac6d202415": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/10/17 10:38 AM",
      "commitNameOld": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 126.95,
      "commitsBetweenForRepo": 833,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,43 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n     WriteStableHow stableHow \u003d request.getStableHow();\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     int count \u003d request.getCount();\n \n     WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n     if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n       processOverWrite(dfsClient, request, channel, xid, iug);\n     } else {\n       // The write is added to pendingWrites.\n       // Check and start writing back if necessary\n       boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n       if (!startWriting) {\n         // offset \u003e nextOffset. check if we need to dump data\n         waitForDump();\n         \n         // In test, noticed some Linux client sends a batch (e.g., 1MB)\n         // of reordered writes and won\u0027t send more writes until it gets\n         // responses of the previous batch. So here send response immediately\n         // for unstable non-sequential write\n         if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n-          LOG.info(\"Have to change stable write to unstable write: \"\n-              + request.getStableHow());\n+          LOG.info(\"Have to change stable write to unstable write: {}\",\n+              request.getStableHow());\n           stableHow \u003d WriteStableHow.UNSTABLE;\n         }\n \n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n-              + writeCtx.getOffset());\n-        }\n+        LOG.debug(\"UNSTABLE write request, send response for offset: {}\",\n+            writeCtx.getOffset());\n         WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n         RpcProgramNfs3.metrics.addWrite(Nfs3Utils\n             .getElapsedTime(writeCtx.startTime));\n         Nfs3Utils\n             .writeChannel(channel, response.serialize(new XDR(),\n                 xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The write is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        waitForDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n          LOG.info(\"Have to change stable write to unstable write: {}\",\n              request.getStableHow());\n          stableHow \u003d WriteStableHow.UNSTABLE;\n        }\n\n        LOG.debug(\"UNSTABLE write request, send response for offset: {}\",\n            writeCtx.getOffset());\n        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        RpcProgramNfs3.metrics.addWrite(Nfs3Utils\n            .getElapsedTime(writeCtx.startTime));\n        Nfs3Utils\n            .writeChannel(channel, response.serialize(new XDR(),\n                xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7423. various typos and message formatting fixes in nfs daemon and doc. (Charles Lamb via yliu)\n",
      "commitDate": "28/01/15 12:56 PM",
      "commitName": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
      "commitAuthor": "yliu",
      "commitDateOld": "11/12/14 3:40 PM",
      "commitNameOld": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 47.89,
      "commitsBetweenForRepo": 279,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n     WriteStableHow stableHow \u003d request.getStableHow();\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     int count \u003d request.getCount();\n \n     WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n     if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n       processOverWrite(dfsClient, request, channel, xid, iug);\n     } else {\n-      // The writes is added to pendingWrites.\n+      // The write is added to pendingWrites.\n       // Check and start writing back if necessary\n       boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n       if (!startWriting) {\n         // offset \u003e nextOffset. check if we need to dump data\n         waitForDump();\n         \n         // In test, noticed some Linux client sends a batch (e.g., 1MB)\n         // of reordered writes and won\u0027t send more writes until it gets\n         // responses of the previous batch. So here send response immediately\n         // for unstable non-sequential write\n         if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n-          LOG.info(\"Have to change stable write to unstable write:\"\n+          LOG.info(\"Have to change stable write to unstable write: \"\n               + request.getStableHow());\n           stableHow \u003d WriteStableHow.UNSTABLE;\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UNSTABLE write request, send response for offset: \"\n               + writeCtx.getOffset());\n         }\n         WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n         RpcProgramNfs3.metrics.addWrite(Nfs3Utils\n             .getElapsedTime(writeCtx.startTime));\n         Nfs3Utils\n             .writeChannel(channel, response.serialize(new XDR(),\n                 xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The write is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        waitForDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n          LOG.info(\"Have to change stable write to unstable write: \"\n              + request.getStableHow());\n          stableHow \u003d WriteStableHow.UNSTABLE;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n              + writeCtx.getOffset());\n        }\n        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        RpcProgramNfs3.metrics.addWrite(Nfs3Utils\n            .getElapsedTime(writeCtx.startTime));\n        Nfs3Utils\n            .writeChannel(channel, response.serialize(new XDR(),\n                xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7449. Add metrics to NFS gateway. Contributed by Brandon Li\n",
      "commitDate": "11/12/14 3:40 PM",
      "commitName": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "11/11/14 1:03 PM",
      "commitNameOld": "99d9d0c2d19b9f161b765947f3fb64619ea58090",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 30.11,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,45 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n     WriteStableHow stableHow \u003d request.getStableHow();\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     int count \u003d request.getCount();\n \n     WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n     if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n       processOverWrite(dfsClient, request, channel, xid, iug);\n     } else {\n       // The writes is added to pendingWrites.\n       // Check and start writing back if necessary\n       boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n       if (!startWriting) {\n         // offset \u003e nextOffset. check if we need to dump data\n         waitForDump();\n         \n         // In test, noticed some Linux client sends a batch (e.g., 1MB)\n         // of reordered writes and won\u0027t send more writes until it gets\n         // responses of the previous batch. So here send response immediately\n         // for unstable non-sequential write\n         if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n           LOG.info(\"Have to change stable write to unstable write:\"\n               + request.getStableHow());\n           stableHow \u003d WriteStableHow.UNSTABLE;\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UNSTABLE write request, send response for offset: \"\n               + writeCtx.getOffset());\n         }\n         WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n+        RpcProgramNfs3.metrics.addWrite(Nfs3Utils\n+            .getElapsedTime(writeCtx.startTime));\n         Nfs3Utils\n             .writeChannel(channel, response.serialize(new XDR(),\n                 xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The writes is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        waitForDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n          LOG.info(\"Have to change stable write to unstable write:\"\n              + request.getStableHow());\n          stableHow \u003d WriteStableHow.UNSTABLE;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n              + writeCtx.getOffset());\n        }\n        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        RpcProgramNfs3.metrics.addWrite(Nfs3Utils\n            .getElapsedTime(writeCtx.startTime));\n        Nfs3Utils\n            .writeChannel(channel, response.serialize(new XDR(),\n                xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "72a556d3b0def0ab4e4509528cc513f6df06b084": {
      "type": "Yparameterchange",
      "commitMessage": "HADOOP-11195. Move Id-Name mapping in NFS to the hadoop-common area for better maintenance. Contributed by Yongjun Zhang\n",
      "commitDate": "29/10/14 11:05 AM",
      "commitName": "72a556d3b0def0ab4e4509528cc513f6df06b084",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "22/10/14 9:27 PM",
      "commitNameOld": "d71d40a63d198991077d5babd70be5e9787a53f1",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n-      AsyncDataService asyncDataService, IdUserGroup iug) {\n+      AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n     WriteStableHow stableHow \u003d request.getStableHow();\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     int count \u003d request.getCount();\n \n     WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n     if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n       processOverWrite(dfsClient, request, channel, xid, iug);\n     } else {\n       // The writes is added to pendingWrites.\n       // Check and start writing back if necessary\n       boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n       if (!startWriting) {\n         // offset \u003e nextOffset. check if we need to dump data\n         waitForDump();\n         \n         // In test, noticed some Linux client sends a batch (e.g., 1MB)\n         // of reordered writes and won\u0027t send more writes until it gets\n         // responses of the previous batch. So here send response immediately\n         // for unstable non-sequential write\n         if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n           LOG.info(\"Have to change stable write to unstable write:\"\n               + request.getStableHow());\n           stableHow \u003d WriteStableHow.UNSTABLE;\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UNSTABLE write request, send response for offset: \"\n               + writeCtx.getOffset());\n         }\n         WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n         Nfs3Utils\n             .writeChannel(channel, response.serialize(new XDR(),\n                 xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdMappingServiceProvider iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The writes is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        waitForDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n          LOG.info(\"Have to change stable write to unstable write:\"\n              + request.getStableHow());\n          stableHow \u003d WriteStableHow.UNSTABLE;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n              + writeCtx.getOffset());\n        }\n        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils\n            .writeChannel(channel, response.serialize(new XDR(),\n                xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {
        "oldValue": "[dfsClient-DFSClient, request-WRITE3Request, channel-Channel, xid-int, asyncDataService-AsyncDataService, iug-IdUserGroup]",
        "newValue": "[dfsClient-DFSClient, request-WRITE3Request, channel-Channel, xid-int, asyncDataService-AsyncDataService, iug-IdMappingServiceProvider]"
      }
    },
    "d71d40a63d198991077d5babd70be5e9787a53f1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7180. NFSv3 gateway frequently gets stuck due to GC. Contributed by Brandon Li\n",
      "commitDate": "22/10/14 9:27 PM",
      "commitName": "d71d40a63d198991077d5babd70be5e9787a53f1",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "21/10/14 10:20 AM",
      "commitNameOld": "b6f9d5538cf2b425652687e99503f3d566b2056a",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 1.46,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdUserGroup iug) {\n     WriteStableHow stableHow \u003d request.getStableHow();\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     int count \u003d request.getCount();\n \n     WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n     if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n       processOverWrite(dfsClient, request, channel, xid, iug);\n     } else {\n       // The writes is added to pendingWrites.\n       // Check and start writing back if necessary\n       boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n       if (!startWriting) {\n         // offset \u003e nextOffset. check if we need to dump data\n-        checkDump();\n+        waitForDump();\n         \n         // In test, noticed some Linux client sends a batch (e.g., 1MB)\n         // of reordered writes and won\u0027t send more writes until it gets\n         // responses of the previous batch. So here send response immediately\n         // for unstable non-sequential write\n         if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n           LOG.info(\"Have to change stable write to unstable write:\"\n               + request.getStableHow());\n           stableHow \u003d WriteStableHow.UNSTABLE;\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UNSTABLE write request, send response for offset: \"\n               + writeCtx.getOffset());\n         }\n         WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n         Nfs3Utils\n             .writeChannel(channel, response.serialize(new XDR(),\n                 xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The writes is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        waitForDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n          LOG.info(\"Have to change stable write to unstable write:\"\n              + request.getStableHow());\n          stableHow \u003d WriteStableHow.UNSTABLE;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n              + writeCtx.getOffset());\n        }\n        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils\n            .writeChannel(channel, response.serialize(new XDR(),\n                xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "875aa797caee96572162ff59bc50cf97d1195348": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6894. Add XDR parser method for each NFS response. Contributed by Brandon Li.\n",
      "commitDate": "01/10/14 1:18 PM",
      "commitName": "875aa797caee96572162ff59bc50cf97d1195348",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "18/09/14 2:57 PM",
      "commitNameOld": "70be56d093022de9953e14a92dfa1a146bd9a290",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 12.93,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdUserGroup iug) {\n     WriteStableHow stableHow \u003d request.getStableHow();\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     int count \u003d request.getCount();\n \n     WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n     if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n       processOverWrite(dfsClient, request, channel, xid, iug);\n     } else {\n       // The writes is added to pendingWrites.\n       // Check and start writing back if necessary\n       boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n       if (!startWriting) {\n         // offset \u003e nextOffset. check if we need to dump data\n         checkDump();\n         \n         // In test, noticed some Linux client sends a batch (e.g., 1MB)\n         // of reordered writes and won\u0027t send more writes until it gets\n         // responses of the previous batch. So here send response immediately\n         // for unstable non-sequential write\n         if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n           LOG.info(\"Have to change stable write to unstable write:\"\n               + request.getStableHow());\n           stableHow \u003d WriteStableHow.UNSTABLE;\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UNSTABLE write request, send response for offset: \"\n               + writeCtx.getOffset());\n         }\n         WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n         Nfs3Utils\n-            .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),\n+            .writeChannel(channel, response.serialize(new XDR(),\n                 xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The writes is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        checkDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n          LOG.info(\"Have to change stable write to unstable write:\"\n              + request.getStableHow());\n          stableHow \u003d WriteStableHow.UNSTABLE;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n              + writeCtx.getOffset());\n        }\n        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils\n            .writeChannel(channel, response.serialize(new XDR(),\n                xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "5c02d2f6225144772dcb975d3144b057b71d6476": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5281. COMMIT request should not block. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/10/13 4:40 PM",
      "commitName": "5c02d2f6225144772dcb975d3144b057b71d6476",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "06/10/13 7:57 PM",
      "commitNameOld": "caa4abd30cfc4361c7bc9f212a9092840d7c3b53",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 1.86,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,43 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdUserGroup iug) {\n     WriteStableHow stableHow \u003d request.getStableHow();\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     int count \u003d request.getCount();\n \n     WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n     if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n       processOverWrite(dfsClient, request, channel, xid, iug);\n     } else {\n       // The writes is added to pendingWrites.\n       // Check and start writing back if necessary\n       boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n       if (!startWriting) {\n         // offset \u003e nextOffset. check if we need to dump data\n         checkDump();\n         \n         // In test, noticed some Linux client sends a batch (e.g., 1MB)\n         // of reordered writes and won\u0027t send more writes until it gets\n         // responses of the previous batch. So here send response immediately\n         // for unstable non-sequential write\n-        if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"UNSTABLE write request, send response for offset: \"\n-                + writeCtx.getOffset());\n-          }\n-          WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n-          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n-              fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n-          Nfs3Utils\n-              .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),\n-                  xid, new VerifierNone()), xid);\n-          writeCtx.setReplied(true);\n+        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n+          LOG.info(\"Have to change stable write to unstable write:\"\n+              + request.getStableHow());\n+          stableHow \u003d WriteStableHow.UNSTABLE;\n         }\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n+              + writeCtx.getOffset());\n+        }\n+        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n+        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n+            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n+        Nfs3Utils\n+            .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),\n+                xid, new VerifierNone()), xid);\n+        writeCtx.setReplied(true);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The writes is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        checkDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (stableHow !\u003d WriteStableHow.UNSTABLE) {\n          LOG.info(\"Have to change stable write to unstable write:\"\n              + request.getStableHow());\n          stableHow \u003d WriteStableHow.UNSTABLE;\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UNSTABLE write request, send response for offset: \"\n              + writeCtx.getOffset());\n        }\n        WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils\n            .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),\n                xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "28e3d09230971b32f74284311931525cb7ad1b7c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4971. Move IO operations out of locking in OpenFileCtx. Contributed by Jing Zhao and Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525681 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/09/13 1:02 PM",
      "commitName": "28e3d09230971b32f74284311931525cb7ad1b7c",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "17/09/13 11:08 PM",
      "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,39 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdUserGroup iug) {\n-    long offset \u003d request.getOffset();\n-    int count \u003d request.getCount();\n     WriteStableHow stableHow \u003d request.getStableHow();\n-\n-    // Get file length, fail non-append call\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n-          + preOpAttr.getSize());\n-    }\n+    int count \u003d request.getCount();\n \n-    long nextOffset \u003d getNextOffsetUnprotected();\n-    if (offset \u003d\u003d nextOffset) {\n-      LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n-          + \" nextOffset:\" + nextOffset);\n-      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n-          request.getOffset(), request.getCount(), request.getStableHow(),\n-          request.getData().array(), channel, xid, false, DataState.NO_DUMP);\n-      addWrite(writeCtx);\n-      \n-      // Create an async task and change openFileCtx status to indicate async\n-      // task pending\n-      if (!asyncStatus) {\n-        asyncStatus \u003d true;\n-        asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n-      }\n-      \n-      // Update the write time first\n-      updateLastAccessTime();\n-      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n-\n-      // Send response immediately for unstable write\n-      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n-        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n-        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n-            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n-            new XDR(), xid, new VerifierNone()), xid);\n-        writeCtx.setReplied(true);\n-      }\n-\n-    } else if (offset \u003e nextOffset) {\n-      LOG.info(\"Add new write to the list but not update nextOffset:\"\n-          + nextOffset);\n-      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n-          request.getOffset(), request.getCount(), request.getStableHow(),\n-          request.getData().array(), channel, xid, false, DataState.ALLOW_DUMP);\n-      addWrite(writeCtx);\n-\n-      // Check if need to dump some pending requests to file\n-      checkDump(request.getCount());\n-      updateLastAccessTime();\n-      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n-      \n-      // In test, noticed some Linux client sends a batch (e.g., 1MB)\n-      // of reordered writes and won\u0027t send more writes until it gets\n-      // responses of the previous batch. So here send response immediately for\n-      // unstable non-sequential write\n-      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n-        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n-        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n-            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n-            new XDR(), xid, new VerifierNone()), xid);\n-        writeCtx.setReplied(true);\n-      }\n-\n-    } else {\n+    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n+    if (writeCtx \u003d\u003d null) {\n       // offset \u003c nextOffset\n-      LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n-          + nextOffset + \")\");\n-      WccData wccData \u003d new WccData(preOpAttr, null);\n-      WRITE3Response response;\n-\n-      if (offset + count \u003e nextOffset) {\n-        LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n-            + \"write requests, so treat it as a real random write, no support.\");\n-        response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n-            WriteStableHow.UNSTABLE, 0);\n-      } else {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Process perfectOverWrite\");\n+      processOverWrite(dfsClient, request, channel, xid, iug);\n+    } else {\n+      // The writes is added to pendingWrites.\n+      // Check and start writing back if necessary\n+      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n+      if (!startWriting) {\n+        // offset \u003e nextOffset. check if we need to dump data\n+        checkDump();\n+        \n+        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n+        // of reordered writes and won\u0027t send more writes until it gets\n+        // responses of the previous batch. So here send response immediately\n+        // for unstable non-sequential write\n+        if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"UNSTABLE write request, send response for offset: \"\n+                + writeCtx.getOffset());\n+          }\n+          WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n+          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n+              fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n+          Nfs3Utils\n+              .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),\n+                  xid, new VerifierNone()), xid);\n+          writeCtx.setReplied(true);\n         }\n-        response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n-            request.getData().array(),\n-            Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n       }\n-      \n-      updateLastAccessTime();\n-      Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n-          new XDR(), xid, new VerifierNone()), xid);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    WriteStableHow stableHow \u003d request.getStableHow();\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    int count \u003d request.getCount();\n\n    WriteCtx writeCtx \u003d addWritesToCache(request, channel, xid);\n    if (writeCtx \u003d\u003d null) {\n      // offset \u003c nextOffset\n      processOverWrite(dfsClient, request, channel, xid, iug);\n    } else {\n      // The writes is added to pendingWrites.\n      // Check and start writing back if necessary\n      boolean startWriting \u003d checkAndStartWrite(asyncDataService, writeCtx);\n      if (!startWriting) {\n        // offset \u003e nextOffset. check if we need to dump data\n        checkDump();\n        \n        // In test, noticed some Linux client sends a batch (e.g., 1MB)\n        // of reordered writes and won\u0027t send more writes until it gets\n        // responses of the previous batch. So here send response immediately\n        // for unstable non-sequential write\n        if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"UNSTABLE write request, send response for offset: \"\n                + writeCtx.getOffset());\n          }\n          WccData fileWcc \u003d new WccData(preOpAttr, latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils\n              .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),\n                  xid, new VerifierNone()), xid);\n          writeCtx.setReplied(true);\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "5e18410e06dd63113c49029894007e0878312903": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5212. Refactor RpcMessage and NFS3Response to support different types of authentication information. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1524298 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/09/13 11:08 PM",
      "commitName": "5e18410e06dd63113c49029894007e0878312903",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/09/13 4:14 PM",
      "commitNameOld": "a56a4b6ef06602312144783b7507bf2b82821e4f",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 4.29,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,96 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdUserGroup iug) {\n     long offset \u003d request.getOffset();\n     int count \u003d request.getCount();\n     WriteStableHow stableHow \u003d request.getStableHow();\n \n     // Get file length, fail non-append call\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n           + preOpAttr.getSize());\n     }\n \n     long nextOffset \u003d getNextOffsetUnprotected();\n     if (offset \u003d\u003d nextOffset) {\n       LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n           + \" nextOffset:\" + nextOffset);\n       WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n           request.getOffset(), request.getCount(), request.getStableHow(),\n           request.getData().array(), channel, xid, false, DataState.NO_DUMP);\n       addWrite(writeCtx);\n       \n       // Create an async task and change openFileCtx status to indicate async\n       // task pending\n       if (!asyncStatus) {\n         asyncStatus \u003d true;\n         asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n       }\n       \n       // Update the write time first\n       updateLastAccessTime();\n       Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n \n       // Send response immediately for unstable write\n       if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n         WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n+        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n+            new XDR(), xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n \n     } else if (offset \u003e nextOffset) {\n       LOG.info(\"Add new write to the list but not update nextOffset:\"\n           + nextOffset);\n       WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n           request.getOffset(), request.getCount(), request.getStableHow(),\n           request.getData().array(), channel, xid, false, DataState.ALLOW_DUMP);\n       addWrite(writeCtx);\n \n       // Check if need to dump some pending requests to file\n       checkDump(request.getCount());\n       updateLastAccessTime();\n       Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n       \n       // In test, noticed some Linux client sends a batch (e.g., 1MB)\n       // of reordered writes and won\u0027t send more writes until it gets\n       // responses of the previous batch. So here send response immediately for\n       // unstable non-sequential write\n       if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n         WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n+        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n+            new XDR(), xid, new VerifierNone()), xid);\n         writeCtx.setReplied(true);\n       }\n \n     } else {\n       // offset \u003c nextOffset\n       LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n           + nextOffset + \")\");\n       WccData wccData \u003d new WccData(preOpAttr, null);\n       WRITE3Response response;\n \n       if (offset + count \u003e nextOffset) {\n         LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n             + \"write requests, so treat it as a real random write, no support.\");\n         response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n             WriteStableHow.UNSTABLE, 0);\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Process perfectOverWrite\");\n         }\n         response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n             request.getData().array(),\n             Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n       }\n       \n       updateLastAccessTime();\n-      Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n+      Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n+          new XDR(), xid, new VerifierNone()), xid);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    long offset \u003d request.getOffset();\n    int count \u003d request.getCount();\n    WriteStableHow stableHow \u003d request.getStableHow();\n\n    // Get file length, fail non-append call\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n          + preOpAttr.getSize());\n    }\n\n    long nextOffset \u003d getNextOffsetUnprotected();\n    if (offset \u003d\u003d nextOffset) {\n      LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n          + \" nextOffset:\" + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, DataState.NO_DUMP);\n      addWrite(writeCtx);\n      \n      // Create an async task and change openFileCtx status to indicate async\n      // task pending\n      if (!asyncStatus) {\n        asyncStatus \u003d true;\n        asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n      }\n      \n      // Update the write time first\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n\n      // Send response immediately for unstable write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n            new XDR(), xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n\n    } else if (offset \u003e nextOffset) {\n      LOG.info(\"Add new write to the list but not update nextOffset:\"\n          + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, DataState.ALLOW_DUMP);\n      addWrite(writeCtx);\n\n      // Check if need to dump some pending requests to file\n      checkDump(request.getCount());\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n      \n      // In test, noticed some Linux client sends a batch (e.g., 1MB)\n      // of reordered writes and won\u0027t send more writes until it gets\n      // responses of the previous batch. So here send response immediately for\n      // unstable non-sequential write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n            new XDR(), xid, new VerifierNone()), xid);\n        writeCtx.setReplied(true);\n      }\n\n    } else {\n      // offset \u003c nextOffset\n      LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n          + nextOffset + \")\");\n      WccData wccData \u003d new WccData(preOpAttr, null);\n      WRITE3Response response;\n\n      if (offset + count \u003e nextOffset) {\n        LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n            + \"write requests, so treat it as a real random write, no support.\");\n        response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n            WriteStableHow.UNSTABLE, 0);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Process perfectOverWrite\");\n        }\n        response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n            request.getData().array(),\n            Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n      }\n      \n      updateLastAccessTime();\n      Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n          new XDR(), xid, new VerifierNone()), xid);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "a56a4b6ef06602312144783b7507bf2b82821e4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5199 Add more debug trace for NFS READ and WRITE. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523140 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/09/13 4:14 PM",
      "commitName": "a56a4b6ef06602312144783b7507bf2b82821e4f",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "28/08/13 10:23 AM",
      "commitNameOld": "30b8ef91a32ddf1fe3756bae6d7dc538a150bdc4",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 16.24,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,93 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdUserGroup iug) {\n     long offset \u003d request.getOffset();\n     int count \u003d request.getCount();\n     WriteStableHow stableHow \u003d request.getStableHow();\n \n     // Get file length, fail non-append call\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n           + preOpAttr.getSize());\n     }\n \n     long nextOffset \u003d getNextOffsetUnprotected();\n     if (offset \u003d\u003d nextOffset) {\n       LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n           + \" nextOffset:\" + nextOffset);\n       WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n           request.getOffset(), request.getCount(), request.getStableHow(),\n           request.getData().array(), channel, xid, false, DataState.NO_DUMP);\n       addWrite(writeCtx);\n       \n       // Create an async task and change openFileCtx status to indicate async\n       // task pending\n       if (!asyncStatus) {\n         asyncStatus \u003d true;\n         asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n       }\n       \n       // Update the write time first\n       updateLastAccessTime();\n       Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n \n       // Send response immediately for unstable write\n       if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n         WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n         writeCtx.setReplied(true);\n       }\n \n     } else if (offset \u003e nextOffset) {\n       LOG.info(\"Add new write to the list but not update nextOffset:\"\n           + nextOffset);\n       WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n           request.getOffset(), request.getCount(), request.getStableHow(),\n           request.getData().array(), channel, xid, false, DataState.ALLOW_DUMP);\n       addWrite(writeCtx);\n \n       // Check if need to dump some pending requests to file\n       checkDump(request.getCount());\n       updateLastAccessTime();\n       Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n       \n       // In test, noticed some Linux client sends a batch (e.g., 1MB)\n       // of reordered writes and won\u0027t send more writes until it gets\n       // responses of the previous batch. So here send response immediately for\n       // unstable non-sequential write\n       if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n         WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n         writeCtx.setReplied(true);\n       }\n \n     } else {\n       // offset \u003c nextOffset\n       LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n           + nextOffset + \")\");\n       WccData wccData \u003d new WccData(preOpAttr, null);\n       WRITE3Response response;\n \n       if (offset + count \u003e nextOffset) {\n         LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n             + \"write requests, so treat it as a real random write, no support.\");\n         response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n             WriteStableHow.UNSTABLE, 0);\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Process perfectOverWrite\");\n         }\n         response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n             request.getData().array(),\n             Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n       }\n       \n       updateLastAccessTime();\n-      Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+      Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    long offset \u003d request.getOffset();\n    int count \u003d request.getCount();\n    WriteStableHow stableHow \u003d request.getStableHow();\n\n    // Get file length, fail non-append call\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n          + preOpAttr.getSize());\n    }\n\n    long nextOffset \u003d getNextOffsetUnprotected();\n    if (offset \u003d\u003d nextOffset) {\n      LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n          + \" nextOffset:\" + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, DataState.NO_DUMP);\n      addWrite(writeCtx);\n      \n      // Create an async task and change openFileCtx status to indicate async\n      // task pending\n      if (!asyncStatus) {\n        asyncStatus \u003d true;\n        asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n      }\n      \n      // Update the write time first\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n\n      // Send response immediately for unstable write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n        writeCtx.setReplied(true);\n      }\n\n    } else if (offset \u003e nextOffset) {\n      LOG.info(\"Add new write to the list but not update nextOffset:\"\n          + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, DataState.ALLOW_DUMP);\n      addWrite(writeCtx);\n\n      // Check if need to dump some pending requests to file\n      checkDump(request.getCount());\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n      \n      // In test, noticed some Linux client sends a batch (e.g., 1MB)\n      // of reordered writes and won\u0027t send more writes until it gets\n      // responses of the previous batch. So here send response immediately for\n      // unstable non-sequential write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n        writeCtx.setReplied(true);\n      }\n\n    } else {\n      // offset \u003c nextOffset\n      LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n          + nextOffset + \")\");\n      WccData wccData \u003d new WccData(preOpAttr, null);\n      WRITE3Response response;\n\n      if (offset + count \u003e nextOffset) {\n        LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n            + \"write requests, so treat it as a real random write, no support.\");\n        response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n            WriteStableHow.UNSTABLE, 0);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Process perfectOverWrite\");\n        }\n        response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n            request.getData().array(),\n            Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n      }\n      \n      updateLastAccessTime();\n      Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "58d75576c4d2a03d4954174bc223ed0334b34fee": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4962. Use enum for nfs constants. Contributed by Tsz Wo (Nicholas) SZE.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 10:01 AM",
      "commitName": "58d75576c4d2a03d4954174bc223ed0334b34fee",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "02/07/13 10:31 AM",
      "commitNameOld": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 7.98,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,93 @@\n   private void receivedNewWriteInternal(DFSClient dfsClient,\n       WRITE3Request request, Channel channel, int xid,\n       AsyncDataService asyncDataService, IdUserGroup iug) {\n     long offset \u003d request.getOffset();\n     int count \u003d request.getCount();\n     WriteStableHow stableHow \u003d request.getStableHow();\n \n     // Get file length, fail non-append call\n     WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n           + preOpAttr.getSize());\n     }\n \n     long nextOffset \u003d getNextOffsetUnprotected();\n     if (offset \u003d\u003d nextOffset) {\n       LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n           + \" nextOffset:\" + nextOffset);\n       WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n           request.getOffset(), request.getCount(), request.getStableHow(),\n-          request.getData().array(), channel, xid, false, WriteCtx.NO_DUMP);\n+          request.getData().array(), channel, xid, false, DataState.NO_DUMP);\n       addWrite(writeCtx);\n       \n       // Create an async task and change openFileCtx status to indicate async\n       // task pending\n       if (!asyncStatus) {\n         asyncStatus \u003d true;\n         asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n       }\n       \n       // Update the write time first\n       updateLastAccessTime();\n       Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n \n       // Send response immediately for unstable write\n       if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n         WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n         Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n         writeCtx.setReplied(true);\n       }\n \n     } else if (offset \u003e nextOffset) {\n       LOG.info(\"Add new write to the list but not update nextOffset:\"\n           + nextOffset);\n       WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n           request.getOffset(), request.getCount(), request.getStableHow(),\n-          request.getData().array(), channel, xid, false, WriteCtx.ALLOW_DUMP);\n+          request.getData().array(), channel, xid, false, DataState.ALLOW_DUMP);\n       addWrite(writeCtx);\n \n       // Check if need to dump some pending requests to file\n       checkDump(request.getCount());\n       updateLastAccessTime();\n       Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n       \n       // In test, noticed some Linux client sends a batch (e.g., 1MB)\n       // of reordered writes and won\u0027t send more writes until it gets\n       // responses of the previous batch. So here send response immediately for\n       // unstable non-sequential write\n       if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n         WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n             fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n         Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n         writeCtx.setReplied(true);\n       }\n \n     } else {\n       // offset \u003c nextOffset\n       LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n           + nextOffset + \")\");\n       WccData wccData \u003d new WccData(preOpAttr, null);\n       WRITE3Response response;\n \n       if (offset + count \u003e nextOffset) {\n         LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n             + \"write requests, so treat it as a real random write, no support.\");\n         response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n             WriteStableHow.UNSTABLE, 0);\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Process perfectOverWrite\");\n         }\n         response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n             request.getData().array(),\n             Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n       }\n       \n       updateLastAccessTime();\n       Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    long offset \u003d request.getOffset();\n    int count \u003d request.getCount();\n    WriteStableHow stableHow \u003d request.getStableHow();\n\n    // Get file length, fail non-append call\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n          + preOpAttr.getSize());\n    }\n\n    long nextOffset \u003d getNextOffsetUnprotected();\n    if (offset \u003d\u003d nextOffset) {\n      LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n          + \" nextOffset:\" + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, DataState.NO_DUMP);\n      addWrite(writeCtx);\n      \n      // Create an async task and change openFileCtx status to indicate async\n      // task pending\n      if (!asyncStatus) {\n        asyncStatus \u003d true;\n        asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n      }\n      \n      // Update the write time first\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n\n      // Send response immediately for unstable write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n        writeCtx.setReplied(true);\n      }\n\n    } else if (offset \u003e nextOffset) {\n      LOG.info(\"Add new write to the list but not update nextOffset:\"\n          + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, DataState.ALLOW_DUMP);\n      addWrite(writeCtx);\n\n      // Check if need to dump some pending requests to file\n      checkDump(request.getCount());\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n      \n      // In test, noticed some Linux client sends a batch (e.g., 1MB)\n      // of reordered writes and won\u0027t send more writes until it gets\n      // responses of the previous batch. So here send response immediately for\n      // unstable non-sequential write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n        writeCtx.setReplied(true);\n      }\n\n    } else {\n      // offset \u003c nextOffset\n      LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n          + nextOffset + \")\");\n      WccData wccData \u003d new WccData(preOpAttr, null);\n      WRITE3Response response;\n\n      if (offset + count \u003e nextOffset) {\n        LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n            + \"write requests, so treat it as a real random write, no support.\");\n        response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n            WriteStableHow.UNSTABLE, 0);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Process perfectOverWrite\");\n        }\n        response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n            request.getData().array(),\n            Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n      }\n      \n      updateLastAccessTime();\n      Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "37f587563a943a827fbff865f5302bac6d202415": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4762 Provide HDFS based NFSv3 and Mountd implementation. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1499029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/13 10:31 AM",
      "commitName": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,93 @@\n+  private void receivedNewWriteInternal(DFSClient dfsClient,\n+      WRITE3Request request, Channel channel, int xid,\n+      AsyncDataService asyncDataService, IdUserGroup iug) {\n+    long offset \u003d request.getOffset();\n+    int count \u003d request.getCount();\n+    WriteStableHow stableHow \u003d request.getStableHow();\n+\n+    // Get file length, fail non-append call\n+    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n+          + preOpAttr.getSize());\n+    }\n+\n+    long nextOffset \u003d getNextOffsetUnprotected();\n+    if (offset \u003d\u003d nextOffset) {\n+      LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n+          + \" nextOffset:\" + nextOffset);\n+      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n+          request.getOffset(), request.getCount(), request.getStableHow(),\n+          request.getData().array(), channel, xid, false, WriteCtx.NO_DUMP);\n+      addWrite(writeCtx);\n+      \n+      // Create an async task and change openFileCtx status to indicate async\n+      // task pending\n+      if (!asyncStatus) {\n+        asyncStatus \u003d true;\n+        asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n+      }\n+      \n+      // Update the write time first\n+      updateLastAccessTime();\n+      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n+\n+      // Send response immediately for unstable write\n+      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n+        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n+        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n+            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n+        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+        writeCtx.setReplied(true);\n+      }\n+\n+    } else if (offset \u003e nextOffset) {\n+      LOG.info(\"Add new write to the list but not update nextOffset:\"\n+          + nextOffset);\n+      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n+          request.getOffset(), request.getCount(), request.getStableHow(),\n+          request.getData().array(), channel, xid, false, WriteCtx.ALLOW_DUMP);\n+      addWrite(writeCtx);\n+\n+      // Check if need to dump some pending requests to file\n+      checkDump(request.getCount());\n+      updateLastAccessTime();\n+      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n+      \n+      // In test, noticed some Linux client sends a batch (e.g., 1MB)\n+      // of reordered writes and won\u0027t send more writes until it gets\n+      // responses of the previous batch. So here send response immediately for\n+      // unstable non-sequential write\n+      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n+        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n+        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n+            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n+        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+        writeCtx.setReplied(true);\n+      }\n+\n+    } else {\n+      // offset \u003c nextOffset\n+      LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n+          + nextOffset + \")\");\n+      WccData wccData \u003d new WccData(preOpAttr, null);\n+      WRITE3Response response;\n+\n+      if (offset + count \u003e nextOffset) {\n+        LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n+            + \"write requests, so treat it as a real random write, no support.\");\n+        response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n+            WriteStableHow.UNSTABLE, 0);\n+      } else {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Process perfectOverWrite\");\n+        }\n+        response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n+            request.getData().array(),\n+            Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n+      }\n+      \n+      updateLastAccessTime();\n+      Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void receivedNewWriteInternal(DFSClient dfsClient,\n      WRITE3Request request, Channel channel, int xid,\n      AsyncDataService asyncDataService, IdUserGroup iug) {\n    long offset \u003d request.getOffset();\n    int count \u003d request.getCount();\n    WriteStableHow stableHow \u003d request.getStableHow();\n\n    // Get file length, fail non-append call\n    WccAttr preOpAttr \u003d latestAttr.getWccAttr();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"requesed offset\u003d\" + offset + \" and current filesize\u003d\"\n          + preOpAttr.getSize());\n    }\n\n    long nextOffset \u003d getNextOffsetUnprotected();\n    if (offset \u003d\u003d nextOffset) {\n      LOG.info(\"Add to the list, update nextOffset and notify the writer,\"\n          + \" nextOffset:\" + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, WriteCtx.NO_DUMP);\n      addWrite(writeCtx);\n      \n      // Create an async task and change openFileCtx status to indicate async\n      // task pending\n      if (!asyncStatus) {\n        asyncStatus \u003d true;\n        asyncDataService.execute(new AsyncDataService.WriteBackTask(this));\n      }\n      \n      // Update the write time first\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n\n      // Send response immediately for unstable write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n        writeCtx.setReplied(true);\n      }\n\n    } else if (offset \u003e nextOffset) {\n      LOG.info(\"Add new write to the list but not update nextOffset:\"\n          + nextOffset);\n      WriteCtx writeCtx \u003d new WriteCtx(request.getHandle(),\n          request.getOffset(), request.getCount(), request.getStableHow(),\n          request.getData().array(), channel, xid, false, WriteCtx.ALLOW_DUMP);\n      addWrite(writeCtx);\n\n      // Check if need to dump some pending requests to file\n      checkDump(request.getCount());\n      updateLastAccessTime();\n      Nfs3FileAttributes postOpAttr \u003d new Nfs3FileAttributes(latestAttr);\n      \n      // In test, noticed some Linux client sends a batch (e.g., 1MB)\n      // of reordered writes and won\u0027t send more writes until it gets\n      // responses of the previous batch. So here send response immediately for\n      // unstable non-sequential write\n      if (request.getStableHow() \u003d\u003d WriteStableHow.UNSTABLE) {\n        WccData fileWcc \u003d new WccData(preOpAttr, postOpAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n        writeCtx.setReplied(true);\n      }\n\n    } else {\n      // offset \u003c nextOffset\n      LOG.warn(\"(offset,count,nextOffset):\" + \"(\" + offset + \",\" + count + \",\"\n          + nextOffset + \")\");\n      WccData wccData \u003d new WccData(preOpAttr, null);\n      WRITE3Response response;\n\n      if (offset + count \u003e nextOffset) {\n        LOG.warn(\"Haven\u0027t noticed any partial overwrite out of a sequential file\"\n            + \"write requests, so treat it as a real random write, no support.\");\n        response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_INVAL, wccData, 0,\n            WriteStableHow.UNSTABLE, 0);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Process perfectOverWrite\");\n        }\n        response \u003d processPerfectOverWrite(dfsClient, offset, count, stableHow,\n            request.getData().array(),\n            Nfs3Utils.getFileIdPath(request.getHandle()), wccData, iug);\n      }\n      \n      updateLastAccessTime();\n      Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java"
    }
  }
}