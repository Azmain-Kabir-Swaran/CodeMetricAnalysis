{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImageFormatPBSnapshot.java",
  "functionName": "serializeDirDiffList",
  "functionId": "serializeDirDiffList___dir-INodeDirectory__refList-List__INodeReference__(modifiers-final)__out-OutputStream",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
  "functionStartLine": 581,
  "functionEndLine": 642,
  "numCommitsSeen": 36,
  "timeTaken": 4134,
  "changeHistory": [
    "a991e899fb9f98d2089f37ac9ac7c485d3bbb959",
    "ba0da2785d251745969f88a50d33ce61876d91aa",
    "6ea7d78ccb0d1c4af9bcac02a4cff89bdffff252",
    "2624b20291629b4565ea45590b66f2c38f96df67",
    "5c978a43c3052cc1466b23653c354399186b4e10",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305"
  ],
  "changeHistoryShort": {
    "a991e899fb9f98d2089f37ac9ac7c485d3bbb959": "Ybodychange",
    "ba0da2785d251745969f88a50d33ce61876d91aa": "Ybodychange",
    "6ea7d78ccb0d1c4af9bcac02a4cff89bdffff252": "Ybodychange",
    "2624b20291629b4565ea45590b66f2c38f96df67": "Ymultichange(Yparameterchange,Ybodychange)",
    "5c978a43c3052cc1466b23653c354399186b4e10": "Ybodychange",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a991e899fb9f98d2089f37ac9ac7c485d3bbb959": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13314. NameNode should optionally exit if it detects FsImage corruption. Contributed by Arpit Agarwal.\n",
      "commitDate": "28/03/18 12:49 PM",
      "commitName": "a991e899fb9f98d2089f37ac9ac7c485d3bbb959",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "14/03/18 9:42 AM",
      "commitNameOld": "4c57fb0cd9344290a9f4f6422c1457d69465eec7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 14.13,
      "commitsBetweenForRepo": 223,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,62 @@\n     private void serializeDirDiffList(INodeDirectory dir,\n         final List\u003cINodeReference\u003e refList, OutputStream out)\n         throws IOException {\n       DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n       if (sf !\u003d null) {\n         DiffList\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n         SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n             .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n             .setNumOfDiff(diffList.size()).build();\n         entry.writeDelimitedTo(out);\n         for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n           DirectoryDiff diff \u003d diffList.get(i);\n           SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n               DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                            .setChildrenSize(diff.getChildrenSize())\n                            .setIsSnapshotRoot(diff.isSnapshotRoot());\n           INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n           if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n             db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                 .setSnapshotCopy(\n                     buildINodeDirectory(copy, parent.getSaverContext()));\n           }\n           // process created list and deleted list\n           List\u003cINode\u003e created \u003d diff.getChildrenDiff().getCreatedUnmodifiable();\n           db.setCreatedListSize(created.size());\n           List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getDeletedUnmodifiable();\n+          INode previousNode \u003d null;\n+          boolean misordered \u003d false;\n           for (INode d : deleted) {\n+            // getBytes() may return null below, and that is okay.\n+            final int result \u003d previousNode \u003d\u003d null ? -1 :\n+                previousNode.compareTo(d.getLocalNameBytes());\n+            if (result \u003d\u003d 0) {\n+              FSImage.LOG.error(\n+                  \"Name \u0027\" + d.getLocalName() + \"\u0027 is repeated in the \" +\n+                      \"\u0027deleted\u0027 difflist of directory \" +\n+                      dir.getFullPathName() + \", INodeId\u003d\" + dir.getId());\n+              ++numImageErrors;\n+            } else if (result \u003e 0 \u0026\u0026 !misordered) {\n+              misordered \u003d true;\n+              ++numImageErrors;\n+            }\n+            previousNode \u003d d;\n             if (d.isReference()) {\n               refList.add(d.asReference());\n               db.addDeletedINodeRef(refList.size() - 1);\n             } else {\n               db.addDeletedINode(d.getId());\n             }\n           }\n+          if (misordered) {\n+            FSImage.LOG.error(\n+                \"Misordered entries in the \u0027deleted\u0027 difflist of directory \" +\n+                    dir.getFullPathName() + \", INodeId\u003d\" + dir.getId() +\n+                    \". The full list is \" +\n+                    Arrays.toString(deleted.toArray()));\n+          }\n           db.build().writeDelimitedTo(out);\n           saveCreatedList(created, out);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void serializeDirDiffList(INodeDirectory dir,\n        final List\u003cINodeReference\u003e refList, OutputStream out)\n        throws IOException {\n      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n      if (sf !\u003d null) {\n        DiffList\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n            .setNumOfDiff(diffList.size()).build();\n        entry.writeDelimitedTo(out);\n        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n          DirectoryDiff diff \u003d diffList.get(i);\n          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                           .setChildrenSize(diff.getChildrenSize())\n                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                .setSnapshotCopy(\n                    buildINodeDirectory(copy, parent.getSaverContext()));\n          }\n          // process created list and deleted list\n          List\u003cINode\u003e created \u003d diff.getChildrenDiff().getCreatedUnmodifiable();\n          db.setCreatedListSize(created.size());\n          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getDeletedUnmodifiable();\n          INode previousNode \u003d null;\n          boolean misordered \u003d false;\n          for (INode d : deleted) {\n            // getBytes() may return null below, and that is okay.\n            final int result \u003d previousNode \u003d\u003d null ? -1 :\n                previousNode.compareTo(d.getLocalNameBytes());\n            if (result \u003d\u003d 0) {\n              FSImage.LOG.error(\n                  \"Name \u0027\" + d.getLocalName() + \"\u0027 is repeated in the \" +\n                      \"\u0027deleted\u0027 difflist of directory \" +\n                      dir.getFullPathName() + \", INodeId\u003d\" + dir.getId());\n              ++numImageErrors;\n            } else if (result \u003e 0 \u0026\u0026 !misordered) {\n              misordered \u003d true;\n              ++numImageErrors;\n            }\n            previousNode \u003d d;\n            if (d.isReference()) {\n              refList.add(d.asReference());\n              db.addDeletedINodeRef(refList.size() - 1);\n            } else {\n              db.addDeletedINode(d.getId());\n            }\n          }\n          if (misordered) {\n            FSImage.LOG.error(\n                \"Misordered entries in the \u0027deleted\u0027 difflist of directory \" +\n                    dir.getFullPathName() + \", INodeId\u003d\" + dir.getId() +\n                    \". The full list is \" +\n                    Arrays.toString(deleted.toArray()));\n          }\n          db.build().writeDelimitedTo(out);\n          saveCreatedList(created, out);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "ba0da2785d251745969f88a50d33ce61876d91aa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13252. Code refactoring: Remove Diff.ListType.\n",
      "commitDate": "09/03/18 3:50 PM",
      "commitName": "ba0da2785d251745969f88a50d33ce61876d91aa",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "15/02/18 3:33 AM",
      "commitNameOld": "6ea7d78ccb0d1c4af9bcac02a4cff89bdffff252",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 22.51,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,39 @@\n     private void serializeDirDiffList(INodeDirectory dir,\n         final List\u003cINodeReference\u003e refList, OutputStream out)\n         throws IOException {\n       DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n       if (sf !\u003d null) {\n         DiffList\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n         SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n             .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n             .setNumOfDiff(diffList.size()).build();\n         entry.writeDelimitedTo(out);\n         for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n           DirectoryDiff diff \u003d diffList.get(i);\n           SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n               DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                            .setChildrenSize(diff.getChildrenSize())\n                            .setIsSnapshotRoot(diff.isSnapshotRoot());\n           INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n           if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n             db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                 .setSnapshotCopy(\n                     buildINodeDirectory(copy, parent.getSaverContext()));\n           }\n           // process created list and deleted list\n-          List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n-              .getList(ListType.CREATED);\n+          List\u003cINode\u003e created \u003d diff.getChildrenDiff().getCreatedUnmodifiable();\n           db.setCreatedListSize(created.size());\n-          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n+          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getDeletedUnmodifiable();\n           for (INode d : deleted) {\n             if (d.isReference()) {\n               refList.add(d.asReference());\n               db.addDeletedINodeRef(refList.size() - 1);\n             } else {\n               db.addDeletedINode(d.getId());\n             }\n           }\n           db.build().writeDelimitedTo(out);\n           saveCreatedList(created, out);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void serializeDirDiffList(INodeDirectory dir,\n        final List\u003cINodeReference\u003e refList, OutputStream out)\n        throws IOException {\n      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n      if (sf !\u003d null) {\n        DiffList\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n            .setNumOfDiff(diffList.size()).build();\n        entry.writeDelimitedTo(out);\n        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n          DirectoryDiff diff \u003d diffList.get(i);\n          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                           .setChildrenSize(diff.getChildrenSize())\n                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                .setSnapshotCopy(\n                    buildINodeDirectory(copy, parent.getSaverContext()));\n          }\n          // process created list and deleted list\n          List\u003cINode\u003e created \u003d diff.getChildrenDiff().getCreatedUnmodifiable();\n          db.setCreatedListSize(created.size());\n          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getDeletedUnmodifiable();\n          for (INode d : deleted) {\n            if (d.isReference()) {\n              refList.add(d.asReference());\n              db.addDeletedINodeRef(refList.size() - 1);\n            } else {\n              db.addDeletedINode(d.getId());\n            }\n          }\n          db.build().writeDelimitedTo(out);\n          saveCreatedList(created, out);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "6ea7d78ccb0d1c4af9bcac02a4cff89bdffff252": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13142. Define and Implement a DiifList Interface to store and manage SnapshotDiffs.  Contributed by Shashikant Banerjee\n",
      "commitDate": "15/02/18 3:33 AM",
      "commitName": "6ea7d78ccb0d1c4af9bcac02a4cff89bdffff252",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/02/18 2:46 PM",
      "commitNameOld": "4d1bf33d0fa7689a6f83a9c6e5adaac665c0d5d5",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 8.53,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     private void serializeDirDiffList(INodeDirectory dir,\n         final List\u003cINodeReference\u003e refList, OutputStream out)\n         throws IOException {\n       DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n       if (sf !\u003d null) {\n-        List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n+        DiffList\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n         SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n             .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n             .setNumOfDiff(diffList.size()).build();\n         entry.writeDelimitedTo(out);\n         for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n           DirectoryDiff diff \u003d diffList.get(i);\n           SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n               DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                            .setChildrenSize(diff.getChildrenSize())\n                            .setIsSnapshotRoot(diff.isSnapshotRoot());\n           INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n           if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n             db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                 .setSnapshotCopy(\n                     buildINodeDirectory(copy, parent.getSaverContext()));\n           }\n           // process created list and deleted list\n           List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n               .getList(ListType.CREATED);\n           db.setCreatedListSize(created.size());\n           List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n           for (INode d : deleted) {\n             if (d.isReference()) {\n               refList.add(d.asReference());\n               db.addDeletedINodeRef(refList.size() - 1);\n             } else {\n               db.addDeletedINode(d.getId());\n             }\n           }\n           db.build().writeDelimitedTo(out);\n           saveCreatedList(created, out);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void serializeDirDiffList(INodeDirectory dir,\n        final List\u003cINodeReference\u003e refList, OutputStream out)\n        throws IOException {\n      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n      if (sf !\u003d null) {\n        DiffList\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n            .setNumOfDiff(diffList.size()).build();\n        entry.writeDelimitedTo(out);\n        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n          DirectoryDiff diff \u003d diffList.get(i);\n          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                           .setChildrenSize(diff.getChildrenSize())\n                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                .setSnapshotCopy(\n                    buildINodeDirectory(copy, parent.getSaverContext()));\n          }\n          // process created list and deleted list\n          List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n              .getList(ListType.CREATED);\n          db.setCreatedListSize(created.size());\n          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n          for (INode d : deleted) {\n            if (d.isReference()) {\n              refList.add(d.asReference());\n              db.addDeletedINodeRef(refList.size() - 1);\n            } else {\n              db.addDeletedINode(d.getId());\n            }\n          }\n          db.build().writeDelimitedTo(out);\n          saveCreatedList(created, out);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "2624b20291629b4565ea45590b66f2c38f96df67": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5847. Consolidate INodeReference into a separate section. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567812 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 4:00 PM",
      "commitName": "2624b20291629b4565ea45590b66f2c38f96df67",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5847. Consolidate INodeReference into a separate section. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567812 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/02/14 4:00 PM",
          "commitName": "2624b20291629b4565ea45590b66f2c38f96df67",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "10/02/14 3:13 PM",
          "commitNameOld": "5c978a43c3052cc1466b23653c354399186b4e10",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 2.03,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-    private void serializeDirDiffList(INodeDirectory dir, OutputStream out)\n+    private void serializeDirDiffList(INodeDirectory dir,\n+        final List\u003cINodeReference\u003e refList, OutputStream out)\n         throws IOException {\n       DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n       if (sf !\u003d null) {\n         List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n         SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n             .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n             .setNumOfDiff(diffList.size()).build();\n         entry.writeDelimitedTo(out);\n         for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n           DirectoryDiff diff \u003d diffList.get(i);\n           SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n               DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                            .setChildrenSize(diff.getChildrenSize())\n                            .setIsSnapshotRoot(diff.isSnapshotRoot());\n           INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n           if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n             db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                 .setSnapshotCopy(\n                     buildINodeDirectory(copy, parent.getSaverContext().getStringMap()));\n           }\n           // process created list and deleted list\n           List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n               .getList(ListType.CREATED);\n           db.setCreatedListSize(created.size());\n           List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n-          List\u003cINodeReference\u003e refs \u003d new ArrayList\u003cINodeReference\u003e();\n           for (INode d : deleted) {\n             if (d.isReference()) {\n-              refs.add(d.asReference());\n+              refList.add(d.asReference());\n+              db.addDeletedINodeRef(refList.size() - 1);\n             } else {\n               db.addDeletedINode(d.getId());\n             }\n           }\n-          db.setNumOfDeletedRef(refs.size());\n           db.build().writeDelimitedTo(out);\n-          saveCreatedDeletedList(created, refs, out);\n+          saveCreatedList(created, out);\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void serializeDirDiffList(INodeDirectory dir,\n        final List\u003cINodeReference\u003e refList, OutputStream out)\n        throws IOException {\n      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n      if (sf !\u003d null) {\n        List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n            .setNumOfDiff(diffList.size()).build();\n        entry.writeDelimitedTo(out);\n        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n          DirectoryDiff diff \u003d diffList.get(i);\n          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                           .setChildrenSize(diff.getChildrenSize())\n                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                .setSnapshotCopy(\n                    buildINodeDirectory(copy, parent.getSaverContext().getStringMap()));\n          }\n          // process created list and deleted list\n          List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n              .getList(ListType.CREATED);\n          db.setCreatedListSize(created.size());\n          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n          for (INode d : deleted) {\n            if (d.isReference()) {\n              refList.add(d.asReference());\n              db.addDeletedINodeRef(refList.size() - 1);\n            } else {\n              db.addDeletedINode(d.getId());\n            }\n          }\n          db.build().writeDelimitedTo(out);\n          saveCreatedList(created, out);\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
          "extendedDetails": {
            "oldValue": "[dir-INodeDirectory, out-OutputStream]",
            "newValue": "[dir-INodeDirectory, refList-List\u003cINodeReference\u003e(modifiers-final), out-OutputStream]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5847. Consolidate INodeReference into a separate section. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567812 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/02/14 4:00 PM",
          "commitName": "2624b20291629b4565ea45590b66f2c38f96df67",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "10/02/14 3:13 PM",
          "commitNameOld": "5c978a43c3052cc1466b23653c354399186b4e10",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 2.03,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-    private void serializeDirDiffList(INodeDirectory dir, OutputStream out)\n+    private void serializeDirDiffList(INodeDirectory dir,\n+        final List\u003cINodeReference\u003e refList, OutputStream out)\n         throws IOException {\n       DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n       if (sf !\u003d null) {\n         List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n         SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n             .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n             .setNumOfDiff(diffList.size()).build();\n         entry.writeDelimitedTo(out);\n         for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n           DirectoryDiff diff \u003d diffList.get(i);\n           SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n               DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                            .setChildrenSize(diff.getChildrenSize())\n                            .setIsSnapshotRoot(diff.isSnapshotRoot());\n           INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n           if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n             db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                 .setSnapshotCopy(\n                     buildINodeDirectory(copy, parent.getSaverContext().getStringMap()));\n           }\n           // process created list and deleted list\n           List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n               .getList(ListType.CREATED);\n           db.setCreatedListSize(created.size());\n           List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n-          List\u003cINodeReference\u003e refs \u003d new ArrayList\u003cINodeReference\u003e();\n           for (INode d : deleted) {\n             if (d.isReference()) {\n-              refs.add(d.asReference());\n+              refList.add(d.asReference());\n+              db.addDeletedINodeRef(refList.size() - 1);\n             } else {\n               db.addDeletedINode(d.getId());\n             }\n           }\n-          db.setNumOfDeletedRef(refs.size());\n           db.build().writeDelimitedTo(out);\n-          saveCreatedDeletedList(created, refs, out);\n+          saveCreatedList(created, out);\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void serializeDirDiffList(INodeDirectory dir,\n        final List\u003cINodeReference\u003e refList, OutputStream out)\n        throws IOException {\n      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n      if (sf !\u003d null) {\n        List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n            .setNumOfDiff(diffList.size()).build();\n        entry.writeDelimitedTo(out);\n        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n          DirectoryDiff diff \u003d diffList.get(i);\n          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                           .setChildrenSize(diff.getChildrenSize())\n                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                .setSnapshotCopy(\n                    buildINodeDirectory(copy, parent.getSaverContext().getStringMap()));\n          }\n          // process created list and deleted list\n          List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n              .getList(ListType.CREATED);\n          db.setCreatedListSize(created.size());\n          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n          for (INode d : deleted) {\n            if (d.isReference()) {\n              refList.add(d.asReference());\n              db.addDeletedINodeRef(refList.size() - 1);\n            } else {\n              db.addDeletedINode(d.getId());\n            }\n          }\n          db.build().writeDelimitedTo(out);\n          saveCreatedList(created, out);\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
          "extendedDetails": {}
        }
      ]
    },
    "5c978a43c3052cc1466b23653c354399186b4e10": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5915. Refactor FSImageFormatProtobuf to simplify cross section reads. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1566824 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/02/14 3:13 PM",
      "commitName": "5c978a43c3052cc1466b23653c354399186b4e10",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "09/02/14 11:18 AM",
      "commitNameOld": "a2edb11b68ae01a44092cb14ac2717a6aad93305",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     private void serializeDirDiffList(INodeDirectory dir, OutputStream out)\n         throws IOException {\n       DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n       if (sf !\u003d null) {\n         List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n         SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n             .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n             .setNumOfDiff(diffList.size()).build();\n         entry.writeDelimitedTo(out);\n         for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n           DirectoryDiff diff \u003d diffList.get(i);\n           SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n               DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                            .setChildrenSize(diff.getChildrenSize())\n                            .setIsSnapshotRoot(diff.isSnapshotRoot());\n           INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n           if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n             db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                 .setSnapshotCopy(\n-                    buildINodeDirectory(copy, parent.getStringMap()));\n+                    buildINodeDirectory(copy, parent.getSaverContext().getStringMap()));\n           }\n           // process created list and deleted list\n           List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n               .getList(ListType.CREATED);\n           db.setCreatedListSize(created.size());\n           List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n           List\u003cINodeReference\u003e refs \u003d new ArrayList\u003cINodeReference\u003e();\n           for (INode d : deleted) {\n             if (d.isReference()) {\n               refs.add(d.asReference());\n             } else {\n               db.addDeletedINode(d.getId());\n             }\n           }\n           db.setNumOfDeletedRef(refs.size());\n           db.build().writeDelimitedTo(out);\n           saveCreatedDeletedList(created, refs, out);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void serializeDirDiffList(INodeDirectory dir, OutputStream out)\n        throws IOException {\n      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n      if (sf !\u003d null) {\n        List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n            .setNumOfDiff(diffList.size()).build();\n        entry.writeDelimitedTo(out);\n        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n          DirectoryDiff diff \u003d diffList.get(i);\n          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                           .setChildrenSize(diff.getChildrenSize())\n                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                .setSnapshotCopy(\n                    buildINodeDirectory(copy, parent.getSaverContext().getStringMap()));\n          }\n          // process created list and deleted list\n          List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n              .getList(ListType.CREATED);\n          db.setCreatedListSize(created.size());\n          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n          List\u003cINodeReference\u003e refs \u003d new ArrayList\u003cINodeReference\u003e();\n          for (INode d : deleted) {\n            if (d.isReference()) {\n              refs.add(d.asReference());\n            } else {\n              db.addDeletedINode(d.getId());\n            }\n          }\n          db.setNumOfDeletedRef(refs.size());\n          db.build().writeDelimitedTo(out);\n          saveCreatedDeletedList(created, refs, out);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5698. Use protobuf to serialize / deserialize FSImage. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1566359 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/02/14 11:18 AM",
      "commitName": "a2edb11b68ae01a44092cb14ac2717a6aad93305",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,40 @@\n+    private void serializeDirDiffList(INodeDirectory dir, OutputStream out)\n+        throws IOException {\n+      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n+      if (sf !\u003d null) {\n+        List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n+        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n+            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n+            .setNumOfDiff(diffList.size()).build();\n+        entry.writeDelimitedTo(out);\n+        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n+          DirectoryDiff diff \u003d diffList.get(i);\n+          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n+              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n+                           .setChildrenSize(diff.getChildrenSize())\n+                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n+          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n+          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n+            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n+                .setSnapshotCopy(\n+                    buildINodeDirectory(copy, parent.getStringMap()));\n+          }\n+          // process created list and deleted list\n+          List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n+              .getList(ListType.CREATED);\n+          db.setCreatedListSize(created.size());\n+          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n+          List\u003cINodeReference\u003e refs \u003d new ArrayList\u003cINodeReference\u003e();\n+          for (INode d : deleted) {\n+            if (d.isReference()) {\n+              refs.add(d.asReference());\n+            } else {\n+              db.addDeletedINode(d.getId());\n+            }\n+          }\n+          db.setNumOfDeletedRef(refs.size());\n+          db.build().writeDelimitedTo(out);\n+          saveCreatedDeletedList(created, refs, out);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void serializeDirDiffList(INodeDirectory dir, OutputStream out)\n        throws IOException {\n      DirectoryWithSnapshotFeature sf \u003d dir.getDirectoryWithSnapshotFeature();\n      if (sf !\u003d null) {\n        List\u003cDirectoryDiff\u003e diffList \u003d sf.getDiffs().asList();\n        SnapshotDiffSection.DiffEntry entry \u003d SnapshotDiffSection.DiffEntry\n            .newBuilder().setInodeId(dir.getId()).setType(Type.DIRECTORYDIFF)\n            .setNumOfDiff(diffList.size()).build();\n        entry.writeDelimitedTo(out);\n        for (int i \u003d diffList.size() - 1; i \u003e\u003d 0; i--) { // reverse order!\n          DirectoryDiff diff \u003d diffList.get(i);\n          SnapshotDiffSection.DirectoryDiff.Builder db \u003d SnapshotDiffSection.\n              DirectoryDiff.newBuilder().setSnapshotId(diff.getSnapshotId())\n                           .setChildrenSize(diff.getChildrenSize())\n                           .setIsSnapshotRoot(diff.isSnapshotRoot());\n          INodeDirectoryAttributes copy \u003d diff.snapshotINode;\n          if (!diff.isSnapshotRoot() \u0026\u0026 copy !\u003d null) {\n            db.setName(ByteString.copyFrom(copy.getLocalNameBytes()))\n                .setSnapshotCopy(\n                    buildINodeDirectory(copy, parent.getStringMap()));\n          }\n          // process created list and deleted list\n          List\u003cINode\u003e created \u003d diff.getChildrenDiff()\n              .getList(ListType.CREATED);\n          db.setCreatedListSize(created.size());\n          List\u003cINode\u003e deleted \u003d diff.getChildrenDiff().getList(ListType.DELETED);\n          List\u003cINodeReference\u003e refs \u003d new ArrayList\u003cINodeReference\u003e();\n          for (INode d : deleted) {\n            if (d.isReference()) {\n              refs.add(d.asReference());\n            } else {\n              db.addDeletedINode(d.getId());\n            }\n          }\n          db.setNumOfDeletedRef(refs.size());\n          db.build().writeDelimitedTo(out);\n          saveCreatedDeletedList(created, refs, out);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java"
    }
  }
}