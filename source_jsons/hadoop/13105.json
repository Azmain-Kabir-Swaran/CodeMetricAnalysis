{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManagerSafeMode.java",
  "functionName": "leaveSafeMode",
  "functionId": "leaveSafeMode___force-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
  "functionStartLine": 364,
  "functionEndLine": 421,
  "numCommitsSeen": 1430,
  "timeTaken": 44979,
  "changeHistory": [
    "999c8fcbefc876d9c26c23c5b87a64a81e4f113e",
    "67c9780609f707c11626f05028ddfd28f1b878f1",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
    "715b9c649982bff91d1f9eae656ba3b82178e1a3",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "da8e962e39bd41b73b53966826c82e741b08010b",
    "ead7fa0413fd8aacd6d93697cf398ed17c30930f",
    "8bb0dc34e4f14698bea104be6294acb4954358ca",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
    "8c0366bf103ca638b5ef9e962671f7728db4fd10",
    "e918b91e23985fa1bb353c54a2e733f8ba6dbe49",
    "465663afbf0463f8e91d978993f7d46ea9c48dc2",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "2892f6d817d74e90ff50073cd3721ed4ec75ba92",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "cde987996ae727154b5081bf0a76e10c7c236118",
    "5d5b1c6c10c66c6a17b483a3e1a98d59d3d0bdee",
    "c3f6575ca44e8ad803d0b46991472465b595cdeb",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "999c8fcbefc876d9c26c23c5b87a64a81e4f113e": "Ybodychange",
    "67c9780609f707c11626f05028ddfd28f1b878f1": "Ymultichange(Yreturntypechange,Ybodychange)",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yrename)",
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe": "Ymultichange(Yparameterchange,Ybodychange)",
    "715b9c649982bff91d1f9eae656ba3b82178e1a3": "Ybodychange",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "da8e962e39bd41b73b53966826c82e741b08010b": "Ybodychange",
    "ead7fa0413fd8aacd6d93697cf398ed17c30930f": "Ybodychange",
    "8bb0dc34e4f14698bea104be6294acb4954358ca": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": "Ymultichange(Yparameterchange,Ybodychange)",
    "8c0366bf103ca638b5ef9e962671f7728db4fd10": "Ybodychange",
    "e918b91e23985fa1bb353c54a2e733f8ba6dbe49": "Ybodychange",
    "465663afbf0463f8e91d978993f7d46ea9c48dc2": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "2892f6d817d74e90ff50073cd3721ed4ec75ba92": "Ymodifierchange",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "cde987996ae727154b5081bf0a76e10c7c236118": "Ybodychange",
    "5d5b1c6c10c66c6a17b483a3e1a98d59d3d0bdee": "Ybodychange",
    "c3f6575ca44e8ad803d0b46991472465b595cdeb": "Ybodychange",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "999c8fcbefc876d9c26c23c5b87a64a81e4f113e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10999. Introduce separate stats for Replicated and Erasure Coded Blocks apart from the current Aggregated stats. (Manoj Govindassamy via lei)\n",
      "commitDate": "14/06/17 10:44 AM",
      "commitName": "999c8fcbefc876d9c26c23c5b87a64a81e4f113e",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "03/11/16 3:31 PM",
      "commitNameOld": "5cad93d5c753112931ce97dba966d1ce6b53724b",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 222.8,
      "commitsBetweenForRepo": 1228,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,58 @@\n   boolean leaveSafeMode(boolean force) {\n     assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n \n-    final long bytesInFuture \u003d numberOfBytesInFutureBlocks.get();\n+    final long bytesInFuture \u003d getBytesInFuture();\n     if (bytesInFuture \u003e 0) {\n       if (force) {\n         LOG.warn(\"Leaving safe mode due to forceExit. This will cause a data \"\n             + \"loss of {} byte(s).\", bytesInFuture);\n-        numberOfBytesInFutureBlocks.set(0);\n+        bytesInFutureBlocks.reset();\n+        bytesInFutureECBlockGroups.reset();\n       } else {\n         LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n             \"Exiting safe mode will cause a deletion of {} byte(s). Please \" +\n             \"use -forceExit flag to exit safe mode forcefully if data loss is\" +\n             \" acceptable.\", bytesInFuture);\n         return false;\n       }\n     } else if (force) {\n       LOG.warn(\"forceExit used when normal exist would suffice. Treating \" +\n           \"force exit as normal safe mode exit.\");\n     }\n \n     // if not done yet, initialize replication queues.\n     // In the standby, do not populate repl queues\n     if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n         blockManager.shouldPopulateReplQueues()) {\n       blockManager.initializeReplQueues();\n     }\n \n     if (status !\u003d BMSafeModeStatus.OFF) {\n       NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n     }\n     status \u003d BMSafeModeStatus.OFF;\n \n     final long timeInSafemode \u003d monotonicNow() - startTime;\n     NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n         timeInSafemode / 1000);\n     NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n \n     final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n         .getNetworkTopology();\n     NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n         \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n     NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n         blockManager.numOfUnderReplicatedBlocks());\n \n     namesystem.startSecretManagerIfNecessary();\n \n     // If startup has not yet completed, end safemode phase.\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n       prog.endStep(Phase.SAFEMODE,\n           BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n       prog.endPhase(Phase.SAFEMODE);\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean leaveSafeMode(boolean force) {\n    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n\n    final long bytesInFuture \u003d getBytesInFuture();\n    if (bytesInFuture \u003e 0) {\n      if (force) {\n        LOG.warn(\"Leaving safe mode due to forceExit. This will cause a data \"\n            + \"loss of {} byte(s).\", bytesInFuture);\n        bytesInFutureBlocks.reset();\n        bytesInFutureECBlockGroups.reset();\n      } else {\n        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n            \"Exiting safe mode will cause a deletion of {} byte(s). Please \" +\n            \"use -forceExit flag to exit safe mode forcefully if data loss is\" +\n            \" acceptable.\", bytesInFuture);\n        return false;\n      }\n    } else if (force) {\n      LOG.warn(\"forceExit used when normal exist would suffice. Treating \" +\n          \"force exit as normal safe mode exit.\");\n    }\n\n    // if not done yet, initialize replication queues.\n    // In the standby, do not populate repl queues\n    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n        blockManager.shouldPopulateReplQueues()) {\n      blockManager.initializeReplQueues();\n    }\n\n    if (status !\u003d BMSafeModeStatus.OFF) {\n      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n    }\n    status \u003d BMSafeModeStatus.OFF;\n\n    final long timeInSafemode \u003d monotonicNow() - startTime;\n    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n        timeInSafemode / 1000);\n    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n\n    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n        .getNetworkTopology();\n    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n        blockManager.numOfUnderReplicatedBlocks());\n\n    namesystem.startSecretManagerIfNecessary();\n\n    // If startup has not yet completed, end safemode phase.\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n      prog.endStep(Phase.SAFEMODE,\n          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n      prog.endPhase(Phase.SAFEMODE);\n    }\n\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
      "extendedDetails": {}
    },
    "67c9780609f707c11626f05028ddfd28f1b878f1": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-9498. Move code that tracks blocks with future generation stamps to BlockManagerSafeMode. (Contributed by Mingliang Liu)\n",
      "commitDate": "06/01/16 10:30 AM",
      "commitName": "67c9780609f707c11626f05028ddfd28f1b878f1",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-9498. Move code that tracks blocks with future generation stamps to BlockManagerSafeMode. (Contributed by Mingliang Liu)\n",
          "commitDate": "06/01/16 10:30 AM",
          "commitName": "67c9780609f707c11626f05028ddfd28f1b878f1",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "01/12/15 4:09 PM",
          "commitNameOld": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 35.77,
          "commitsBetweenForRepo": 175,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,57 @@\n-  void leaveSafeMode(boolean force) {\n+  boolean leaveSafeMode(boolean force) {\n     assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n \n+    final long bytesInFuture \u003d numberOfBytesInFutureBlocks.get();\n+    if (bytesInFuture \u003e 0) {\n+      if (force) {\n+        LOG.warn(\"Leaving safe mode due to forceExit. This will cause a data \"\n+            + \"loss of {} byte(s).\", bytesInFuture);\n+        numberOfBytesInFutureBlocks.set(0);\n+      } else {\n+        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+            \"Exiting safe mode will cause a deletion of {} byte(s). Please \" +\n+            \"use -forceExit flag to exit safe mode forcefully if data loss is\" +\n+            \" acceptable.\", bytesInFuture);\n+        return false;\n+      }\n+    } else if (force) {\n+      LOG.warn(\"forceExit used when normal exist would suffice. Treating \" +\n+          \"force exit as normal safe mode exit.\");\n+    }\n+\n     // if not done yet, initialize replication queues.\n     // In the standby, do not populate repl queues\n     if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n         blockManager.shouldPopulateReplQueues()) {\n       blockManager.initializeReplQueues();\n     }\n \n-    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n-      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n-          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n-          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n-          \"acceptable.\", blockManager.getBytesInFuture());\n-      return;\n-    }\n-\n     if (status !\u003d BMSafeModeStatus.OFF) {\n       NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n     }\n     status \u003d BMSafeModeStatus.OFF;\n \n     final long timeInSafemode \u003d monotonicNow() - startTime;\n     NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n         timeInSafemode / 1000);\n     NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n \n     final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n         .getNetworkTopology();\n     NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n         \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n     NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n         blockManager.numOfUnderReplicatedBlocks());\n \n     namesystem.startSecretManagerIfNecessary();\n \n     // If startup has not yet completed, end safemode phase.\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n       prog.endStep(Phase.SAFEMODE,\n           BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n       prog.endPhase(Phase.SAFEMODE);\n     }\n+\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean leaveSafeMode(boolean force) {\n    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n\n    final long bytesInFuture \u003d numberOfBytesInFutureBlocks.get();\n    if (bytesInFuture \u003e 0) {\n      if (force) {\n        LOG.warn(\"Leaving safe mode due to forceExit. This will cause a data \"\n            + \"loss of {} byte(s).\", bytesInFuture);\n        numberOfBytesInFutureBlocks.set(0);\n      } else {\n        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n            \"Exiting safe mode will cause a deletion of {} byte(s). Please \" +\n            \"use -forceExit flag to exit safe mode forcefully if data loss is\" +\n            \" acceptable.\", bytesInFuture);\n        return false;\n      }\n    } else if (force) {\n      LOG.warn(\"forceExit used when normal exist would suffice. Treating \" +\n          \"force exit as normal safe mode exit.\");\n    }\n\n    // if not done yet, initialize replication queues.\n    // In the standby, do not populate repl queues\n    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n        blockManager.shouldPopulateReplQueues()) {\n      blockManager.initializeReplQueues();\n    }\n\n    if (status !\u003d BMSafeModeStatus.OFF) {\n      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n    }\n    status \u003d BMSafeModeStatus.OFF;\n\n    final long timeInSafemode \u003d monotonicNow() - startTime;\n    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n        timeInSafemode / 1000);\n    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n\n    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n        .getNetworkTopology();\n    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n        blockManager.numOfUnderReplicatedBlocks());\n\n    namesystem.startSecretManagerIfNecessary();\n\n    // If startup has not yet completed, end safemode phase.\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n      prog.endStep(Phase.SAFEMODE,\n          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n      prog.endPhase(Phase.SAFEMODE);\n    }\n\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9498. Move code that tracks blocks with future generation stamps to BlockManagerSafeMode. (Contributed by Mingliang Liu)\n",
          "commitDate": "06/01/16 10:30 AM",
          "commitName": "67c9780609f707c11626f05028ddfd28f1b878f1",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "01/12/15 4:09 PM",
          "commitNameOld": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 35.77,
          "commitsBetweenForRepo": 175,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,57 @@\n-  void leaveSafeMode(boolean force) {\n+  boolean leaveSafeMode(boolean force) {\n     assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n \n+    final long bytesInFuture \u003d numberOfBytesInFutureBlocks.get();\n+    if (bytesInFuture \u003e 0) {\n+      if (force) {\n+        LOG.warn(\"Leaving safe mode due to forceExit. This will cause a data \"\n+            + \"loss of {} byte(s).\", bytesInFuture);\n+        numberOfBytesInFutureBlocks.set(0);\n+      } else {\n+        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+            \"Exiting safe mode will cause a deletion of {} byte(s). Please \" +\n+            \"use -forceExit flag to exit safe mode forcefully if data loss is\" +\n+            \" acceptable.\", bytesInFuture);\n+        return false;\n+      }\n+    } else if (force) {\n+      LOG.warn(\"forceExit used when normal exist would suffice. Treating \" +\n+          \"force exit as normal safe mode exit.\");\n+    }\n+\n     // if not done yet, initialize replication queues.\n     // In the standby, do not populate repl queues\n     if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n         blockManager.shouldPopulateReplQueues()) {\n       blockManager.initializeReplQueues();\n     }\n \n-    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n-      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n-          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n-          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n-          \"acceptable.\", blockManager.getBytesInFuture());\n-      return;\n-    }\n-\n     if (status !\u003d BMSafeModeStatus.OFF) {\n       NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n     }\n     status \u003d BMSafeModeStatus.OFF;\n \n     final long timeInSafemode \u003d monotonicNow() - startTime;\n     NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n         timeInSafemode / 1000);\n     NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n \n     final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n         .getNetworkTopology();\n     NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n         \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n     NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n         blockManager.numOfUnderReplicatedBlocks());\n \n     namesystem.startSecretManagerIfNecessary();\n \n     // If startup has not yet completed, end safemode phase.\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n       prog.endStep(Phase.SAFEMODE,\n           BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n       prog.endPhase(Phase.SAFEMODE);\n     }\n+\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean leaveSafeMode(boolean force) {\n    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n\n    final long bytesInFuture \u003d numberOfBytesInFutureBlocks.get();\n    if (bytesInFuture \u003e 0) {\n      if (force) {\n        LOG.warn(\"Leaving safe mode due to forceExit. This will cause a data \"\n            + \"loss of {} byte(s).\", bytesInFuture);\n        numberOfBytesInFutureBlocks.set(0);\n      } else {\n        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n            \"Exiting safe mode will cause a deletion of {} byte(s). Please \" +\n            \"use -forceExit flag to exit safe mode forcefully if data loss is\" +\n            \" acceptable.\", bytesInFuture);\n        return false;\n      }\n    } else if (force) {\n      LOG.warn(\"forceExit used when normal exist would suffice. Treating \" +\n          \"force exit as normal safe mode exit.\");\n    }\n\n    // if not done yet, initialize replication queues.\n    // In the standby, do not populate repl queues\n    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n        blockManager.shouldPopulateReplQueues()) {\n      blockManager.initializeReplQueues();\n    }\n\n    if (status !\u003d BMSafeModeStatus.OFF) {\n      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n    }\n    status \u003d BMSafeModeStatus.OFF;\n\n    final long timeInSafemode \u003d monotonicNow() - startTime;\n    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n        timeInSafemode / 1000);\n    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n\n    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n        .getNetworkTopology();\n    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n        blockManager.numOfUnderReplicatedBlocks());\n\n    namesystem.startSecretManagerIfNecessary();\n\n    // If startup has not yet completed, end safemode phase.\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n      prog.endStep(Phase.SAFEMODE,\n          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n      prog.endPhase(Phase.SAFEMODE);\n    }\n\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
          "extendedDetails": {}
        }
      ]
    },
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yrename)",
      "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
      "commitDate": "01/12/15 4:09 PM",
      "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
          "commitDate": "01/12/15 4:09 PM",
          "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "01/12/15 1:32 PM",
          "commitNameOld": "58f6f54eeac779428ac995d196b60ffb90563f97",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-    private synchronized void leave(boolean force) {\n-      // if not done yet, initialize replication queues.\n-      // In the standby, do not populate repl queues\n-      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n-        blockManager.initializeReplQueues();\n-      }\n+  void leaveSafeMode(boolean force) {\n+    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n \n+    // if not done yet, initialize replication queues.\n+    // In the standby, do not populate repl queues\n+    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n+        blockManager.shouldPopulateReplQueues()) {\n+      blockManager.initializeReplQueues();\n+    }\n \n-      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n-        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n-            \"Exiting safe mode will cause a deletion of \" + blockManager\n-            .getBytesInFuture() + \" byte(s). Please use \" +\n-            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n-            \"acceptable.\");\n-        return;\n-      }\n+    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n+      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n+          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n+          \"acceptable.\", blockManager.getBytesInFuture());\n+      return;\n+    }\n \n-      long timeInSafemode \u003d now() - startTime;\n-      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n-                                    + timeInSafemode/1000 + \" secs\");\n-      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n+    if (status !\u003d BMSafeModeStatus.OFF) {\n+      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n+    }\n+    status \u003d BMSafeModeStatus.OFF;\n \n-      //Log the following only once (when transitioning from ON -\u003e OFF)\n-      if (reached \u003e\u003d 0) {\n-        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n-      }\n-      reached \u003d -1;\n-      reachedTimestamp \u003d -1;\n-      safeMode \u003d null;\n-      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n-      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n-          + nt.getNumOfRacks() + \" racks and \"\n-          + nt.getNumOfLeaves() + \" datanodes\");\n-      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n-          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n+    final long timeInSafemode \u003d monotonicNow() - startTime;\n+    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n+        timeInSafemode / 1000);\n+    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n \n-      startSecretManagerIfNecessary();\n+    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n+        .getNetworkTopology();\n+    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n+        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n+    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n+        blockManager.numOfUnderReplicatedBlocks());\n \n-      // If startup has not yet completed, end safemode phase.\n-      StartupProgress prog \u003d NameNode.getStartupProgress();\n-      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n-        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n-        prog.endPhase(Phase.SAFEMODE);\n-      }\n-    }\n\\ No newline at end of file\n+    namesystem.startSecretManagerIfNecessary();\n+\n+    // If startup has not yet completed, end safemode phase.\n+    StartupProgress prog \u003d NameNode.getStartupProgress();\n+    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n+      prog.endStep(Phase.SAFEMODE,\n+          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n+      prog.endPhase(Phase.SAFEMODE);\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  void leaveSafeMode(boolean force) {\n    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n\n    // if not done yet, initialize replication queues.\n    // In the standby, do not populate repl queues\n    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n        blockManager.shouldPopulateReplQueues()) {\n      blockManager.initializeReplQueues();\n    }\n\n    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n          \"acceptable.\", blockManager.getBytesInFuture());\n      return;\n    }\n\n    if (status !\u003d BMSafeModeStatus.OFF) {\n      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n    }\n    status \u003d BMSafeModeStatus.OFF;\n\n    final long timeInSafemode \u003d monotonicNow() - startTime;\n    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n        timeInSafemode / 1000);\n    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n\n    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n        .getNetworkTopology();\n    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n        blockManager.numOfUnderReplicatedBlocks());\n\n    namesystem.startSecretManagerIfNecessary();\n\n    // If startup has not yet completed, end safemode phase.\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n      prog.endStep(Phase.SAFEMODE,\n          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n      prog.endPhase(Phase.SAFEMODE);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
            "oldMethodName": "leave",
            "newMethodName": "leaveSafeMode"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
          "commitDate": "01/12/15 4:09 PM",
          "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "01/12/15 1:32 PM",
          "commitNameOld": "58f6f54eeac779428ac995d196b60ffb90563f97",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-    private synchronized void leave(boolean force) {\n-      // if not done yet, initialize replication queues.\n-      // In the standby, do not populate repl queues\n-      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n-        blockManager.initializeReplQueues();\n-      }\n+  void leaveSafeMode(boolean force) {\n+    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n \n+    // if not done yet, initialize replication queues.\n+    // In the standby, do not populate repl queues\n+    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n+        blockManager.shouldPopulateReplQueues()) {\n+      blockManager.initializeReplQueues();\n+    }\n \n-      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n-        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n-            \"Exiting safe mode will cause a deletion of \" + blockManager\n-            .getBytesInFuture() + \" byte(s). Please use \" +\n-            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n-            \"acceptable.\");\n-        return;\n-      }\n+    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n+      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n+          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n+          \"acceptable.\", blockManager.getBytesInFuture());\n+      return;\n+    }\n \n-      long timeInSafemode \u003d now() - startTime;\n-      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n-                                    + timeInSafemode/1000 + \" secs\");\n-      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n+    if (status !\u003d BMSafeModeStatus.OFF) {\n+      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n+    }\n+    status \u003d BMSafeModeStatus.OFF;\n \n-      //Log the following only once (when transitioning from ON -\u003e OFF)\n-      if (reached \u003e\u003d 0) {\n-        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n-      }\n-      reached \u003d -1;\n-      reachedTimestamp \u003d -1;\n-      safeMode \u003d null;\n-      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n-      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n-          + nt.getNumOfRacks() + \" racks and \"\n-          + nt.getNumOfLeaves() + \" datanodes\");\n-      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n-          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n+    final long timeInSafemode \u003d monotonicNow() - startTime;\n+    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n+        timeInSafemode / 1000);\n+    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n \n-      startSecretManagerIfNecessary();\n+    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n+        .getNetworkTopology();\n+    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n+        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n+    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n+        blockManager.numOfUnderReplicatedBlocks());\n \n-      // If startup has not yet completed, end safemode phase.\n-      StartupProgress prog \u003d NameNode.getStartupProgress();\n-      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n-        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n-        prog.endPhase(Phase.SAFEMODE);\n-      }\n-    }\n\\ No newline at end of file\n+    namesystem.startSecretManagerIfNecessary();\n+\n+    // If startup has not yet completed, end safemode phase.\n+    StartupProgress prog \u003d NameNode.getStartupProgress();\n+    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n+      prog.endStep(Phase.SAFEMODE,\n+          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n+      prog.endPhase(Phase.SAFEMODE);\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  void leaveSafeMode(boolean force) {\n    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n\n    // if not done yet, initialize replication queues.\n    // In the standby, do not populate repl queues\n    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n        blockManager.shouldPopulateReplQueues()) {\n      blockManager.initializeReplQueues();\n    }\n\n    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n          \"acceptable.\", blockManager.getBytesInFuture());\n      return;\n    }\n\n    if (status !\u003d BMSafeModeStatus.OFF) {\n      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n    }\n    status \u003d BMSafeModeStatus.OFF;\n\n    final long timeInSafemode \u003d monotonicNow() - startTime;\n    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n        timeInSafemode / 1000);\n    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n\n    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n        .getNetworkTopology();\n    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n        blockManager.numOfUnderReplicatedBlocks());\n\n    namesystem.startSecretManagerIfNecessary();\n\n    // If startup has not yet completed, end safemode phase.\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n      prog.endStep(Phase.SAFEMODE,\n          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n      prog.endPhase(Phase.SAFEMODE);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
          "commitDate": "01/12/15 4:09 PM",
          "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "01/12/15 1:32 PM",
          "commitNameOld": "58f6f54eeac779428ac995d196b60ffb90563f97",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-    private synchronized void leave(boolean force) {\n-      // if not done yet, initialize replication queues.\n-      // In the standby, do not populate repl queues\n-      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n-        blockManager.initializeReplQueues();\n-      }\n+  void leaveSafeMode(boolean force) {\n+    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n \n+    // if not done yet, initialize replication queues.\n+    // In the standby, do not populate repl queues\n+    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n+        blockManager.shouldPopulateReplQueues()) {\n+      blockManager.initializeReplQueues();\n+    }\n \n-      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n-        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n-            \"Exiting safe mode will cause a deletion of \" + blockManager\n-            .getBytesInFuture() + \" byte(s). Please use \" +\n-            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n-            \"acceptable.\");\n-        return;\n-      }\n+    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n+      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n+          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n+          \"acceptable.\", blockManager.getBytesInFuture());\n+      return;\n+    }\n \n-      long timeInSafemode \u003d now() - startTime;\n-      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n-                                    + timeInSafemode/1000 + \" secs\");\n-      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n+    if (status !\u003d BMSafeModeStatus.OFF) {\n+      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n+    }\n+    status \u003d BMSafeModeStatus.OFF;\n \n-      //Log the following only once (when transitioning from ON -\u003e OFF)\n-      if (reached \u003e\u003d 0) {\n-        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n-      }\n-      reached \u003d -1;\n-      reachedTimestamp \u003d -1;\n-      safeMode \u003d null;\n-      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n-      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n-          + nt.getNumOfRacks() + \" racks and \"\n-          + nt.getNumOfLeaves() + \" datanodes\");\n-      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n-          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n+    final long timeInSafemode \u003d monotonicNow() - startTime;\n+    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n+        timeInSafemode / 1000);\n+    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n \n-      startSecretManagerIfNecessary();\n+    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n+        .getNetworkTopology();\n+    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n+        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n+    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n+        blockManager.numOfUnderReplicatedBlocks());\n \n-      // If startup has not yet completed, end safemode phase.\n-      StartupProgress prog \u003d NameNode.getStartupProgress();\n-      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n-        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n-        prog.endPhase(Phase.SAFEMODE);\n-      }\n-    }\n\\ No newline at end of file\n+    namesystem.startSecretManagerIfNecessary();\n+\n+    // If startup has not yet completed, end safemode phase.\n+    StartupProgress prog \u003d NameNode.getStartupProgress();\n+    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n+      prog.endStep(Phase.SAFEMODE,\n+          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n+      prog.endPhase(Phase.SAFEMODE);\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  void leaveSafeMode(boolean force) {\n    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n\n    // if not done yet, initialize replication queues.\n    // In the standby, do not populate repl queues\n    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n        blockManager.shouldPopulateReplQueues()) {\n      blockManager.initializeReplQueues();\n    }\n\n    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n          \"acceptable.\", blockManager.getBytesInFuture());\n      return;\n    }\n\n    if (status !\u003d BMSafeModeStatus.OFF) {\n      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n    }\n    status \u003d BMSafeModeStatus.OFF;\n\n    final long timeInSafemode \u003d monotonicNow() - startTime;\n    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n        timeInSafemode / 1000);\n    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n\n    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n        .getNetworkTopology();\n    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n        blockManager.numOfUnderReplicatedBlocks());\n\n    namesystem.startSecretManagerIfNecessary();\n\n    // If startup has not yet completed, end safemode phase.\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n      prog.endStep(Phase.SAFEMODE,\n          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n      prog.endPhase(Phase.SAFEMODE);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
          "commitDate": "01/12/15 4:09 PM",
          "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "01/12/15 1:32 PM",
          "commitNameOld": "58f6f54eeac779428ac995d196b60ffb90563f97",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-    private synchronized void leave(boolean force) {\n-      // if not done yet, initialize replication queues.\n-      // In the standby, do not populate repl queues\n-      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n-        blockManager.initializeReplQueues();\n-      }\n+  void leaveSafeMode(boolean force) {\n+    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n \n+    // if not done yet, initialize replication queues.\n+    // In the standby, do not populate repl queues\n+    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n+        blockManager.shouldPopulateReplQueues()) {\n+      blockManager.initializeReplQueues();\n+    }\n \n-      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n-        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n-            \"Exiting safe mode will cause a deletion of \" + blockManager\n-            .getBytesInFuture() + \" byte(s). Please use \" +\n-            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n-            \"acceptable.\");\n-        return;\n-      }\n+    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n+      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n+          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n+          \"acceptable.\", blockManager.getBytesInFuture());\n+      return;\n+    }\n \n-      long timeInSafemode \u003d now() - startTime;\n-      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n-                                    + timeInSafemode/1000 + \" secs\");\n-      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n+    if (status !\u003d BMSafeModeStatus.OFF) {\n+      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n+    }\n+    status \u003d BMSafeModeStatus.OFF;\n \n-      //Log the following only once (when transitioning from ON -\u003e OFF)\n-      if (reached \u003e\u003d 0) {\n-        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n-      }\n-      reached \u003d -1;\n-      reachedTimestamp \u003d -1;\n-      safeMode \u003d null;\n-      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n-      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n-          + nt.getNumOfRacks() + \" racks and \"\n-          + nt.getNumOfLeaves() + \" datanodes\");\n-      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n-          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n+    final long timeInSafemode \u003d monotonicNow() - startTime;\n+    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n+        timeInSafemode / 1000);\n+    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n \n-      startSecretManagerIfNecessary();\n+    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n+        .getNetworkTopology();\n+    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n+        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n+    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n+        blockManager.numOfUnderReplicatedBlocks());\n \n-      // If startup has not yet completed, end safemode phase.\n-      StartupProgress prog \u003d NameNode.getStartupProgress();\n-      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n-        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n-        prog.endPhase(Phase.SAFEMODE);\n-      }\n-    }\n\\ No newline at end of file\n+    namesystem.startSecretManagerIfNecessary();\n+\n+    // If startup has not yet completed, end safemode phase.\n+    StartupProgress prog \u003d NameNode.getStartupProgress();\n+    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n+      prog.endStep(Phase.SAFEMODE,\n+          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n+      prog.endPhase(Phase.SAFEMODE);\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  void leaveSafeMode(boolean force) {\n    assert namesystem.hasWriteLock() : \"Leaving safe mode needs write lock!\";\n\n    // if not done yet, initialize replication queues.\n    // In the standby, do not populate repl queues\n    if (!blockManager.isPopulatingReplQueues() \u0026\u0026\n        blockManager.shouldPopulateReplQueues()) {\n      blockManager.initializeReplQueues();\n    }\n\n    if (!force \u0026\u0026 blockManager.getBytesInFuture() \u003e 0) {\n      LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n          \"Exiting safe mode will cause a deletion of {} byte(s). Please use \" +\n          \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n          \"acceptable.\", blockManager.getBytesInFuture());\n      return;\n    }\n\n    if (status !\u003d BMSafeModeStatus.OFF) {\n      NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\");\n    }\n    status \u003d BMSafeModeStatus.OFF;\n\n    final long timeInSafemode \u003d monotonicNow() - startTime;\n    NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after {} secs\",\n        timeInSafemode / 1000);\n    NameNode.getNameNodeMetrics().setSafeModeTime(timeInSafemode);\n\n    final NetworkTopology nt \u003d blockManager.getDatanodeManager()\n        .getNetworkTopology();\n    NameNode.stateChangeLog.info(\"STATE* Network topology has {} racks and {}\" +\n        \" datanodes\", nt.getNumOfRacks(), nt.getNumOfLeaves());\n    NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has {} blocks\",\n        blockManager.numOfUnderReplicatedBlocks());\n\n    namesystem.startSecretManagerIfNecessary();\n\n    // If startup has not yet completed, end safemode phase.\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n      prog.endStep(Phase.SAFEMODE,\n          BlockManagerSafeMode.STEP_AWAITING_REPORTED_BLOCKS);\n      prog.endPhase(Phase.SAFEMODE);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManagerSafeMode.java",
          "extendedDetails": {
            "oldValue": "leave",
            "newValue": "leaveSafeMode"
          }
        }
      ]
    },
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-4015. Safemode should count and report orphaned blocks. (Contributed by Anu Engineer)\n",
      "commitDate": "23/10/15 6:07 PM",
      "commitName": "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-4015. Safemode should count and report orphaned blocks. (Contributed by Anu Engineer)\n",
          "commitDate": "23/10/15 6:07 PM",
          "commitName": "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/10/15 12:15 PM",
          "commitNameOld": "600ad7bf4104bcaeec00a4089d59bb1fdf423299",
          "commitAuthorOld": "Jitendra Pandey",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,45 @@\n-    private synchronized void leave() {\n+    private synchronized void leave(boolean force) {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n         blockManager.initializeReplQueues();\n       }\n+\n+\n+      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n+        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+            \"Exiting safe mode will cause a deletion of \" + blockManager\n+            .getBytesInFuture() + \" byte(s). Please use \" +\n+            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n+            \"acceptable.\");\n+        return;\n+      }\n+\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n \n       //Log the following only once (when transitioning from ON -\u003e OFF)\n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n       reachedTimestamp \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n \n       // If startup has not yet completed, end safemode phase.\n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n         prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n         prog.endPhase(Phase.SAFEMODE);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void leave(boolean force) {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n        blockManager.initializeReplQueues();\n      }\n\n\n      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n            \"Exiting safe mode will cause a deletion of \" + blockManager\n            .getBytesInFuture() + \" byte(s). Please use \" +\n            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n            \"acceptable.\");\n        return;\n      }\n\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n\n      //Log the following only once (when transitioning from ON -\u003e OFF)\n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      reachedTimestamp \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n\n      // If startup has not yet completed, end safemode phase.\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n        prog.endPhase(Phase.SAFEMODE);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[force-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4015. Safemode should count and report orphaned blocks. (Contributed by Anu Engineer)\n",
          "commitDate": "23/10/15 6:07 PM",
          "commitName": "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/10/15 12:15 PM",
          "commitNameOld": "600ad7bf4104bcaeec00a4089d59bb1fdf423299",
          "commitAuthorOld": "Jitendra Pandey",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,45 @@\n-    private synchronized void leave() {\n+    private synchronized void leave(boolean force) {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n         blockManager.initializeReplQueues();\n       }\n+\n+\n+      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n+        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n+            \"Exiting safe mode will cause a deletion of \" + blockManager\n+            .getBytesInFuture() + \" byte(s). Please use \" +\n+            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n+            \"acceptable.\");\n+        return;\n+      }\n+\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n \n       //Log the following only once (when transitioning from ON -\u003e OFF)\n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n       reachedTimestamp \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n \n       // If startup has not yet completed, end safemode phase.\n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n         prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n         prog.endPhase(Phase.SAFEMODE);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void leave(boolean force) {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n        blockManager.initializeReplQueues();\n      }\n\n\n      if (!force \u0026\u0026 (blockManager.getBytesInFuture() \u003e 0)) {\n        LOG.error(\"Refusing to leave safe mode without a force flag. \" +\n            \"Exiting safe mode will cause a deletion of \" + blockManager\n            .getBytesInFuture() + \" byte(s). Please use \" +\n            \"-forceExit flag to exit safe mode forcefully if data loss is \" +\n            \"acceptable.\");\n        return;\n      }\n\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n\n      //Log the following only once (when transitioning from ON -\u003e OFF)\n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      reachedTimestamp \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n\n      // If startup has not yet completed, end safemode phase.\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n        prog.endPhase(Phase.SAFEMODE);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "715b9c649982bff91d1f9eae656ba3b82178e1a3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8984. Move replication queues related methods in FSNamesystem to BlockManager. Contributed by Haohui Mai.\n",
      "commitDate": "04/09/15 11:45 AM",
      "commitName": "715b9c649982bff91d1f9eae656ba3b82178e1a3",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "04/09/15 11:42 AM",
      "commitNameOld": "8928729c80af0a154524e06fb13ed9b191986a78",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n-      if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n-        initializeReplQueues();\n+      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n+        blockManager.initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n \n       //Log the following only once (when transitioning from ON -\u003e OFF)\n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n       reachedTimestamp \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n \n       // If startup has not yet completed, end safemode phase.\n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n         prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n         prog.endPhase(Phase.SAFEMODE);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!blockManager.isPopulatingReplQueues() \u0026\u0026 blockManager.shouldPopulateReplQueues()) {\n        blockManager.initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n\n      //Log the following only once (when transitioning from ON -\u003e OFF)\n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      reachedTimestamp \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n\n      // If startup has not yet completed, end safemode phase.\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n        prog.endPhase(Phase.SAFEMODE);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "20/03/15 11:50 AM",
      "commitNameOld": "d368d3647a858644b9fcd3be33d9fea2a6962f69",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n     private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n \n       //Log the following only once (when transitioning from ON -\u003e OFF)\n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n+      reachedTimestamp \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n \n       // If startup has not yet completed, end safemode phase.\n       StartupProgress prog \u003d NameNode.getStartupProgress();\n       if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n         prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n         prog.endPhase(Phase.SAFEMODE);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n\n      //Log the following only once (when transitioning from ON -\u003e OFF)\n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      reachedTimestamp \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n\n      // If startup has not yet completed, end safemode phase.\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n        prog.endPhase(Phase.SAFEMODE);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "da8e962e39bd41b73b53966826c82e741b08010b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4372. Track NameNode startup progress. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 10:35 PM",
      "commitName": "da8e962e39bd41b73b53966826c82e741b08010b",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "07/07/13 10:29 PM",
      "commitNameOld": "6770de7ec4f73e16740f1723f4e35d2fef2c22c8",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,33 @@\n     private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n \n       //Log the following only once (when transitioning from ON -\u003e OFF)\n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n+\n+      // If startup has not yet completed, end safemode phase.\n+      StartupProgress prog \u003d NameNode.getStartupProgress();\n+      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n+        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n+        prog.endPhase(Phase.SAFEMODE);\n+      }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n\n      //Log the following only once (when transitioning from ON -\u003e OFF)\n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n\n      // If startup has not yet completed, end safemode phase.\n      StartupProgress prog \u003d NameNode.getStartupProgress();\n      if (prog.getStatus(Phase.SAFEMODE) !\u003d Status.COMPLETE) {\n        prog.endStep(Phase.SAFEMODE, STEP_AWAITING_REPORTED_BLOCKS);\n        prog.endPhase(Phase.SAFEMODE);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ead7fa0413fd8aacd6d93697cf398ed17c30930f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4888. Refactor and fix FSNamesystem.getTurnOffTip. Contributed by Ravi Prakash.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1498665 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/07/13 1:20 PM",
      "commitName": "ead7fa0413fd8aacd6d93697cf398ed17c30930f",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "21/06/13 12:28 AM",
      "commitNameOld": "92cbba386ff6e8daafc813a07aa30dbbe9825b1d",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 10.54,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,26 @@\n     private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n-      \n+\n+      //Log the following only once (when transitioning from ON -\u003e OFF)\n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n\n      //Log the following only once (when transitioning from ON -\u003e OFF)\n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "8bb0dc34e4f14698bea104be6294acb4954358ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4268. Remove redundant enum NNHAStatusHeartbeat.State. Contributed by Konstantin Shvachko.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1417752 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/12/12 11:20 PM",
      "commitName": "8bb0dc34e4f14698bea104be6294acb4954358ca",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "02/12/12 3:17 PM",
      "commitNameOld": "cbed126eec1f1a1bccce6ad77005cbaa0bf816d4",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 3.34,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n     private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n-      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n+      if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 shouldPopulateReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "26/10/12 11:08 AM",
      "commitNameOld": "0e796b61e829c4bf763caf13b0f53cb1bcefdeee",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.21,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n     private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n-                                    + timeInSafemode/1000 + \" secs.\");\n+                                    + timeInSafemode/1000 + \" secs\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n-        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n+        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2686. Remove DistributedUpgrade related code. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375800 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/12 2:18 PM",
      "commitName": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2686. Remove DistributedUpgrade related code. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375800 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/08/12 2:18 PM",
          "commitName": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "18/08/12 10:46 PM",
          "commitNameOld": "b0ea77303ba62a400376ca32c63c5b138f32cbe7",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.65,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,25 @@\n-    private synchronized void leave(boolean checkForUpgrades) {\n-      if(checkForUpgrades) {\n-        // verify whether a distributed upgrade needs to be started\n-        boolean needUpgrade \u003d false;\n-        try {\n-          needUpgrade \u003d upgradeManager.startUpgrade();\n-        } catch(IOException e) {\n-          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n-        }\n-        if(needUpgrade) {\n-          // switch to manual safe mode\n-          safeMode \u003d new SafeModeInfo(false);\n-          return;\n-        }\n-      }\n+    private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[checkForUpgrades-boolean]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2686. Remove DistributedUpgrade related code. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375800 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/08/12 2:18 PM",
          "commitName": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "18/08/12 10:46 PM",
          "commitNameOld": "b0ea77303ba62a400376ca32c63c5b138f32cbe7",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.65,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,25 @@\n-    private synchronized void leave(boolean checkForUpgrades) {\n-      if(checkForUpgrades) {\n-        // verify whether a distributed upgrade needs to be started\n-        boolean needUpgrade \u003d false;\n-        try {\n-          needUpgrade \u003d upgradeManager.startUpgrade();\n-        } catch(IOException e) {\n-          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n-        }\n-        if(needUpgrade) {\n-          // switch to manual safe mode\n-          safeMode \u003d new SafeModeInfo(false);\n-          return;\n-        }\n-      }\n+    private synchronized void leave() {\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void leave() {\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "8c0366bf103ca638b5ef9e962671f7728db4fd10": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3168. Remove unnecessary \"throw IOException\" and change fields to final in FSNamesystem and BlockManager. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1309218 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/12 7:51 PM",
      "commitName": "8c0366bf103ca638b5ef9e962671f7728db4fd10",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "02/04/12 4:13 PM",
      "commitNameOld": "72b3f302dc3590b7f731cad26558cd592c35dc5a",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n     private synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n           needUpgrade \u003d upgradeManager.startUpgrade();\n         } catch(IOException e) {\n           FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n         initializeReplQueues();\n       }\n-      long timeInSafemode \u003d now() - systemStart;\n+      long timeInSafemode \u003d now() - startTime;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n \n       startSecretManagerIfNecessary();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - startTime;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "e918b91e23985fa1bb353c54a2e733f8ba6dbe49": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2579. Starting delegation token manager during safemode fails. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1242225 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/02/12 10:12 PM",
      "commitName": "e918b91e23985fa1bb353c54a2e733f8ba6dbe49",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "06/02/12 12:24 AM",
      "commitNameOld": "2e4cf977aea30c2a8b35be4eb876874e0055e5f4",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 2.91,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,39 @@\n     private synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n           needUpgrade \u003d upgradeManager.startUpgrade();\n         } catch(IOException e) {\n           FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n       // if not done yet, initialize replication queues.\n       // In the standby, do not populate repl queues\n       if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - systemStart;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n+\n+      startSecretManagerIfNecessary();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n\n      startSecretManagerIfNecessary();\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "465663afbf0463f8e91d978993f7d46ea9c48dc2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2804. Should not mark blocks under-replicated when exiting safemode. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1235033 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/01/12 2:22 PM",
      "commitName": "465663afbf0463f8e91d978993f7d46ea9c48dc2",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "23/01/12 1:49 PM",
      "commitNameOld": "c10853a6b949806a77c2ce610c56a1ad77068a6f",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n     private synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n           needUpgrade \u003d upgradeManager.startUpgrade();\n         } catch(IOException e) {\n           FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n-      // if not done yet, initialize replication queues\n-      if (!isPopulatingReplQueues()) {\n+      // if not done yet, initialize replication queues.\n+      // In the standby, do not populate repl queues\n+      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - systemStart;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues.\n      // In the standby, do not populate repl queues\n      if (!isPopulatingReplQueues() \u0026\u0026 !isInStandbyState()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
      }
    },
    "2892f6d817d74e90ff50073cd3721ed4ec75ba92": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-2266.  Add Namesystem and SafeMode interfaces to avoid directly referring to FSNamesystem in BlockManager.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1160493 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/08/11 4:14 PM",
      "commitName": "2892f6d817d74e90ff50073cd3721ed4ec75ba92",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/08/11 10:36 AM",
      "commitNameOld": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n-    synchronized void leave(boolean checkForUpgrades) {\n+    private synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n           needUpgrade \u003d upgradeManager.startUpgrade();\n         } catch(IOException e) {\n           FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n       // if not done yet, initialize replication queues\n       if (!isPopulatingReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - systemStart;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n           + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldValue": "[synchronized]",
        "newValue": "[private, synchronized]"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
      }
    },
    "cde987996ae727154b5081bf0a76e10c7c236118": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2237. Change UnderReplicatedBlocks from public to package private.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1156424 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/08/11 6:05 PM",
      "commitName": "cde987996ae727154b5081bf0a76e10c7c236118",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "10/08/11 5:46 PM",
      "commitNameOld": "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n     synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n           needUpgrade \u003d upgradeManager.startUpgrade();\n         } catch(IOException e) {\n           FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n       // if not done yet, initialize replication queues\n       if (!isPopulatingReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - systemStart;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n-                                   +blockManager.neededReplications.size()+\" blocks\");\n+          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n          + blockManager.numOfUnderReplicatedBlocks() + \" blocks\");\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5d5b1c6c10c66c6a17b483a3e1a98d59d3d0bdee": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2239. Reduce access levels of the fields and methods in FSNamesystem.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1155998 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/11 6:50 PM",
      "commitName": "5d5b1c6c10c66c6a17b483a3e1a98d59d3d0bdee",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/08/11 3:06 AM",
      "commitNameOld": "371f4a59059322000a40eb4bdf5386b96b626ece",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n     synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n-          needUpgrade \u003d startDistributedUpgradeIfNeeded();\n+          needUpgrade \u003d upgradeManager.startUpgrade();\n         } catch(IOException e) {\n           FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n       // if not done yet, initialize replication queues\n       if (!isPopulatingReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - systemStart;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n           + nt.getNumOfRacks() + \" racks and \"\n           + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n                                    +blockManager.neededReplications.size()+\" blocks\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d upgradeManager.startUpgrade();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n                                   +blockManager.neededReplications.size()+\" blocks\");\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c3f6575ca44e8ad803d0b46991472465b595cdeb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2147. Move cluster network topology to block management and fix some javac warnings.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1148112 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/11 5:26 PM",
      "commitName": "c3f6575ca44e8ad803d0b46991472465b595cdeb",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "13/07/11 4:24 PM",
      "commitNameOld": "8327e70be87990c37ac14dcc1cb1a4d209c65593",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 5.04,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,36 @@\n     synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n           needUpgrade \u003d startDistributedUpgradeIfNeeded();\n         } catch(IOException e) {\n           FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n       // if not done yet, initialize replication queues\n       if (!isPopulatingReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - systemStart;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n+      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n-                                   +clusterMap.getNumOfRacks()+\" racks and \"\n-                                   +clusterMap.getNumOfLeaves()+ \" datanodes\");\n+          + nt.getNumOfRacks() + \" racks and \"\n+          + nt.getNumOfLeaves() + \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n                                    +blockManager.neededReplications.size()+\" blocks\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d startDistributedUpgradeIfNeeded();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      final NetworkTopology nt \u003d blockManager.getDatanodeManager().getNetworkTopology();\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n          + nt.getNumOfRacks() + \" racks and \"\n          + nt.getNumOfLeaves() + \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n                                   +blockManager.neededReplications.size()+\" blocks\");\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1977. Stop using StringUtils.stringifyException(). Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1145834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/11 6:11 PM",
      "commitName": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "11/07/11 4:06 PM",
      "commitNameOld": "b9189f7b158f9c50566a1b591e25e3d76c3b0917",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n     synchronized void leave(boolean checkForUpgrades) {\n       if(checkForUpgrades) {\n         // verify whether a distributed upgrade needs to be started\n         boolean needUpgrade \u003d false;\n         try {\n           needUpgrade \u003d startDistributedUpgradeIfNeeded();\n         } catch(IOException e) {\n-          FSNamesystem.LOG.error(StringUtils.stringifyException(e));\n+          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n         }\n         if(needUpgrade) {\n           // switch to manual safe mode\n           safeMode \u003d new SafeModeInfo(false);\n           return;\n         }\n       }\n       // if not done yet, initialize replication queues\n       if (!isPopulatingReplQueues()) {\n         initializeReplQueues();\n       }\n       long timeInSafemode \u003d now() - systemStart;\n       NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                     + timeInSafemode/1000 + \" secs.\");\n       NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n       \n       if (reached \u003e\u003d 0) {\n         NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n       }\n       reached \u003d -1;\n       safeMode \u003d null;\n       NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n                                    +clusterMap.getNumOfRacks()+\" racks and \"\n                                    +clusterMap.getNumOfLeaves()+ \" datanodes\");\n       NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n                                    +blockManager.neededReplications.size()+\" blocks\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d startDistributedUpgradeIfNeeded();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(\"IOException in startDistributedUpgradeIfNeeded\", e);\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n                                   +clusterMap.getNumOfRacks()+\" racks and \"\n                                   +clusterMap.getNumOfLeaves()+ \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n                                   +blockManager.neededReplications.size()+\" blocks\");\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,35 @@\n+    synchronized void leave(boolean checkForUpgrades) {\n+      if(checkForUpgrades) {\n+        // verify whether a distributed upgrade needs to be started\n+        boolean needUpgrade \u003d false;\n+        try {\n+          needUpgrade \u003d startDistributedUpgradeIfNeeded();\n+        } catch(IOException e) {\n+          FSNamesystem.LOG.error(StringUtils.stringifyException(e));\n+        }\n+        if(needUpgrade) {\n+          // switch to manual safe mode\n+          safeMode \u003d new SafeModeInfo(false);\n+          return;\n+        }\n+      }\n+      // if not done yet, initialize replication queues\n+      if (!isPopulatingReplQueues()) {\n+        initializeReplQueues();\n+      }\n+      long timeInSafemode \u003d now() - systemStart;\n+      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n+                                    + timeInSafemode/1000 + \" secs.\");\n+      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n+      \n+      if (reached \u003e\u003d 0) {\n+        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n+      }\n+      reached \u003d -1;\n+      safeMode \u003d null;\n+      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n+                                   +clusterMap.getNumOfRacks()+\" racks and \"\n+                                   +clusterMap.getNumOfLeaves()+ \" datanodes\");\n+      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n+                                   +blockManager.neededReplications.size()+\" blocks\");\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    synchronized void leave(boolean checkForUpgrades) {\n      if(checkForUpgrades) {\n        // verify whether a distributed upgrade needs to be started\n        boolean needUpgrade \u003d false;\n        try {\n          needUpgrade \u003d startDistributedUpgradeIfNeeded();\n        } catch(IOException e) {\n          FSNamesystem.LOG.error(StringUtils.stringifyException(e));\n        }\n        if(needUpgrade) {\n          // switch to manual safe mode\n          safeMode \u003d new SafeModeInfo(false);\n          return;\n        }\n      }\n      // if not done yet, initialize replication queues\n      if (!isPopulatingReplQueues()) {\n        initializeReplQueues();\n      }\n      long timeInSafemode \u003d now() - systemStart;\n      NameNode.stateChangeLog.info(\"STATE* Leaving safe mode after \" \n                                    + timeInSafemode/1000 + \" secs.\");\n      NameNode.getNameNodeMetrics().setSafeModeTime((int) timeInSafemode);\n      \n      if (reached \u003e\u003d 0) {\n        NameNode.stateChangeLog.info(\"STATE* Safe mode is OFF.\"); \n      }\n      reached \u003d -1;\n      safeMode \u003d null;\n      NameNode.stateChangeLog.info(\"STATE* Network topology has \"\n                                   +clusterMap.getNumOfRacks()+\" racks and \"\n                                   +clusterMap.getNumOfLeaves()+ \" datanodes\");\n      NameNode.stateChangeLog.info(\"STATE* UnderReplicatedBlocks has \"\n                                   +blockManager.neededReplications.size()+\" blocks\");\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}