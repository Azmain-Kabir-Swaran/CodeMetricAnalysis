{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FederationInterceptor.java",
  "functionName": "allocate",
  "functionId": "allocate___request-AllocateRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
  "functionStartLine": 623,
  "functionEndLine": 721,
  "numCommitsSeen": 21,
  "timeTaken": 4729,
  "changeHistory": [
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
    "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
    "3090922805699b8374a359e92323884a4177dc4e",
    "f1525825623a1307b5aa55c456b6afa3e0c61135",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32",
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e",
    "bed1832c934fe4ba44efdcdc49fce06457dc3d4f"
  ],
  "changeHistoryShort": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": "Ybodychange",
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de": "Ybodychange",
    "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a": "Ybodychange",
    "3090922805699b8374a359e92323884a4177dc4e": "Ymultichange(Yexceptionschange,Ybodychange)",
    "f1525825623a1307b5aa55c456b6afa3e0c61135": "Ybodychange",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": "Ybodychange",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": "Ybodychange",
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e": "Ybodychange",
    "bed1832c934fe4ba44efdcdc49fce06457dc3d4f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "11/11/18 11:12 AM",
      "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
      "commitAuthor": "Botong Huang",
      "commitDateOld": "02/11/18 3:30 PM",
      "commitNameOld": "989715ec5066c6ac7868e25ad9234dc64723e61e",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   public AllocateResponse allocate(AllocateRequest request)\n       throws YarnException, IOException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n+    this.lastAMHeartbeatTime \u003d this.clock.getTime();\n \n     if (this.justRecovered) {\n       throw new ApplicationMasterNotRegisteredException(\n           \"AMRMProxy just restarted and recovered for \" + this.attemptId\n               + \". AM should re-register and full re-send pending requests.\");\n     }\n \n     if (this.finishAMCalled) {\n       LOG.warn(\"FinishApplicationMaster already called by {}, skip heartbeat \"\n           + \"processing and return dummy response\" + this.attemptId);\n       return RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n     }\n \n     // Check responseId and handle duplicate heartbeat exactly same as RM\n     synchronized (this.lastAllocateResponseLock) {\n       LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n           + request.getResponseId() + \" when we are expecting \"\n           + this.lastAllocateResponse.getResponseId());\n       // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n       if (AMRMClientUtils.getNextResponseId(\n           request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n               .getResponseId()) {\n         // heartbeat one step old, simply return lastReponse\n         return this.lastAllocateResponse;\n       } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n           .getResponseId()) {\n         throw new InvalidApplicationMasterRequestException(\n             AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                 this.lastAllocateResponse.getResponseId(),\n                 request.getResponseId()));\n       }\n     }\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n       /**\n        * Send the requests to the all sub-cluster resource managers. All\n        * requests are synchronously triggered but sent asynchronously. Later the\n        * responses will be collected and merged.\n        */\n       sendRequestsToResourceManagers(requests);\n \n       // Wait for the first async response to arrive\n       long startTime \u003d this.clock.getTime();\n       synchronized (this.asyncResponseSink) {\n         try {\n           this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n         } catch (InterruptedException e) {\n         }\n       }\n       long firstResponseTime \u003d this.clock.getTime() - startTime;\n \n       // An extra brief wait for other async heart beats, so that most of their\n       // responses can make it back to AM in the same heart beat round trip.\n       try {\n         Thread.sleep(firstResponseTime);\n       } catch (InterruptedException e) {\n       }\n \n       // Prepare the response to AM\n-      AllocateResponse response \u003d\n-          RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n+      AllocateResponse response \u003d generateBaseAllocationResponse();\n \n       // Merge all responses from response sink\n       mergeAllocateResponses(response);\n \n       // Merge the containers and NMTokens from the new registrations into\n       // the response\n \n       if (!isNullOrEmpty(this.uamRegistrations)) {\n         Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e newRegistrations;\n         synchronized (this.uamRegistrations) {\n           newRegistrations \u003d new HashMap\u003c\u003e(this.uamRegistrations);\n           this.uamRegistrations.clear();\n         }\n         mergeRegistrationResponses(response, newRegistrations);\n       }\n \n       // update the responseId and return the final response to AM\n       synchronized (this.lastAllocateResponseLock) {\n         response.setResponseId(AMRMClientUtils\n             .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n         this.lastAllocateResponse \u003d response;\n       }\n       return response;\n     } catch (Throwable ex) {\n       LOG.error(\"Exception encountered while processing heart beat for \"\n           + this.attemptId, ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException, IOException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n    this.lastAMHeartbeatTime \u003d this.clock.getTime();\n\n    if (this.justRecovered) {\n      throw new ApplicationMasterNotRegisteredException(\n          \"AMRMProxy just restarted and recovered for \" + this.attemptId\n              + \". AM should re-register and full re-send pending requests.\");\n    }\n\n    if (this.finishAMCalled) {\n      LOG.warn(\"FinishApplicationMaster already called by {}, skip heartbeat \"\n          + \"processing and return dummy response\" + this.attemptId);\n      return RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n    }\n\n    // Check responseId and handle duplicate heartbeat exactly same as RM\n    synchronized (this.lastAllocateResponseLock) {\n      LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n          + request.getResponseId() + \" when we are expecting \"\n          + this.lastAllocateResponse.getResponseId());\n      // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n      if (AMRMClientUtils.getNextResponseId(\n          request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n              .getResponseId()) {\n        // heartbeat one step old, simply return lastReponse\n        return this.lastAllocateResponse;\n      } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n          .getResponseId()) {\n        throw new InvalidApplicationMasterRequestException(\n            AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                this.lastAllocateResponse.getResponseId(),\n                request.getResponseId()));\n      }\n    }\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      /**\n       * Send the requests to the all sub-cluster resource managers. All\n       * requests are synchronously triggered but sent asynchronously. Later the\n       * responses will be collected and merged.\n       */\n      sendRequestsToResourceManagers(requests);\n\n      // Wait for the first async response to arrive\n      long startTime \u003d this.clock.getTime();\n      synchronized (this.asyncResponseSink) {\n        try {\n          this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n        } catch (InterruptedException e) {\n        }\n      }\n      long firstResponseTime \u003d this.clock.getTime() - startTime;\n\n      // An extra brief wait for other async heart beats, so that most of their\n      // responses can make it back to AM in the same heart beat round trip.\n      try {\n        Thread.sleep(firstResponseTime);\n      } catch (InterruptedException e) {\n      }\n\n      // Prepare the response to AM\n      AllocateResponse response \u003d generateBaseAllocationResponse();\n\n      // Merge all responses from response sink\n      mergeAllocateResponses(response);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the response\n\n      if (!isNullOrEmpty(this.uamRegistrations)) {\n        Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e newRegistrations;\n        synchronized (this.uamRegistrations) {\n          newRegistrations \u003d new HashMap\u003c\u003e(this.uamRegistrations);\n          this.uamRegistrations.clear();\n        }\n        mergeRegistrationResponses(response, newRegistrations);\n      }\n\n      // update the responseId and return the final response to AM\n      synchronized (this.lastAllocateResponseLock) {\n        response.setResponseId(AMRMClientUtils\n            .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n        this.lastAllocateResponse \u003d response;\n      }\n      return response;\n    } catch (Throwable ex) {\n      LOG.error(\"Exception encountered while processing heart beat for \"\n          + this.attemptId, ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7652. Handle AM register requests asynchronously in FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "09/10/18 10:29 AM",
      "commitName": "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "01/10/18 1:12 PM",
      "commitNameOld": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 7.89,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,99 @@\n   public AllocateResponse allocate(AllocateRequest request)\n       throws YarnException, IOException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n \n     if (this.justRecovered) {\n       throw new ApplicationMasterNotRegisteredException(\n           \"AMRMProxy just restarted and recovered for \" + this.attemptId\n               + \". AM should re-register and full re-send pending requests.\");\n     }\n \n     if (this.finishAMCalled) {\n       LOG.warn(\"FinishApplicationMaster already called by {}, skip heartbeat \"\n           + \"processing and return dummy response\" + this.attemptId);\n       return RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n     }\n \n     // Check responseId and handle duplicate heartbeat exactly same as RM\n     synchronized (this.lastAllocateResponseLock) {\n       LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n           + request.getResponseId() + \" when we are expecting \"\n           + this.lastAllocateResponse.getResponseId());\n       // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n       if (AMRMClientUtils.getNextResponseId(\n           request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n               .getResponseId()) {\n         // heartbeat one step old, simply return lastReponse\n         return this.lastAllocateResponse;\n       } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n           .getResponseId()) {\n         throw new InvalidApplicationMasterRequestException(\n             AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                 this.lastAllocateResponse.getResponseId(),\n                 request.getResponseId()));\n       }\n     }\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n       /**\n        * Send the requests to the all sub-cluster resource managers. All\n        * requests are synchronously triggered but sent asynchronously. Later the\n-       * responses will be collected and merged. In addition, it also returns\n-       * the newly registered UAMs.\n+       * responses will be collected and merged.\n        */\n-      Registrations newRegistrations \u003d sendRequestsToResourceManagers(requests);\n+      sendRequestsToResourceManagers(requests);\n \n       // Wait for the first async response to arrive\n       long startTime \u003d this.clock.getTime();\n       synchronized (this.asyncResponseSink) {\n         try {\n           this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n         } catch (InterruptedException e) {\n         }\n       }\n       long firstResponseTime \u003d this.clock.getTime() - startTime;\n \n       // An extra brief wait for other async heart beats, so that most of their\n       // responses can make it back to AM in the same heart beat round trip.\n       try {\n         Thread.sleep(firstResponseTime);\n       } catch (InterruptedException e) {\n       }\n \n       // Prepare the response to AM\n       AllocateResponse response \u003d\n           RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n \n       // Merge all responses from response sink\n       mergeAllocateResponses(response);\n \n       // Merge the containers and NMTokens from the new registrations into\n       // the response\n-      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n-        mergeRegistrationResponses(response,\n-            newRegistrations.getSuccessfulRegistrations());\n+\n+      if (!isNullOrEmpty(this.uamRegistrations)) {\n+        Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e newRegistrations;\n+        synchronized (this.uamRegistrations) {\n+          newRegistrations \u003d new HashMap\u003c\u003e(this.uamRegistrations);\n+          this.uamRegistrations.clear();\n+        }\n+        mergeRegistrationResponses(response, newRegistrations);\n       }\n \n       // update the responseId and return the final response to AM\n       synchronized (this.lastAllocateResponseLock) {\n         response.setResponseId(AMRMClientUtils\n             .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n         this.lastAllocateResponse \u003d response;\n       }\n       return response;\n     } catch (Throwable ex) {\n       LOG.error(\"Exception encountered while processing heart beat for \"\n           + this.attemptId, ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException, IOException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    if (this.justRecovered) {\n      throw new ApplicationMasterNotRegisteredException(\n          \"AMRMProxy just restarted and recovered for \" + this.attemptId\n              + \". AM should re-register and full re-send pending requests.\");\n    }\n\n    if (this.finishAMCalled) {\n      LOG.warn(\"FinishApplicationMaster already called by {}, skip heartbeat \"\n          + \"processing and return dummy response\" + this.attemptId);\n      return RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n    }\n\n    // Check responseId and handle duplicate heartbeat exactly same as RM\n    synchronized (this.lastAllocateResponseLock) {\n      LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n          + request.getResponseId() + \" when we are expecting \"\n          + this.lastAllocateResponse.getResponseId());\n      // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n      if (AMRMClientUtils.getNextResponseId(\n          request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n              .getResponseId()) {\n        // heartbeat one step old, simply return lastReponse\n        return this.lastAllocateResponse;\n      } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n          .getResponseId()) {\n        throw new InvalidApplicationMasterRequestException(\n            AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                this.lastAllocateResponse.getResponseId(),\n                request.getResponseId()));\n      }\n    }\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      /**\n       * Send the requests to the all sub-cluster resource managers. All\n       * requests are synchronously triggered but sent asynchronously. Later the\n       * responses will be collected and merged.\n       */\n      sendRequestsToResourceManagers(requests);\n\n      // Wait for the first async response to arrive\n      long startTime \u003d this.clock.getTime();\n      synchronized (this.asyncResponseSink) {\n        try {\n          this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n        } catch (InterruptedException e) {\n        }\n      }\n      long firstResponseTime \u003d this.clock.getTime() - startTime;\n\n      // An extra brief wait for other async heart beats, so that most of their\n      // responses can make it back to AM in the same heart beat round trip.\n      try {\n        Thread.sleep(firstResponseTime);\n      } catch (InterruptedException e) {\n      }\n\n      // Prepare the response to AM\n      AllocateResponse response \u003d\n          RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n\n      // Merge all responses from response sink\n      mergeAllocateResponses(response);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the response\n\n      if (!isNullOrEmpty(this.uamRegistrations)) {\n        Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e newRegistrations;\n        synchronized (this.uamRegistrations) {\n          newRegistrations \u003d new HashMap\u003c\u003e(this.uamRegistrations);\n          this.uamRegistrations.clear();\n        }\n        mergeRegistrationResponses(response, newRegistrations);\n      }\n\n      // update the responseId and return the final response to AM\n      synchronized (this.lastAllocateResponseLock) {\n        response.setResponseId(AMRMClientUtils\n            .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n        this.lastAllocateResponse \u003d response;\n      }\n      return response;\n    } catch (Throwable ex) {\n      LOG.error(\"Exception encountered while processing heart beat for \"\n          + this.attemptId, ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8760. [AMRMProxy] Fix concurrent re-register due to YarnRM failover in AMRMClientRelayer. Contributed by Botong Huang.\n",
      "commitDate": "01/10/18 1:12 PM",
      "commitName": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "24/09/18 11:37 AM",
      "commitNameOld": "3090922805699b8374a359e92323884a4177dc4e",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 7.07,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,95 @@\n   public AllocateResponse allocate(AllocateRequest request)\n       throws YarnException, IOException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n \n     if (this.justRecovered) {\n       throw new ApplicationMasterNotRegisteredException(\n           \"AMRMProxy just restarted and recovered for \" + this.attemptId\n               + \". AM should re-register and full re-send pending requests.\");\n     }\n \n+    if (this.finishAMCalled) {\n+      LOG.warn(\"FinishApplicationMaster already called by {}, skip heartbeat \"\n+          + \"processing and return dummy response\" + this.attemptId);\n+      return RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n+    }\n+\n     // Check responseId and handle duplicate heartbeat exactly same as RM\n     synchronized (this.lastAllocateResponseLock) {\n       LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n           + request.getResponseId() + \" when we are expecting \"\n           + this.lastAllocateResponse.getResponseId());\n       // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n       if (AMRMClientUtils.getNextResponseId(\n           request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n               .getResponseId()) {\n         // heartbeat one step old, simply return lastReponse\n         return this.lastAllocateResponse;\n       } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n           .getResponseId()) {\n         throw new InvalidApplicationMasterRequestException(\n             AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                 this.lastAllocateResponse.getResponseId(),\n                 request.getResponseId()));\n       }\n     }\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n       /**\n        * Send the requests to the all sub-cluster resource managers. All\n        * requests are synchronously triggered but sent asynchronously. Later the\n        * responses will be collected and merged. In addition, it also returns\n        * the newly registered UAMs.\n        */\n       Registrations newRegistrations \u003d sendRequestsToResourceManagers(requests);\n \n       // Wait for the first async response to arrive\n       long startTime \u003d this.clock.getTime();\n       synchronized (this.asyncResponseSink) {\n         try {\n           this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n         } catch (InterruptedException e) {\n         }\n       }\n       long firstResponseTime \u003d this.clock.getTime() - startTime;\n \n       // An extra brief wait for other async heart beats, so that most of their\n       // responses can make it back to AM in the same heart beat round trip.\n       try {\n         Thread.sleep(firstResponseTime);\n       } catch (InterruptedException e) {\n       }\n \n       // Prepare the response to AM\n       AllocateResponse response \u003d\n           RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n \n       // Merge all responses from response sink\n       mergeAllocateResponses(response);\n \n       // Merge the containers and NMTokens from the new registrations into\n       // the response\n       if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n         mergeRegistrationResponses(response,\n             newRegistrations.getSuccessfulRegistrations());\n       }\n \n       // update the responseId and return the final response to AM\n       synchronized (this.lastAllocateResponseLock) {\n         response.setResponseId(AMRMClientUtils\n             .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n         this.lastAllocateResponse \u003d response;\n       }\n       return response;\n     } catch (Throwable ex) {\n       LOG.error(\"Exception encountered while processing heart beat for \"\n           + this.attemptId, ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException, IOException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    if (this.justRecovered) {\n      throw new ApplicationMasterNotRegisteredException(\n          \"AMRMProxy just restarted and recovered for \" + this.attemptId\n              + \". AM should re-register and full re-send pending requests.\");\n    }\n\n    if (this.finishAMCalled) {\n      LOG.warn(\"FinishApplicationMaster already called by {}, skip heartbeat \"\n          + \"processing and return dummy response\" + this.attemptId);\n      return RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n    }\n\n    // Check responseId and handle duplicate heartbeat exactly same as RM\n    synchronized (this.lastAllocateResponseLock) {\n      LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n          + request.getResponseId() + \" when we are expecting \"\n          + this.lastAllocateResponse.getResponseId());\n      // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n      if (AMRMClientUtils.getNextResponseId(\n          request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n              .getResponseId()) {\n        // heartbeat one step old, simply return lastReponse\n        return this.lastAllocateResponse;\n      } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n          .getResponseId()) {\n        throw new InvalidApplicationMasterRequestException(\n            AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                this.lastAllocateResponse.getResponseId(),\n                request.getResponseId()));\n      }\n    }\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      /**\n       * Send the requests to the all sub-cluster resource managers. All\n       * requests are synchronously triggered but sent asynchronously. Later the\n       * responses will be collected and merged. In addition, it also returns\n       * the newly registered UAMs.\n       */\n      Registrations newRegistrations \u003d sendRequestsToResourceManagers(requests);\n\n      // Wait for the first async response to arrive\n      long startTime \u003d this.clock.getTime();\n      synchronized (this.asyncResponseSink) {\n        try {\n          this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n        } catch (InterruptedException e) {\n        }\n      }\n      long firstResponseTime \u003d this.clock.getTime() - startTime;\n\n      // An extra brief wait for other async heart beats, so that most of their\n      // responses can make it back to AM in the same heart beat round trip.\n      try {\n        Thread.sleep(firstResponseTime);\n      } catch (InterruptedException e) {\n      }\n\n      // Prepare the response to AM\n      AllocateResponse response \u003d\n          RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n\n      // Merge all responses from response sink\n      mergeAllocateResponses(response);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the response\n      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n        mergeRegistrationResponses(response,\n            newRegistrations.getSuccessfulRegistrations());\n      }\n\n      // update the responseId and return the final response to AM\n      synchronized (this.lastAllocateResponseLock) {\n        response.setResponseId(AMRMClientUtils\n            .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n        this.lastAllocateResponse \u003d response;\n      }\n      return response;\n    } catch (Throwable ex) {\n      LOG.error(\"Exception encountered while processing heart beat for \"\n          + this.attemptId, ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "3090922805699b8374a359e92323884a4177dc4e": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.\n",
      "commitDate": "24/09/18 11:37 AM",
      "commitName": "3090922805699b8374a359e92323884a4177dc4e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.\n",
          "commitDate": "24/09/18 11:37 AM",
          "commitName": "3090922805699b8374a359e92323884a4177dc4e",
          "commitAuthor": "Giovanni Matteo Fumarola",
          "commitDateOld": "12/09/18 11:46 AM",
          "commitNameOld": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 11.99,
          "commitsBetweenForRepo": 142,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,89 @@\n   public AllocateResponse allocate(AllocateRequest request)\n-      throws YarnException {\n+      throws YarnException, IOException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n \n-    if (this.justRecovered \u0026\u0026 this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n-      // Save the responseId home RM is expecting\n-      this.lastHomeResponseId \u003d request.getResponseId();\n-\n+    if (this.justRecovered) {\n       throw new ApplicationMasterNotRegisteredException(\n           \"AMRMProxy just restarted and recovered for \" + this.attemptId\n               + \". AM should re-register and full re-send pending requests.\");\n     }\n \n-    // Override responseId in the request in two cases:\n-    //\n-    // 1. After we just recovered after an NM restart and AM\u0027s responseId is\n-    // reset due to the exception we generate. We need to override the\n-    // responseId to the one homeRM expects.\n-    //\n-    // 2. After homeRM fail-over, the allocate response with reseted responseId\n-    // might not be returned successfully back to AM because of RPC connection\n-    // timeout between AM and AMRMProxy. In this case, we remember and reset the\n-    // responseId for AM.\n-    if (this.justRecovered\n-        || request.getResponseId() \u003e this.lastHomeResponseId) {\n-      LOG.warn(\"Setting allocate responseId for {} from {} to {}\",\n-          this.attemptId, request.getResponseId(), this.lastHomeResponseId);\n-      request.setResponseId(this.lastHomeResponseId);\n+    // Check responseId and handle duplicate heartbeat exactly same as RM\n+    synchronized (this.lastAllocateResponseLock) {\n+      LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n+          + request.getResponseId() + \" when we are expecting \"\n+          + this.lastAllocateResponse.getResponseId());\n+      // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n+      if (AMRMClientUtils.getNextResponseId(\n+          request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n+              .getResponseId()) {\n+        // heartbeat one step old, simply return lastReponse\n+        return this.lastAllocateResponse;\n+      } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n+          .getResponseId()) {\n+        throw new InvalidApplicationMasterRequestException(\n+            AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n+                this.lastAllocateResponse.getResponseId(),\n+                request.getResponseId()));\n+      }\n     }\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n-      // Send the requests to the secondary sub-cluster resource managers.\n-      // These secondary requests are send asynchronously and the responses will\n-      // be collected and merged with the home response. In addition, it also\n-      // return the newly registered Unmanaged AMs.\n-      Registrations newRegistrations \u003d\n-          sendRequestsToSecondaryResourceManagers(requests);\n+      /**\n+       * Send the requests to the all sub-cluster resource managers. All\n+       * requests are synchronously triggered but sent asynchronously. Later the\n+       * responses will be collected and merged. In addition, it also returns\n+       * the newly registered UAMs.\n+       */\n+      Registrations newRegistrations \u003d sendRequestsToResourceManagers(requests);\n \n-      // Send the request to the home RM and get the response\n-      AllocateRequest homeRequest \u003d requests.get(this.homeSubClusterId);\n-      LOG.info(\"{} heartbeating to home RM with responseId {}\", this.attemptId,\n-          homeRequest.getResponseId());\n-\n-      AllocateResponse homeResponse \u003d this.homeRMRelayer.allocate(homeRequest);\n-\n-      // Reset the flag after the first successful homeRM allocate response,\n-      // otherwise keep overriding the responseId of new allocate request\n-      if (this.justRecovered) {\n-        this.justRecovered \u003d false;\n+      // Wait for the first async response to arrive\n+      long startTime \u003d this.clock.getTime();\n+      synchronized (this.asyncResponseSink) {\n+        try {\n+          this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n+        } catch (InterruptedException e) {\n+        }\n       }\n+      long firstResponseTime \u003d this.clock.getTime() - startTime;\n \n-      // Notify policy of home response\n+      // An extra brief wait for other async heart beats, so that most of their\n+      // responses can make it back to AM in the same heart beat round trip.\n       try {\n-        this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n-            homeResponse);\n-      } catch (YarnException e) {\n-        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n-            + this.homeSubClusterId, e);\n+        Thread.sleep(firstResponseTime);\n+      } catch (InterruptedException e) {\n       }\n \n-      // If the resource manager sent us a new token, add to the current user\n-      if (homeResponse.getAMRMToken() !\u003d null) {\n-        LOG.debug(\"Received new AMRMToken\");\n-        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n-            this.appOwner, getConf());\n-      }\n+      // Prepare the response to AM\n+      AllocateResponse response \u003d\n+          RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n \n-      // Merge the responses from home and secondary sub-cluster RMs\n-      homeResponse \u003d mergeAllocateResponses(homeResponse);\n+      // Merge all responses from response sink\n+      mergeAllocateResponses(response);\n \n       // Merge the containers and NMTokens from the new registrations into\n-      // the homeResponse.\n+      // the response\n       if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n-        homeResponse \u003d mergeRegistrationResponses(homeResponse,\n+        mergeRegistrationResponses(response,\n             newRegistrations.getSuccessfulRegistrations());\n       }\n \n-      LOG.info(\"{} heartbeat response from home RM with responseId {}\",\n-          this.attemptId, homeResponse.getResponseId());\n-\n-      // Update lastHomeResponseId in three cases:\n-      // 1. The normal responseId increments\n-      // 2. homeResponse.getResponseId() \u003d\u003d 1. This happens when homeRM fails\n-      // over, AMRMClientRelayer auto re-register and full re-send for homeRM.\n-      // 3. lastHomeResponseId \u003d\u003d MAX_INT. This is the initial case or\n-      // responseId about to overflow and wrap around\n-      if (homeResponse.getResponseId() \u003d\u003d this.lastHomeResponseId + 1\n-          || homeResponse.getResponseId() \u003d\u003d 1\n-          || this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n-        this.lastHomeResponseId \u003d homeResponse.getResponseId();\n+      // update the responseId and return the final response to AM\n+      synchronized (this.lastAllocateResponseLock) {\n+        response.setResponseId(AMRMClientUtils\n+            .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n+        this.lastAllocateResponse \u003d response;\n       }\n-\n-      // return the final response to the application master.\n-      return homeResponse;\n-    } catch (IOException ex) {\n-      LOG.error(\"Exception encountered while processing heart beat\", ex);\n+      return response;\n+    } catch (Throwable ex) {\n+      LOG.error(\"Exception encountered while processing heart beat for \"\n+          + this.attemptId, ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException, IOException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    if (this.justRecovered) {\n      throw new ApplicationMasterNotRegisteredException(\n          \"AMRMProxy just restarted and recovered for \" + this.attemptId\n              + \". AM should re-register and full re-send pending requests.\");\n    }\n\n    // Check responseId and handle duplicate heartbeat exactly same as RM\n    synchronized (this.lastAllocateResponseLock) {\n      LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n          + request.getResponseId() + \" when we are expecting \"\n          + this.lastAllocateResponse.getResponseId());\n      // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n      if (AMRMClientUtils.getNextResponseId(\n          request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n              .getResponseId()) {\n        // heartbeat one step old, simply return lastReponse\n        return this.lastAllocateResponse;\n      } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n          .getResponseId()) {\n        throw new InvalidApplicationMasterRequestException(\n            AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                this.lastAllocateResponse.getResponseId(),\n                request.getResponseId()));\n      }\n    }\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      /**\n       * Send the requests to the all sub-cluster resource managers. All\n       * requests are synchronously triggered but sent asynchronously. Later the\n       * responses will be collected and merged. In addition, it also returns\n       * the newly registered UAMs.\n       */\n      Registrations newRegistrations \u003d sendRequestsToResourceManagers(requests);\n\n      // Wait for the first async response to arrive\n      long startTime \u003d this.clock.getTime();\n      synchronized (this.asyncResponseSink) {\n        try {\n          this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n        } catch (InterruptedException e) {\n        }\n      }\n      long firstResponseTime \u003d this.clock.getTime() - startTime;\n\n      // An extra brief wait for other async heart beats, so that most of their\n      // responses can make it back to AM in the same heart beat round trip.\n      try {\n        Thread.sleep(firstResponseTime);\n      } catch (InterruptedException e) {\n      }\n\n      // Prepare the response to AM\n      AllocateResponse response \u003d\n          RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n\n      // Merge all responses from response sink\n      mergeAllocateResponses(response);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the response\n      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n        mergeRegistrationResponses(response,\n            newRegistrations.getSuccessfulRegistrations());\n      }\n\n      // update the responseId and return the final response to AM\n      synchronized (this.lastAllocateResponseLock) {\n        response.setResponseId(AMRMClientUtils\n            .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n        this.lastAllocateResponse \u003d response;\n      }\n      return response;\n    } catch (Throwable ex) {\n      LOG.error(\"Exception encountered while processing heart beat for \"\n          + this.attemptId, ex);\n      throw new YarnException(ex);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
          "extendedDetails": {
            "oldValue": "[YarnException]",
            "newValue": "[YarnException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.\n",
          "commitDate": "24/09/18 11:37 AM",
          "commitName": "3090922805699b8374a359e92323884a4177dc4e",
          "commitAuthor": "Giovanni Matteo Fumarola",
          "commitDateOld": "12/09/18 11:46 AM",
          "commitNameOld": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 11.99,
          "commitsBetweenForRepo": 142,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,89 @@\n   public AllocateResponse allocate(AllocateRequest request)\n-      throws YarnException {\n+      throws YarnException, IOException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n \n-    if (this.justRecovered \u0026\u0026 this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n-      // Save the responseId home RM is expecting\n-      this.lastHomeResponseId \u003d request.getResponseId();\n-\n+    if (this.justRecovered) {\n       throw new ApplicationMasterNotRegisteredException(\n           \"AMRMProxy just restarted and recovered for \" + this.attemptId\n               + \". AM should re-register and full re-send pending requests.\");\n     }\n \n-    // Override responseId in the request in two cases:\n-    //\n-    // 1. After we just recovered after an NM restart and AM\u0027s responseId is\n-    // reset due to the exception we generate. We need to override the\n-    // responseId to the one homeRM expects.\n-    //\n-    // 2. After homeRM fail-over, the allocate response with reseted responseId\n-    // might not be returned successfully back to AM because of RPC connection\n-    // timeout between AM and AMRMProxy. In this case, we remember and reset the\n-    // responseId for AM.\n-    if (this.justRecovered\n-        || request.getResponseId() \u003e this.lastHomeResponseId) {\n-      LOG.warn(\"Setting allocate responseId for {} from {} to {}\",\n-          this.attemptId, request.getResponseId(), this.lastHomeResponseId);\n-      request.setResponseId(this.lastHomeResponseId);\n+    // Check responseId and handle duplicate heartbeat exactly same as RM\n+    synchronized (this.lastAllocateResponseLock) {\n+      LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n+          + request.getResponseId() + \" when we are expecting \"\n+          + this.lastAllocateResponse.getResponseId());\n+      // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n+      if (AMRMClientUtils.getNextResponseId(\n+          request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n+              .getResponseId()) {\n+        // heartbeat one step old, simply return lastReponse\n+        return this.lastAllocateResponse;\n+      } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n+          .getResponseId()) {\n+        throw new InvalidApplicationMasterRequestException(\n+            AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n+                this.lastAllocateResponse.getResponseId(),\n+                request.getResponseId()));\n+      }\n     }\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n-      // Send the requests to the secondary sub-cluster resource managers.\n-      // These secondary requests are send asynchronously and the responses will\n-      // be collected and merged with the home response. In addition, it also\n-      // return the newly registered Unmanaged AMs.\n-      Registrations newRegistrations \u003d\n-          sendRequestsToSecondaryResourceManagers(requests);\n+      /**\n+       * Send the requests to the all sub-cluster resource managers. All\n+       * requests are synchronously triggered but sent asynchronously. Later the\n+       * responses will be collected and merged. In addition, it also returns\n+       * the newly registered UAMs.\n+       */\n+      Registrations newRegistrations \u003d sendRequestsToResourceManagers(requests);\n \n-      // Send the request to the home RM and get the response\n-      AllocateRequest homeRequest \u003d requests.get(this.homeSubClusterId);\n-      LOG.info(\"{} heartbeating to home RM with responseId {}\", this.attemptId,\n-          homeRequest.getResponseId());\n-\n-      AllocateResponse homeResponse \u003d this.homeRMRelayer.allocate(homeRequest);\n-\n-      // Reset the flag after the first successful homeRM allocate response,\n-      // otherwise keep overriding the responseId of new allocate request\n-      if (this.justRecovered) {\n-        this.justRecovered \u003d false;\n+      // Wait for the first async response to arrive\n+      long startTime \u003d this.clock.getTime();\n+      synchronized (this.asyncResponseSink) {\n+        try {\n+          this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n+        } catch (InterruptedException e) {\n+        }\n       }\n+      long firstResponseTime \u003d this.clock.getTime() - startTime;\n \n-      // Notify policy of home response\n+      // An extra brief wait for other async heart beats, so that most of their\n+      // responses can make it back to AM in the same heart beat round trip.\n       try {\n-        this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n-            homeResponse);\n-      } catch (YarnException e) {\n-        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n-            + this.homeSubClusterId, e);\n+        Thread.sleep(firstResponseTime);\n+      } catch (InterruptedException e) {\n       }\n \n-      // If the resource manager sent us a new token, add to the current user\n-      if (homeResponse.getAMRMToken() !\u003d null) {\n-        LOG.debug(\"Received new AMRMToken\");\n-        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n-            this.appOwner, getConf());\n-      }\n+      // Prepare the response to AM\n+      AllocateResponse response \u003d\n+          RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n \n-      // Merge the responses from home and secondary sub-cluster RMs\n-      homeResponse \u003d mergeAllocateResponses(homeResponse);\n+      // Merge all responses from response sink\n+      mergeAllocateResponses(response);\n \n       // Merge the containers and NMTokens from the new registrations into\n-      // the homeResponse.\n+      // the response\n       if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n-        homeResponse \u003d mergeRegistrationResponses(homeResponse,\n+        mergeRegistrationResponses(response,\n             newRegistrations.getSuccessfulRegistrations());\n       }\n \n-      LOG.info(\"{} heartbeat response from home RM with responseId {}\",\n-          this.attemptId, homeResponse.getResponseId());\n-\n-      // Update lastHomeResponseId in three cases:\n-      // 1. The normal responseId increments\n-      // 2. homeResponse.getResponseId() \u003d\u003d 1. This happens when homeRM fails\n-      // over, AMRMClientRelayer auto re-register and full re-send for homeRM.\n-      // 3. lastHomeResponseId \u003d\u003d MAX_INT. This is the initial case or\n-      // responseId about to overflow and wrap around\n-      if (homeResponse.getResponseId() \u003d\u003d this.lastHomeResponseId + 1\n-          || homeResponse.getResponseId() \u003d\u003d 1\n-          || this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n-        this.lastHomeResponseId \u003d homeResponse.getResponseId();\n+      // update the responseId and return the final response to AM\n+      synchronized (this.lastAllocateResponseLock) {\n+        response.setResponseId(AMRMClientUtils\n+            .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n+        this.lastAllocateResponse \u003d response;\n       }\n-\n-      // return the final response to the application master.\n-      return homeResponse;\n-    } catch (IOException ex) {\n-      LOG.error(\"Exception encountered while processing heart beat\", ex);\n+      return response;\n+    } catch (Throwable ex) {\n+      LOG.error(\"Exception encountered while processing heart beat for \"\n+          + this.attemptId, ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException, IOException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    if (this.justRecovered) {\n      throw new ApplicationMasterNotRegisteredException(\n          \"AMRMProxy just restarted and recovered for \" + this.attemptId\n              + \". AM should re-register and full re-send pending requests.\");\n    }\n\n    // Check responseId and handle duplicate heartbeat exactly same as RM\n    synchronized (this.lastAllocateResponseLock) {\n      LOG.info(\"Heartbeat from \" + this.attemptId + \" with responseId \"\n          + request.getResponseId() + \" when we are expecting \"\n          + this.lastAllocateResponse.getResponseId());\n      // Normally request.getResponseId() \u003d\u003d lastResponse.getResponseId()\n      if (AMRMClientUtils.getNextResponseId(\n          request.getResponseId()) \u003d\u003d this.lastAllocateResponse\n              .getResponseId()) {\n        // heartbeat one step old, simply return lastReponse\n        return this.lastAllocateResponse;\n      } else if (request.getResponseId() !\u003d this.lastAllocateResponse\n          .getResponseId()) {\n        throw new InvalidApplicationMasterRequestException(\n            AMRMClientUtils.assembleInvalidResponseIdExceptionMessage(attemptId,\n                this.lastAllocateResponse.getResponseId(),\n                request.getResponseId()));\n      }\n    }\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      /**\n       * Send the requests to the all sub-cluster resource managers. All\n       * requests are synchronously triggered but sent asynchronously. Later the\n       * responses will be collected and merged. In addition, it also returns\n       * the newly registered UAMs.\n       */\n      Registrations newRegistrations \u003d sendRequestsToResourceManagers(requests);\n\n      // Wait for the first async response to arrive\n      long startTime \u003d this.clock.getTime();\n      synchronized (this.asyncResponseSink) {\n        try {\n          this.asyncResponseSink.wait(this.heartbeatMaxWaitTimeMs);\n        } catch (InterruptedException e) {\n        }\n      }\n      long firstResponseTime \u003d this.clock.getTime() - startTime;\n\n      // An extra brief wait for other async heart beats, so that most of their\n      // responses can make it back to AM in the same heart beat round trip.\n      try {\n        Thread.sleep(firstResponseTime);\n      } catch (InterruptedException e) {\n      }\n\n      // Prepare the response to AM\n      AllocateResponse response \u003d\n          RECORD_FACTORY.newRecordInstance(AllocateResponse.class);\n\n      // Merge all responses from response sink\n      mergeAllocateResponses(response);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the response\n      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n        mergeRegistrationResponses(response,\n            newRegistrations.getSuccessfulRegistrations());\n      }\n\n      // update the responseId and return the final response to AM\n      synchronized (this.lastAllocateResponseLock) {\n        response.setResponseId(AMRMClientUtils\n            .getNextResponseId(this.lastAllocateResponse.getResponseId()));\n        this.lastAllocateResponse \u003d response;\n      }\n      return response;\n    } catch (Throwable ex) {\n      LOG.error(\"Exception encountered while processing heart beat for \"\n          + this.attemptId, ex);\n      throw new YarnException(ex);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1525825623a1307b5aa55c456b6afa3e0c61135": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8705. Refactor the UAM heartbeat thread in preparation for YARN-8696. Contributed by Botong Huang.\n",
      "commitDate": "27/08/18 10:32 AM",
      "commitName": "f1525825623a1307b5aa55c456b6afa3e0c61135",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "20/08/18 12:22 PM",
      "commitNameOld": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,105 @@\n   public AllocateResponse allocate(AllocateRequest request)\n       throws YarnException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n \n     if (this.justRecovered \u0026\u0026 this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n       // Save the responseId home RM is expecting\n       this.lastHomeResponseId \u003d request.getResponseId();\n \n       throw new ApplicationMasterNotRegisteredException(\n-          \"AMRMProxy just restarted and recovered for \"\n-              + getApplicationContext().getApplicationAttemptId()\n+          \"AMRMProxy just restarted and recovered for \" + this.attemptId\n               + \". AM should re-register and full re-send pending requests.\");\n     }\n \n     // Override responseId in the request in two cases:\n     //\n     // 1. After we just recovered after an NM restart and AM\u0027s responseId is\n     // reset due to the exception we generate. We need to override the\n     // responseId to the one homeRM expects.\n     //\n     // 2. After homeRM fail-over, the allocate response with reseted responseId\n     // might not be returned successfully back to AM because of RPC connection\n     // timeout between AM and AMRMProxy. In this case, we remember and reset the\n     // responseId for AM.\n     if (this.justRecovered\n         || request.getResponseId() \u003e this.lastHomeResponseId) {\n       LOG.warn(\"Setting allocate responseId for {} from {} to {}\",\n-          getApplicationContext().getApplicationAttemptId(),\n-          request.getResponseId(), this.lastHomeResponseId);\n+          this.attemptId, request.getResponseId(), this.lastHomeResponseId);\n       request.setResponseId(this.lastHomeResponseId);\n     }\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n       // Send the requests to the secondary sub-cluster resource managers.\n       // These secondary requests are send asynchronously and the responses will\n       // be collected and merged with the home response. In addition, it also\n       // return the newly registered Unmanaged AMs.\n       Registrations newRegistrations \u003d\n           sendRequestsToSecondaryResourceManagers(requests);\n \n       // Send the request to the home RM and get the response\n       AllocateRequest homeRequest \u003d requests.get(this.homeSubClusterId);\n-      LOG.info(\"{} heartbeating to home RM with responseId {}\",\n-          getApplicationContext().getApplicationAttemptId(),\n+      LOG.info(\"{} heartbeating to home RM with responseId {}\", this.attemptId,\n           homeRequest.getResponseId());\n \n       AllocateResponse homeResponse \u003d this.homeRMRelayer.allocate(homeRequest);\n \n       // Reset the flag after the first successful homeRM allocate response,\n       // otherwise keep overriding the responseId of new allocate request\n       if (this.justRecovered) {\n         this.justRecovered \u003d false;\n       }\n \n       // Notify policy of home response\n       try {\n         this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n             homeResponse);\n       } catch (YarnException e) {\n         LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n             + this.homeSubClusterId, e);\n       }\n \n       // If the resource manager sent us a new token, add to the current user\n       if (homeResponse.getAMRMToken() !\u003d null) {\n         LOG.debug(\"Received new AMRMToken\");\n         YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n             this.appOwner, getConf());\n       }\n \n       // Merge the responses from home and secondary sub-cluster RMs\n       homeResponse \u003d mergeAllocateResponses(homeResponse);\n \n       // Merge the containers and NMTokens from the new registrations into\n       // the homeResponse.\n       if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n         homeResponse \u003d mergeRegistrationResponses(homeResponse,\n             newRegistrations.getSuccessfulRegistrations());\n       }\n \n       LOG.info(\"{} heartbeat response from home RM with responseId {}\",\n-          getApplicationContext().getApplicationAttemptId(),\n-          homeResponse.getResponseId());\n+          this.attemptId, homeResponse.getResponseId());\n \n       // Update lastHomeResponseId in three cases:\n       // 1. The normal responseId increments\n       // 2. homeResponse.getResponseId() \u003d\u003d 1. This happens when homeRM fails\n       // over, AMRMClientRelayer auto re-register and full re-send for homeRM.\n       // 3. lastHomeResponseId \u003d\u003d MAX_INT. This is the initial case or\n       // responseId about to overflow and wrap around\n       if (homeResponse.getResponseId() \u003d\u003d this.lastHomeResponseId + 1\n           || homeResponse.getResponseId() \u003d\u003d 1\n           || this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n         this.lastHomeResponseId \u003d homeResponse.getResponseId();\n       }\n \n       // return the final response to the application master.\n       return homeResponse;\n     } catch (IOException ex) {\n       LOG.error(\"Exception encountered while processing heart beat\", ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    if (this.justRecovered \u0026\u0026 this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n      // Save the responseId home RM is expecting\n      this.lastHomeResponseId \u003d request.getResponseId();\n\n      throw new ApplicationMasterNotRegisteredException(\n          \"AMRMProxy just restarted and recovered for \" + this.attemptId\n              + \". AM should re-register and full re-send pending requests.\");\n    }\n\n    // Override responseId in the request in two cases:\n    //\n    // 1. After we just recovered after an NM restart and AM\u0027s responseId is\n    // reset due to the exception we generate. We need to override the\n    // responseId to the one homeRM expects.\n    //\n    // 2. After homeRM fail-over, the allocate response with reseted responseId\n    // might not be returned successfully back to AM because of RPC connection\n    // timeout between AM and AMRMProxy. In this case, we remember and reset the\n    // responseId for AM.\n    if (this.justRecovered\n        || request.getResponseId() \u003e this.lastHomeResponseId) {\n      LOG.warn(\"Setting allocate responseId for {} from {} to {}\",\n          this.attemptId, request.getResponseId(), this.lastHomeResponseId);\n      request.setResponseId(this.lastHomeResponseId);\n    }\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      // Send the requests to the secondary sub-cluster resource managers.\n      // These secondary requests are send asynchronously and the responses will\n      // be collected and merged with the home response. In addition, it also\n      // return the newly registered Unmanaged AMs.\n      Registrations newRegistrations \u003d\n          sendRequestsToSecondaryResourceManagers(requests);\n\n      // Send the request to the home RM and get the response\n      AllocateRequest homeRequest \u003d requests.get(this.homeSubClusterId);\n      LOG.info(\"{} heartbeating to home RM with responseId {}\", this.attemptId,\n          homeRequest.getResponseId());\n\n      AllocateResponse homeResponse \u003d this.homeRMRelayer.allocate(homeRequest);\n\n      // Reset the flag after the first successful homeRM allocate response,\n      // otherwise keep overriding the responseId of new allocate request\n      if (this.justRecovered) {\n        this.justRecovered \u003d false;\n      }\n\n      // Notify policy of home response\n      try {\n        this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n            homeResponse);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n            + this.homeSubClusterId, e);\n      }\n\n      // If the resource manager sent us a new token, add to the current user\n      if (homeResponse.getAMRMToken() !\u003d null) {\n        LOG.debug(\"Received new AMRMToken\");\n        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n            this.appOwner, getConf());\n      }\n\n      // Merge the responses from home and secondary sub-cluster RMs\n      homeResponse \u003d mergeAllocateResponses(homeResponse);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the homeResponse.\n      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n        homeResponse \u003d mergeRegistrationResponses(homeResponse,\n            newRegistrations.getSuccessfulRegistrations());\n      }\n\n      LOG.info(\"{} heartbeat response from home RM with responseId {}\",\n          this.attemptId, homeResponse.getResponseId());\n\n      // Update lastHomeResponseId in three cases:\n      // 1. The normal responseId increments\n      // 2. homeResponse.getResponseId() \u003d\u003d 1. This happens when homeRM fails\n      // over, AMRMClientRelayer auto re-register and full re-send for homeRM.\n      // 3. lastHomeResponseId \u003d\u003d MAX_INT. This is the initial case or\n      // responseId about to overflow and wrap around\n      if (homeResponse.getResponseId() \u003d\u003d this.lastHomeResponseId + 1\n          || homeResponse.getResponseId() \u003d\u003d 1\n          || this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n        this.lastHomeResponseId \u003d homeResponse.getResponseId();\n      }\n\n      // return the final response to the application master.\n      return homeResponse;\n    } catch (IOException ex) {\n      LOG.error(\"Exception encountered while processing heart beat\", ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7899. [AMRMProxy] Stateful FederationInterceptor for pending requests. Contributed by Botong Huang.\n",
      "commitDate": "09/07/18 12:27 PM",
      "commitName": "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "17/05/18 8:00 PM",
      "commitNameOld": "3159bffce23abf35754da2d7d51de7d8c2631ae3",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 52.69,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,109 @@\n   public AllocateResponse allocate(AllocateRequest request)\n       throws YarnException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n \n+    if (this.justRecovered \u0026\u0026 this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n+      // Save the responseId home RM is expecting\n+      this.lastHomeResponseId \u003d request.getResponseId();\n+\n+      throw new ApplicationMasterNotRegisteredException(\n+          \"AMRMProxy just restarted and recovered for \"\n+              + getApplicationContext().getApplicationAttemptId()\n+              + \". AM should re-register and full re-send pending requests.\");\n+    }\n+\n+    // Override responseId in the request in two cases:\n+    //\n+    // 1. After we just recovered after an NM restart and AM\u0027s responseId is\n+    // reset due to the exception we generate. We need to override the\n+    // responseId to the one homeRM expects.\n+    //\n+    // 2. After homeRM fail-over, the allocate response with reseted responseId\n+    // might not be returned successfully back to AM because of RPC connection\n+    // timeout between AM and AMRMProxy. In this case, we remember and reset the\n+    // responseId for AM.\n+    if (this.justRecovered\n+        || request.getResponseId() \u003e this.lastHomeResponseId) {\n+      LOG.warn(\"Setting allocate responseId for {} from {} to {}\",\n+          getApplicationContext().getApplicationAttemptId(),\n+          request.getResponseId(), this.lastHomeResponseId);\n+      request.setResponseId(this.lastHomeResponseId);\n+    }\n+\n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n       // Send the requests to the secondary sub-cluster resource managers.\n       // These secondary requests are send asynchronously and the responses will\n       // be collected and merged with the home response. In addition, it also\n       // return the newly registered Unmanaged AMs.\n       Registrations newRegistrations \u003d\n           sendRequestsToSecondaryResourceManagers(requests);\n \n       // Send the request to the home RM and get the response\n-      AllocateResponse homeResponse \u003d AMRMClientUtils.allocateWithReRegister(\n-          requests.get(this.homeSubClusterId), this.homeRM,\n-          this.amRegistrationRequest,\n-          getApplicationContext().getApplicationAttemptId().getApplicationId());\n+      AllocateRequest homeRequest \u003d requests.get(this.homeSubClusterId);\n+      LOG.info(\"{} heartbeating to home RM with responseId {}\",\n+          getApplicationContext().getApplicationAttemptId(),\n+          homeRequest.getResponseId());\n+\n+      AllocateResponse homeResponse \u003d this.homeRMRelayer.allocate(homeRequest);\n+\n+      // Reset the flag after the first successful homeRM allocate response,\n+      // otherwise keep overriding the responseId of new allocate request\n+      if (this.justRecovered) {\n+        this.justRecovered \u003d false;\n+      }\n \n       // Notify policy of home response\n       try {\n         this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n             homeResponse);\n       } catch (YarnException e) {\n         LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n             + this.homeSubClusterId, e);\n       }\n \n       // If the resource manager sent us a new token, add to the current user\n       if (homeResponse.getAMRMToken() !\u003d null) {\n         LOG.debug(\"Received new AMRMToken\");\n         YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n             this.appOwner, getConf());\n       }\n \n       // Merge the responses from home and secondary sub-cluster RMs\n       homeResponse \u003d mergeAllocateResponses(homeResponse);\n \n       // Merge the containers and NMTokens from the new registrations into\n       // the homeResponse.\n       if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n         homeResponse \u003d mergeRegistrationResponses(homeResponse,\n             newRegistrations.getSuccessfulRegistrations());\n       }\n \n+      LOG.info(\"{} heartbeat response from home RM with responseId {}\",\n+          getApplicationContext().getApplicationAttemptId(),\n+          homeResponse.getResponseId());\n+\n+      // Update lastHomeResponseId in three cases:\n+      // 1. The normal responseId increments\n+      // 2. homeResponse.getResponseId() \u003d\u003d 1. This happens when homeRM fails\n+      // over, AMRMClientRelayer auto re-register and full re-send for homeRM.\n+      // 3. lastHomeResponseId \u003d\u003d MAX_INT. This is the initial case or\n+      // responseId about to overflow and wrap around\n+      if (homeResponse.getResponseId() \u003d\u003d this.lastHomeResponseId + 1\n+          || homeResponse.getResponseId() \u003d\u003d 1\n+          || this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n+        this.lastHomeResponseId \u003d homeResponse.getResponseId();\n+      }\n+\n       // return the final response to the application master.\n       return homeResponse;\n     } catch (IOException ex) {\n       LOG.error(\"Exception encountered while processing heart beat\", ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    if (this.justRecovered \u0026\u0026 this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n      // Save the responseId home RM is expecting\n      this.lastHomeResponseId \u003d request.getResponseId();\n\n      throw new ApplicationMasterNotRegisteredException(\n          \"AMRMProxy just restarted and recovered for \"\n              + getApplicationContext().getApplicationAttemptId()\n              + \". AM should re-register and full re-send pending requests.\");\n    }\n\n    // Override responseId in the request in two cases:\n    //\n    // 1. After we just recovered after an NM restart and AM\u0027s responseId is\n    // reset due to the exception we generate. We need to override the\n    // responseId to the one homeRM expects.\n    //\n    // 2. After homeRM fail-over, the allocate response with reseted responseId\n    // might not be returned successfully back to AM because of RPC connection\n    // timeout between AM and AMRMProxy. In this case, we remember and reset the\n    // responseId for AM.\n    if (this.justRecovered\n        || request.getResponseId() \u003e this.lastHomeResponseId) {\n      LOG.warn(\"Setting allocate responseId for {} from {} to {}\",\n          getApplicationContext().getApplicationAttemptId(),\n          request.getResponseId(), this.lastHomeResponseId);\n      request.setResponseId(this.lastHomeResponseId);\n    }\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      // Send the requests to the secondary sub-cluster resource managers.\n      // These secondary requests are send asynchronously and the responses will\n      // be collected and merged with the home response. In addition, it also\n      // return the newly registered Unmanaged AMs.\n      Registrations newRegistrations \u003d\n          sendRequestsToSecondaryResourceManagers(requests);\n\n      // Send the request to the home RM and get the response\n      AllocateRequest homeRequest \u003d requests.get(this.homeSubClusterId);\n      LOG.info(\"{} heartbeating to home RM with responseId {}\",\n          getApplicationContext().getApplicationAttemptId(),\n          homeRequest.getResponseId());\n\n      AllocateResponse homeResponse \u003d this.homeRMRelayer.allocate(homeRequest);\n\n      // Reset the flag after the first successful homeRM allocate response,\n      // otherwise keep overriding the responseId of new allocate request\n      if (this.justRecovered) {\n        this.justRecovered \u003d false;\n      }\n\n      // Notify policy of home response\n      try {\n        this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n            homeResponse);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n            + this.homeSubClusterId, e);\n      }\n\n      // If the resource manager sent us a new token, add to the current user\n      if (homeResponse.getAMRMToken() !\u003d null) {\n        LOG.debug(\"Received new AMRMToken\");\n        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n            this.appOwner, getConf());\n      }\n\n      // Merge the responses from home and secondary sub-cluster RMs\n      homeResponse \u003d mergeAllocateResponses(homeResponse);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the homeResponse.\n      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n        homeResponse \u003d mergeRegistrationResponses(homeResponse,\n            newRegistrations.getSuccessfulRegistrations());\n      }\n\n      LOG.info(\"{} heartbeat response from home RM with responseId {}\",\n          getApplicationContext().getApplicationAttemptId(),\n          homeResponse.getResponseId());\n\n      // Update lastHomeResponseId in three cases:\n      // 1. The normal responseId increments\n      // 2. homeResponse.getResponseId() \u003d\u003d 1. This happens when homeRM fails\n      // over, AMRMClientRelayer auto re-register and full re-send for homeRM.\n      // 3. lastHomeResponseId \u003d\u003d MAX_INT. This is the initial case or\n      // responseId about to overflow and wrap around\n      if (homeResponse.getResponseId() \u003d\u003d this.lastHomeResponseId + 1\n          || homeResponse.getResponseId() \u003d\u003d 1\n          || this.lastHomeResponseId \u003d\u003d Integer.MAX_VALUE) {\n        this.lastHomeResponseId \u003d homeResponse.getResponseId();\n      }\n\n      // return the final response to the application master.\n      return homeResponse;\n    } catch (IOException ex) {\n      LOG.error(\"Exception encountered while processing heart beat\", ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
      "commitDate": "17/11/17 5:39 PM",
      "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "28/09/17 1:04 PM",
      "commitNameOld": "ca669f9f8bc7abe5b7d4648c589aa1756bd336d1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 50.23,
      "commitsBetweenForRepo": 444,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   public AllocateResponse allocate(AllocateRequest request)\n       throws YarnException {\n     Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n         \"Allocate should be called after registerApplicationMaster\");\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n       // Send the requests to the secondary sub-cluster resource managers.\n       // These secondary requests are send asynchronously and the responses will\n       // be collected and merged with the home response. In addition, it also\n       // return the newly registered Unmanaged AMs.\n       Registrations newRegistrations \u003d\n           sendRequestsToSecondaryResourceManagers(requests);\n \n       // Send the request to the home RM and get the response\n       AllocateResponse homeResponse \u003d AMRMClientUtils.allocateWithReRegister(\n           requests.get(this.homeSubClusterId), this.homeRM,\n           this.amRegistrationRequest,\n-          getApplicationContext().getApplicationAttemptId());\n+          getApplicationContext().getApplicationAttemptId().getApplicationId());\n \n       // Notify policy of home response\n       try {\n         this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n             homeResponse);\n       } catch (YarnException e) {\n         LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n             + this.homeSubClusterId, e);\n       }\n \n       // If the resource manager sent us a new token, add to the current user\n       if (homeResponse.getAMRMToken() !\u003d null) {\n         LOG.debug(\"Received new AMRMToken\");\n         YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n             this.appOwner, getConf());\n       }\n \n       // Merge the responses from home and secondary sub-cluster RMs\n       homeResponse \u003d mergeAllocateResponses(homeResponse);\n \n       // Merge the containers and NMTokens from the new registrations into\n       // the homeResponse.\n       if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n         homeResponse \u003d mergeRegistrationResponses(homeResponse,\n             newRegistrations.getSuccessfulRegistrations());\n       }\n \n       // return the final response to the application master.\n       return homeResponse;\n     } catch (IOException ex) {\n       LOG.error(\"Exception encountered while processing heart beat\", ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      // Send the requests to the secondary sub-cluster resource managers.\n      // These secondary requests are send asynchronously and the responses will\n      // be collected and merged with the home response. In addition, it also\n      // return the newly registered Unmanaged AMs.\n      Registrations newRegistrations \u003d\n          sendRequestsToSecondaryResourceManagers(requests);\n\n      // Send the request to the home RM and get the response\n      AllocateResponse homeResponse \u003d AMRMClientUtils.allocateWithReRegister(\n          requests.get(this.homeSubClusterId), this.homeRM,\n          this.amRegistrationRequest,\n          getApplicationContext().getApplicationAttemptId().getApplicationId());\n\n      // Notify policy of home response\n      try {\n        this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n            homeResponse);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n            + this.homeSubClusterId, e);\n      }\n\n      // If the resource manager sent us a new token, add to the current user\n      if (homeResponse.getAMRMToken() !\u003d null) {\n        LOG.debug(\"Received new AMRMToken\");\n        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n            this.appOwner, getConf());\n      }\n\n      // Merge the responses from home and secondary sub-cluster RMs\n      homeResponse \u003d mergeAllocateResponses(homeResponse);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the homeResponse.\n      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n        homeResponse \u003d mergeRegistrationResponses(homeResponse,\n            newRegistrations.getSuccessfulRegistrations());\n      }\n\n      // return the final response to the application master.\n      return homeResponse;\n    } catch (IOException ex) {\n      LOG.error(\"Exception encountered while processing heart beat\", ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6511. Federation: transparently spanning application across multiple sub-clusters. (Botong Huang via Subru).\n\n(cherry picked from commit 8c988d235eaf0972783985b1ab24680d029aea79)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "70b1a757f13b01a9192ea5fb0820ba7babfd974e",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "bed1832c934fe4ba44efdcdc49fce06457dc3d4f",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,57 @@\n   public AllocateResponse allocate(AllocateRequest request)\n       throws YarnException {\n+    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n+        \"Allocate should be called after registerApplicationMaster\");\n \n     try {\n       // Split the heart beat request into multiple requests, one for each\n       // sub-cluster RM that is used by this application.\n       Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n           splitAllocateRequest(request);\n \n+      // Send the requests to the secondary sub-cluster resource managers.\n+      // These secondary requests are send asynchronously and the responses will\n+      // be collected and merged with the home response. In addition, it also\n+      // return the newly registered Unmanaged AMs.\n+      Registrations newRegistrations \u003d\n+          sendRequestsToSecondaryResourceManagers(requests);\n+\n       // Send the request to the home RM and get the response\n       AllocateResponse homeResponse \u003d AMRMClientUtils.allocateWithReRegister(\n           requests.get(this.homeSubClusterId), this.homeRM,\n           this.amRegistrationRequest,\n           getApplicationContext().getApplicationAttemptId());\n \n+      // Notify policy of home response\n+      try {\n+        this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n+            homeResponse);\n+      } catch (YarnException e) {\n+        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n+            + this.homeSubClusterId, e);\n+      }\n+\n       // If the resource manager sent us a new token, add to the current user\n       if (homeResponse.getAMRMToken() !\u003d null) {\n         LOG.debug(\"Received new AMRMToken\");\n         YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n             this.appOwner, getConf());\n       }\n \n       // Merge the responses from home and secondary sub-cluster RMs\n       homeResponse \u003d mergeAllocateResponses(homeResponse);\n \n+      // Merge the containers and NMTokens from the new registrations into\n+      // the homeResponse.\n+      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n+        homeResponse \u003d mergeRegistrationResponses(homeResponse,\n+            newRegistrations.getSuccessfulRegistrations());\n+      }\n+\n       // return the final response to the application master.\n       return homeResponse;\n     } catch (IOException ex) {\n       LOG.error(\"Exception encountered while processing heart beat\", ex);\n       throw new YarnException(ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException {\n    Preconditions.checkArgument(this.policyInterpreter !\u003d null,\n        \"Allocate should be called after registerApplicationMaster\");\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      // Send the requests to the secondary sub-cluster resource managers.\n      // These secondary requests are send asynchronously and the responses will\n      // be collected and merged with the home response. In addition, it also\n      // return the newly registered Unmanaged AMs.\n      Registrations newRegistrations \u003d\n          sendRequestsToSecondaryResourceManagers(requests);\n\n      // Send the request to the home RM and get the response\n      AllocateResponse homeResponse \u003d AMRMClientUtils.allocateWithReRegister(\n          requests.get(this.homeSubClusterId), this.homeRM,\n          this.amRegistrationRequest,\n          getApplicationContext().getApplicationAttemptId());\n\n      // Notify policy of home response\n      try {\n        this.policyInterpreter.notifyOfResponse(this.homeSubClusterId,\n            homeResponse);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n            + this.homeSubClusterId, e);\n      }\n\n      // If the resource manager sent us a new token, add to the current user\n      if (homeResponse.getAMRMToken() !\u003d null) {\n        LOG.debug(\"Received new AMRMToken\");\n        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n            this.appOwner, getConf());\n      }\n\n      // Merge the responses from home and secondary sub-cluster RMs\n      homeResponse \u003d mergeAllocateResponses(homeResponse);\n\n      // Merge the containers and NMTokens from the new registrations into\n      // the homeResponse.\n      if (!isNullOrEmpty(newRegistrations.getSuccessfulRegistrations())) {\n        homeResponse \u003d mergeRegistrationResponses(homeResponse,\n            newRegistrations.getSuccessfulRegistrations());\n      }\n\n      // return the final response to the application master.\n      return homeResponse;\n    } catch (IOException ex) {\n      LOG.error(\"Exception encountered while processing heart beat\", ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "bed1832c934fe4ba44efdcdc49fce06457dc3d4f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3666. Federation Intercepting and propagating AM- home RM communications. (Botong Huang via Subru).\n\n(cherry picked from commit 2399eb8200609246cb623c74450ca4a2032063cc)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "bed1832c934fe4ba44efdcdc49fce06457dc3d4f",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,32 @@\n+  public AllocateResponse allocate(AllocateRequest request)\n+      throws YarnException {\n+\n+    try {\n+      // Split the heart beat request into multiple requests, one for each\n+      // sub-cluster RM that is used by this application.\n+      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n+          splitAllocateRequest(request);\n+\n+      // Send the request to the home RM and get the response\n+      AllocateResponse homeResponse \u003d AMRMClientUtils.allocateWithReRegister(\n+          requests.get(this.homeSubClusterId), this.homeRM,\n+          this.amRegistrationRequest,\n+          getApplicationContext().getApplicationAttemptId());\n+\n+      // If the resource manager sent us a new token, add to the current user\n+      if (homeResponse.getAMRMToken() !\u003d null) {\n+        LOG.debug(\"Received new AMRMToken\");\n+        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n+            this.appOwner, getConf());\n+      }\n+\n+      // Merge the responses from home and secondary sub-cluster RMs\n+      homeResponse \u003d mergeAllocateResponses(homeResponse);\n+\n+      // return the final response to the application master.\n+      return homeResponse;\n+    } catch (IOException ex) {\n+      LOG.error(\"Exception encountered while processing heart beat\", ex);\n+      throw new YarnException(ex);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest request)\n      throws YarnException {\n\n    try {\n      // Split the heart beat request into multiple requests, one for each\n      // sub-cluster RM that is used by this application.\n      Map\u003cSubClusterId, AllocateRequest\u003e requests \u003d\n          splitAllocateRequest(request);\n\n      // Send the request to the home RM and get the response\n      AllocateResponse homeResponse \u003d AMRMClientUtils.allocateWithReRegister(\n          requests.get(this.homeSubClusterId), this.homeRM,\n          this.amRegistrationRequest,\n          getApplicationContext().getApplicationAttemptId());\n\n      // If the resource manager sent us a new token, add to the current user\n      if (homeResponse.getAMRMToken() !\u003d null) {\n        LOG.debug(\"Received new AMRMToken\");\n        YarnServerSecurityUtils.updateAMRMToken(homeResponse.getAMRMToken(),\n            this.appOwner, getConf());\n      }\n\n      // Merge the responses from home and secondary sub-cluster RMs\n      homeResponse \u003d mergeAllocateResponses(homeResponse);\n\n      // return the final response to the application master.\n      return homeResponse;\n    } catch (IOException ex) {\n      LOG.error(\"Exception encountered while processing heart beat\", ex);\n      throw new YarnException(ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java"
    }
  }
}