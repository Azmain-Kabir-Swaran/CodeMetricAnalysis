{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirRenameOp.java",
  "functionName": "renameTo",
  "functionId": "renameTo___fsd-FSDirectory__pc-FSPermissionChecker__srcIIP-INodesInPath__dstIIP-INodesInPath__logRetryCache-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
  "functionStartLine": 478,
  "functionEndLine": 513,
  "numCommitsSeen": 934,
  "timeTaken": 37000,
  "changeHistory": [
    "67f2c491fe3cd400605fb6082fd3504bc5e97037",
    "5f34402adae191232fe78e62990396ca07f314bb",
    "869393643de23dcb010cc33091c8eb398de0fd6c",
    "fcd4cb751665adb241081e42b3403c3856b6c6fe",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
    "e98529858edeed11c4f900b0db30d7e4eb2ab1ec",
    "e9c6840b24bab7d6c21243baa9b2353119b0f976",
    "8c7a7e619699386f9e6991842558d78aa0c8053d",
    "02d5830a0099d118bc19845a11ee5d8fae5ead70",
    "0b101bd7e875ee5597ddb8f0d887159076310ffa",
    "980e6c54bab4ffc87e168cd5c217fef44c72a878",
    "fd1000bcefa07992ff5c6fae3508f3e33b7955c6",
    "cdb292f44caff9763631d9e9bcd69c375a7cddea",
    "88eea2157275d4c7e1bf70cac98fe52c326f3585",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "67f2c491fe3cd400605fb6082fd3504bc5e97037": "Ybodychange",
    "5f34402adae191232fe78e62990396ca07f314bb": "Ymultichange(Yreturntypechange,Ybodychange)",
    "869393643de23dcb010cc33091c8eb398de0fd6c": "Ymultichange(Yparameterchange,Ybodychange)",
    "fcd4cb751665adb241081e42b3403c3856b6c6fe": "Ybodychange",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ymultichange(Yrename,Ybodychange)",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": "Ybodychange",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
    "e98529858edeed11c4f900b0db30d7e4eb2ab1ec": "Ybodychange",
    "e9c6840b24bab7d6c21243baa9b2353119b0f976": "Ybodychange",
    "8c7a7e619699386f9e6991842558d78aa0c8053d": "Ymultichange(Yparameterchange,Ybodychange)",
    "02d5830a0099d118bc19845a11ee5d8fae5ead70": "Ybodychange",
    "0b101bd7e875ee5597ddb8f0d887159076310ffa": "Ybodychange",
    "980e6c54bab4ffc87e168cd5c217fef44c72a878": "Ybodychange",
    "fd1000bcefa07992ff5c6fae3508f3e33b7955c6": "Ybodychange",
    "cdb292f44caff9763631d9e9bcd69c375a7cddea": "Ymultichange(Yparameterchange,Ybodychange)",
    "88eea2157275d4c7e1bf70cac98fe52c326f3585": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "67f2c491fe3cd400605fb6082fd3504bc5e97037": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14802. The feature of protect directories should be used in RenameOp (#1669)\n\n",
      "commitDate": "15/11/19 12:35 PM",
      "commitName": "67f2c491fe3cd400605fb6082fd3504bc5e97037",
      "commitAuthor": "Hui Fei",
      "commitDateOld": "01/11/19 4:37 PM",
      "commitNameOld": "de6b8b0c0b1933aab2af3e8adc50a2091d428238",
      "commitAuthorOld": "Zhao Junwang",
      "daysBetweenCommits": 13.87,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,36 @@\n   private static RenameResult renameTo(FSDirectory fsd, FSPermissionChecker pc,\n       INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n           throws IOException {\n+    if(fsd.isNonEmptyDirectory(srcIIP)) {\n+      DFSUtil.checkProtectedDescendants(fsd, srcIIP);\n+    }\n+\n     if (fsd.isPermissionEnabled()) {\n       // Check write access to parent of src\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" +\n           srcIIP.getPath() + \" to \" + dstIIP.getPath());\n     }\n     final long mtime \u003d Time.now();\n     INodesInPath renameIIP;\n     fsd.writeLock();\n     try {\n       renameIIP \u003d unprotectedRenameTo(fsd, srcIIP, dstIIP, mtime);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (renameIIP !\u003d null) {\n       fsd.getEditLog().logRename(\n           srcIIP.getPath(), dstIIP.getPath(), mtime, logRetryCache);\n     }\n     // this rename never overwrites the dest so files deleted and collected\n     // are irrelevant.\n     return createRenameResult(fsd, renameIIP, false, null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static RenameResult renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n          throws IOException {\n    if(fsd.isNonEmptyDirectory(srcIIP)) {\n      DFSUtil.checkProtectedDescendants(fsd, srcIIP);\n    }\n\n    if (fsd.isPermissionEnabled()) {\n      // Check write access to parent of src\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" +\n          srcIIP.getPath() + \" to \" + dstIIP.getPath());\n    }\n    final long mtime \u003d Time.now();\n    INodesInPath renameIIP;\n    fsd.writeLock();\n    try {\n      renameIIP \u003d unprotectedRenameTo(fsd, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (renameIIP !\u003d null) {\n      fsd.getEditLog().logRename(\n          srcIIP.getPath(), dstIIP.getPath(), mtime, logRetryCache);\n    }\n    // this rename never overwrites the dest so files deleted and collected\n    // are irrelevant.\n    return createRenameResult(fsd, renameIIP, false, null);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5f34402adae191232fe78e62990396ca07f314bb": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
      "commitDate": "28/09/16 3:57 PM",
      "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,32 @@\n-  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n+  private static RenameResult renameTo(FSDirectory fsd, FSPermissionChecker pc,\n       INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n           throws IOException {\n-    String src \u003d srcIIP.getPath();\n-    String dst \u003d dstIIP.getPath();\n-    // Note: We should not be doing this.  This is move() not renameTo().\n-    if (fsd.isDir(dst)) {\n-      dstIIP \u003d INodesInPath.append(dstIIP, null, srcIIP.getLastLocalName());\n-    }\n-    final String actualDst \u003d dstIIP.getPath();\n     if (fsd.isPermissionEnabled()) {\n       // Check write access to parent of src\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n-      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n-          + dst);\n+      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" +\n+          srcIIP.getPath() + \" to \" + dstIIP.getPath());\n     }\n     final long mtime \u003d Time.now();\n-    boolean stat \u003d false;\n+    INodesInPath renameIIP;\n     fsd.writeLock();\n     try {\n-      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n+      renameIIP \u003d unprotectedRenameTo(fsd, srcIIP, dstIIP, mtime);\n     } finally {\n       fsd.writeUnlock();\n     }\n-    if (stat) {\n-      fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n-      return true;\n+    if (renameIIP !\u003d null) {\n+      fsd.getEditLog().logRename(\n+          srcIIP.getPath(), dstIIP.getPath(), mtime, logRetryCache);\n     }\n-    return false;\n+    // this rename never overwrites the dest so files deleted and collected\n+    // are irrelevant.\n+    return createRenameResult(fsd, renameIIP, false, null);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static RenameResult renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n          throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      // Check write access to parent of src\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" +\n          srcIIP.getPath() + \" to \" + dstIIP.getPath());\n    }\n    final long mtime \u003d Time.now();\n    INodesInPath renameIIP;\n    fsd.writeLock();\n    try {\n      renameIIP \u003d unprotectedRenameTo(fsd, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (renameIIP !\u003d null) {\n      fsd.getEditLog().logRename(\n          srcIIP.getPath(), dstIIP.getPath(), mtime, logRetryCache);\n    }\n    // this rename never overwrites the dest so files deleted and collected\n    // are irrelevant.\n    return createRenameResult(fsd, renameIIP, false, null);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "RenameResult"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,32 @@\n-  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n+  private static RenameResult renameTo(FSDirectory fsd, FSPermissionChecker pc,\n       INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n           throws IOException {\n-    String src \u003d srcIIP.getPath();\n-    String dst \u003d dstIIP.getPath();\n-    // Note: We should not be doing this.  This is move() not renameTo().\n-    if (fsd.isDir(dst)) {\n-      dstIIP \u003d INodesInPath.append(dstIIP, null, srcIIP.getLastLocalName());\n-    }\n-    final String actualDst \u003d dstIIP.getPath();\n     if (fsd.isPermissionEnabled()) {\n       // Check write access to parent of src\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n-      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n-          + dst);\n+      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" +\n+          srcIIP.getPath() + \" to \" + dstIIP.getPath());\n     }\n     final long mtime \u003d Time.now();\n-    boolean stat \u003d false;\n+    INodesInPath renameIIP;\n     fsd.writeLock();\n     try {\n-      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n+      renameIIP \u003d unprotectedRenameTo(fsd, srcIIP, dstIIP, mtime);\n     } finally {\n       fsd.writeUnlock();\n     }\n-    if (stat) {\n-      fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n-      return true;\n+    if (renameIIP !\u003d null) {\n+      fsd.getEditLog().logRename(\n+          srcIIP.getPath(), dstIIP.getPath(), mtime, logRetryCache);\n     }\n-    return false;\n+    // this rename never overwrites the dest so files deleted and collected\n+    // are irrelevant.\n+    return createRenameResult(fsd, renameIIP, false, null);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static RenameResult renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n          throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      // Check write access to parent of src\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" +\n          srcIIP.getPath() + \" to \" + dstIIP.getPath());\n    }\n    final long mtime \u003d Time.now();\n    INodesInPath renameIIP;\n    fsd.writeLock();\n    try {\n      renameIIP \u003d unprotectedRenameTo(fsd, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (renameIIP !\u003d null) {\n      fsd.getEditLog().logRename(\n          srcIIP.getPath(), dstIIP.getPath(), mtime, logRetryCache);\n    }\n    // this rename never overwrites the dest so files deleted and collected\n    // are irrelevant.\n    return createRenameResult(fsd, renameIIP, false, null);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "869393643de23dcb010cc33091c8eb398de0fd6c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
      "commitDate": "17/08/16 1:53 PM",
      "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
          "commitDate": "17/08/16 1:53 PM",
          "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "15/08/16 2:45 PM",
          "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 1.96,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n   private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n-      String src, String dst, boolean logRetryCache) throws IOException {\n-    // Rename does not operate on link targets\n-    // Do not resolveLink when checking permissions of src and dst\n-    // Check write access to parent of src\n-    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n+      INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n+          throws IOException {\n+    String src \u003d srcIIP.getPath();\n+    String dst \u003d dstIIP.getPath();\n     // Note: We should not be doing this.  This is move() not renameTo().\n-    final String actualDst \u003d fsd.isDir(dst) ?\n-        dst + Path.SEPARATOR + new Path(src).getName() : dst;\n-    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n+    if (fsd.isDir(dst)) {\n+      dstIIP \u003d INodesInPath.append(dstIIP, null, srcIIP.getLastLocalName());\n+    }\n+    final String actualDst \u003d dstIIP.getPath();\n     if (fsd.isPermissionEnabled()) {\n+      // Check write access to parent of src\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n           + dst);\n     }\n     final long mtime \u003d Time.now();\n     boolean stat \u003d false;\n     fsd.writeLock();\n     try {\n       stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (stat) {\n       fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n          throws IOException {\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // Note: We should not be doing this.  This is move() not renameTo().\n    if (fsd.isDir(dst)) {\n      dstIIP \u003d INodesInPath.append(dstIIP, null, srcIIP.getLastLocalName());\n    }\n    final String actualDst \u003d dstIIP.getPath();\n    if (fsd.isPermissionEnabled()) {\n      // Check write access to parent of src\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n          + dst);\n    }\n    final long mtime \u003d Time.now();\n    boolean stat \u003d false;\n    fsd.writeLock();\n    try {\n      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (stat) {\n      fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, pc-FSPermissionChecker, src-String, dst-String, logRetryCache-boolean]",
            "newValue": "[fsd-FSDirectory, pc-FSPermissionChecker, srcIIP-INodesInPath, dstIIP-INodesInPath, logRetryCache-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
          "commitDate": "17/08/16 1:53 PM",
          "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "15/08/16 2:45 PM",
          "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 1.96,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n   private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n-      String src, String dst, boolean logRetryCache) throws IOException {\n-    // Rename does not operate on link targets\n-    // Do not resolveLink when checking permissions of src and dst\n-    // Check write access to parent of src\n-    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n+      INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n+          throws IOException {\n+    String src \u003d srcIIP.getPath();\n+    String dst \u003d dstIIP.getPath();\n     // Note: We should not be doing this.  This is move() not renameTo().\n-    final String actualDst \u003d fsd.isDir(dst) ?\n-        dst + Path.SEPARATOR + new Path(src).getName() : dst;\n-    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n+    if (fsd.isDir(dst)) {\n+      dstIIP \u003d INodesInPath.append(dstIIP, null, srcIIP.getLastLocalName());\n+    }\n+    final String actualDst \u003d dstIIP.getPath();\n     if (fsd.isPermissionEnabled()) {\n+      // Check write access to parent of src\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n           + dst);\n     }\n     final long mtime \u003d Time.now();\n     boolean stat \u003d false;\n     fsd.writeLock();\n     try {\n       stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (stat) {\n       fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      INodesInPath srcIIP, INodesInPath dstIIP, boolean logRetryCache)\n          throws IOException {\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // Note: We should not be doing this.  This is move() not renameTo().\n    if (fsd.isDir(dst)) {\n      dstIIP \u003d INodesInPath.append(dstIIP, null, srcIIP.getLastLocalName());\n    }\n    final String actualDst \u003d dstIIP.getPath();\n    if (fsd.isPermissionEnabled()) {\n      // Check write access to parent of src\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n          + dst);\n    }\n    final long mtime \u003d Time.now();\n    boolean stat \u003d false;\n    fsd.writeLock();\n    try {\n      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (stat) {\n      fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "fcd4cb751665adb241081e42b3403c3856b6c6fe": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8305: HDFS INotify: the destination field of RenameOp should always end with the file name (cmccabe)\n",
      "commitDate": "05/05/15 10:50 AM",
      "commitName": "fcd4cb751665adb241081e42b3403c3856b6c6fe",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "11/02/15 10:41 AM",
      "commitNameOld": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 82.96,
      "commitsBetweenForRepo": 748,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n       String src, String dst, boolean logRetryCache) throws IOException {\n     // Rename does not operate on link targets\n     // Do not resolveLink when checking permissions of src and dst\n     // Check write access to parent of src\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     // Note: We should not be doing this.  This is move() not renameTo().\n     final String actualDst \u003d fsd.isDir(dst) ?\n         dst + Path.SEPARATOR + new Path(src).getName() : dst;\n     final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n     if (fsd.isPermissionEnabled()) {\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n           + dst);\n     }\n     final long mtime \u003d Time.now();\n     boolean stat \u003d false;\n     fsd.writeLock();\n     try {\n       stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (stat) {\n-      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n+      fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      String src, String dst, boolean logRetryCache) throws IOException {\n    // Rename does not operate on link targets\n    // Do not resolveLink when checking permissions of src and dst\n    // Check write access to parent of src\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    // Note: We should not be doing this.  This is move() not renameTo().\n    final String actualDst \u003d fsd.isDir(dst) ?\n        dst + Path.SEPARATOR + new Path(src).getName() : dst;\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n    if (fsd.isPermissionEnabled()) {\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n          + dst);\n    }\n    final long mtime \u003d Time.now();\n    boolean stat \u003d false;\n    fsd.writeLock();\n    try {\n      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (stat) {\n      fsd.getEditLog().logRename(src, actualDst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "11/12/14 12:36 PM",
          "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,36 @@\n-  private static boolean renameToInternal(\n-      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n-      boolean logRetryCache)\n-      throws IOException {\n+  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n+      String src, String dst, boolean logRetryCache) throws IOException {\n+    // Rename does not operate on link targets\n+    // Do not resolveLink when checking permissions of src and dst\n+    // Check write access to parent of src\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n+    // Note: We should not be doing this.  This is move() not renameTo().\n+    final String actualDst \u003d fsd.isDir(dst) ?\n+        dst + Path.SEPARATOR + new Path(src).getName() : dst;\n+    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n     if (fsd.isPermissionEnabled()) {\n-      //We should not be doing this.  This is move() not renameTo().\n-      //but for now,\n-      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n-      //      of rewriting the dst\n-      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n-          (src).getName() : dst;\n-      // Rename does not operates on link targets\n-      // Do not resolveLink when checking permissions of src and dst\n-      // Check write access to parent of src\n-      INodesInPath srcIIP \u003d fsd.getINodesInPath(src, false);\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n-      INodesInPath dstIIP \u003d fsd.getINodesInPath(actualdst, false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n-    long mtime \u003d now();\n-    @SuppressWarnings(\"deprecation\")\n-    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n+          + dst);\n+    }\n+    final long mtime \u003d Time.now();\n+    boolean stat \u003d false;\n+    fsd.writeLock();\n+    try {\n+      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n+    } finally {\n+      fsd.writeUnlock();\n+    }\n     if (stat) {\n       fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      String src, String dst, boolean logRetryCache) throws IOException {\n    // Rename does not operate on link targets\n    // Do not resolveLink when checking permissions of src and dst\n    // Check write access to parent of src\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    // Note: We should not be doing this.  This is move() not renameTo().\n    final String actualDst \u003d fsd.isDir(dst) ?\n        dst + Path.SEPARATOR + new Path(src).getName() : dst;\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n    if (fsd.isPermissionEnabled()) {\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n          + dst);\n    }\n    final long mtime \u003d Time.now();\n    boolean stat \u003d false;\n    fsd.writeLock();\n    try {\n      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "renameToInternal",
            "newValue": "renameTo"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "11/12/14 12:36 PM",
          "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,36 @@\n-  private static boolean renameToInternal(\n-      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n-      boolean logRetryCache)\n-      throws IOException {\n+  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n+      String src, String dst, boolean logRetryCache) throws IOException {\n+    // Rename does not operate on link targets\n+    // Do not resolveLink when checking permissions of src and dst\n+    // Check write access to parent of src\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n+    // Note: We should not be doing this.  This is move() not renameTo().\n+    final String actualDst \u003d fsd.isDir(dst) ?\n+        dst + Path.SEPARATOR + new Path(src).getName() : dst;\n+    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n     if (fsd.isPermissionEnabled()) {\n-      //We should not be doing this.  This is move() not renameTo().\n-      //but for now,\n-      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n-      //      of rewriting the dst\n-      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n-          (src).getName() : dst;\n-      // Rename does not operates on link targets\n-      // Do not resolveLink when checking permissions of src and dst\n-      // Check write access to parent of src\n-      INodesInPath srcIIP \u003d fsd.getINodesInPath(src, false);\n       fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n           false);\n-      INodesInPath dstIIP \u003d fsd.getINodesInPath(actualdst, false);\n       // Check write access to ancestor of dst\n       fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n           null, false);\n     }\n \n-    long mtime \u003d now();\n-    @SuppressWarnings(\"deprecation\")\n-    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n+          + dst);\n+    }\n+    final long mtime \u003d Time.now();\n+    boolean stat \u003d false;\n+    fsd.writeLock();\n+    try {\n+      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n+    } finally {\n+      fsd.writeUnlock();\n+    }\n     if (stat) {\n       fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,\n      String src, String dst, boolean logRetryCache) throws IOException {\n    // Rename does not operate on link targets\n    // Do not resolveLink when checking permissions of src and dst\n    // Check write access to parent of src\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    // Note: We should not be doing this.  This is move() not renameTo().\n    final String actualDst \u003d fsd.isDir(dst) ?\n        dst + Path.SEPARATOR + new Path(src).getName() : dst;\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(actualDst, false);\n    if (fsd.isPermissionEnabled()) {\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.renameTo: \" + src + \" to \"\n          + dst);\n    }\n    final long mtime \u003d Time.now();\n    boolean stat \u003d false;\n    fsd.writeLock();\n    try {\n      stat \u003d unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
      "commitDate": "05/12/14 2:17 PM",
      "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/12/14 2:09 PM",
      "commitNameOld": "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,32 @@\n   private static boolean renameToInternal(\n       FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n       boolean logRetryCache)\n       throws IOException {\n     if (fsd.isPermissionEnabled()) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n           (src).getName() : dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n-      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n-          false, false);\n+      INodesInPath srcIIP \u003d fsd.getINodesInPath(src, false);\n+      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n+          false);\n+      INodesInPath dstIIP \u003d fsd.getINodesInPath(actualdst, false);\n       // Check write access to ancestor of dst\n-      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n-          null, false, false);\n+      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n+          null, false);\n     }\n \n     long mtime \u003d now();\n     @SuppressWarnings(\"deprecation\")\n     final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n     if (stat) {\n       fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean renameToInternal(\n      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n      boolean logRetryCache)\n      throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n          (src).getName() : dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      INodesInPath srcIIP \u003d fsd.getINodesInPath(src, false);\n      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,\n          false);\n      INodesInPath dstIIP \u003d fsd.getINodesInPath(actualdst, false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null,\n          null, false);\n    }\n\n    long mtime \u003d now();\n    @SuppressWarnings(\"deprecation\")\n    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "01/12/14 9:48 PM",
      "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  private boolean renameToInternal(FSPermissionChecker pc, String src,\n-      String dst, boolean logRetryCache) throws IOException,\n-      UnresolvedLinkException {\n-    assert hasWriteLock();\n-    if (isPermissionEnabled) {\n+  private static boolean renameToInternal(\n+      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n+      boolean logRetryCache)\n+      throws IOException {\n+    if (fsd.isPermissionEnabled()) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n-      String actualdst \u003d dir.isDir(dst)?\n-          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n+      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n+          (src).getName() : dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n-      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n+      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n           false, false);\n       // Check write access to ancestor of dst\n-      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n-          false, false);\n+      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n+          null, false, false);\n     }\n \n     long mtime \u003d now();\n-    if (dir.renameTo(src, dst, mtime)) {\n-      getEditLog().logRename(src, dst, mtime, logRetryCache);\n+    @SuppressWarnings(\"deprecation\")\n+    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n+    if (stat) {\n+      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameToInternal(\n      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n      boolean logRetryCache)\n      throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n          (src).getName() : dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n          false, false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n          null, false, false);\n    }\n\n    long mtime \u003d now();\n    @SuppressWarnings(\"deprecation\")\n    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
            "oldMethodName": "renameToInternal",
            "newMethodName": "renameToInternal"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  private boolean renameToInternal(FSPermissionChecker pc, String src,\n-      String dst, boolean logRetryCache) throws IOException,\n-      UnresolvedLinkException {\n-    assert hasWriteLock();\n-    if (isPermissionEnabled) {\n+  private static boolean renameToInternal(\n+      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n+      boolean logRetryCache)\n+      throws IOException {\n+    if (fsd.isPermissionEnabled()) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n-      String actualdst \u003d dir.isDir(dst)?\n-          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n+      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n+          (src).getName() : dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n-      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n+      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n           false, false);\n       // Check write access to ancestor of dst\n-      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n-          false, false);\n+      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n+          null, false, false);\n     }\n \n     long mtime \u003d now();\n-    if (dir.renameTo(src, dst, mtime)) {\n-      getEditLog().logRename(src, dst, mtime, logRetryCache);\n+    @SuppressWarnings(\"deprecation\")\n+    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n+    if (stat) {\n+      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameToInternal(\n      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n      boolean logRetryCache)\n      throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n          (src).getName() : dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n          false, false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n          null, false, false);\n    }\n\n    long mtime \u003d now();\n    @SuppressWarnings(\"deprecation\")\n    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  private boolean renameToInternal(FSPermissionChecker pc, String src,\n-      String dst, boolean logRetryCache) throws IOException,\n-      UnresolvedLinkException {\n-    assert hasWriteLock();\n-    if (isPermissionEnabled) {\n+  private static boolean renameToInternal(\n+      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n+      boolean logRetryCache)\n+      throws IOException {\n+    if (fsd.isPermissionEnabled()) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n-      String actualdst \u003d dir.isDir(dst)?\n-          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n+      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n+          (src).getName() : dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n-      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n+      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n           false, false);\n       // Check write access to ancestor of dst\n-      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n-          false, false);\n+      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n+          null, false, false);\n     }\n \n     long mtime \u003d now();\n-    if (dir.renameTo(src, dst, mtime)) {\n-      getEditLog().logRename(src, dst, mtime, logRetryCache);\n+    @SuppressWarnings(\"deprecation\")\n+    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n+    if (stat) {\n+      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameToInternal(\n      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n      boolean logRetryCache)\n      throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n          (src).getName() : dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n          false, false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n          null, false, false);\n    }\n\n    long mtime \u003d now();\n    @SuppressWarnings(\"deprecation\")\n    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[IOException, UnresolvedLinkException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  private boolean renameToInternal(FSPermissionChecker pc, String src,\n-      String dst, boolean logRetryCache) throws IOException,\n-      UnresolvedLinkException {\n-    assert hasWriteLock();\n-    if (isPermissionEnabled) {\n+  private static boolean renameToInternal(\n+      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n+      boolean logRetryCache)\n+      throws IOException {\n+    if (fsd.isPermissionEnabled()) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n-      String actualdst \u003d dir.isDir(dst)?\n-          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n+      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n+          (src).getName() : dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n-      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n+      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n           false, false);\n       // Check write access to ancestor of dst\n-      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n-          false, false);\n+      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n+          null, false, false);\n     }\n \n     long mtime \u003d now();\n-    if (dir.renameTo(src, dst, mtime)) {\n-      getEditLog().logRename(src, dst, mtime, logRetryCache);\n+    @SuppressWarnings(\"deprecation\")\n+    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n+    if (stat) {\n+      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameToInternal(\n      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n      boolean logRetryCache)\n      throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n          (src).getName() : dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n          false, false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n          null, false, false);\n    }\n\n    long mtime \u003d now();\n    @SuppressWarnings(\"deprecation\")\n    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  private boolean renameToInternal(FSPermissionChecker pc, String src,\n-      String dst, boolean logRetryCache) throws IOException,\n-      UnresolvedLinkException {\n-    assert hasWriteLock();\n-    if (isPermissionEnabled) {\n+  private static boolean renameToInternal(\n+      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n+      boolean logRetryCache)\n+      throws IOException {\n+    if (fsd.isPermissionEnabled()) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n-      String actualdst \u003d dir.isDir(dst)?\n-          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n+      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n+          (src).getName() : dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n-      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n+      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n           false, false);\n       // Check write access to ancestor of dst\n-      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n-          false, false);\n+      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n+          null, false, false);\n     }\n \n     long mtime \u003d now();\n-    if (dir.renameTo(src, dst, mtime)) {\n-      getEditLog().logRename(src, dst, mtime, logRetryCache);\n+    @SuppressWarnings(\"deprecation\")\n+    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n+    if (stat) {\n+      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean renameToInternal(\n      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,\n      boolean logRetryCache)\n      throws IOException {\n    if (fsd.isPermissionEnabled()) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path\n          (src).getName() : dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      fsd.checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n          false, false);\n      // Check write access to ancestor of dst\n      fsd.checkPermission(pc, actualdst, false, FsAction.WRITE, null, null,\n          null, false, false);\n    }\n\n    long mtime \u003d now();\n    @SuppressWarnings(\"deprecation\")\n    final boolean stat \u003d renameTo(fsd, src, dst, mtime);\n    if (stat) {\n      fsd.getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, src-String, dst-String, logRetryCache-boolean]",
            "newValue": "[fsd-FSDirectory, pc-FSPermissionChecker, src-String, dst-String, logRetryCache-boolean]"
          }
        }
      ]
    },
    "e98529858edeed11c4f900b0db30d7e4eb2ab1ec": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6315. Decouple recording edit logs from FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601960 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/14 10:22 AM",
      "commitName": "e98529858edeed11c4f900b0db30d7e4eb2ab1ec",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "03/06/14 11:33 AM",
      "commitNameOld": "02fcb6b6bae7c3fe2a10b00b2a563e4098ff225e",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,28 @@\n   private boolean renameToInternal(FSPermissionChecker pc, String src,\n       String dst, boolean logRetryCache) throws IOException,\n       UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n       checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n           false, false);\n       // Check write access to ancestor of dst\n       checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n           false, false);\n     }\n \n-    if (dir.renameTo(src, dst, logRetryCache)) {\n+    long mtime \u003d now();\n+    if (dir.renameTo(src, dst, mtime)) {\n+      getEditLog().logRename(src, dst, mtime, logRetryCache);\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src,\n      String dst, boolean logRetryCache) throws IOException,\n      UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n          false, false);\n      // Check write access to ancestor of dst\n      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n          false, false);\n    }\n\n    long mtime \u003d now();\n    if (dir.renameTo(src, dst, mtime)) {\n      getEditLog().logRename(src, dst, mtime, logRetryCache);\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "e9c6840b24bab7d6c21243baa9b2353119b0f976": {
      "type": "Ybodychange",
      "commitMessage": "Command hdfs dfs -rm -r can\u0027t remove empty directory. Contributed by Yongjun Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594036 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/05/14 10:54 AM",
      "commitName": "e9c6840b24bab7d6c21243baa9b2353119b0f976",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "09/05/14 3:36 PM",
      "commitNameOld": "f131dba8a3d603a5d15c4f035ed3da75b4daf0dc",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 2.8,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,26 @@\n   private boolean renameToInternal(FSPermissionChecker pc, String src,\n       String dst, boolean logRetryCache) throws IOException,\n       UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n-      checkPermission(pc, src, false, null, FsAction.WRITE, null, null, false);\n+      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n+          false, false);\n       // Check write access to ancestor of dst\n       checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n-          false);\n+          false, false);\n     }\n \n     if (dir.renameTo(src, dst, logRetryCache)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src,\n      String dst, boolean logRetryCache) throws IOException,\n      UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      checkPermission(pc, src, false, null, FsAction.WRITE, null, null,\n          false, false);\n      // Check write access to ancestor of dst\n      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n          false, false);\n    }\n\n    if (dir.renameTo(src, dst, logRetryCache)) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "8c7a7e619699386f9e6991842558d78aa0c8053d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5025. Record ClientId and CallId in EditLog to enable rebuilding retry cache in case of HA failover. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/07/13 12:51 AM",
      "commitName": "8c7a7e619699386f9e6991842558d78aa0c8053d",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5025. Record ClientId and CallId in EditLog to enable rebuilding retry cache in case of HA failover. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508332 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/07/13 12:51 AM",
          "commitName": "8c7a7e619699386f9e6991842558d78aa0c8053d",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "26/07/13 4:59 PM",
          "commitNameOld": "dc17bda4b677e30c02c2a9a053895a43e41f7a12",
          "commitAuthorOld": "Konstantin Boudnik",
          "daysBetweenCommits": 3.33,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,25 @@\n-  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n-    throws IOException, UnresolvedLinkException {\n+  private boolean renameToInternal(FSPermissionChecker pc, String src,\n+      String dst, boolean logRetryCache) throws IOException,\n+      UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n       checkPermission(pc, src, false, null, FsAction.WRITE, null, null, false);\n       // Check write access to ancestor of dst\n       checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n           false);\n     }\n \n-    if (dir.renameTo(src, dst)) {\n+    if (dir.renameTo(src, dst, logRetryCache)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src,\n      String dst, boolean logRetryCache) throws IOException,\n      UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      checkPermission(pc, src, false, null, FsAction.WRITE, null, null, false);\n      // Check write access to ancestor of dst\n      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n          false);\n    }\n\n    if (dir.renameTo(src, dst, logRetryCache)) {\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, src-String, dst-String]",
            "newValue": "[pc-FSPermissionChecker, src-String, dst-String, logRetryCache-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5025. Record ClientId and CallId in EditLog to enable rebuilding retry cache in case of HA failover. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508332 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/07/13 12:51 AM",
          "commitName": "8c7a7e619699386f9e6991842558d78aa0c8053d",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "26/07/13 4:59 PM",
          "commitNameOld": "dc17bda4b677e30c02c2a9a053895a43e41f7a12",
          "commitAuthorOld": "Konstantin Boudnik",
          "daysBetweenCommits": 3.33,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,25 @@\n-  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n-    throws IOException, UnresolvedLinkException {\n+  private boolean renameToInternal(FSPermissionChecker pc, String src,\n+      String dst, boolean logRetryCache) throws IOException,\n+      UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       // Rename does not operates on link targets\n       // Do not resolveLink when checking permissions of src and dst\n       // Check write access to parent of src\n       checkPermission(pc, src, false, null, FsAction.WRITE, null, null, false);\n       // Check write access to ancestor of dst\n       checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n           false);\n     }\n \n-    if (dir.renameTo(src, dst)) {\n+    if (dir.renameTo(src, dst, logRetryCache)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src,\n      String dst, boolean logRetryCache) throws IOException,\n      UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      checkPermission(pc, src, false, null, FsAction.WRITE, null, null, false);\n      // Check write access to ancestor of dst\n      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n          false);\n    }\n\n    if (dir.renameTo(src, dst, logRetryCache)) {\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "02d5830a0099d118bc19845a11ee5d8fae5ead70": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5035.  getFileLinkStatus and rename do not correctly check permissions of symlinks (Andrew Wang via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1507525 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/07/13 4:54 PM",
      "commitName": "02d5830a0099d118bc19845a11ee5d8fae5ead70",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "25/07/13 6:09 PM",
      "commitNameOld": "1b531c1dbb452a6192fad411605d2baaa3831bcd",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,24 @@\n   private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n     throws IOException, UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n-      checkParentAccess(pc, src, FsAction.WRITE);\n-      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n+      // Rename does not operates on link targets\n+      // Do not resolveLink when checking permissions of src and dst\n+      // Check write access to parent of src\n+      checkPermission(pc, src, false, null, FsAction.WRITE, null, null, false);\n+      // Check write access to ancestor of dst\n+      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n+          false);\n     }\n \n     if (dir.renameTo(src, dst)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      // Rename does not operates on link targets\n      // Do not resolveLink when checking permissions of src and dst\n      // Check write access to parent of src\n      checkPermission(pc, src, false, null, FsAction.WRITE, null, null, false);\n      // Check write access to ancestor of dst\n      checkPermission(pc, actualdst, false, FsAction.WRITE, null, null, null,\n          false);\n    }\n\n    if (dir.renameTo(src, dst)) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "0b101bd7e875ee5597ddb8f0d887159076310ffa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4434. Reverting change r1470089 that merges trunk to HDFS-2802.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1470194 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/04/13 9:57 AM",
      "commitName": "0b101bd7e875ee5597ddb8f0d887159076310ffa",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "19/04/13 5:02 PM",
      "commitNameOld": "9af0babe7ef9c4bc956b77aac250f8eee6c8450f",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,23 @@\n   private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n     throws IOException, UnresolvedLinkException {\n     assert hasWriteLock();\n+      checkOperation(OperationCategory.WRITE);\n+    if (isInSafeMode()) {\n+      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n+    }\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       checkParentAccess(pc, src, FsAction.WRITE);\n       checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n     }\n \n     if (dir.renameTo(src, dst)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n      checkOperation(OperationCategory.WRITE);\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(pc, src, FsAction.WRITE);\n      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n    }\n\n    if (dir.renameTo(src, dst)) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "980e6c54bab4ffc87e168cd5c217fef44c72a878": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4434. Provide a mapping from INodeId to INode. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469644 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 5:10 PM",
      "commitName": "980e6c54bab4ffc87e168cd5c217fef44c72a878",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "12/04/13 6:35 PM",
      "commitNameOld": "242028a3fb887708dea5ef557c0ded22e014ac7d",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 5.94,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,19 @@\n   private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n     throws IOException, UnresolvedLinkException {\n     assert hasWriteLock();\n-      checkOperation(OperationCategory.WRITE);\n-    if (isInSafeMode()) {\n-      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n-    }\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       checkParentAccess(pc, src, FsAction.WRITE);\n       checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n     }\n \n     if (dir.renameTo(src, dst)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(pc, src, FsAction.WRITE);\n      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n    }\n\n    if (dir.renameTo(src, dst)) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "fd1000bcefa07992ff5c6fae3508f3e33b7955c6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4679. Namenode operation checks should be done in a consistent manner. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466721 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 3:45 PM",
      "commitName": "fd1000bcefa07992ff5c6fae3508f3e33b7955c6",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "08/04/13 6:21 PM",
      "commitNameOld": "f680865d994b8b75c11fa85f3241b1b9c6851187",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 1.89,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,23 @@\n   private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n     throws IOException, UnresolvedLinkException {\n     assert hasWriteLock();\n+      checkOperation(OperationCategory.WRITE);\n     if (isInSafeMode()) {\n       throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n     }\n-    if (!DFSUtil.isValidName(dst)) {\n-      throw new IOException(\"Invalid name: \" + dst);\n-    }\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       checkParentAccess(pc, src, FsAction.WRITE);\n       checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n     }\n \n     if (dir.renameTo(src, dst)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n      checkOperation(OperationCategory.WRITE);\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(pc, src, FsAction.WRITE);\n      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n    }\n\n    if (dir.renameTo(src, dst)) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "cdb292f44caff9763631d9e9bcd69c375a7cddea": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-4222. NN is unresponsive and loses heartbeats from DNs when configured to use LDAP and LDAP has issues. Contributed by Xiaobo Peng and Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1448801 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/02/13 1:02 PM",
      "commitName": "cdb292f44caff9763631d9e9bcd69c375a7cddea",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-4222. NN is unresponsive and loses heartbeats from DNs when configured to use LDAP and LDAP has issues. Contributed by Xiaobo Peng and Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1448801 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/02/13 1:02 PM",
          "commitName": "cdb292f44caff9763631d9e9bcd69c375a7cddea",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "11/02/13 4:50 PM",
          "commitNameOld": "969e84decbc976bd98f1050aead695d15a024ab6",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 9.84,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,25 @@\n-  private boolean renameToInternal(String src, String dst)\n+  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n     throws IOException, UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isInSafeMode()) {\n       throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n     }\n     if (!DFSUtil.isValidName(dst)) {\n       throw new IOException(\"Invalid name: \" + dst);\n     }\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n-      checkParentAccess(src, FsAction.WRITE);\n-      checkAncestorAccess(actualdst, FsAction.WRITE);\n+      checkParentAccess(pc, src, FsAction.WRITE);\n+      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n     }\n \n     if (dir.renameTo(src, dst)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (!DFSUtil.isValidName(dst)) {\n      throw new IOException(\"Invalid name: \" + dst);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(pc, src, FsAction.WRITE);\n      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n    }\n\n    if (dir.renameTo(src, dst)) {\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[src-String, dst-String]",
            "newValue": "[pc-FSPermissionChecker, src-String, dst-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4222. NN is unresponsive and loses heartbeats from DNs when configured to use LDAP and LDAP has issues. Contributed by Xiaobo Peng and Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1448801 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/02/13 1:02 PM",
          "commitName": "cdb292f44caff9763631d9e9bcd69c375a7cddea",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "11/02/13 4:50 PM",
          "commitNameOld": "969e84decbc976bd98f1050aead695d15a024ab6",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 9.84,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,25 @@\n-  private boolean renameToInternal(String src, String dst)\n+  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n     throws IOException, UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isInSafeMode()) {\n       throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n     }\n     if (!DFSUtil.isValidName(dst)) {\n       throw new IOException(\"Invalid name: \" + dst);\n     }\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n       //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n       //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n-      checkParentAccess(src, FsAction.WRITE);\n-      checkAncestorAccess(actualdst, FsAction.WRITE);\n+      checkParentAccess(pc, src, FsAction.WRITE);\n+      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n     }\n \n     if (dir.renameTo(src, dst)) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean renameToInternal(FSPermissionChecker pc, String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (!DFSUtil.isValidName(dst)) {\n      throw new IOException(\"Invalid name: \" + dst);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(pc, src, FsAction.WRITE);\n      checkAncestorAccess(pc, actualdst, FsAction.WRITE);\n    }\n\n    if (dir.renameTo(src, dst)) {\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "88eea2157275d4c7e1bf70cac98fe52c326f3585": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4248. Renaming directories may incorrectly remove the paths in leases under the tree.  Contributed by daryn\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1416064 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/12/12 2:29 PM",
      "commitName": "88eea2157275d4c7e1bf70cac98fe52c326f3585",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/12/12 10:18 AM",
      "commitNameOld": "64fe19e0d4c1eb78982ac6103a00cb338eb8822d",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   private boolean renameToInternal(String src, String dst)\n     throws IOException, UnresolvedLinkException {\n     assert hasWriteLock();\n     if (isInSafeMode()) {\n       throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n     }\n     if (!DFSUtil.isValidName(dst)) {\n       throw new IOException(\"Invalid name: \" + dst);\n     }\n     if (isPermissionEnabled) {\n       //We should not be doing this.  This is move() not renameTo().\n       //but for now,\n+      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n+      //      of rewriting the dst\n       String actualdst \u003d dir.isDir(dst)?\n           dst + Path.SEPARATOR + new Path(src).getName(): dst;\n       checkParentAccess(src, FsAction.WRITE);\n       checkAncestorAccess(actualdst, FsAction.WRITE);\n     }\n \n-    HdfsFileStatus dinfo \u003d dir.getFileInfo(dst, false);\n     if (dir.renameTo(src, dst)) {\n-      unprotectedChangeLease(src, dst, dinfo);     // update lease with new filename\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (!DFSUtil.isValidName(dst)) {\n      throw new IOException(\"Invalid name: \" + dst);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      //NOTE: yes, this is bad!  it\u0027s assuming much lower level behavior\n      //      of rewriting the dst\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(src, FsAction.WRITE);\n      checkAncestorAccess(actualdst, FsAction.WRITE);\n    }\n\n    if (dir.renameTo(src, dst)) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private boolean renameToInternal(String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (!DFSUtil.isValidName(dst)) {\n      throw new IOException(\"Invalid name: \" + dst);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(src, FsAction.WRITE);\n      checkAncestorAccess(actualdst, FsAction.WRITE);\n    }\n\n    HdfsFileStatus dinfo \u003d dir.getFileInfo(dst, false);\n    if (dir.renameTo(src, dst)) {\n      unprotectedChangeLease(src, dst, dinfo);     // update lease with new filename\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private boolean renameToInternal(String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (!DFSUtil.isValidName(dst)) {\n      throw new IOException(\"Invalid name: \" + dst);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(src, FsAction.WRITE);\n      checkAncestorAccess(actualdst, FsAction.WRITE);\n    }\n\n    HdfsFileStatus dinfo \u003d dir.getFileInfo(dst, false);\n    if (dir.renameTo(src, dst)) {\n      unprotectedChangeLease(src, dst, dinfo);     // update lease with new filename\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,25 @@\n+  private boolean renameToInternal(String src, String dst)\n+    throws IOException, UnresolvedLinkException {\n+    assert hasWriteLock();\n+    if (isInSafeMode()) {\n+      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n+    }\n+    if (!DFSUtil.isValidName(dst)) {\n+      throw new IOException(\"Invalid name: \" + dst);\n+    }\n+    if (isPermissionEnabled) {\n+      //We should not be doing this.  This is move() not renameTo().\n+      //but for now,\n+      String actualdst \u003d dir.isDir(dst)?\n+          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n+      checkParentAccess(src, FsAction.WRITE);\n+      checkAncestorAccess(actualdst, FsAction.WRITE);\n+    }\n+\n+    HdfsFileStatus dinfo \u003d dir.getFileInfo(dst, false);\n+    if (dir.renameTo(src, dst)) {\n+      unprotectedChangeLease(src, dst, dinfo);     // update lease with new filename\n+      return true;\n+    }\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean renameToInternal(String src, String dst)\n    throws IOException, UnresolvedLinkException {\n    assert hasWriteLock();\n    if (isInSafeMode()) {\n      throw new SafeModeException(\"Cannot rename \" + src, safeMode);\n    }\n    if (!DFSUtil.isValidName(dst)) {\n      throw new IOException(\"Invalid name: \" + dst);\n    }\n    if (isPermissionEnabled) {\n      //We should not be doing this.  This is move() not renameTo().\n      //but for now,\n      String actualdst \u003d dir.isDir(dst)?\n          dst + Path.SEPARATOR + new Path(src).getName(): dst;\n      checkParentAccess(src, FsAction.WRITE);\n      checkAncestorAccess(actualdst, FsAction.WRITE);\n    }\n\n    HdfsFileStatus dinfo \u003d dir.getFileInfo(dst, false);\n    if (dir.renameTo(src, dst)) {\n      unprotectedChangeLease(src, dst, dinfo);     // update lease with new filename\n      return true;\n    }\n    return false;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}