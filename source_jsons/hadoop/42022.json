{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKRMStateStore.java",
  "functionName": "handleApplicationAttemptStateOp",
  "functionId": "handleApplicationAttemptStateOp___appAttemptId-ApplicationAttemptId__attemptStateDataPB-ApplicationAttemptStateData__operation-AppAttemptOp",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
  "functionStartLine": 901,
  "functionEndLine": 950,
  "numCommitsSeen": 77,
  "timeTaken": 3212,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9",
    "4249172e1419acdb2b69ae3db43dc59da2aa2e03",
    "2e52789edf68016e7a3f450164f8bd3d8e6cb210"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9": "Ybodychange",
    "4249172e1419acdb2b69ae3db43dc59da2aa2e03": "Ybodychange",
    "2e52789edf68016e7a3f450164f8bd3d8e6cb210": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,50 @@\n   private void handleApplicationAttemptStateOp(\n       ApplicationAttemptId appAttemptId,\n       ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n       throws Exception {\n     String appId \u003d appAttemptId.getApplicationId().toString();\n     String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n     // Look for paths based on other split indices.\n     if (!exists(appDirPath)) {\n       ZnodeSplitInfo alternatePathInfo \u003d getAlternateAppPath(appId);\n       if (alternatePathInfo \u003d\u003d null) {\n         if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n           // Unexpected. Assume that app attempt has been deleted.\n           return;\n         } else { // Store or Update operation\n           throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n               \"app \" + appId + \" not found\");\n         }\n       } else {\n         appDirPath \u003d alternatePathInfo.path;\n       }\n     }\n     String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n     byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n         attemptStateDataPB.getProto().toByteArray();\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(operation + \" info for attempt: \" + appAttemptId + \" at: \"\n-          + path);\n-    }\n+    LOG.debug(\"{} info for attempt: {} at: {}\", operation, appAttemptId, path);\n+\n     switch (operation) {\n     case UPDATE:\n       if (exists(path)) {\n         zkManager.safeSetData(path, attemptStateData, -1, zkAcl,\n             fencingNodePath);\n       } else {\n         zkManager.safeCreate(path, attemptStateData, zkAcl,\n             CreateMode.PERSISTENT, zkAcl, fencingNodePath);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Path \" + path + \" for \" + appAttemptId + \" didn\u0027t exist.\" +\n-              \" Created a new znode to update the application attempt state.\");\n-        }\n+        LOG.debug(\"Path {} for {} didn\u0027t exist. Created a new znode to update\"\n+            + \" the application attempt state.\", path, appAttemptId);\n+\n       }\n       break;\n     case STORE:\n       zkManager.safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT,\n           zkAcl, fencingNodePath);\n       break;\n     case REMOVE:\n       zkManager.safeDelete(path, zkAcl, fencingNodePath);\n       break;\n     default:\n       break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleApplicationAttemptStateOp(\n      ApplicationAttemptId appAttemptId,\n      ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n      throws Exception {\n    String appId \u003d appAttemptId.getApplicationId().toString();\n    String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n    // Look for paths based on other split indices.\n    if (!exists(appDirPath)) {\n      ZnodeSplitInfo alternatePathInfo \u003d getAlternateAppPath(appId);\n      if (alternatePathInfo \u003d\u003d null) {\n        if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n          // Unexpected. Assume that app attempt has been deleted.\n          return;\n        } else { // Store or Update operation\n          throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n              \"app \" + appId + \" not found\");\n        }\n      } else {\n        appDirPath \u003d alternatePathInfo.path;\n      }\n    }\n    String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n    byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n        attemptStateDataPB.getProto().toByteArray();\n    LOG.debug(\"{} info for attempt: {} at: {}\", operation, appAttemptId, path);\n\n    switch (operation) {\n    case UPDATE:\n      if (exists(path)) {\n        zkManager.safeSetData(path, attemptStateData, -1, zkAcl,\n            fencingNodePath);\n      } else {\n        zkManager.safeCreate(path, attemptStateData, zkAcl,\n            CreateMode.PERSISTENT, zkAcl, fencingNodePath);\n        LOG.debug(\"Path {} for {} didn\u0027t exist. Created a new znode to update\"\n            + \" the application attempt state.\", path, appAttemptId);\n\n      }\n      break;\n    case STORE:\n      zkManager.safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT,\n          zkAcl, fencingNodePath);\n      break;\n    case REMOVE:\n      zkManager.safeDelete(path, zkAcl, fencingNodePath);\n      break;\n    default:\n      break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7262. Add a hierarchy into the ZKRMStateStore for delegation token znodes to prevent jute buffer overflow (rkanter)\n",
      "commitDate": "26/10/17 5:47 PM",
      "commitName": "b1de78619f3e5e25d6f9d5eaf41925f22d212fb9",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 17.28,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   private void handleApplicationAttemptStateOp(\n       ApplicationAttemptId appAttemptId,\n       ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n       throws Exception {\n     String appId \u003d appAttemptId.getApplicationId().toString();\n     String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n     // Look for paths based on other split indices.\n     if (!exists(appDirPath)) {\n-      AppNodeSplitInfo alternatePathInfo \u003d getAlternatePath(appId);\n+      ZnodeSplitInfo alternatePathInfo \u003d getAlternateAppPath(appId);\n       if (alternatePathInfo \u003d\u003d null) {\n         if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n           // Unexpected. Assume that app attempt has been deleted.\n           return;\n         } else { // Store or Update operation\n           throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n               \"app \" + appId + \" not found\");\n         }\n       } else {\n         appDirPath \u003d alternatePathInfo.path;\n       }\n     }\n     String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n     byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n         attemptStateDataPB.getProto().toByteArray();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(operation + \" info for attempt: \" + appAttemptId + \" at: \"\n           + path);\n     }\n     switch (operation) {\n     case UPDATE:\n       if (exists(path)) {\n         zkManager.safeSetData(path, attemptStateData, -1, zkAcl,\n             fencingNodePath);\n       } else {\n         zkManager.safeCreate(path, attemptStateData, zkAcl,\n             CreateMode.PERSISTENT, zkAcl, fencingNodePath);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Path \" + path + \" for \" + appAttemptId + \" didn\u0027t exist.\" +\n               \" Created a new znode to update the application attempt state.\");\n         }\n       }\n       break;\n     case STORE:\n       zkManager.safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT,\n           zkAcl, fencingNodePath);\n       break;\n     case REMOVE:\n       zkManager.safeDelete(path, zkAcl, fencingNodePath);\n       break;\n     default:\n       break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleApplicationAttemptStateOp(\n      ApplicationAttemptId appAttemptId,\n      ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n      throws Exception {\n    String appId \u003d appAttemptId.getApplicationId().toString();\n    String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n    // Look for paths based on other split indices.\n    if (!exists(appDirPath)) {\n      ZnodeSplitInfo alternatePathInfo \u003d getAlternateAppPath(appId);\n      if (alternatePathInfo \u003d\u003d null) {\n        if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n          // Unexpected. Assume that app attempt has been deleted.\n          return;\n        } else { // Store or Update operation\n          throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n              \"app \" + appId + \" not found\");\n        }\n      } else {\n        appDirPath \u003d alternatePathInfo.path;\n      }\n    }\n    String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n    byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n        attemptStateDataPB.getProto().toByteArray();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(operation + \" info for attempt: \" + appAttemptId + \" at: \"\n          + path);\n    }\n    switch (operation) {\n    case UPDATE:\n      if (exists(path)) {\n        zkManager.safeSetData(path, attemptStateData, -1, zkAcl,\n            fencingNodePath);\n      } else {\n        zkManager.safeCreate(path, attemptStateData, zkAcl,\n            CreateMode.PERSISTENT, zkAcl, fencingNodePath);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Path \" + path + \" for \" + appAttemptId + \" didn\u0027t exist.\" +\n              \" Created a new znode to update the application attempt state.\");\n        }\n      }\n      break;\n    case STORE:\n      zkManager.safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT,\n          zkAcl, fencingNodePath);\n      break;\n    case REMOVE:\n      zkManager.safeDelete(path, zkAcl, fencingNodePath);\n      break;\n    default:\n      break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "4249172e1419acdb2b69ae3db43dc59da2aa2e03": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7053. Move curator transaction support to ZKCuratorManager. (Jonathan Hung via Subru).\n",
      "commitDate": "22/08/17 7:20 PM",
      "commitName": "4249172e1419acdb2b69ae3db43dc59da2aa2e03",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "15/08/17 4:53 PM",
      "commitNameOld": "75dd866bfb8b63cb9f13179d4365b05c48e0907d",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 7.1,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,53 @@\n   private void handleApplicationAttemptStateOp(\n       ApplicationAttemptId appAttemptId,\n       ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n       throws Exception {\n     String appId \u003d appAttemptId.getApplicationId().toString();\n     String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n     // Look for paths based on other split indices.\n     if (!exists(appDirPath)) {\n       AppNodeSplitInfo alternatePathInfo \u003d getAlternatePath(appId);\n       if (alternatePathInfo \u003d\u003d null) {\n         if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n           // Unexpected. Assume that app attempt has been deleted.\n           return;\n         } else { // Store or Update operation\n           throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n               \"app \" + appId + \" not found\");\n         }\n       } else {\n         appDirPath \u003d alternatePathInfo.path;\n       }\n     }\n     String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n     byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n         attemptStateDataPB.getProto().toByteArray();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(operation + \" info for attempt: \" + appAttemptId + \" at: \"\n           + path);\n     }\n     switch (operation) {\n     case UPDATE:\n       if (exists(path)) {\n-        safeSetData(path, attemptStateData, -1);\n+        zkManager.safeSetData(path, attemptStateData, -1, zkAcl,\n+            fencingNodePath);\n       } else {\n-        safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);\n+        zkManager.safeCreate(path, attemptStateData, zkAcl,\n+            CreateMode.PERSISTENT, zkAcl, fencingNodePath);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Path \" + path + \" for \" + appAttemptId + \" didn\u0027t exist.\" +\n               \" Created a new znode to update the application attempt state.\");\n         }\n       }\n       break;\n     case STORE:\n-      safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);\n+      zkManager.safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT,\n+          zkAcl, fencingNodePath);\n       break;\n     case REMOVE:\n-      safeDelete(path);\n+      zkManager.safeDelete(path, zkAcl, fencingNodePath);\n       break;\n     default:\n       break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleApplicationAttemptStateOp(\n      ApplicationAttemptId appAttemptId,\n      ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n      throws Exception {\n    String appId \u003d appAttemptId.getApplicationId().toString();\n    String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n    // Look for paths based on other split indices.\n    if (!exists(appDirPath)) {\n      AppNodeSplitInfo alternatePathInfo \u003d getAlternatePath(appId);\n      if (alternatePathInfo \u003d\u003d null) {\n        if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n          // Unexpected. Assume that app attempt has been deleted.\n          return;\n        } else { // Store or Update operation\n          throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n              \"app \" + appId + \" not found\");\n        }\n      } else {\n        appDirPath \u003d alternatePathInfo.path;\n      }\n    }\n    String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n    byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n        attemptStateDataPB.getProto().toByteArray();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(operation + \" info for attempt: \" + appAttemptId + \" at: \"\n          + path);\n    }\n    switch (operation) {\n    case UPDATE:\n      if (exists(path)) {\n        zkManager.safeSetData(path, attemptStateData, -1, zkAcl,\n            fencingNodePath);\n      } else {\n        zkManager.safeCreate(path, attemptStateData, zkAcl,\n            CreateMode.PERSISTENT, zkAcl, fencingNodePath);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Path \" + path + \" for \" + appAttemptId + \" didn\u0027t exist.\" +\n              \" Created a new znode to update the application attempt state.\");\n        }\n      }\n      break;\n    case STORE:\n      zkManager.safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT,\n          zkAcl, fencingNodePath);\n      break;\n    case REMOVE:\n      zkManager.safeDelete(path, zkAcl, fencingNodePath);\n      break;\n    default:\n      break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java",
      "extendedDetails": {}
    },
    "2e52789edf68016e7a3f450164f8bd3d8e6cb210": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2962. ZKRMStateStore: Limit the number of znodes under a znode (Contributed by Varun Sexena via Daniel Templeton)\n",
      "commitDate": "28/04/17 1:30 PM",
      "commitName": "2e52789edf68016e7a3f450164f8bd3d8e6cb210",
      "commitAuthor": "Daniel Templeton",
      "diff": "@@ -0,0 +1,50 @@\n+  private void handleApplicationAttemptStateOp(\n+      ApplicationAttemptId appAttemptId,\n+      ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n+      throws Exception {\n+    String appId \u003d appAttemptId.getApplicationId().toString();\n+    String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n+    // Look for paths based on other split indices.\n+    if (!exists(appDirPath)) {\n+      AppNodeSplitInfo alternatePathInfo \u003d getAlternatePath(appId);\n+      if (alternatePathInfo \u003d\u003d null) {\n+        if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n+          // Unexpected. Assume that app attempt has been deleted.\n+          return;\n+        } else { // Store or Update operation\n+          throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n+              \"app \" + appId + \" not found\");\n+        }\n+      } else {\n+        appDirPath \u003d alternatePathInfo.path;\n+      }\n+    }\n+    String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n+    byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n+        attemptStateDataPB.getProto().toByteArray();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(operation + \" info for attempt: \" + appAttemptId + \" at: \"\n+          + path);\n+    }\n+    switch (operation) {\n+    case UPDATE:\n+      if (exists(path)) {\n+        safeSetData(path, attemptStateData, -1);\n+      } else {\n+        safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Path \" + path + \" for \" + appAttemptId + \" didn\u0027t exist.\" +\n+              \" Created a new znode to update the application attempt state.\");\n+        }\n+      }\n+      break;\n+    case STORE:\n+      safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);\n+      break;\n+    case REMOVE:\n+      safeDelete(path);\n+      break;\n+    default:\n+      break;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleApplicationAttemptStateOp(\n      ApplicationAttemptId appAttemptId,\n      ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)\n      throws Exception {\n    String appId \u003d appAttemptId.getApplicationId().toString();\n    String appDirPath \u003d getLeafAppIdNodePath(appId, false);\n    // Look for paths based on other split indices.\n    if (!exists(appDirPath)) {\n      AppNodeSplitInfo alternatePathInfo \u003d getAlternatePath(appId);\n      if (alternatePathInfo \u003d\u003d null) {\n        if (operation \u003d\u003d AppAttemptOp.REMOVE) {\n          // Unexpected. Assume that app attempt has been deleted.\n          return;\n        } else { // Store or Update operation\n          throw new YarnRuntimeException(\"Unexpected Exception. App node for \" +\n              \"app \" + appId + \" not found\");\n        }\n      } else {\n        appDirPath \u003d alternatePathInfo.path;\n      }\n    }\n    String path \u003d getNodePath(appDirPath, appAttemptId.toString());\n    byte[] attemptStateData \u003d (attemptStateDataPB \u003d\u003d null) ? null :\n        attemptStateDataPB.getProto().toByteArray();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(operation + \" info for attempt: \" + appAttemptId + \" at: \"\n          + path);\n    }\n    switch (operation) {\n    case UPDATE:\n      if (exists(path)) {\n        safeSetData(path, attemptStateData, -1);\n      } else {\n        safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Path \" + path + \" for \" + appAttemptId + \" didn\u0027t exist.\" +\n              \" Created a new znode to update the application attempt state.\");\n        }\n      }\n      break;\n    case STORE:\n      safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);\n      break;\n    case REMOVE:\n      safeDelete(path);\n      break;\n    default:\n      break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java"
    }
  }
}