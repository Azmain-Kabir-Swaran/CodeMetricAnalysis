{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CacheManager.java",
  "functionName": "addDirective",
  "functionId": "addDirective___info-CacheDirectiveInfo__pc-FSPermissionChecker__flags-EnumSet__CacheFlag__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
  "functionStartLine": 545,
  "functionEndLine": 572,
  "numCommitsSeen": 144,
  "timeTaken": 7829,
  "changeHistory": [
    "5f6b4157a40e974ccc6a56c39dbd35c54f393fbd",
    "93e23a99157c30b51752fc49748c3c210745a187",
    "d85c017d0488930d806f267141057fc73e68c728",
    "b9ae3087c0f83bfeeea47ded8e19932b46fd2350",
    "991c453ca3ac141a3f286f74af8401f83c38b230",
    "9da451cac57f3cd64c2c047675e5b60ca88ecf83",
    "13edb391d06c479720202eb5ac81f1c71fe64748",
    "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
    "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
    "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92",
    "f79b3e6b17450e9d34c483046b7437b09dd72016",
    "d61af9781086073152113d97106f708ea1cf6e8c",
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
    "af1ac9a5e8d8d97a855940d853dd59ab4666f6e2",
    "a0d9a155a4a4258f628e927e096ecf6673f788ec",
    "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
    "85c203602993a946fb5f41eadf1cf1484a0ce686",
    "40eb94ade3161d93e7a762a839004748f6d0ae89",
    "02e0e158a26f81ce8375426ba0ea56db09ee36be",
    "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
    "d56d0b46e1b82ae068083ddb99872d314684dc82",
    "97b7267977ef42201e5844df49bc37ec3d10ce16",
    "920b4cc06f1bc15809902bdd1968cc434a694a08"
  ],
  "changeHistoryShort": {
    "5f6b4157a40e974ccc6a56c39dbd35c54f393fbd": "Ybodychange",
    "93e23a99157c30b51752fc49748c3c210745a187": "Ybodychange",
    "d85c017d0488930d806f267141057fc73e68c728": "Ybodychange",
    "b9ae3087c0f83bfeeea47ded8e19932b46fd2350": "Ybodychange",
    "991c453ca3ac141a3f286f74af8401f83c38b230": "Ymultichange(Yparameterchange,Ybodychange)",
    "9da451cac57f3cd64c2c047675e5b60ca88ecf83": "Ybodychange",
    "13edb391d06c479720202eb5ac81f1c71fe64748": "Ymultichange(Yparameterchange,Ybodychange)",
    "f91a45a96c21db9e5d40097c7d3f5d005ae10dde": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0": "Ybodychange",
    "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92": "Ybodychange",
    "f79b3e6b17450e9d34c483046b7437b09dd72016": "Ymultichange(Yreturntypechange,Ybodychange)",
    "d61af9781086073152113d97106f708ea1cf6e8c": "Ybodychange",
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a": "Ymultichange(Ymodifierchange,Ybodychange)",
    "af1ac9a5e8d8d97a855940d853dd59ab4666f6e2": "Ybodychange",
    "a0d9a155a4a4258f628e927e096ecf6673f788ec": "Ymultichange(Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange)",
    "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04": "Ymultichange(Yreturntypechange,Ybodychange)",
    "85c203602993a946fb5f41eadf1cf1484a0ce686": "Ybodychange",
    "40eb94ade3161d93e7a762a839004748f6d0ae89": "Ybodychange",
    "02e0e158a26f81ce8375426ba0ea56db09ee36be": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "f41f8b8842c3f26d19f7fa928070c7c07f760e4c": "Ymultichange(Yparameterchange,Ybodychange)",
    "d56d0b46e1b82ae068083ddb99872d314684dc82": "Ymultichange(Yparameterchange,Ybodychange)",
    "97b7267977ef42201e5844df49bc37ec3d10ce16": "Ymultichange(Yparameterchange,Ybodychange)",
    "920b4cc06f1bc15809902bdd1968cc434a694a08": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5f6b4157a40e974ccc6a56c39dbd35c54f393fbd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10328. Add per-cache-pool default replication num configuration (xupeng via cmccabe)\n",
      "commitDate": "20/06/16 10:42 AM",
      "commitName": "5f6b4157a40e974ccc6a56c39dbd35c54f393fbd",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "16/12/15 6:16 PM",
      "commitNameOld": "f741476146574550a1a208d58ef8be76639e5ddc",
      "commitAuthorOld": "Uma Mahesh",
      "daysBetweenCommits": 186.64,
      "commitsBetweenForRepo": 1171,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,28 @@\n   public CacheDirectiveInfo addDirective(\n       CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CacheDirective directive;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(info);\n-      short replication \u003d validateReplication(info, (short)1);\n+      short replication \u003d validateReplication(\n+              info, pool.getDefaultReplication());\n       long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n       // Do quota validation if required\n       if (!flags.contains(CacheFlag.FORCE)) {\n         checkLimit(pool, path, replication);\n       }\n       // All validation passed\n       // Add a new entry with the next available ID.\n       long id \u003d getNextDirectiveId();\n       directive \u003d new CacheDirective(id, path, replication, expiryTime);\n       addInternal(directive, pool);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of {} successful.\", info);\n     return directive.toInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(\n              info, pool.getDefaultReplication());\n      long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n      // Do quota validation if required\n      if (!flags.contains(CacheFlag.FORCE)) {\n        checkLimit(pool, path, replication);\n      }\n      // All validation passed\n      // Add a new entry with the next available ID.\n      long id \u003d getNextDirectiveId();\n      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of {} successful.\", info);\n    return directive.toInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "93e23a99157c30b51752fc49748c3c210745a187": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6613. Improve logging in caching classes. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607697 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/07/14 10:13 AM",
      "commitName": "93e23a99157c30b51752fc49748c3c210745a187",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "15/05/14 6:18 PM",
      "commitNameOld": "8f48760663070529ff09927d1772010fffe5f438",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 48.66,
      "commitsBetweenForRepo": 297,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   public CacheDirectiveInfo addDirective(\n       CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CacheDirective directive;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(info);\n       short replication \u003d validateReplication(info, (short)1);\n       long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n       // Do quota validation if required\n       if (!flags.contains(CacheFlag.FORCE)) {\n         checkLimit(pool, path, replication);\n       }\n       // All validation passed\n       // Add a new entry with the next available ID.\n       long id \u003d getNextDirectiveId();\n       directive \u003d new CacheDirective(id, path, replication, expiryTime);\n       addInternal(directive, pool);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n-    LOG.info(\"addDirective of \" + info + \" successful.\");\n+    LOG.info(\"addDirective of {} successful.\", info);\n     return directive.toInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n      // Do quota validation if required\n      if (!flags.contains(CacheFlag.FORCE)) {\n        checkLimit(pool, path, replication);\n      }\n      // All validation passed\n      // Add a new entry with the next available ID.\n      long id \u003d getNextDirectiveId();\n      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of {} successful.\", info);\n    return directive.toInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "d85c017d0488930d806f267141057fc73e68c728": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5651. Remove dfs.namenode.caching.enabled and improve CRM locking. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1555002 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 6:45 PM",
      "commitName": "d85c017d0488930d806f267141057fc73e68c728",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "31/12/13 4:01 PM",
      "commitNameOld": "07e4fb1455abc33584fc666ef745abe256ebd7d1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,27 @@\n   public CacheDirectiveInfo addDirective(\n       CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CacheDirective directive;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(info);\n       short replication \u003d validateReplication(info, (short)1);\n       long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n       // Do quota validation if required\n       if (!flags.contains(CacheFlag.FORCE)) {\n-        // Can\u0027t kick and wait if caching is disabled\n-        if (monitor !\u003d null) {\n-          monitor.waitForRescan();\n-        }\n         checkLimit(pool, path, replication);\n       }\n       // All validation passed\n       // Add a new entry with the next available ID.\n       long id \u003d getNextDirectiveId();\n       directive \u003d new CacheDirective(id, path, replication, expiryTime);\n       addInternal(directive, pool);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + info + \" successful.\");\n     return directive.toInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n      // Do quota validation if required\n      if (!flags.contains(CacheFlag.FORCE)) {\n        checkLimit(pool, path, replication);\n      }\n      // All validation passed\n      // Add a new entry with the next available ID.\n      long id \u003d getNextDirectiveId();\n      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + info + \" successful.\");\n    return directive.toInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "b9ae3087c0f83bfeeea47ded8e19932b46fd2350": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5636. Enforce a max TTL per cache pool (awang via cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1552841 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/12/13 3:27 PM",
      "commitName": "b9ae3087c0f83bfeeea47ded8e19932b46fd2350",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "17/12/13 10:47 AM",
      "commitNameOld": "991c453ca3ac141a3f286f74af8401f83c38b230",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 3.19,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,31 @@\n   public CacheDirectiveInfo addDirective(\n       CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CacheDirective directive;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(info);\n       short replication \u003d validateReplication(info, (short)1);\n-      long expiryTime \u003d validateExpiryTime(info,\n-          CacheDirectiveInfo.Expiration.EXPIRY_NEVER);\n+      long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n       // Do quota validation if required\n       if (!flags.contains(CacheFlag.FORCE)) {\n         // Can\u0027t kick and wait if caching is disabled\n         if (monitor !\u003d null) {\n           monitor.waitForRescan();\n         }\n         checkLimit(pool, path, replication);\n       }\n       // All validation passed\n       // Add a new entry with the next available ID.\n       long id \u003d getNextDirectiveId();\n       directive \u003d new CacheDirective(id, path, replication, expiryTime);\n       addInternal(directive, pool);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + info + \" successful.\");\n     return directive.toInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long expiryTime \u003d validateExpiryTime(info, pool.getMaxRelativeExpiryMs());\n      // Do quota validation if required\n      if (!flags.contains(CacheFlag.FORCE)) {\n        // Can\u0027t kick and wait if caching is disabled\n        if (monitor !\u003d null) {\n          monitor.waitForRescan();\n        }\n        checkLimit(pool, path, replication);\n      }\n      // All validation passed\n      // Add a new entry with the next available ID.\n      long id \u003d getNextDirectiveId();\n      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + info + \" successful.\");\n    return directive.toInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "991c453ca3ac141a3f286f74af8401f83c38b230": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5431. Support cachepool-based limit management in path-based caching. (awang via cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551651 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/13 10:47 AM",
      "commitName": "991c453ca3ac141a3f286f74af8401f83c38b230",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5431. Support cachepool-based limit management in path-based caching. (awang via cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551651 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/12/13 10:47 AM",
          "commitName": "991c453ca3ac141a3f286f74af8401f83c38b230",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "05/12/13 1:09 PM",
          "commitNameOld": "55e5b0653c34a5f4146ce5a97a5b4a88a976d88a",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 11.9,
          "commitsBetweenForRepo": 67,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,32 @@\n   public CacheDirectiveInfo addDirective(\n-      CacheDirectiveInfo info, FSPermissionChecker pc)\n+      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CacheDirective directive;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(info);\n       short replication \u003d validateReplication(info, (short)1);\n       long expiryTime \u003d validateExpiryTime(info,\n           CacheDirectiveInfo.Expiration.EXPIRY_NEVER);\n+      // Do quota validation if required\n+      if (!flags.contains(CacheFlag.FORCE)) {\n+        // Can\u0027t kick and wait if caching is disabled\n+        if (monitor !\u003d null) {\n+          monitor.waitForRescan();\n+        }\n+        checkLimit(pool, path, replication);\n+      }\n       // All validation passed\n       // Add a new entry with the next available ID.\n       long id \u003d getNextDirectiveId();\n       directive \u003d new CacheDirective(id, path, replication, expiryTime);\n       addInternal(directive, pool);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + info + \" successful.\");\n-    if (monitor !\u003d null) {\n-      monitor.kick();\n-    }\n     return directive.toInfo();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long expiryTime \u003d validateExpiryTime(info,\n          CacheDirectiveInfo.Expiration.EXPIRY_NEVER);\n      // Do quota validation if required\n      if (!flags.contains(CacheFlag.FORCE)) {\n        // Can\u0027t kick and wait if caching is disabled\n        if (monitor !\u003d null) {\n          monitor.waitForRescan();\n        }\n        checkLimit(pool, path, replication);\n      }\n      // All validation passed\n      // Add a new entry with the next available ID.\n      long id \u003d getNextDirectiveId();\n      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + info + \" successful.\");\n    return directive.toInfo();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[info-CacheDirectiveInfo, pc-FSPermissionChecker]",
            "newValue": "[info-CacheDirectiveInfo, pc-FSPermissionChecker, flags-EnumSet\u003cCacheFlag\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5431. Support cachepool-based limit management in path-based caching. (awang via cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551651 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/12/13 10:47 AM",
          "commitName": "991c453ca3ac141a3f286f74af8401f83c38b230",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "05/12/13 1:09 PM",
          "commitNameOld": "55e5b0653c34a5f4146ce5a97a5b4a88a976d88a",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 11.9,
          "commitsBetweenForRepo": 67,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,32 @@\n   public CacheDirectiveInfo addDirective(\n-      CacheDirectiveInfo info, FSPermissionChecker pc)\n+      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CacheDirective directive;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(info);\n       short replication \u003d validateReplication(info, (short)1);\n       long expiryTime \u003d validateExpiryTime(info,\n           CacheDirectiveInfo.Expiration.EXPIRY_NEVER);\n+      // Do quota validation if required\n+      if (!flags.contains(CacheFlag.FORCE)) {\n+        // Can\u0027t kick and wait if caching is disabled\n+        if (monitor !\u003d null) {\n+          monitor.waitForRescan();\n+        }\n+        checkLimit(pool, path, replication);\n+      }\n       // All validation passed\n       // Add a new entry with the next available ID.\n       long id \u003d getNextDirectiveId();\n       directive \u003d new CacheDirective(id, path, replication, expiryTime);\n       addInternal(directive, pool);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + info + \" successful.\");\n-    if (monitor !\u003d null) {\n-      monitor.kick();\n-    }\n     return directive.toInfo();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc, EnumSet\u003cCacheFlag\u003e flags)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long expiryTime \u003d validateExpiryTime(info,\n          CacheDirectiveInfo.Expiration.EXPIRY_NEVER);\n      // Do quota validation if required\n      if (!flags.contains(CacheFlag.FORCE)) {\n        // Can\u0027t kick and wait if caching is disabled\n        if (monitor !\u003d null) {\n          monitor.waitForRescan();\n        }\n        checkLimit(pool, path, replication);\n      }\n      // All validation passed\n      // Add a new entry with the next available ID.\n      long id \u003d getNextDirectiveId();\n      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + info + \" successful.\");\n    return directive.toInfo();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "9da451cac57f3cd64c2c047675e5b60ca88ecf83": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5430. Support TTL on CacheDirectives. Contributed by Andrew Wang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546301 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 11:20 PM",
      "commitName": "9da451cac57f3cd64c2c047675e5b60ca88ecf83",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/11/13 9:55 AM",
      "commitNameOld": "13edb391d06c479720202eb5ac81f1c71fe64748",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,27 @@\n   public CacheDirectiveInfo addDirective(\n       CacheDirectiveInfo info, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CacheDirective directive;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(info);\n       short replication \u003d validateReplication(info, (short)1);\n-      long id;\n-      if (info.getId() !\u003d null) {\n-        // We are loading a directive from the edit log.\n-        // Use the ID from the edit log.\n-        id \u003d info.getId();\n-        if (id \u003c\u003d 0) {\n-          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n-              \"of \" + id + \": it is not positive.\");\n-        }\n-        if (id \u003e\u003d Long.MAX_VALUE) {\n-          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n-              \"of \" + id + \": it is too big.\");\n-        }\n-        if (nextDirectiveId \u003c\u003d id) {\n-          nextDirectiveId \u003d id + 1;\n-        }\n-      } else {\n-        // Add a new directive with the next available ID.\n-        id \u003d getNextEntryId();\n-      }\n-      directive \u003d new CacheDirective(id, path, replication);\n+      long expiryTime \u003d validateExpiryTime(info,\n+          CacheDirectiveInfo.Expiration.EXPIRY_NEVER);\n+      // All validation passed\n+      // Add a new entry with the next available ID.\n+      long id \u003d getNextDirectiveId();\n+      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n       addInternal(directive, pool);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + info + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n     return directive.toInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long expiryTime \u003d validateExpiryTime(info,\n          CacheDirectiveInfo.Expiration.EXPIRY_NEVER);\n      // All validation passed\n      // Add a new entry with the next available ID.\n      long id \u003d getNextDirectiveId();\n      directive \u003d new CacheDirective(id, path, replication, expiryTime);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + info + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return directive.toInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "13edb391d06c479720202eb5ac81f1c71fe64748": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5556. Add some more NameNode cache statistics, cache pool stats (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 9:55 AM",
      "commitName": "13edb391d06c479720202eb5ac81f1c71fe64748",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5556. Add some more NameNode cache statistics, cache pool stats (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/11/13 9:55 AM",
          "commitName": "13edb391d06c479720202eb5ac81f1c71fe64748",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/11/13 9:12 AM",
          "commitNameOld": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 6.03,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n   public CacheDirectiveInfo addDirective(\n-      CacheDirectiveInfo directive, FSPermissionChecker pc)\n+      CacheDirectiveInfo info, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n-    CacheDirective entry;\n+    CacheDirective directive;\n     try {\n-      CachePool pool \u003d getCachePool(validatePoolName(directive));\n+      CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n-      String path \u003d validatePath(directive);\n-      short replication \u003d validateReplication(directive, (short)1);\n+      String path \u003d validatePath(info);\n+      short replication \u003d validateReplication(info, (short)1);\n       long id;\n-      if (directive.getId() !\u003d null) {\n-        // We are loading an entry from the edit log.\n+      if (info.getId() !\u003d null) {\n+        // We are loading a directive from the edit log.\n         // Use the ID from the edit log.\n-        id \u003d directive.getId();\n+        id \u003d info.getId();\n         if (id \u003c\u003d 0) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is not positive.\");\n         }\n         if (id \u003e\u003d Long.MAX_VALUE) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is too big.\");\n         }\n-        if (nextEntryId \u003c\u003d id) {\n-          nextEntryId \u003d id + 1;\n+        if (nextDirectiveId \u003c\u003d id) {\n+          nextDirectiveId \u003d id + 1;\n         }\n       } else {\n-        // Add a new entry with the next available ID.\n+        // Add a new directive with the next available ID.\n         id \u003d getNextEntryId();\n       }\n-      entry \u003d new CacheDirective(id, path, replication, pool);\n-      addInternal(entry);\n+      directive \u003d new CacheDirective(id, path, replication);\n+      addInternal(directive, pool);\n     } catch (IOException e) {\n-      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n+      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n-    LOG.info(\"addDirective of \" + directive + \" successful.\");\n+    LOG.info(\"addDirective of \" + info + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n-    return entry.toDirective();\n+    return directive.toInfo();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long id;\n      if (info.getId() !\u003d null) {\n        // We are loading a directive from the edit log.\n        // Use the ID from the edit log.\n        id \u003d info.getId();\n        if (id \u003c\u003d 0) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is not positive.\");\n        }\n        if (id \u003e\u003d Long.MAX_VALUE) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is too big.\");\n        }\n        if (nextDirectiveId \u003c\u003d id) {\n          nextDirectiveId \u003d id + 1;\n        }\n      } else {\n        // Add a new directive with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      directive \u003d new CacheDirective(id, path, replication);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + info + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return directive.toInfo();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[directive-CacheDirectiveInfo, pc-FSPermissionChecker]",
            "newValue": "[info-CacheDirectiveInfo, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5556. Add some more NameNode cache statistics, cache pool stats (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/11/13 9:55 AM",
          "commitName": "13edb391d06c479720202eb5ac81f1c71fe64748",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/11/13 9:12 AM",
          "commitNameOld": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 6.03,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n   public CacheDirectiveInfo addDirective(\n-      CacheDirectiveInfo directive, FSPermissionChecker pc)\n+      CacheDirectiveInfo info, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n-    CacheDirective entry;\n+    CacheDirective directive;\n     try {\n-      CachePool pool \u003d getCachePool(validatePoolName(directive));\n+      CachePool pool \u003d getCachePool(validatePoolName(info));\n       checkWritePermission(pc, pool);\n-      String path \u003d validatePath(directive);\n-      short replication \u003d validateReplication(directive, (short)1);\n+      String path \u003d validatePath(info);\n+      short replication \u003d validateReplication(info, (short)1);\n       long id;\n-      if (directive.getId() !\u003d null) {\n-        // We are loading an entry from the edit log.\n+      if (info.getId() !\u003d null) {\n+        // We are loading a directive from the edit log.\n         // Use the ID from the edit log.\n-        id \u003d directive.getId();\n+        id \u003d info.getId();\n         if (id \u003c\u003d 0) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is not positive.\");\n         }\n         if (id \u003e\u003d Long.MAX_VALUE) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is too big.\");\n         }\n-        if (nextEntryId \u003c\u003d id) {\n-          nextEntryId \u003d id + 1;\n+        if (nextDirectiveId \u003c\u003d id) {\n+          nextDirectiveId \u003d id + 1;\n         }\n       } else {\n-        // Add a new entry with the next available ID.\n+        // Add a new directive with the next available ID.\n         id \u003d getNextEntryId();\n       }\n-      entry \u003d new CacheDirective(id, path, replication, pool);\n-      addInternal(entry);\n+      directive \u003d new CacheDirective(id, path, replication);\n+      addInternal(directive, pool);\n     } catch (IOException e) {\n-      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n+      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n       throw e;\n     }\n-    LOG.info(\"addDirective of \" + directive + \" successful.\");\n+    LOG.info(\"addDirective of \" + info + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n-    return entry.toDirective();\n+    return directive.toInfo();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo info, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective directive;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(info));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(info);\n      short replication \u003d validateReplication(info, (short)1);\n      long id;\n      if (info.getId() !\u003d null) {\n        // We are loading a directive from the edit log.\n        // Use the ID from the edit log.\n        id \u003d info.getId();\n        if (id \u003c\u003d 0) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is not positive.\");\n        }\n        if (id \u003e\u003d Long.MAX_VALUE) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is too big.\");\n        }\n        if (nextDirectiveId \u003c\u003d id) {\n          nextDirectiveId \u003d id + 1;\n        }\n      } else {\n        // Add a new directive with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      directive \u003d new CacheDirective(id, path, replication);\n      addInternal(directive, pool);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + info + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + info + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return directive.toInfo();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "f91a45a96c21db9e5d40097c7d3f5d005ae10dde": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/13 9:12 AM",
      "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/13 9:12 AM",
          "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "18/11/13 6:01 PM",
          "commitNameOld": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.63,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n-  public PathBasedCacheDirective addDirective(\n-      PathBasedCacheDirective directive, FSPermissionChecker pc)\n+  public CacheDirectiveInfo addDirective(\n+      CacheDirectiveInfo directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n-    PathBasedCacheEntry entry;\n+    CacheDirective entry;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(directive));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(directive);\n       short replication \u003d validateReplication(directive, (short)1);\n       long id;\n       if (directive.getId() !\u003d null) {\n         // We are loading an entry from the edit log.\n         // Use the ID from the edit log.\n         id \u003d directive.getId();\n         if (id \u003c\u003d 0) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is not positive.\");\n         }\n         if (id \u003e\u003d Long.MAX_VALUE) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is too big.\");\n         }\n         if (nextEntryId \u003c\u003d id) {\n           nextEntryId \u003d id + 1;\n         }\n       } else {\n         // Add a new entry with the next available ID.\n         id \u003d getNextEntryId();\n       }\n-      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n+      entry \u003d new CacheDirective(id, path, replication, pool);\n       addInternal(entry);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + directive + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n     return entry.toDirective();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective entry;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(directive));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(directive);\n      short replication \u003d validateReplication(directive, (short)1);\n      long id;\n      if (directive.getId() !\u003d null) {\n        // We are loading an entry from the edit log.\n        // Use the ID from the edit log.\n        id \u003d directive.getId();\n        if (id \u003c\u003d 0) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is not positive.\");\n        }\n        if (id \u003e\u003d Long.MAX_VALUE) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is too big.\");\n        }\n        if (nextEntryId \u003c\u003d id) {\n          nextEntryId \u003d id + 1;\n        }\n      } else {\n        // Add a new entry with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      entry \u003d new CacheDirective(id, path, replication, pool);\n      addInternal(entry);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + directive + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.toDirective();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[directive-PathBasedCacheDirective, pc-FSPermissionChecker]",
            "newValue": "[directive-CacheDirectiveInfo, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/13 9:12 AM",
          "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "18/11/13 6:01 PM",
          "commitNameOld": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.63,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n-  public PathBasedCacheDirective addDirective(\n-      PathBasedCacheDirective directive, FSPermissionChecker pc)\n+  public CacheDirectiveInfo addDirective(\n+      CacheDirectiveInfo directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n-    PathBasedCacheEntry entry;\n+    CacheDirective entry;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(directive));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(directive);\n       short replication \u003d validateReplication(directive, (short)1);\n       long id;\n       if (directive.getId() !\u003d null) {\n         // We are loading an entry from the edit log.\n         // Use the ID from the edit log.\n         id \u003d directive.getId();\n         if (id \u003c\u003d 0) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is not positive.\");\n         }\n         if (id \u003e\u003d Long.MAX_VALUE) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is too big.\");\n         }\n         if (nextEntryId \u003c\u003d id) {\n           nextEntryId \u003d id + 1;\n         }\n       } else {\n         // Add a new entry with the next available ID.\n         id \u003d getNextEntryId();\n       }\n-      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n+      entry \u003d new CacheDirective(id, path, replication, pool);\n       addInternal(entry);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + directive + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n     return entry.toDirective();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective entry;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(directive));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(directive);\n      short replication \u003d validateReplication(directive, (short)1);\n      long id;\n      if (directive.getId() !\u003d null) {\n        // We are loading an entry from the edit log.\n        // Use the ID from the edit log.\n        id \u003d directive.getId();\n        if (id \u003c\u003d 0) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is not positive.\");\n        }\n        if (id \u003e\u003d Long.MAX_VALUE) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is too big.\");\n        }\n        if (nextEntryId \u003c\u003d id) {\n          nextEntryId \u003d id + 1;\n        }\n      } else {\n        // Add a new entry with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      entry \u003d new CacheDirective(id, path, replication, pool);\n      addInternal(entry);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + directive + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.toDirective();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "PathBasedCacheDirective",
            "newValue": "CacheDirectiveInfo"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/13 9:12 AM",
          "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "18/11/13 6:01 PM",
          "commitNameOld": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.63,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n-  public PathBasedCacheDirective addDirective(\n-      PathBasedCacheDirective directive, FSPermissionChecker pc)\n+  public CacheDirectiveInfo addDirective(\n+      CacheDirectiveInfo directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n-    PathBasedCacheEntry entry;\n+    CacheDirective entry;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(directive));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(directive);\n       short replication \u003d validateReplication(directive, (short)1);\n       long id;\n       if (directive.getId() !\u003d null) {\n         // We are loading an entry from the edit log.\n         // Use the ID from the edit log.\n         id \u003d directive.getId();\n         if (id \u003c\u003d 0) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is not positive.\");\n         }\n         if (id \u003e\u003d Long.MAX_VALUE) {\n           throw new InvalidRequestException(\"can\u0027t add an ID \" +\n               \"of \" + id + \": it is too big.\");\n         }\n         if (nextEntryId \u003c\u003d id) {\n           nextEntryId \u003d id + 1;\n         }\n       } else {\n         // Add a new entry with the next available ID.\n         id \u003d getNextEntryId();\n       }\n-      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n+      entry \u003d new CacheDirective(id, path, replication, pool);\n       addInternal(entry);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + directive + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n     return entry.toDirective();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public CacheDirectiveInfo addDirective(\n      CacheDirectiveInfo directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CacheDirective entry;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(directive));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(directive);\n      short replication \u003d validateReplication(directive, (short)1);\n      long id;\n      if (directive.getId() !\u003d null) {\n        // We are loading an entry from the edit log.\n        // Use the ID from the edit log.\n        id \u003d directive.getId();\n        if (id \u003c\u003d 0) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is not positive.\");\n        }\n        if (id \u003e\u003d Long.MAX_VALUE) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is too big.\");\n        }\n        if (nextEntryId \u003c\u003d id) {\n          nextEntryId \u003d id + 1;\n        }\n      } else {\n        // Add a new entry with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      entry \u003d new CacheDirective(id, path, replication, pool);\n      addInternal(entry);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + directive + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.toDirective();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5520. loading cache path directives from edit log doesnt update nextEntryId (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543286 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 6:01 PM",
      "commitName": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "17/11/13 8:18 PM",
      "commitNameOld": "e3d7ef36ef7dd31b295b1f1d86a1bfa7887ca771",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,42 @@\n   public PathBasedCacheDirective addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     PathBasedCacheEntry entry;\n     try {\n       CachePool pool \u003d getCachePool(validatePoolName(directive));\n       checkWritePermission(pc, pool);\n       String path \u003d validatePath(directive);\n       short replication \u003d validateReplication(directive, (short)1);\n       long id;\n       if (directive.getId() !\u003d null) {\n         // We are loading an entry from the edit log.\n         // Use the ID from the edit log.\n         id \u003d directive.getId();\n+        if (id \u003c\u003d 0) {\n+          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n+              \"of \" + id + \": it is not positive.\");\n+        }\n+        if (id \u003e\u003d Long.MAX_VALUE) {\n+          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n+              \"of \" + id + \": it is too big.\");\n+        }\n+        if (nextEntryId \u003c\u003d id) {\n+          nextEntryId \u003d id + 1;\n+        }\n       } else {\n         // Add a new entry with the next available ID.\n         id \u003d getNextEntryId();\n       }\n       entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n       addInternal(entry);\n     } catch (IOException e) {\n       LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n       throw e;\n     }\n     LOG.info(\"addDirective of \" + directive + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n     return entry.toDirective();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public PathBasedCacheDirective addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    PathBasedCacheEntry entry;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(directive));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(directive);\n      short replication \u003d validateReplication(directive, (short)1);\n      long id;\n      if (directive.getId() !\u003d null) {\n        // We are loading an entry from the edit log.\n        // Use the ID from the edit log.\n        id \u003d directive.getId();\n        if (id \u003c\u003d 0) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is not positive.\");\n        }\n        if (id \u003e\u003d Long.MAX_VALUE) {\n          throw new InvalidRequestException(\"can\u0027t add an ID \" +\n              \"of \" + id + \": it is too big.\");\n        }\n        if (nextEntryId \u003c\u003d id) {\n          nextEntryId \u003d id + 1;\n        }\n      } else {\n        // Add a new entry with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n      addInternal(entry);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + directive + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.toDirective();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5471. CacheAdmin -listPools fails when user lacks permissions to view all pools (Andrew Wang via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1541323 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/11/13 3:52 PM",
      "commitName": "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "07/11/13 2:07 PM",
      "commitNameOld": "f79b3e6b17450e9d34c483046b7437b09dd72016",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 5.07,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,31 @@\n   public PathBasedCacheDirective addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     PathBasedCacheEntry entry;\n     try {\n-      if (directive.getPool() \u003d\u003d null) {\n-        throw new IdNotFoundException(\"addDirective: no pool was specified.\");\n-      }\n-      if (directive.getPool().isEmpty()) {\n-        throw new IdNotFoundException(\"addDirective: pool name was empty.\");\n-      }\n-      CachePool pool \u003d cachePools.get(directive.getPool());\n-      if (pool \u003d\u003d null) {\n-        throw new IdNotFoundException(\"addDirective: no such pool as \" +\n-            directive.getPool());\n-      }\n-      if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n-        throw new AccessControlException(\"addDirective: write \" +\n-            \"permission denied for pool \" + directive.getPool());\n-      }\n-      if (directive.getPath() \u003d\u003d null) {\n-        throw new IOException(\"addDirective: no path was specified.\");\n-      }\n-      String path \u003d directive.getPath().toUri().getPath();\n-      if (!DFSUtil.isValidName(path)) {\n-        throw new IOException(\"addDirective: path \u0027\" + path + \"\u0027 is invalid.\");\n-      }\n-      short replication \u003d directive.getReplication() \u003d\u003d null ? \n-          (short)1 : directive.getReplication();\n-      if (replication \u003c\u003d 0) {\n-        throw new IOException(\"addDirective: replication \" + replication +\n-            \" is invalid.\");\n-      }\n+      CachePool pool \u003d getCachePool(validatePoolName(directive));\n+      checkWritePermission(pc, pool);\n+      String path \u003d validatePath(directive);\n+      short replication \u003d validateReplication(directive, (short)1);\n       long id;\n       if (directive.getId() !\u003d null) {\n         // We are loading an entry from the edit log.\n         // Use the ID from the edit log.\n         id \u003d directive.getId();\n       } else {\n         // Add a new entry with the next available ID.\n         id \u003d getNextEntryId();\n       }\n       entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n       addInternal(entry);\n     } catch (IOException e) {\n-      LOG.warn(\"addDirective \" + directive + \": failed.\", e);\n+      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n       throw e;\n     }\n-    LOG.info(\"addDirective \" + directive + \": succeeded.\");\n+    LOG.info(\"addDirective of \" + directive + \" successful.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n     return entry.toDirective();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public PathBasedCacheDirective addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    PathBasedCacheEntry entry;\n    try {\n      CachePool pool \u003d getCachePool(validatePoolName(directive));\n      checkWritePermission(pc, pool);\n      String path \u003d validatePath(directive);\n      short replication \u003d validateReplication(directive, (short)1);\n      long id;\n      if (directive.getId() !\u003d null) {\n        // We are loading an entry from the edit log.\n        // Use the ID from the edit log.\n        id \u003d directive.getId();\n      } else {\n        // Add a new entry with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n      addInternal(entry);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective of \" + directive + \" failed: \", e);\n      throw e;\n    }\n    LOG.info(\"addDirective of \" + directive + \" successful.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.toDirective();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "f79b3e6b17450e9d34c483046b7437b09dd72016": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/13 2:07 PM",
      "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/11/13 2:07 PM",
          "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/10/13 12:29 PM",
          "commitNameOld": "f9c08d02ebe4a5477cf5d753f0d9d48fc6f9fa48",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 17.11,
          "commitsBetweenForRepo": 76,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,55 @@\n-  public PathBasedCacheDescriptor addDirective(\n+  public PathBasedCacheDirective addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n-    CachePool pool \u003d cachePools.get(directive.getPool());\n-    if (pool \u003d\u003d null) {\n-      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      throw new InvalidPoolNameError(directive);\n-    }\n-    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n-      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      throw new PoolWritePermissionDeniedError(directive);\n-    }\n-    try {\n-      directive.validate();\n-    } catch (IOException ioe) {\n-      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n-          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      throw ioe;\n-    }\n-    \n-    // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n-      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n-          directive.getPath().toUri().getPath(),\n-          directive.getReplication(), pool);\n-    } catch (IOException ioe) {\n-      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n+      if (directive.getPool() \u003d\u003d null) {\n+        throw new IdNotFoundException(\"addDirective: no pool was specified.\");\n+      }\n+      if (directive.getPool().isEmpty()) {\n+        throw new IdNotFoundException(\"addDirective: pool name was empty.\");\n+      }\n+      CachePool pool \u003d cachePools.get(directive.getPool());\n+      if (pool \u003d\u003d null) {\n+        throw new IdNotFoundException(\"addDirective: no such pool as \" +\n+            directive.getPool());\n+      }\n+      if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n+        throw new AccessControlException(\"addDirective: write \" +\n+            \"permission denied for pool \" + directive.getPool());\n+      }\n+      if (directive.getPath() \u003d\u003d null) {\n+        throw new IOException(\"addDirective: no path was specified.\");\n+      }\n+      String path \u003d directive.getPath().toUri().getPath();\n+      if (!DFSUtil.isValidName(path)) {\n+        throw new IOException(\"addDirective: path \u0027\" + path + \"\u0027 is invalid.\");\n+      }\n+      short replication \u003d directive.getReplication() \u003d\u003d null ? \n+          (short)1 : directive.getReplication();\n+      if (replication \u003c\u003d 0) {\n+        throw new IOException(\"addDirective: replication \" + replication +\n+            \" is invalid.\");\n+      }\n+      long id;\n+      if (directive.getId() !\u003d null) {\n+        // We are loading an entry from the edit log.\n+        // Use the ID from the edit log.\n+        id \u003d directive.getId();\n+      } else {\n+        // Add a new entry with the next available ID.\n+        id \u003d getNextEntryId();\n+      }\n+      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n+      addInternal(entry);\n+    } catch (IOException e) {\n+      LOG.warn(\"addDirective \" + directive + \": failed.\", e);\n+      throw e;\n     }\n-    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n-        + directive);\n-\n-    // Success!\n-    // First, add it to the various maps\n-    entriesById.put(entry.getEntryId(), entry);\n-    String path \u003d directive.getPath().toUri().getPath();\n-    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n-    if (entryList \u003d\u003d null) {\n-      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n-      entriesByPath.put(path, entryList);\n-    }\n-    entryList.add(entry);\n+    LOG.info(\"addDirective \" + directive + \": succeeded.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n-    return entry.getDescriptor();\n+    return entry.toDirective();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public PathBasedCacheDirective addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    PathBasedCacheEntry entry;\n    try {\n      if (directive.getPool() \u003d\u003d null) {\n        throw new IdNotFoundException(\"addDirective: no pool was specified.\");\n      }\n      if (directive.getPool().isEmpty()) {\n        throw new IdNotFoundException(\"addDirective: pool name was empty.\");\n      }\n      CachePool pool \u003d cachePools.get(directive.getPool());\n      if (pool \u003d\u003d null) {\n        throw new IdNotFoundException(\"addDirective: no such pool as \" +\n            directive.getPool());\n      }\n      if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n        throw new AccessControlException(\"addDirective: write \" +\n            \"permission denied for pool \" + directive.getPool());\n      }\n      if (directive.getPath() \u003d\u003d null) {\n        throw new IOException(\"addDirective: no path was specified.\");\n      }\n      String path \u003d directive.getPath().toUri().getPath();\n      if (!DFSUtil.isValidName(path)) {\n        throw new IOException(\"addDirective: path \u0027\" + path + \"\u0027 is invalid.\");\n      }\n      short replication \u003d directive.getReplication() \u003d\u003d null ? \n          (short)1 : directive.getReplication();\n      if (replication \u003c\u003d 0) {\n        throw new IOException(\"addDirective: replication \" + replication +\n            \" is invalid.\");\n      }\n      long id;\n      if (directive.getId() !\u003d null) {\n        // We are loading an entry from the edit log.\n        // Use the ID from the edit log.\n        id \u003d directive.getId();\n      } else {\n        // Add a new entry with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n      addInternal(entry);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective \" + directive + \": failed.\", e);\n      throw e;\n    }\n    LOG.info(\"addDirective \" + directive + \": succeeded.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.toDirective();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "PathBasedCacheDescriptor",
            "newValue": "PathBasedCacheDirective"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/11/13 2:07 PM",
          "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/10/13 12:29 PM",
          "commitNameOld": "f9c08d02ebe4a5477cf5d753f0d9d48fc6f9fa48",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 17.11,
          "commitsBetweenForRepo": 76,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,55 @@\n-  public PathBasedCacheDescriptor addDirective(\n+  public PathBasedCacheDirective addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n-    CachePool pool \u003d cachePools.get(directive.getPool());\n-    if (pool \u003d\u003d null) {\n-      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      throw new InvalidPoolNameError(directive);\n-    }\n-    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n-      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      throw new PoolWritePermissionDeniedError(directive);\n-    }\n-    try {\n-      directive.validate();\n-    } catch (IOException ioe) {\n-      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n-          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      throw ioe;\n-    }\n-    \n-    // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n-      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n-          directive.getPath().toUri().getPath(),\n-          directive.getReplication(), pool);\n-    } catch (IOException ioe) {\n-      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n+      if (directive.getPool() \u003d\u003d null) {\n+        throw new IdNotFoundException(\"addDirective: no pool was specified.\");\n+      }\n+      if (directive.getPool().isEmpty()) {\n+        throw new IdNotFoundException(\"addDirective: pool name was empty.\");\n+      }\n+      CachePool pool \u003d cachePools.get(directive.getPool());\n+      if (pool \u003d\u003d null) {\n+        throw new IdNotFoundException(\"addDirective: no such pool as \" +\n+            directive.getPool());\n+      }\n+      if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n+        throw new AccessControlException(\"addDirective: write \" +\n+            \"permission denied for pool \" + directive.getPool());\n+      }\n+      if (directive.getPath() \u003d\u003d null) {\n+        throw new IOException(\"addDirective: no path was specified.\");\n+      }\n+      String path \u003d directive.getPath().toUri().getPath();\n+      if (!DFSUtil.isValidName(path)) {\n+        throw new IOException(\"addDirective: path \u0027\" + path + \"\u0027 is invalid.\");\n+      }\n+      short replication \u003d directive.getReplication() \u003d\u003d null ? \n+          (short)1 : directive.getReplication();\n+      if (replication \u003c\u003d 0) {\n+        throw new IOException(\"addDirective: replication \" + replication +\n+            \" is invalid.\");\n+      }\n+      long id;\n+      if (directive.getId() !\u003d null) {\n+        // We are loading an entry from the edit log.\n+        // Use the ID from the edit log.\n+        id \u003d directive.getId();\n+      } else {\n+        // Add a new entry with the next available ID.\n+        id \u003d getNextEntryId();\n+      }\n+      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n+      addInternal(entry);\n+    } catch (IOException e) {\n+      LOG.warn(\"addDirective \" + directive + \": failed.\", e);\n+      throw e;\n     }\n-    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n-        + directive);\n-\n-    // Success!\n-    // First, add it to the various maps\n-    entriesById.put(entry.getEntryId(), entry);\n-    String path \u003d directive.getPath().toUri().getPath();\n-    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n-    if (entryList \u003d\u003d null) {\n-      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n-      entriesByPath.put(path, entryList);\n-    }\n-    entryList.add(entry);\n+    LOG.info(\"addDirective \" + directive + \": succeeded.\");\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n-    return entry.getDescriptor();\n+    return entry.toDirective();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public PathBasedCacheDirective addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    PathBasedCacheEntry entry;\n    try {\n      if (directive.getPool() \u003d\u003d null) {\n        throw new IdNotFoundException(\"addDirective: no pool was specified.\");\n      }\n      if (directive.getPool().isEmpty()) {\n        throw new IdNotFoundException(\"addDirective: pool name was empty.\");\n      }\n      CachePool pool \u003d cachePools.get(directive.getPool());\n      if (pool \u003d\u003d null) {\n        throw new IdNotFoundException(\"addDirective: no such pool as \" +\n            directive.getPool());\n      }\n      if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n        throw new AccessControlException(\"addDirective: write \" +\n            \"permission denied for pool \" + directive.getPool());\n      }\n      if (directive.getPath() \u003d\u003d null) {\n        throw new IOException(\"addDirective: no path was specified.\");\n      }\n      String path \u003d directive.getPath().toUri().getPath();\n      if (!DFSUtil.isValidName(path)) {\n        throw new IOException(\"addDirective: path \u0027\" + path + \"\u0027 is invalid.\");\n      }\n      short replication \u003d directive.getReplication() \u003d\u003d null ? \n          (short)1 : directive.getReplication();\n      if (replication \u003c\u003d 0) {\n        throw new IOException(\"addDirective: replication \" + replication +\n            \" is invalid.\");\n      }\n      long id;\n      if (directive.getId() !\u003d null) {\n        // We are loading an entry from the edit log.\n        // Use the ID from the edit log.\n        id \u003d directive.getId();\n      } else {\n        // Add a new entry with the next available ID.\n        id \u003d getNextEntryId();\n      }\n      entry \u003d new PathBasedCacheEntry(id, path, replication, pool);\n      addInternal(entry);\n    } catch (IOException e) {\n      LOG.warn(\"addDirective \" + directive + \": failed.\", e);\n      throw e;\n    }\n    LOG.info(\"addDirective \" + directive + \": succeeded.\");\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.toDirective();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "d61af9781086073152113d97106f708ea1cf6e8c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5203. Concurrent clients that add a cache directive on the same path may prematurely uncache each other.  (Chris Nauroth via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1533651 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/13 3:15 PM",
      "commitName": "d61af9781086073152113d97106f708ea1cf6e8c",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "18/10/13 1:20 PM",
      "commitNameOld": "1d96e3601312d771270567482cb0a051be786a21",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,48 @@\n   public PathBasedCacheDescriptor addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n     assert namesystem.hasWriteLock();\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n       throw ioe;\n     }\n     \n-    // Check if we already have this entry.\n-    PathBasedCacheEntry existing \u003d findEntry(directive);\n-    if (existing !\u003d null) {\n-      LOG.info(\"addDirective \" + directive + \": there is an \" +\n-          \"existing directive \" + existing + \" in this pool.\");\n-      return existing.getDescriptor();\n-    }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n       entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n           directive.getPath().toUri().getPath(),\n           directive.getReplication(), pool);\n     } catch (IOException ioe) {\n       throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath().toUri().getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n     if (monitor !\u003d null) {\n       monitor.kick();\n     }\n     return entry.getDescriptor();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath().toUri().getPath(),\n          directive.getReplication(), pool);\n    } catch (IOException ioe) {\n      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath().toUri().getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.getDescriptor();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/10/13 3:15 PM",
      "commitName": "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/10/13 3:15 PM",
          "commitName": "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "14/10/13 3:56 PM",
          "commitNameOld": "efe545b0c219eeba61ac5259aee4d518beb74316",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,55 @@\n-  public synchronized PathBasedCacheDescriptor addDirective(\n+  public PathBasedCacheDescriptor addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n+    assert namesystem.hasWriteLock();\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n       throw ioe;\n     }\n     \n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing + \" in this pool.\");\n       return existing.getDescriptor();\n     }\n-\n-    // Success!\n-    PathBasedCacheDescriptor d \u003d unprotectedAddDirective(directive);\n+    // Add a new entry with the next available ID.\n+    PathBasedCacheEntry entry;\n+    try {\n+      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n+          directive.getPath().toUri().getPath(),\n+          directive.getReplication(), pool);\n+    } catch (IOException ioe) {\n+      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n+    }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n-    return d;\n+\n+    // Success!\n+    // First, add it to the various maps\n+    entriesById.put(entry.getEntryId(), entry);\n+    String path \u003d directive.getPath().toUri().getPath();\n+    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n+    if (entryList \u003d\u003d null) {\n+      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n+      entriesByPath.put(path, entryList);\n+    }\n+    entryList.add(entry);\n+    if (monitor !\u003d null) {\n+      monitor.kick();\n+    }\n+    return entry.getDescriptor();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return existing.getDescriptor();\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath().toUri().getPath(),\n          directive.getReplication(), pool);\n    } catch (IOException ioe) {\n      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath().toUri().getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.getDescriptor();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/10/13 3:15 PM",
          "commitName": "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "14/10/13 3:56 PM",
          "commitNameOld": "efe545b0c219eeba61ac5259aee4d518beb74316",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,55 @@\n-  public synchronized PathBasedCacheDescriptor addDirective(\n+  public PathBasedCacheDescriptor addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n+    assert namesystem.hasWriteLock();\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n       throw ioe;\n     }\n     \n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing + \" in this pool.\");\n       return existing.getDescriptor();\n     }\n-\n-    // Success!\n-    PathBasedCacheDescriptor d \u003d unprotectedAddDirective(directive);\n+    // Add a new entry with the next available ID.\n+    PathBasedCacheEntry entry;\n+    try {\n+      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n+          directive.getPath().toUri().getPath(),\n+          directive.getReplication(), pool);\n+    } catch (IOException ioe) {\n+      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n+    }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n-    return d;\n+\n+    // Success!\n+    // First, add it to the various maps\n+    entriesById.put(entry.getEntryId(), entry);\n+    String path \u003d directive.getPath().toUri().getPath();\n+    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n+    if (entryList \u003d\u003d null) {\n+      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n+      entriesByPath.put(path, entryList);\n+    }\n+    entryList.add(entry);\n+    if (monitor !\u003d null) {\n+      monitor.kick();\n+    }\n+    return entry.getDescriptor();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    assert namesystem.hasWriteLock();\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return existing.getDescriptor();\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath().toUri().getPath(),\n          directive.getReplication(), pool);\n    } catch (IOException ioe) {\n      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath().toUri().getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n    if (monitor !\u003d null) {\n      monitor.kick();\n    }\n    return entry.getDescriptor();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "af1ac9a5e8d8d97a855940d853dd59ab4666f6e2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5119. Persist CacheManager state in the edit log. (Contributed by Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1529238 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/10/13 10:46 AM",
      "commitName": "af1ac9a5e8d8d97a855940d853dd59ab4666f6e2",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "20/09/13 5:20 PM",
      "commitNameOld": "a0d9a155a4a4258f628e927e096ecf6673f788ec",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 13.73,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,34 @@\n   public synchronized PathBasedCacheDescriptor addDirective(\n       PathBasedCacheDirective directive, FSPermissionChecker pc)\n       throws IOException {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n       throw ioe;\n     }\n     \n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing + \" in this pool.\");\n       return existing.getDescriptor();\n     }\n-    // Add a new entry with the next available ID.\n-    PathBasedCacheEntry entry;\n-    try {\n-      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n-          directive.getPath(), pool);\n-    } catch (IOException ioe) {\n-      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n-    }\n-    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n-        + directive);\n \n     // Success!\n-    // First, add it to the various maps\n-    entriesById.put(entry.getEntryId(), entry);\n-    String path \u003d directive.getPath();\n-    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n-    if (entryList \u003d\u003d null) {\n-      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n-      entriesByPath.put(path, entryList);\n-    }\n-    entryList.add(entry);\n-\n-    // Next, set the path as cached in the namesystem\n-    try {\n-      INode node \u003d dir.getINode(directive.getPath());\n-      if (node !\u003d null \u0026\u0026 node.isFile()) {\n-        INodeFile file \u003d node.asFile();\n-        // TODO: adjustable cache replication factor\n-        namesystem.setCacheReplicationInt(directive.getPath(),\n-            file.getBlockReplication());\n-      } else {\n-        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n-      }\n-    } catch (IOException ioe) {\n-      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n-          ioe.getClass().getName() +\": \" + ioe.getMessage());\n-      throw ioe;\n-    }\n-    return entry.getDescriptor();\n+    PathBasedCacheDescriptor d \u003d unprotectedAddDirective(directive);\n+    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n+        + directive);\n+    return d;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return existing.getDescriptor();\n    }\n\n    // Success!\n    PathBasedCacheDescriptor d \u003d unprotectedAddDirective(directive);\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    return d;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "a0d9a155a4a4258f628e927e096ecf6673f788ec": {
      "type": "Ymultichange(Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-5236. Change PathBasedCacheDirective APIs to be a single value rather than batch. (Contributed by Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1525183 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/09/13 5:20 PM",
      "commitName": "a0d9a155a4a4258f628e927e096ecf6673f788ec",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5236. Change PathBasedCacheDirective APIs to be a single value rather than batch. (Contributed by Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1525183 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "20/09/13 5:20 PM",
          "commitName": "a0d9a155a4a4258f628e927e096ecf6673f788ec",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "18/09/13 1:43 PM",
          "commitNameOld": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,67 @@\n-  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n-        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n+  public synchronized PathBasedCacheDescriptor addDirective(\n+      PathBasedCacheDirective directive, FSPermissionChecker pc)\n+      throws IOException {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new InvalidPoolNameError(directive));\n+      throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new PoolWritePermissionDeniedError(directive));\n+      throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n     \n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing + \" in this pool.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          existing.getDescriptor());\n+      return existing.getDescriptor();\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n       entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n           directive.getPath(), pool);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n+      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n \n     // Next, set the path as cached in the namesystem\n     try {\n       INode node \u003d dir.getINode(directive.getPath());\n       if (node !\u003d null \u0026\u0026 node.isFile()) {\n         INodeFile file \u003d node.asFile();\n         // TODO: adjustable cache replication factor\n         namesystem.setCacheReplicationInt(directive.getPath(),\n             file.getBlockReplication());\n       } else {\n         LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n       }\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n           ioe.getClass().getName() +\": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n-    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-        entry.getDescriptor());\n+    return entry.getDescriptor();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return existing.getDescriptor();\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath(), pool);\n    } catch (IOException ioe) {\n      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node !\u003d null \u0026\u0026 node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      } else {\n        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      throw ioe;\n    }\n    return entry.getDescriptor();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "Fallible\u003cPathBasedCacheDescriptor\u003e",
            "newValue": "PathBasedCacheDescriptor"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5236. Change PathBasedCacheDirective APIs to be a single value rather than batch. (Contributed by Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1525183 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "20/09/13 5:20 PM",
          "commitName": "a0d9a155a4a4258f628e927e096ecf6673f788ec",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "18/09/13 1:43 PM",
          "commitNameOld": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,67 @@\n-  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n-        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n+  public synchronized PathBasedCacheDescriptor addDirective(\n+      PathBasedCacheDirective directive, FSPermissionChecker pc)\n+      throws IOException {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new InvalidPoolNameError(directive));\n+      throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new PoolWritePermissionDeniedError(directive));\n+      throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n     \n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing + \" in this pool.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          existing.getDescriptor());\n+      return existing.getDescriptor();\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n       entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n           directive.getPath(), pool);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n+      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n \n     // Next, set the path as cached in the namesystem\n     try {\n       INode node \u003d dir.getINode(directive.getPath());\n       if (node !\u003d null \u0026\u0026 node.isFile()) {\n         INodeFile file \u003d node.asFile();\n         // TODO: adjustable cache replication factor\n         namesystem.setCacheReplicationInt(directive.getPath(),\n             file.getBlockReplication());\n       } else {\n         LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n       }\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n           ioe.getClass().getName() +\": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n-    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-        entry.getDescriptor());\n+    return entry.getDescriptor();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return existing.getDescriptor();\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath(), pool);\n    } catch (IOException ioe) {\n      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node !\u003d null \u0026\u0026 node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      } else {\n        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      throw ioe;\n    }\n    return entry.getDescriptor();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[public, synchronized]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-5236. Change PathBasedCacheDirective APIs to be a single value rather than batch. (Contributed by Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1525183 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "20/09/13 5:20 PM",
          "commitName": "a0d9a155a4a4258f628e927e096ecf6673f788ec",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "18/09/13 1:43 PM",
          "commitNameOld": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,67 @@\n-  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n-        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n+  public synchronized PathBasedCacheDescriptor addDirective(\n+      PathBasedCacheDirective directive, FSPermissionChecker pc)\n+      throws IOException {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new InvalidPoolNameError(directive));\n+      throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new PoolWritePermissionDeniedError(directive));\n+      throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n     \n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing + \" in this pool.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          existing.getDescriptor());\n+      return existing.getDescriptor();\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n       entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n           directive.getPath(), pool);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n+      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n \n     // Next, set the path as cached in the namesystem\n     try {\n       INode node \u003d dir.getINode(directive.getPath());\n       if (node !\u003d null \u0026\u0026 node.isFile()) {\n         INodeFile file \u003d node.asFile();\n         // TODO: adjustable cache replication factor\n         namesystem.setCacheReplicationInt(directive.getPath(),\n             file.getBlockReplication());\n       } else {\n         LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n       }\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n           ioe.getClass().getName() +\": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n-    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-        entry.getDescriptor());\n+    return entry.getDescriptor();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return existing.getDescriptor();\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath(), pool);\n    } catch (IOException ioe) {\n      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node !\u003d null \u0026\u0026 node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      } else {\n        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      throw ioe;\n    }\n    return entry.getDescriptor();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5236. Change PathBasedCacheDirective APIs to be a single value rather than batch. (Contributed by Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1525183 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "20/09/13 5:20 PM",
          "commitName": "a0d9a155a4a4258f628e927e096ecf6673f788ec",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "18/09/13 1:43 PM",
          "commitNameOld": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,67 @@\n-  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n-        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n+  public synchronized PathBasedCacheDescriptor addDirective(\n+      PathBasedCacheDirective directive, FSPermissionChecker pc)\n+      throws IOException {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new InvalidPoolNameError(directive));\n+      throw new InvalidPoolNameError(directive);\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new PoolWritePermissionDeniedError(directive));\n+      throw new PoolWritePermissionDeniedError(directive);\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n     \n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing + \" in this pool.\");\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          existing.getDescriptor());\n+      return existing.getDescriptor();\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n       entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n           directive.getPath(), pool);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n+      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n \n     // Next, set the path as cached in the namesystem\n     try {\n       INode node \u003d dir.getINode(directive.getPath());\n       if (node !\u003d null \u0026\u0026 node.isFile()) {\n         INodeFile file \u003d node.asFile();\n         // TODO: adjustable cache replication factor\n         namesystem.setCacheReplicationInt(directive.getPath(),\n             file.getBlockReplication());\n       } else {\n         LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n       }\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n           ioe.getClass().getName() +\": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n+      throw ioe;\n     }\n-    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n-        entry.getDescriptor());\n+    return entry.getDescriptor();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized PathBasedCacheDescriptor addDirective(\n      PathBasedCacheDirective directive, FSPermissionChecker pc)\n      throws IOException {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      throw new InvalidPoolNameError(directive);\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      throw new PoolWritePermissionDeniedError(directive);\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      throw ioe;\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return existing.getDescriptor();\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath(), pool);\n    } catch (IOException ioe) {\n      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node !\u003d null \u0026\u0026 node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      } else {\n        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      throw ioe;\n    }\n    return entry.getDescriptor();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5213. Separate PathBasedCacheEntry and PathBasedCacheDirectiveWithId. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524561 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/09/13 1:43 PM",
      "commitName": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5213. Separate PathBasedCacheEntry and PathBasedCacheDirectiveWithId. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524561 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/09/13 1:43 PM",
          "commitName": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "16/09/13 11:41 AM",
          "commitNameOld": "85c203602993a946fb5f41eadf1cf1484a0ce686",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,71 @@\n-  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n+  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n         PathBasedCacheDirective directive, FSPermissionChecker pc) {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n           new InvalidPoolNameError(directive));\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n     }\n+    \n     // Check if we already have this entry.\n-    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n+    PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n-      // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n-          \"existing directive \" + existing);\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n+          \"existing directive \" + existing + \" in this pool.\");\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n+          existing.getDescriptor());\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n-      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n+      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n+          directive.getPath(), pool);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n           new UnexpectedAddPathBasedCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n-    entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n \n     // Next, set the path as cached in the namesystem\n     try {\n       INode node \u003d dir.getINode(directive.getPath());\n-      if (node.isFile()) {\n+      if (node !\u003d null \u0026\u0026 node.isFile()) {\n         INodeFile file \u003d node.asFile();\n         // TODO: adjustable cache replication factor\n         namesystem.setCacheReplicationInt(directive.getPath(),\n             file.getBlockReplication());\n       } else {\n         LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n       }\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n           ioe.getClass().getName() +\": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n     }\n-\n-    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n+    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n+        entry.getDescriptor());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          existing.getDescriptor());\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath(), pool);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node !\u003d null \u0026\u0026 node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      } else {\n        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n    }\n    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n        entry.getDescriptor());\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "Fallible\u003cPathBasedCacheEntry\u003e",
            "newValue": "Fallible\u003cPathBasedCacheDescriptor\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5213. Separate PathBasedCacheEntry and PathBasedCacheDirectiveWithId. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524561 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/09/13 1:43 PM",
          "commitName": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "16/09/13 11:41 AM",
          "commitNameOld": "85c203602993a946fb5f41eadf1cf1484a0ce686",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,71 @@\n-  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n+  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n         PathBasedCacheDirective directive, FSPermissionChecker pc) {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n           new InvalidPoolNameError(directive));\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n     }\n+    \n     // Check if we already have this entry.\n-    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n+    PathBasedCacheEntry existing \u003d findEntry(directive);\n     if (existing !\u003d null) {\n-      // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n-          \"existing directive \" + existing);\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n+          \"existing directive \" + existing + \" in this pool.\");\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n+          existing.getDescriptor());\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n-      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n+      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n+          directive.getPath(), pool);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n           new UnexpectedAddPathBasedCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n-    entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n \n     // Next, set the path as cached in the namesystem\n     try {\n       INode node \u003d dir.getINode(directive.getPath());\n-      if (node.isFile()) {\n+      if (node !\u003d null \u0026\u0026 node.isFile()) {\n         INodeFile file \u003d node.asFile();\n         // TODO: adjustable cache replication factor\n         namesystem.setCacheReplicationInt(directive.getPath(),\n             file.getBlockReplication());\n       } else {\n         LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n       }\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n           ioe.getClass().getName() +\": \" + ioe.getMessage());\n-      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n+      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n     }\n-\n-    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n+    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n+        entry.getDescriptor());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathBasedCacheDescriptor\u003e addDirective(\n        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n    }\n    \n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d findEntry(directive);\n    if (existing !\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing + \" in this pool.\");\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          existing.getDescriptor());\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(),\n          directive.getPath(), pool);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node !\u003d null \u0026\u0026 node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      } else {\n        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheDescriptor\u003e(ioe);\n    }\n    return new Fallible\u003cPathBasedCacheDescriptor\u003e(\n        entry.getDescriptor());\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "85c203602993a946fb5f41eadf1cf1484a0ce686": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5210. Fix some failing unit tests on HDFS-4949 branch. (Contributed by Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1523754 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/09/13 11:41 AM",
      "commitName": "85c203602993a946fb5f41eadf1cf1484a0ce686",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "13/09/13 4:27 PM",
      "commitNameOld": "40eb94ade3161d93e7a762a839004748f6d0ae89",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.8,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,70 @@\n   private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n         PathBasedCacheDirective directive, FSPermissionChecker pc) {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new InvalidPoolNameError(directive));\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed: \"\n           + ioe.getClass().getName() + \": \" + ioe.getMessage());\n       return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n       return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n       entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new UnexpectedAddPathBasedCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n \n     // Success!\n     // First, add it to the various maps\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     String path \u003d directive.getPath();\n     List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n     if (entryList \u003d\u003d null) {\n       entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n       entriesByPath.put(path, entryList);\n     }\n     entryList.add(entry);\n \n     // Next, set the path as cached in the namesystem\n     try {\n       INode node \u003d dir.getINode(directive.getPath());\n       if (node.isFile()) {\n         INodeFile file \u003d node.asFile();\n         // TODO: adjustable cache replication factor\n         namesystem.setCacheReplicationInt(directive.getPath(),\n             file.getBlockReplication());\n+      } else {\n+        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n       }\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n           ioe.getClass().getName() +\": \" + ioe.getMessage());\n       return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n     }\n \n     return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      } else {\n        LOG.warn(\"Path \" + directive.getPath() + \" is not a file\");\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n    }\n\n    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "40eb94ade3161d93e7a762a839004748f6d0ae89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5053. NameNode should invoke DataNode APIs to coordinate caching. (Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1523145 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/09/13 4:27 PM",
      "commitName": "40eb94ade3161d93e7a762a839004748f6d0ae89",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "11/09/13 8:55 PM",
      "commitNameOld": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 1.81,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,68 @@\n   private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n         PathBasedCacheDirective directive, FSPermissionChecker pc) {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new InvalidPoolNameError(directive));\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n-      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n+      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n+          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n       return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n       return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathBasedCacheEntry entry;\n     try {\n       entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new UnexpectedAddPathBasedCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n+\n+    // Success!\n+    // First, add it to the various maps\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n+    String path \u003d directive.getPath();\n+    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n+    if (entryList \u003d\u003d null) {\n+      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n+      entriesByPath.put(path, entryList);\n+    }\n+    entryList.add(entry);\n+\n+    // Next, set the path as cached in the namesystem\n+    try {\n+      INode node \u003d dir.getINode(directive.getPath());\n+      if (node.isFile()) {\n+        INodeFile file \u003d node.asFile();\n+        // TODO: adjustable cache replication factor\n+        namesystem.setCacheReplicationInt(directive.getPath(),\n+            file.getBlockReplication());\n+      }\n+    } catch (IOException ioe) {\n+      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n+          ioe.getClass().getName() +\": \" + ioe.getMessage());\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n+    }\n+\n     return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed: \"\n          + ioe.getClass().getName() + \": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n\n    // Success!\n    // First, add it to the various maps\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    String path \u003d directive.getPath();\n    List\u003cPathBasedCacheEntry\u003e entryList \u003d entriesByPath.get(path);\n    if (entryList \u003d\u003d null) {\n      entryList \u003d new ArrayList\u003cPathBasedCacheEntry\u003e(1);\n      entriesByPath.put(path, entryList);\n    }\n    entryList.add(entry);\n\n    // Next, set the path as cached in the namesystem\n    try {\n      INode node \u003d dir.getINode(directive.getPath());\n      if (node.isFile()) {\n        INodeFile file \u003d node.asFile();\n        // TODO: adjustable cache replication factor\n        namesystem.setCacheReplicationInt(directive.getPath(),\n            file.getBlockReplication());\n      }\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive +\": failed to cache file: \" +\n          ioe.getClass().getName() +\": \" + ioe.getMessage());\n      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n    }\n\n    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "02e0e158a26f81ce8375426ba0ea56db09ee36be": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/13 8:55 PM",
      "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n-  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        PathCacheDirective directive, FSPermissionChecker pc) {\n+  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n+        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new InvalidPoolNameError(directive));\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n-    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n+    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n-      return new Fallible\u003cPathCacheEntry\u003e(existing);\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n-    PathCacheEntry entry;\n+    PathBasedCacheEntry entry;\n     try {\n-      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n+      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathCacheEntry\u003e(\n-          new UnexpectedAddPathCacheDirectiveException(directive));\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n-    return new Fallible\u003cPathCacheEntry\u003e(entry);\n+    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[directive-PathCacheDirective, pc-FSPermissionChecker]",
            "newValue": "[directive-PathBasedCacheDirective, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n-  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        PathCacheDirective directive, FSPermissionChecker pc) {\n+  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n+        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new InvalidPoolNameError(directive));\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n-    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n+    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n-      return new Fallible\u003cPathCacheEntry\u003e(existing);\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n-    PathCacheEntry entry;\n+    PathBasedCacheEntry entry;\n     try {\n-      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n+      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathCacheEntry\u003e(\n-          new UnexpectedAddPathCacheDirectiveException(directive));\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n-    return new Fallible\u003cPathCacheEntry\u003e(entry);\n+    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "Fallible\u003cPathCacheEntry\u003e",
            "newValue": "Fallible\u003cPathBasedCacheEntry\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n-  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        PathCacheDirective directive, FSPermissionChecker pc) {\n+  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n+        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n     CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new InvalidPoolNameError(directive));\n     }\n     if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed.\");\n-      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n-    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n+    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n-      return new Fallible\u003cPathCacheEntry\u003e(existing);\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n-    PathCacheEntry entry;\n+    PathBasedCacheEntry entry;\n     try {\n-      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n+      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n-      return new Fallible\u003cPathCacheEntry\u003e(\n-          new UnexpectedAddPathCacheDirectiveException(directive));\n+      return new Fallible\u003cPathBasedCacheEntry\u003e(\n+          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n-    return new Fallible\u003cPathCacheEntry\u003e(entry);\n+    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathBasedCacheEntry\u003e addDirective(\n        PathBasedCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathBasedCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathBasedCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathBasedCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathBasedCacheEntry entry;\n    try {\n      entry \u003d new PathBasedCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathBasedCacheEntry\u003e(\n          new UnexpectedAddPathBasedCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathBasedCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "f41f8b8842c3f26d19f7fa928070c7c07f760e4c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/13 11:52 AM",
      "commitName": "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/09/13 11:52 AM",
          "commitName": "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "04/09/13 11:23 AM",
          "commitNameOld": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n   private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        FSPermissionChecker pc, PathCacheDirective directive) {\n-    CachePool pool \u003d cachePoolsById.get(directive.getPoolId());\n+        PathCacheDirective directive, FSPermissionChecker pc) {\n+    CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n-          new InvalidPoolError(directive));\n+          new InvalidPoolNameError(directive));\n     }\n-    if (!pc.checkPermission(pool, FsAction.WRITE)) {\n+    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed.\");\n       return new Fallible\u003cPathCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n       return new Fallible\u003cPathCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathCacheEntry entry;\n     try {\n       entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new UnexpectedAddPathCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     return new Fallible\u003cPathCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n        PathCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathCacheEntry entry;\n    try {\n      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new UnexpectedAddPathCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, directive-PathCacheDirective]",
            "newValue": "[directive-PathCacheDirective, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/09/13 11:52 AM",
          "commitName": "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "04/09/13 11:23 AM",
          "commitNameOld": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n   private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        FSPermissionChecker pc, PathCacheDirective directive) {\n-    CachePool pool \u003d cachePoolsById.get(directive.getPoolId());\n+        PathCacheDirective directive, FSPermissionChecker pc) {\n+    CachePool pool \u003d cachePools.get(directive.getPool());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n-          new InvalidPoolError(directive));\n+          new InvalidPoolNameError(directive));\n     }\n-    if (!pc.checkPermission(pool, FsAction.WRITE)) {\n+    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed.\");\n       return new Fallible\u003cPathCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n       return new Fallible\u003cPathCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathCacheEntry entry;\n     try {\n       entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new UnexpectedAddPathCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     return new Fallible\u003cPathCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n        PathCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if ((pc !\u003d null) \u0026\u0026 (!pc.checkPermission(pool, FsAction.WRITE))) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathCacheEntry entry;\n    try {\n      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new UnexpectedAddPathCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "d56d0b46e1b82ae068083ddb99872d314684dc82": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "commit correct version of HDFS-5121\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/13 11:23 AM",
      "commitName": "d56d0b46e1b82ae068083ddb99872d314684dc82",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "commit correct version of HDFS-5121\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/09/13 11:23 AM",
          "commitName": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "03/09/13 1:38 PM",
          "commitNameOld": "97b7267977ef42201e5844df49bc37ec3d10ce16",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.91,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,41 @@\n   private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        PathCacheDirective directive, FSPermissionChecker pc) {\n-    CachePool pool \u003d cachePools.get(directive.getPool());\n+        FSPermissionChecker pc, PathCacheDirective directive) {\n+    CachePool pool \u003d cachePoolsById.get(directive.getPoolId());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n-          new InvalidPoolNameError(directive));\n+          new InvalidPoolError(directive));\n     }\n-    if (!pc.checkWritePermission(pool.getOwnerName(),\n-        pool.getGroupName(), pool.getMode())) {\n+    if (!pc.checkPermission(pool, FsAction.WRITE)) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed.\");\n       return new Fallible\u003cPathCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n       return new Fallible\u003cPathCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathCacheEntry entry;\n     try {\n       entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new UnexpectedAddPathCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     return new Fallible\u003cPathCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n        FSPermissionChecker pc, PathCacheDirective directive) {\n    CachePool pool \u003d cachePoolsById.get(directive.getPoolId());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new InvalidPoolError(directive));\n    }\n    if (!pc.checkPermission(pool, FsAction.WRITE)) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathCacheEntry entry;\n    try {\n      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new UnexpectedAddPathCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[directive-PathCacheDirective, pc-FSPermissionChecker]",
            "newValue": "[pc-FSPermissionChecker, directive-PathCacheDirective]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "commit correct version of HDFS-5121\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/09/13 11:23 AM",
          "commitName": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "03/09/13 1:38 PM",
          "commitNameOld": "97b7267977ef42201e5844df49bc37ec3d10ce16",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.91,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,41 @@\n   private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        PathCacheDirective directive, FSPermissionChecker pc) {\n-    CachePool pool \u003d cachePools.get(directive.getPool());\n+        FSPermissionChecker pc, PathCacheDirective directive) {\n+    CachePool pool \u003d cachePoolsById.get(directive.getPoolId());\n     if (pool \u003d\u003d null) {\n       LOG.info(\"addDirective \" + directive + \": pool not found.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n-          new InvalidPoolNameError(directive));\n+          new InvalidPoolError(directive));\n     }\n-    if (!pc.checkWritePermission(pool.getOwnerName(),\n-        pool.getGroupName(), pool.getMode())) {\n+    if (!pc.checkPermission(pool, FsAction.WRITE)) {\n       LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new PoolWritePermissionDeniedError(directive));\n     }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n       LOG.info(\"addDirective \" + directive + \": validation failed.\");\n       return new Fallible\u003cPathCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n       LOG.info(\"addDirective \" + directive + \": there is an \" +\n           \"existing directive \" + existing);\n       return new Fallible\u003cPathCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathCacheEntry entry;\n     try {\n       entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new UnexpectedAddPathCacheDirectiveException(directive));\n     }\n     LOG.info(\"addDirective \" + directive + \": added cache directive \"\n         + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     return new Fallible\u003cPathCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n        FSPermissionChecker pc, PathCacheDirective directive) {\n    CachePool pool \u003d cachePoolsById.get(directive.getPoolId());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new InvalidPoolError(directive));\n    }\n    if (!pc.checkPermission(pool, FsAction.WRITE)) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathCacheEntry entry;\n    try {\n      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new UnexpectedAddPathCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "97b7267977ef42201e5844df49bc37ec3d10ce16": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5121.  Add RPCs for creating and manipulating cache pools.  (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1519841 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/09/13 1:38 PM",
      "commitName": "97b7267977ef42201e5844df49bc37ec3d10ce16",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5121.  Add RPCs for creating and manipulating cache pools.  (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1519841 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/09/13 1:38 PM",
          "commitName": "97b7267977ef42201e5844df49bc37ec3d10ce16",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "22/08/13 4:37 PM",
          "commitNameOld": "920b4cc06f1bc15809902bdd1968cc434a694a08",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 11.88,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,42 @@\n   private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        PathCacheDirective directive) {\n+        PathCacheDirective directive, FSPermissionChecker pc) {\n+    CachePool pool \u003d cachePools.get(directive.getPool());\n+    if (pool \u003d\u003d null) {\n+      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n+      return new Fallible\u003cPathCacheEntry\u003e(\n+          new InvalidPoolNameError(directive));\n+    }\n+    if (!pc.checkWritePermission(pool.getOwnerName(),\n+        pool.getGroupName(), pool.getMode())) {\n+      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n+      return new Fallible\u003cPathCacheEntry\u003e(\n+          new PoolWritePermissionDeniedError(directive));\n+    }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n+      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n       return new Fallible\u003cPathCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n+      LOG.info(\"addDirective \" + directive + \": there is an \" +\n+          \"existing directive \" + existing);\n       return new Fallible\u003cPathCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathCacheEntry entry;\n     try {\n       entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new UnexpectedAddPathCacheDirectiveException(directive));\n     }\n+    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n+        + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     return new Fallible\u003cPathCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n        PathCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if (!pc.checkWritePermission(pool.getOwnerName(),\n        pool.getGroupName(), pool.getMode())) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathCacheEntry entry;\n    try {\n      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new UnexpectedAddPathCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[directive-PathCacheDirective]",
            "newValue": "[directive-PathCacheDirective, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5121.  Add RPCs for creating and manipulating cache pools.  (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1519841 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/09/13 1:38 PM",
          "commitName": "97b7267977ef42201e5844df49bc37ec3d10ce16",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "22/08/13 4:37 PM",
          "commitNameOld": "920b4cc06f1bc15809902bdd1968cc434a694a08",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 11.88,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,42 @@\n   private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n-        PathCacheDirective directive) {\n+        PathCacheDirective directive, FSPermissionChecker pc) {\n+    CachePool pool \u003d cachePools.get(directive.getPool());\n+    if (pool \u003d\u003d null) {\n+      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n+      return new Fallible\u003cPathCacheEntry\u003e(\n+          new InvalidPoolNameError(directive));\n+    }\n+    if (!pc.checkWritePermission(pool.getOwnerName(),\n+        pool.getGroupName(), pool.getMode())) {\n+      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n+      return new Fallible\u003cPathCacheEntry\u003e(\n+          new PoolWritePermissionDeniedError(directive));\n+    }\n     try {\n       directive.validate();\n     } catch (IOException ioe) {\n+      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n       return new Fallible\u003cPathCacheEntry\u003e(ioe);\n     }\n     // Check if we already have this entry.\n     PathCacheEntry existing \u003d entriesByDirective.get(directive);\n     if (existing !\u003d null) {\n       // Entry already exists: return existing entry.\n+      LOG.info(\"addDirective \" + directive + \": there is an \" +\n+          \"existing directive \" + existing);\n       return new Fallible\u003cPathCacheEntry\u003e(existing);\n     }\n     // Add a new entry with the next available ID.\n     PathCacheEntry entry;\n     try {\n       entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n     } catch (IOException ioe) {\n       return new Fallible\u003cPathCacheEntry\u003e(\n           new UnexpectedAddPathCacheDirectiveException(directive));\n     }\n+    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n+        + directive);\n     entriesByDirective.put(directive, entry);\n     entriesById.put(entry.getEntryId(), entry);\n     return new Fallible\u003cPathCacheEntry\u003e(entry);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n        PathCacheDirective directive, FSPermissionChecker pc) {\n    CachePool pool \u003d cachePools.get(directive.getPool());\n    if (pool \u003d\u003d null) {\n      LOG.info(\"addDirective \" + directive + \": pool not found.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new InvalidPoolNameError(directive));\n    }\n    if (!pc.checkWritePermission(pool.getOwnerName(),\n        pool.getGroupName(), pool.getMode())) {\n      LOG.info(\"addDirective \" + directive + \": write permission denied.\");\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new PoolWritePermissionDeniedError(directive));\n    }\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      LOG.info(\"addDirective \" + directive + \": validation failed.\");\n      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      LOG.info(\"addDirective \" + directive + \": there is an \" +\n          \"existing directive \" + existing);\n      return new Fallible\u003cPathCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathCacheEntry entry;\n    try {\n      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new UnexpectedAddPathCacheDirectiveException(directive));\n    }\n    LOG.info(\"addDirective \" + directive + \": added cache directive \"\n        + directive);\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathCacheEntry\u003e(entry);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "920b4cc06f1bc15809902bdd1968cc434a694a08": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5052. Add cacheRequest/uncacheRequest support to NameNode.  (Contributed by Colin Patrick McCabe.)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1516669 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/08/13 4:37 PM",
      "commitName": "920b4cc06f1bc15809902bdd1968cc434a694a08",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,25 @@\n+  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n+        PathCacheDirective directive) {\n+    try {\n+      directive.validate();\n+    } catch (IOException ioe) {\n+      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n+    }\n+    // Check if we already have this entry.\n+    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n+    if (existing !\u003d null) {\n+      // Entry already exists: return existing entry.\n+      return new Fallible\u003cPathCacheEntry\u003e(existing);\n+    }\n+    // Add a new entry with the next available ID.\n+    PathCacheEntry entry;\n+    try {\n+      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n+    } catch (IOException ioe) {\n+      return new Fallible\u003cPathCacheEntry\u003e(\n+          new UnexpectedAddPathCacheDirectiveException(directive));\n+    }\n+    entriesByDirective.put(directive, entry);\n+    entriesById.put(entry.getEntryId(), entry);\n+    return new Fallible\u003cPathCacheEntry\u003e(entry);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized Fallible\u003cPathCacheEntry\u003e addDirective(\n        PathCacheDirective directive) {\n    try {\n      directive.validate();\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(ioe);\n    }\n    // Check if we already have this entry.\n    PathCacheEntry existing \u003d entriesByDirective.get(directive);\n    if (existing !\u003d null) {\n      // Entry already exists: return existing entry.\n      return new Fallible\u003cPathCacheEntry\u003e(existing);\n    }\n    // Add a new entry with the next available ID.\n    PathCacheEntry entry;\n    try {\n      entry \u003d new PathCacheEntry(getNextEntryId(), directive);\n    } catch (IOException ioe) {\n      return new Fallible\u003cPathCacheEntry\u003e(\n          new UnexpectedAddPathCacheDirectiveException(directive));\n    }\n    entriesByDirective.put(directive, entry);\n    entriesById.put(entry.getEntryId(), entry);\n    return new Fallible\u003cPathCacheEntry\u003e(entry);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java"
    }
  }
}