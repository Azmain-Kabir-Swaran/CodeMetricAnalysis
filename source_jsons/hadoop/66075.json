{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NetworkBinding.java",
  "functionName": "bindSSLChannelMode",
  "functionId": "bindSSLChannelMode___conf-Configuration__awsConf-ClientConfiguration",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/NetworkBinding.java",
  "functionStartLine": 71,
  "functionEndLine": 111,
  "numCommitsSeen": 6,
  "timeTaken": 1680,
  "changeHistory": [
    "42711081e3cba5835493b5cbedc23d16dfea7667",
    "f206b736f0b370d212a399937c7a84e432f12eb5",
    "55ce454ce4f1b1eaa9f041f3b0fb69a9fcc56894"
  ],
  "changeHistoryShort": {
    "42711081e3cba5835493b5cbedc23d16dfea7667": "Ybodychange",
    "f206b736f0b370d212a399937c7a84e432f12eb5": "Ybodychange",
    "55ce454ce4f1b1eaa9f041f3b0fb69a9fcc56894": "Yintroduced"
  },
  "changeHistoryDetails": {
    "42711081e3cba5835493b5cbedc23d16dfea7667": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16986. S3A to not need wildfly on the classpath. (#1948)\n\nHADOOP-16986. S3A to not need wildfly JAR on its classpath.\r\n\r\nContributed by Steve Loughran\r\n\r\nThis is a successor to HADOOP-16346, which enabled the S3A connector\r\nto load the native openssl SSL libraries for better HTTPS performance.\r\n\r\nThat patch required wildfly.jar to be on the classpath. This\r\nupdate:\r\n\r\n* Makes wildfly.jar optional except in the special case that \r\n\"fs.s3a.ssl.channel.mode\" is set to \"openssl\"\r\n\r\n* Retains the declaration of wildfly.jar as a compile-time\r\ndependency in the hadoop-aws POM. This means that unless\r\nexplicitly excluded, applications importing that published\r\nmaven artifact will, transitively, add the specified\r\nwildfly JAR into their classpath for compilation/testing/\r\ndistribution.\r\n\r\nThis is done for packaging and to offer that optional\r\nspeedup. It is not mandatory: applications importing\r\nthe hadoop-aws POM can exclude it if they choose.\r\n\r\n",
      "commitDate": "20/04/20 6:32 AM",
      "commitName": "42711081e3cba5835493b5cbedc23d16dfea7667",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/04/20 6:15 AM",
      "commitNameOld": "56350664a76b1ea8e1a942a251880ae3fab12f0c",
      "commitAuthorOld": "Mukund Thakur",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n   public static void bindSSLChannelMode(Configuration conf,\n       ClientConfiguration awsConf) throws IOException {\n-    try {\n-      // Validate that SSL_CHANNEL_MODE is set to a valid value.\n-      String channelModeString \u003d conf.get(\n-              SSL_CHANNEL_MODE, DEFAULT_SSL_CHANNEL_MODE.name());\n-      DelegatingSSLSocketFactory.SSLChannelMode channelMode \u003d null;\n-      for (DelegatingSSLSocketFactory.SSLChannelMode mode :\n-              DelegatingSSLSocketFactory.SSLChannelMode.values()) {\n-        if (mode.name().equalsIgnoreCase(channelModeString)) {\n-          channelMode \u003d mode;\n-        }\n-      }\n-      if (channelMode \u003d\u003d null) {\n-        throw new IllegalArgumentException(channelModeString +\n-                \" is not a valid value for \" + SSL_CHANNEL_MODE);\n-      }\n \n+    // Validate that SSL_CHANNEL_MODE is set to a valid value.\n+    String channelModeString \u003d conf.getTrimmed(\n+            SSL_CHANNEL_MODE, DEFAULT_SSL_CHANNEL_MODE.name());\n+    DelegatingSSLSocketFactory.SSLChannelMode channelMode \u003d null;\n+    for (DelegatingSSLSocketFactory.SSLChannelMode mode :\n+            DelegatingSSLSocketFactory.SSLChannelMode.values()) {\n+      if (mode.name().equalsIgnoreCase(channelModeString)) {\n+        channelMode \u003d mode;\n+      }\n+    }\n+    if (channelMode \u003d\u003d null) {\n+      throw new IllegalArgumentException(channelModeString +\n+              \" is not a valid value for \" + SSL_CHANNEL_MODE);\n+    }\n+\n+    DelegatingSSLSocketFactory.initializeDefaultFactory(channelMode);\n+    try {\n       // Look for AWS_SOCKET_FACTORY_CLASSNAME on the classpath and instantiate\n       // an instance using the DelegatingSSLSocketFactory as the\n       // SSLSocketFactory.\n       Class\u003c?\u003e sslConnectionSocketFactory \u003d Class.forName(\n               AWS_SOCKET_FACTORY_CLASSNAME);\n       Constructor\u003c?\u003e factoryConstructor \u003d\n               sslConnectionSocketFactory.getDeclaredConstructor(\n                       SSLSocketFactory.class, HostnameVerifier.class);\n-      DelegatingSSLSocketFactory.initializeDefaultFactory(channelMode);\n       awsConf.getApacheHttpClientConfig().setSslSocketFactory(\n               (com.amazonaws.thirdparty.apache.http.conn.ssl.\n                       SSLConnectionSocketFactory) factoryConstructor\n                       .newInstance(DelegatingSSLSocketFactory\n                                       .getDefaultFactory(),\n                               (HostnameVerifier) null));\n     } catch (ClassNotFoundException | NoSuchMethodException |\n             IllegalAccessException | InstantiationException |\n-            InvocationTargetException e) {\n+            InvocationTargetException | LinkageError  e) {\n       LOG.debug(\"Unable to create class {}, value of {} will be ignored\",\n               AWS_SOCKET_FACTORY_CLASSNAME, SSL_CHANNEL_MODE, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void bindSSLChannelMode(Configuration conf,\n      ClientConfiguration awsConf) throws IOException {\n\n    // Validate that SSL_CHANNEL_MODE is set to a valid value.\n    String channelModeString \u003d conf.getTrimmed(\n            SSL_CHANNEL_MODE, DEFAULT_SSL_CHANNEL_MODE.name());\n    DelegatingSSLSocketFactory.SSLChannelMode channelMode \u003d null;\n    for (DelegatingSSLSocketFactory.SSLChannelMode mode :\n            DelegatingSSLSocketFactory.SSLChannelMode.values()) {\n      if (mode.name().equalsIgnoreCase(channelModeString)) {\n        channelMode \u003d mode;\n      }\n    }\n    if (channelMode \u003d\u003d null) {\n      throw new IllegalArgumentException(channelModeString +\n              \" is not a valid value for \" + SSL_CHANNEL_MODE);\n    }\n\n    DelegatingSSLSocketFactory.initializeDefaultFactory(channelMode);\n    try {\n      // Look for AWS_SOCKET_FACTORY_CLASSNAME on the classpath and instantiate\n      // an instance using the DelegatingSSLSocketFactory as the\n      // SSLSocketFactory.\n      Class\u003c?\u003e sslConnectionSocketFactory \u003d Class.forName(\n              AWS_SOCKET_FACTORY_CLASSNAME);\n      Constructor\u003c?\u003e factoryConstructor \u003d\n              sslConnectionSocketFactory.getDeclaredConstructor(\n                      SSLSocketFactory.class, HostnameVerifier.class);\n      awsConf.getApacheHttpClientConfig().setSslSocketFactory(\n              (com.amazonaws.thirdparty.apache.http.conn.ssl.\n                      SSLConnectionSocketFactory) factoryConstructor\n                      .newInstance(DelegatingSSLSocketFactory\n                                      .getDefaultFactory(),\n                              (HostnameVerifier) null));\n    } catch (ClassNotFoundException | NoSuchMethodException |\n            IllegalAccessException | InstantiationException |\n            InvocationTargetException | LinkageError  e) {\n      LOG.debug(\"Unable to create class {}, value of {} will be ignored\",\n              AWS_SOCKET_FACTORY_CLASSNAME, SSL_CHANNEL_MODE, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/NetworkBinding.java",
      "extendedDetails": {}
    },
    "f206b736f0b370d212a399937c7a84e432f12eb5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16346. Stabilize S3A OpenSSL support.\n\nIntroduces `openssl` as an option for `fs.s3a.ssl.channel.mode`.\nThe new option is documented and marked as experimental.\n\nFor details on how to use this, consult the peformance document\nin the s3a documentation.\n\nThis patch is the successor to HADOOP-16050 \"S3A SSL connections\nshould use OpenSSL\" -which was reverted because of\nincompatibilities between the wildfly OpenSSL client and the AWS\nHTTPS servers (HADOOP-16347). With the Wildfly release moved up\nto 1.0.7.Final (HADOOP-16405) everything should now work.\n\nRelated issues:\n\n* HADOOP-15669. ABFS: Improve HTTPS Performance\n* HADOOP-16050: S3A SSL connections should use OpenSSL\n* HADOOP-16371: Option to disable GCM for SSL connections when running on Java 8\n* HADOOP-16405: Upgrade Wildfly Openssl version to 1.0.7.Final\n\nContributed by Sahil Takiar\n\nChange-Id: I80a4bc5051519f186b7383b2c1cea140be42444e\n",
      "commitDate": "21/01/20 8:37 AM",
      "commitName": "f206b736f0b370d212a399937c7a84e432f12eb5",
      "commitAuthor": "Sahil Takiar",
      "commitDateOld": "04/11/19 10:24 PM",
      "commitNameOld": "d17ba854823cc1231a55767cfd381ca1474c1e49",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 77.43,
      "commitsBetweenForRepo": 278,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,40 @@\n   public static void bindSSLChannelMode(Configuration conf,\n       ClientConfiguration awsConf) throws IOException {\n     try {\n       // Validate that SSL_CHANNEL_MODE is set to a valid value.\n       String channelModeString \u003d conf.get(\n               SSL_CHANNEL_MODE, DEFAULT_SSL_CHANNEL_MODE.name());\n       DelegatingSSLSocketFactory.SSLChannelMode channelMode \u003d null;\n       for (DelegatingSSLSocketFactory.SSLChannelMode mode :\n               DelegatingSSLSocketFactory.SSLChannelMode.values()) {\n         if (mode.name().equalsIgnoreCase(channelModeString)) {\n           channelMode \u003d mode;\n         }\n       }\n       if (channelMode \u003d\u003d null) {\n         throw new IllegalArgumentException(channelModeString +\n                 \" is not a valid value for \" + SSL_CHANNEL_MODE);\n       }\n-      if (channelMode \u003d\u003d DelegatingSSLSocketFactory.SSLChannelMode.OpenSSL ||\n-          channelMode \u003d\u003d DelegatingSSLSocketFactory.SSLChannelMode.Default) {\n-        throw new UnsupportedOperationException(\"S3A does not support \" +\n-                \"setting \" + SSL_CHANNEL_MODE + \" \" +\n-                DelegatingSSLSocketFactory.SSLChannelMode.OpenSSL + \" or \" +\n-                DelegatingSSLSocketFactory.SSLChannelMode.Default);\n-      }\n \n       // Look for AWS_SOCKET_FACTORY_CLASSNAME on the classpath and instantiate\n       // an instance using the DelegatingSSLSocketFactory as the\n       // SSLSocketFactory.\n       Class\u003c?\u003e sslConnectionSocketFactory \u003d Class.forName(\n               AWS_SOCKET_FACTORY_CLASSNAME);\n       Constructor\u003c?\u003e factoryConstructor \u003d\n               sslConnectionSocketFactory.getDeclaredConstructor(\n                       SSLSocketFactory.class, HostnameVerifier.class);\n       DelegatingSSLSocketFactory.initializeDefaultFactory(channelMode);\n       awsConf.getApacheHttpClientConfig().setSslSocketFactory(\n               (com.amazonaws.thirdparty.apache.http.conn.ssl.\n                       SSLConnectionSocketFactory) factoryConstructor\n                       .newInstance(DelegatingSSLSocketFactory\n                                       .getDefaultFactory(),\n                               (HostnameVerifier) null));\n     } catch (ClassNotFoundException | NoSuchMethodException |\n             IllegalAccessException | InstantiationException |\n             InvocationTargetException e) {\n       LOG.debug(\"Unable to create class {}, value of {} will be ignored\",\n               AWS_SOCKET_FACTORY_CLASSNAME, SSL_CHANNEL_MODE, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void bindSSLChannelMode(Configuration conf,\n      ClientConfiguration awsConf) throws IOException {\n    try {\n      // Validate that SSL_CHANNEL_MODE is set to a valid value.\n      String channelModeString \u003d conf.get(\n              SSL_CHANNEL_MODE, DEFAULT_SSL_CHANNEL_MODE.name());\n      DelegatingSSLSocketFactory.SSLChannelMode channelMode \u003d null;\n      for (DelegatingSSLSocketFactory.SSLChannelMode mode :\n              DelegatingSSLSocketFactory.SSLChannelMode.values()) {\n        if (mode.name().equalsIgnoreCase(channelModeString)) {\n          channelMode \u003d mode;\n        }\n      }\n      if (channelMode \u003d\u003d null) {\n        throw new IllegalArgumentException(channelModeString +\n                \" is not a valid value for \" + SSL_CHANNEL_MODE);\n      }\n\n      // Look for AWS_SOCKET_FACTORY_CLASSNAME on the classpath and instantiate\n      // an instance using the DelegatingSSLSocketFactory as the\n      // SSLSocketFactory.\n      Class\u003c?\u003e sslConnectionSocketFactory \u003d Class.forName(\n              AWS_SOCKET_FACTORY_CLASSNAME);\n      Constructor\u003c?\u003e factoryConstructor \u003d\n              sslConnectionSocketFactory.getDeclaredConstructor(\n                      SSLSocketFactory.class, HostnameVerifier.class);\n      DelegatingSSLSocketFactory.initializeDefaultFactory(channelMode);\n      awsConf.getApacheHttpClientConfig().setSslSocketFactory(\n              (com.amazonaws.thirdparty.apache.http.conn.ssl.\n                      SSLConnectionSocketFactory) factoryConstructor\n                      .newInstance(DelegatingSSLSocketFactory\n                                      .getDefaultFactory(),\n                              (HostnameVerifier) null));\n    } catch (ClassNotFoundException | NoSuchMethodException |\n            IllegalAccessException | InstantiationException |\n            InvocationTargetException e) {\n      LOG.debug(\"Unable to create class {}, value of {} will be ignored\",\n              AWS_SOCKET_FACTORY_CLASSNAME, SSL_CHANNEL_MODE, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/NetworkBinding.java",
      "extendedDetails": {}
    },
    "55ce454ce4f1b1eaa9f041f3b0fb69a9fcc56894": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-16371: Option to disable GCM for SSL connections when running on Java 8.\n\nContributed by Sahil Takiar.\n\nThis moves the SSLSocketFactoryEx class from hadoop-azure into hadoop-common\nas the DelegatingSSLSocketFactory and binds the S3A connector to it so that\nit can avoid using those HTTPS algorithms which are underperformant on Java 8.\n\nChange-Id: Ie9e6ac24deac1aa05e136e08899620efa7d22abd\n",
      "commitDate": "17/09/19 3:32 AM",
      "commitName": "55ce454ce4f1b1eaa9f041f3b0fb69a9fcc56894",
      "commitAuthor": "Sahil Takiar",
      "diff": "@@ -0,0 +1,47 @@\n+  public static void bindSSLChannelMode(Configuration conf,\n+      ClientConfiguration awsConf) throws IOException {\n+    try {\n+      // Validate that SSL_CHANNEL_MODE is set to a valid value.\n+      String channelModeString \u003d conf.get(\n+              SSL_CHANNEL_MODE, DEFAULT_SSL_CHANNEL_MODE.name());\n+      DelegatingSSLSocketFactory.SSLChannelMode channelMode \u003d null;\n+      for (DelegatingSSLSocketFactory.SSLChannelMode mode :\n+              DelegatingSSLSocketFactory.SSLChannelMode.values()) {\n+        if (mode.name().equalsIgnoreCase(channelModeString)) {\n+          channelMode \u003d mode;\n+        }\n+      }\n+      if (channelMode \u003d\u003d null) {\n+        throw new IllegalArgumentException(channelModeString +\n+                \" is not a valid value for \" + SSL_CHANNEL_MODE);\n+      }\n+      if (channelMode \u003d\u003d DelegatingSSLSocketFactory.SSLChannelMode.OpenSSL ||\n+          channelMode \u003d\u003d DelegatingSSLSocketFactory.SSLChannelMode.Default) {\n+        throw new UnsupportedOperationException(\"S3A does not support \" +\n+                \"setting \" + SSL_CHANNEL_MODE + \" \" +\n+                DelegatingSSLSocketFactory.SSLChannelMode.OpenSSL + \" or \" +\n+                DelegatingSSLSocketFactory.SSLChannelMode.Default);\n+      }\n+\n+      // Look for AWS_SOCKET_FACTORY_CLASSNAME on the classpath and instantiate\n+      // an instance using the DelegatingSSLSocketFactory as the\n+      // SSLSocketFactory.\n+      Class\u003c?\u003e sslConnectionSocketFactory \u003d Class.forName(\n+              AWS_SOCKET_FACTORY_CLASSNAME);\n+      Constructor\u003c?\u003e factoryConstructor \u003d\n+              sslConnectionSocketFactory.getDeclaredConstructor(\n+                      SSLSocketFactory.class, HostnameVerifier.class);\n+      DelegatingSSLSocketFactory.initializeDefaultFactory(channelMode);\n+      awsConf.getApacheHttpClientConfig().setSslSocketFactory(\n+              (com.amazonaws.thirdparty.apache.http.conn.ssl.\n+                      SSLConnectionSocketFactory) factoryConstructor\n+                      .newInstance(DelegatingSSLSocketFactory\n+                                      .getDefaultFactory(),\n+                              (HostnameVerifier) null));\n+    } catch (ClassNotFoundException | NoSuchMethodException |\n+            IllegalAccessException | InstantiationException |\n+            InvocationTargetException e) {\n+      LOG.debug(\"Unable to create class {}, value of {} will be ignored\",\n+              AWS_SOCKET_FACTORY_CLASSNAME, SSL_CHANNEL_MODE, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static void bindSSLChannelMode(Configuration conf,\n      ClientConfiguration awsConf) throws IOException {\n    try {\n      // Validate that SSL_CHANNEL_MODE is set to a valid value.\n      String channelModeString \u003d conf.get(\n              SSL_CHANNEL_MODE, DEFAULT_SSL_CHANNEL_MODE.name());\n      DelegatingSSLSocketFactory.SSLChannelMode channelMode \u003d null;\n      for (DelegatingSSLSocketFactory.SSLChannelMode mode :\n              DelegatingSSLSocketFactory.SSLChannelMode.values()) {\n        if (mode.name().equalsIgnoreCase(channelModeString)) {\n          channelMode \u003d mode;\n        }\n      }\n      if (channelMode \u003d\u003d null) {\n        throw new IllegalArgumentException(channelModeString +\n                \" is not a valid value for \" + SSL_CHANNEL_MODE);\n      }\n      if (channelMode \u003d\u003d DelegatingSSLSocketFactory.SSLChannelMode.OpenSSL ||\n          channelMode \u003d\u003d DelegatingSSLSocketFactory.SSLChannelMode.Default) {\n        throw new UnsupportedOperationException(\"S3A does not support \" +\n                \"setting \" + SSL_CHANNEL_MODE + \" \" +\n                DelegatingSSLSocketFactory.SSLChannelMode.OpenSSL + \" or \" +\n                DelegatingSSLSocketFactory.SSLChannelMode.Default);\n      }\n\n      // Look for AWS_SOCKET_FACTORY_CLASSNAME on the classpath and instantiate\n      // an instance using the DelegatingSSLSocketFactory as the\n      // SSLSocketFactory.\n      Class\u003c?\u003e sslConnectionSocketFactory \u003d Class.forName(\n              AWS_SOCKET_FACTORY_CLASSNAME);\n      Constructor\u003c?\u003e factoryConstructor \u003d\n              sslConnectionSocketFactory.getDeclaredConstructor(\n                      SSLSocketFactory.class, HostnameVerifier.class);\n      DelegatingSSLSocketFactory.initializeDefaultFactory(channelMode);\n      awsConf.getApacheHttpClientConfig().setSslSocketFactory(\n              (com.amazonaws.thirdparty.apache.http.conn.ssl.\n                      SSLConnectionSocketFactory) factoryConstructor\n                      .newInstance(DelegatingSSLSocketFactory\n                                      .getDefaultFactory(),\n                              (HostnameVerifier) null));\n    } catch (ClassNotFoundException | NoSuchMethodException |\n            IllegalAccessException | InstantiationException |\n            InvocationTargetException e) {\n      LOG.debug(\"Unable to create class {}, value of {} will be ignored\",\n              AWS_SOCKET_FACTORY_CLASSNAME, SSL_CHANNEL_MODE, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/NetworkBinding.java"
    }
  }
}