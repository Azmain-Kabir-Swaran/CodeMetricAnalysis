{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKSignerSecretProvider.java",
  "functionName": "init",
  "functionId": "init___config-Properties__servletContext-ServletContext__tokenValidity-long",
  "sourceFilePath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/util/ZKSignerSecretProvider.java",
  "functionStartLine": 167,
  "functionEndLine": 215,
  "numCommitsSeen": 11,
  "timeTaken": 916,
  "changeHistory": [
    "db890eef3208cc557476fa510f7a253ba22bc68a",
    "932ae036acb96634c5dd435d57ba02ce4d5e8918"
  ],
  "changeHistoryShort": {
    "db890eef3208cc557476fa510f7a253ba22bc68a": "Ybodychange",
    "932ae036acb96634c5dd435d57ba02ce4d5e8918": "Yintroduced"
  },
  "changeHistoryDetails": {
    "db890eef3208cc557476fa510f7a253ba22bc68a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11017. KMS delegation token secret manager should be able to use zookeeper as store. (asuresh via tucu)\n",
      "commitDate": "20/09/14 8:21 AM",
      "commitName": "db890eef3208cc557476fa510f7a253ba22bc68a",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "15/09/14 7:39 PM",
      "commitNameOld": "7e08c0f23f58aa143f0997f2472e8051175142e9",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 4.53,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,49 @@\n   public void init(Properties config, ServletContext servletContext,\n           long tokenValidity) throws Exception {\n     Object curatorClientObj \u003d servletContext.getAttribute(\n             ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE);\n     if (curatorClientObj !\u003d null\n             \u0026\u0026 curatorClientObj instanceof CuratorFramework) {\n       client \u003d (CuratorFramework) curatorClientObj;\n     } else {\n       client \u003d createCuratorClient(config);\n+      servletContext.setAttribute(\n+          ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE, client);\n     }\n     this.tokenValidity \u003d tokenValidity;\n     shouldDisconnect \u003d Boolean.parseBoolean(\n             config.getProperty(DISCONNECT_FROM_ZOOKEEPER_ON_SHUTDOWN, \"true\"));\n     path \u003d config.getProperty(ZOOKEEPER_PATH);\n     if (path \u003d\u003d null) {\n       throw new IllegalArgumentException(ZOOKEEPER_PATH\n               + \" must be specified\");\n     }\n     try {\n       nextRolloverDate \u003d System.currentTimeMillis() + tokenValidity;\n       // everyone tries to do this, only one will succeed and only when the\n       // znode doesn\u0027t already exist.  Everyone else will synchronize on the\n       // data from the znode\n       client.create().creatingParentsIfNeeded()\n               .forPath(path, generateZKData(generateRandomSecret(),\n               generateRandomSecret(), null));\n       zkVersion \u003d 0;\n       LOG.info(\"Creating secret znode\");\n     } catch (KeeperException.NodeExistsException nee) {\n       LOG.info(\"The secret znode already exists, retrieving data\");\n     }\n     // Synchronize on the data from the znode\n     // passing true tells it to parse out all the data for initing\n     pullFromZK(true);\n     long initialDelay \u003d nextRolloverDate - System.currentTimeMillis();\n     // If it\u0027s in the past, try to find the next interval that we should\n     // be using\n     if (initialDelay \u003c 1l) {\n       int i \u003d 1;\n       while (initialDelay \u003c 1l) {\n         initialDelay \u003d nextRolloverDate + tokenValidity * i\n                 - System.currentTimeMillis();\n         i++;\n       }\n     }\n     super.startScheduler(initialDelay, tokenValidity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Properties config, ServletContext servletContext,\n          long tokenValidity) throws Exception {\n    Object curatorClientObj \u003d servletContext.getAttribute(\n            ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE);\n    if (curatorClientObj !\u003d null\n            \u0026\u0026 curatorClientObj instanceof CuratorFramework) {\n      client \u003d (CuratorFramework) curatorClientObj;\n    } else {\n      client \u003d createCuratorClient(config);\n      servletContext.setAttribute(\n          ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE, client);\n    }\n    this.tokenValidity \u003d tokenValidity;\n    shouldDisconnect \u003d Boolean.parseBoolean(\n            config.getProperty(DISCONNECT_FROM_ZOOKEEPER_ON_SHUTDOWN, \"true\"));\n    path \u003d config.getProperty(ZOOKEEPER_PATH);\n    if (path \u003d\u003d null) {\n      throw new IllegalArgumentException(ZOOKEEPER_PATH\n              + \" must be specified\");\n    }\n    try {\n      nextRolloverDate \u003d System.currentTimeMillis() + tokenValidity;\n      // everyone tries to do this, only one will succeed and only when the\n      // znode doesn\u0027t already exist.  Everyone else will synchronize on the\n      // data from the znode\n      client.create().creatingParentsIfNeeded()\n              .forPath(path, generateZKData(generateRandomSecret(),\n              generateRandomSecret(), null));\n      zkVersion \u003d 0;\n      LOG.info(\"Creating secret znode\");\n    } catch (KeeperException.NodeExistsException nee) {\n      LOG.info(\"The secret znode already exists, retrieving data\");\n    }\n    // Synchronize on the data from the znode\n    // passing true tells it to parse out all the data for initing\n    pullFromZK(true);\n    long initialDelay \u003d nextRolloverDate - System.currentTimeMillis();\n    // If it\u0027s in the past, try to find the next interval that we should\n    // be using\n    if (initialDelay \u003c 1l) {\n      int i \u003d 1;\n      while (initialDelay \u003c 1l) {\n        initialDelay \u003d nextRolloverDate + tokenValidity * i\n                - System.currentTimeMillis();\n        i++;\n      }\n    }\n    super.startScheduler(initialDelay, tokenValidity);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/util/ZKSignerSecretProvider.java",
      "extendedDetails": {}
    },
    "932ae036acb96634c5dd435d57ba02ce4d5e8918": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10868. AuthenticationFilter should support externalizing the secret for signing and provide rotation support. (rkanter via tucu)\n",
      "commitDate": "15/09/14 5:05 PM",
      "commitName": "932ae036acb96634c5dd435d57ba02ce4d5e8918",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,47 @@\n+  public void init(Properties config, ServletContext servletContext,\n+          long tokenValidity) throws Exception {\n+    Object curatorClientObj \u003d servletContext.getAttribute(\n+            ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE);\n+    if (curatorClientObj !\u003d null\n+            \u0026\u0026 curatorClientObj instanceof CuratorFramework) {\n+      client \u003d (CuratorFramework) curatorClientObj;\n+    } else {\n+      client \u003d createCuratorClient(config);\n+    }\n+    this.tokenValidity \u003d tokenValidity;\n+    shouldDisconnect \u003d Boolean.parseBoolean(\n+            config.getProperty(DISCONNECT_FROM_ZOOKEEPER_ON_SHUTDOWN, \"true\"));\n+    path \u003d config.getProperty(ZOOKEEPER_PATH);\n+    if (path \u003d\u003d null) {\n+      throw new IllegalArgumentException(ZOOKEEPER_PATH\n+              + \" must be specified\");\n+    }\n+    try {\n+      nextRolloverDate \u003d System.currentTimeMillis() + tokenValidity;\n+      // everyone tries to do this, only one will succeed and only when the\n+      // znode doesn\u0027t already exist.  Everyone else will synchronize on the\n+      // data from the znode\n+      client.create().creatingParentsIfNeeded()\n+              .forPath(path, generateZKData(generateRandomSecret(),\n+              generateRandomSecret(), null));\n+      zkVersion \u003d 0;\n+      LOG.info(\"Creating secret znode\");\n+    } catch (KeeperException.NodeExistsException nee) {\n+      LOG.info(\"The secret znode already exists, retrieving data\");\n+    }\n+    // Synchronize on the data from the znode\n+    // passing true tells it to parse out all the data for initing\n+    pullFromZK(true);\n+    long initialDelay \u003d nextRolloverDate - System.currentTimeMillis();\n+    // If it\u0027s in the past, try to find the next interval that we should\n+    // be using\n+    if (initialDelay \u003c 1l) {\n+      int i \u003d 1;\n+      while (initialDelay \u003c 1l) {\n+        initialDelay \u003d nextRolloverDate + tokenValidity * i\n+                - System.currentTimeMillis();\n+        i++;\n+      }\n+    }\n+    super.startScheduler(initialDelay, tokenValidity);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Properties config, ServletContext servletContext,\n          long tokenValidity) throws Exception {\n    Object curatorClientObj \u003d servletContext.getAttribute(\n            ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE);\n    if (curatorClientObj !\u003d null\n            \u0026\u0026 curatorClientObj instanceof CuratorFramework) {\n      client \u003d (CuratorFramework) curatorClientObj;\n    } else {\n      client \u003d createCuratorClient(config);\n    }\n    this.tokenValidity \u003d tokenValidity;\n    shouldDisconnect \u003d Boolean.parseBoolean(\n            config.getProperty(DISCONNECT_FROM_ZOOKEEPER_ON_SHUTDOWN, \"true\"));\n    path \u003d config.getProperty(ZOOKEEPER_PATH);\n    if (path \u003d\u003d null) {\n      throw new IllegalArgumentException(ZOOKEEPER_PATH\n              + \" must be specified\");\n    }\n    try {\n      nextRolloverDate \u003d System.currentTimeMillis() + tokenValidity;\n      // everyone tries to do this, only one will succeed and only when the\n      // znode doesn\u0027t already exist.  Everyone else will synchronize on the\n      // data from the znode\n      client.create().creatingParentsIfNeeded()\n              .forPath(path, generateZKData(generateRandomSecret(),\n              generateRandomSecret(), null));\n      zkVersion \u003d 0;\n      LOG.info(\"Creating secret znode\");\n    } catch (KeeperException.NodeExistsException nee) {\n      LOG.info(\"The secret znode already exists, retrieving data\");\n    }\n    // Synchronize on the data from the znode\n    // passing true tells it to parse out all the data for initing\n    pullFromZK(true);\n    long initialDelay \u003d nextRolloverDate - System.currentTimeMillis();\n    // If it\u0027s in the past, try to find the next interval that we should\n    // be using\n    if (initialDelay \u003c 1l) {\n      int i \u003d 1;\n      while (initialDelay \u003c 1l) {\n        initialDelay \u003d nextRolloverDate + tokenValidity * i\n                - System.currentTimeMillis();\n        i++;\n      }\n    }\n    super.startScheduler(initialDelay, tokenValidity);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/util/ZKSignerSecretProvider.java"
    }
  }
}