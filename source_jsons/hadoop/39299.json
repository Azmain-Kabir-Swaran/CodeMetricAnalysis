{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "handle",
  "functionId": "handle___event-SchedulerEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 1794,
  "functionEndLine": 1965,
  "numCommitsSeen": 260,
  "timeTaken": 19765,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
    "cb87e4dc927731e32b0bbcf678bb5600835ff28d",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
    "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "d16b17b4d299b4d58f879a2a15708bacd0938685",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff",
    "adf260a728df427eb729abe8fb9ad7248991ea54",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
    "ab8eb8770c8b8bff41dacb1a399d75906abb1ac4",
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
    "c39ca541f498712133890961598bbff50d89d68b",
    "9b272ccae78918e7d756d84920a9322187d61eed",
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
    "eb3e40b833b9d82c1556843f960194dc42e482f3",
    "5c14bc426b4be381383018ebc2236be83eef15cd",
    "bda23181bf1931c37d2590e03da9acdc6688ad34",
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
    "424fd9494f144c035fdef8c533be51e2027ad8d9",
    "57cdf8626a32b8595a645b7551f46ab950db4789",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288",
    "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": "Ybodychange",
    "cb87e4dc927731e32b0bbcf678bb5600835ff28d": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ybodychange",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Ybodychange",
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d": "Ybodychange",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": "Ybodychange",
    "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6": "Ybodychange",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": "Ybodychange",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": "Ybodychange",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "d16b17b4d299b4d58f879a2a15708bacd0938685": "Ybodychange",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": "Ybodychange",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": "Ybodychange",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": "Ybodychange",
    "adf260a728df427eb729abe8fb9ad7248991ea54": "Ybodychange",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": "Ybodychange",
    "ab8eb8770c8b8bff41dacb1a399d75906abb1ac4": "Ybodychange",
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5": "Ybodychange",
    "c39ca541f498712133890961598bbff50d89d68b": "Ybodychange",
    "9b272ccae78918e7d756d84920a9322187d61eed": "Ybodychange",
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af": "Ybodychange",
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383": "Ybodychange",
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb": "Ybodychange",
    "eb3e40b833b9d82c1556843f960194dc42e482f3": "Ybodychange",
    "5c14bc426b4be381383018ebc2236be83eef15cd": "Ybodychange",
    "bda23181bf1931c37d2590e03da9acdc6688ad34": "Ybodychange",
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6": "Ybodychange",
    "424fd9494f144c035fdef8c533be51e2027ad8d9": "Ybodychange",
    "57cdf8626a32b8595a645b7551f46ab950db4789": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ybodychange",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": "Ybodychange",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": "Ybodychange",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": "Ybodychange",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": "Ybodychange",
    "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "19/03/20 12:25 AM",
      "commitNameOld": "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 6.16,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,172 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n \n       updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n     case NODE_ATTRIBUTES_UPDATE:\n     {\n       NodeAttributesUpdateSchedulerEvent attributeUpdateEvent \u003d\n           (NodeAttributesUpdateSchedulerEvent) event;\n \n       updateNodeAttributes(attributeUpdateEvent);\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n               appAddedEvent.getPlacementContext());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n               appAddedEvent.getPlacementContext());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerUpdate(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case RELEASE_CONTAINER:\n     {\n       RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(),\n             SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     case MANAGE_QUEUE:\n     {\n       QueueManagementChangeEvent queueManagementChangeEvent \u003d\n           (QueueManagementChangeEvent) event;\n       ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n       try {\n         final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n             queueManagementChangeEvent.getQueueManagementChanges();\n         ((ManagedParentQueue) parentQueue)\n             .validateAndApplyQueueManagementChanges(queueManagementChanges);\n       } catch (SchedulerDynamicEditException sde) {\n         LOG.error(\"Queue Management Change event cannot be applied for \"\n-            + \"parent queue : \" + parentQueue.getQueueName(), sde);\n+            + \"parent queue : \" + parentQueue.getQueuePath(), sde);\n       } catch (IOException ioe) {\n         LOG.error(\"Queue Management Change event cannot be applied for \"\n-            + \"parent queue : \" + parentQueue.getQueueName(), ioe);\n+            + \"parent queue : \" + parentQueue.getQueuePath(), ioe);\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n\n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_ATTRIBUTES_UPDATE:\n    {\n      NodeAttributesUpdateSchedulerEvent attributeUpdateEvent \u003d\n          (NodeAttributesUpdateSchedulerEvent) event;\n\n      updateNodeAttributes(attributeUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerUpdate(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case RELEASE_CONTAINER:\n    {\n      RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(),\n            SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    case MANAGE_QUEUE:\n    {\n      QueueManagementChangeEvent queueManagementChangeEvent \u003d\n          (QueueManagementChangeEvent) event;\n      ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n      try {\n        final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n            queueManagementChangeEvent.getQueueManagementChanges();\n        ((ManagedParentQueue) parentQueue)\n            .validateAndApplyQueueManagementChanges(queueManagementChanges);\n      } catch (SchedulerDynamicEditException sde) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueuePath(), sde);\n      } catch (IOException ioe) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueuePath(), ioe);\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7863. Modify placement constraints to support node attributes. Contributed by Sunil Govindan.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "28/08/18 8:13 PM",
      "commitNameOld": "3fa46394214181ed1cc7f06b886282bbdf67a10f",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 14.3,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,172 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n \n       updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n+    case NODE_ATTRIBUTES_UPDATE:\n+    {\n+      NodeAttributesUpdateSchedulerEvent attributeUpdateEvent \u003d\n+          (NodeAttributesUpdateSchedulerEvent) event;\n+\n+      updateNodeAttributes(attributeUpdateEvent);\n+    }\n+    break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n               appAddedEvent.getPlacementContext());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n               appAddedEvent.getPlacementContext());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerUpdate(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case RELEASE_CONTAINER:\n     {\n       RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(),\n             SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     case MANAGE_QUEUE:\n     {\n       QueueManagementChangeEvent queueManagementChangeEvent \u003d\n           (QueueManagementChangeEvent) event;\n       ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n       try {\n         final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n             queueManagementChangeEvent.getQueueManagementChanges();\n         ((ManagedParentQueue) parentQueue)\n             .validateAndApplyQueueManagementChanges(queueManagementChanges);\n       } catch (SchedulerDynamicEditException sde) {\n         LOG.error(\"Queue Management Change event cannot be applied for \"\n             + \"parent queue : \" + parentQueue.getQueueName(), sde);\n       } catch (IOException ioe) {\n         LOG.error(\"Queue Management Change event cannot be applied for \"\n             + \"parent queue : \" + parentQueue.getQueueName(), ioe);\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n\n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_ATTRIBUTES_UPDATE:\n    {\n      NodeAttributesUpdateSchedulerEvent attributeUpdateEvent \u003d\n          (NodeAttributesUpdateSchedulerEvent) event;\n\n      updateNodeAttributes(attributeUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerUpdate(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case RELEASE_CONTAINER:\n    {\n      RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(),\n            SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    case MANAGE_QUEUE:\n    {\n      QueueManagementChangeEvent queueManagementChangeEvent \u003d\n          (QueueManagementChangeEvent) event;\n      ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n      try {\n        final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n            queueManagementChangeEvent.getQueueManagementChanges();\n        ((ManagedParentQueue) parentQueue)\n            .validateAndApplyQueueManagementChanges(queueManagementChanges);\n      } catch (SchedulerDynamicEditException sde) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueueName(), sde);\n      } catch (IOException ioe) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueueName(), ioe);\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "cb87e4dc927731e32b0bbcf678bb5600835ff28d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7643. Handle recovery of applications in case of auto-created leaf queue mapping. Contributed by Suma Shivaprasad.\n",
      "commitDate": "13/12/17 9:19 AM",
      "commitName": "cb87e4dc927731e32b0bbcf678bb5600835ff28d",
      "commitAuthor": "Sunil G",
      "commitDateOld": "08/12/17 3:17 PM",
      "commitNameOld": "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 4.75,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,164 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n \n       updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n               appAddedEvent.getPlacementContext());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n-              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n+              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n+              appAddedEvent.getPlacementContext());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerUpdate(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case RELEASE_CONTAINER:\n     {\n       RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(),\n             SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     case MANAGE_QUEUE:\n     {\n       QueueManagementChangeEvent queueManagementChangeEvent \u003d\n           (QueueManagementChangeEvent) event;\n       ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n       try {\n         final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n             queueManagementChangeEvent.getQueueManagementChanges();\n         ((ManagedParentQueue) parentQueue)\n             .validateAndApplyQueueManagementChanges(queueManagementChanges);\n       } catch (SchedulerDynamicEditException sde) {\n         LOG.error(\"Queue Management Change event cannot be applied for \"\n             + \"parent queue : \" + parentQueue.getQueueName(), sde);\n       } catch (IOException ioe) {\n         LOG.error(\"Queue Management Change event cannot be applied for \"\n             + \"parent queue : \" + parentQueue.getQueueName(), ioe);\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n\n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerUpdate(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case RELEASE_CONTAINER:\n    {\n      RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(),\n            SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    case MANAGE_QUEUE:\n    {\n      QueueManagementChangeEvent queueManagementChangeEvent \u003d\n          (QueueManagementChangeEvent) event;\n      ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n      try {\n        final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n            queueManagementChangeEvent.getQueueManagementChanges();\n        ((ManagedParentQueue) parentQueue)\n            .validateAndApplyQueueManagementChanges(queueManagementChanges);\n      } catch (SchedulerDynamicEditException sde) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueueName(), sde);\n      } catch (IOException ioe) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueueName(), ioe);\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "30/11/17 3:57 PM",
      "commitNameOld": "a63d19d36520fa55bf523483f14329756f6eadd3",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 7.97,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,163 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n-      \n+\n       updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n               appAddedEvent.getPlacementContext());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerUpdate(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case RELEASE_CONTAINER:\n     {\n       RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(),\n             SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n+    case MANAGE_QUEUE:\n+    {\n+      QueueManagementChangeEvent queueManagementChangeEvent \u003d\n+          (QueueManagementChangeEvent) event;\n+      ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n+      try {\n+        final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n+            queueManagementChangeEvent.getQueueManagementChanges();\n+        ((ManagedParentQueue) parentQueue)\n+            .validateAndApplyQueueManagementChanges(queueManagementChanges);\n+      } catch (SchedulerDynamicEditException sde) {\n+        LOG.error(\"Queue Management Change event cannot be applied for \"\n+            + \"parent queue : \" + parentQueue.getQueueName(), sde);\n+      } catch (IOException ioe) {\n+        LOG.error(\"Queue Management Change event cannot be applied for \"\n+            + \"parent queue : \" + parentQueue.getQueueName(), ioe);\n+      }\n+    }\n+    break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n\n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerUpdate(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case RELEASE_CONTAINER:\n    {\n      RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(),\n            SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    case MANAGE_QUEUE:\n    {\n      QueueManagementChangeEvent queueManagementChangeEvent \u003d\n          (QueueManagementChangeEvent) event;\n      ParentQueue parentQueue \u003d queueManagementChangeEvent.getParentQueue();\n      try {\n        final List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n            queueManagementChangeEvent.getQueueManagementChanges();\n        ((ManagedParentQueue) parentQueue)\n            .validateAndApplyQueueManagementChanges(queueManagementChanges);\n      } catch (SchedulerDynamicEditException sde) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueueName(), sde);\n      } catch (IOException ioe) {\n        LOG.error(\"Queue Management Change event cannot be applied for \"\n            + \"parent queue : \" + parentQueue.getQueueName(), ioe);\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/11/17 1:01 PM",
      "commitNameOld": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
      "commitAuthorOld": "Konstantinos Karanasos",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,144 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n-              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n+              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n+              appAddedEvent.getPlacementContext());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerUpdate(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case RELEASE_CONTAINER:\n     {\n       RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(),\n             SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority(),\n              appAddedEvent.getPlacementContext());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerUpdate(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case RELEASE_CONTAINER:\n    {\n      RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(),\n            SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6251. Do async container release to prevent deadlock during container updates. (Arun Suresh via wangda)\n\nChange-Id: I6c67d20c5dd4d22752830ebf0ed2340824976ecb\n",
      "commitDate": "23/08/17 9:56 AM",
      "commitName": "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/08/17 10:51 AM",
      "commitNameOld": "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 8.96,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,143 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerUpdate(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n+    case RELEASE_CONTAINER:\n+    {\n+      RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n+      completedContainer(container,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+            container.getContainerId(),\n+            SchedulerUtils.RELEASED_CONTAINER),\n+          RMContainerEventType.RELEASED);\n+    }\n+    break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerUpdate(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case RELEASE_CONTAINER:\n    {\n      RMContainer container \u003d ((ReleaseContainerEvent) event).getContainer();\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(),\n            SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
      "commitDate": "28/02/17 10:35 AM",
      "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/02/17 10:23 AM",
      "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 19.01,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n-        rollbackContainerResource(containerId);\n+        rollbackContainerUpdate(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d\n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d\n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerUpdate(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5788. Apps not activiated and AM limit resource in UI and REST not updated after -replaceLabelsOnNode (Bibin A Chundatt via Varun Saxena)\n",
      "commitDate": "01/11/16 3:02 AM",
      "commitName": "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "20/10/16 9:17 PM",
      "commitNameOld": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 11.24,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,133 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n-      \n-      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n-          .getUpdatedNodeToLabels().entrySet()) {\n-        NodeId id \u003d entry.getKey();\n-        Set\u003cString\u003e labels \u003d entry.getValue();\n-        updateLabelsOnNode(id, labels);\n-      }\n+\n+      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerResource(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n\n      updateNodeLabelsAndQueueResource(labelUpdateEvent);\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerResource(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5047. Refactor nodeUpdate across schedulers. (Ray Chiang via kasha)\n",
      "commitDate": "20/10/16 9:17 PM",
      "commitName": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/10/16 5:23 PM",
      "commitNameOld": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 16.16,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,138 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n-      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n-      setLastNodeUpdateTime(Time.now());\n-      nodeUpdate(node);\n-      if (!scheduleAsynchronously) {\n-        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n-            node.getNodeID());\n-        allocateContainersToNode(getNode(node.getNodeID()));\n-        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n-            node.getNodeID());\n-      }\n+      nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerResource(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerResource(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4091. Add REST API to retrieve scheduler activity. (Chen Ge and Sunil G via wangda)\n",
      "commitDate": "05/08/16 10:27 AM",
      "commitName": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/07/16 9:22 PM",
      "commitNameOld": "d62e121ffc0239e7feccc1e23ece92c5fac685f6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.54,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,147 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n+        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n+            node.getNodeID());\n         allocateContainersToNode(getNode(node.getNodeID()));\n+        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n+            node.getNodeID());\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerResource(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case MARK_CONTAINER_FOR_KILLABLE:\n     {\n       ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n       markContainerForKillable(killableContainer);\n     }\n     break;\n     case MARK_CONTAINER_FOR_NONKILLABLE:\n     {\n       if (isLazyPreemptionEnabled) {\n         ContainerPreemptEvent cancelKillContainerEvent \u003d\n             (ContainerPreemptEvent) event;\n         markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n       }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            node.getNodeID());\n        allocateContainersToNode(getNode(node.getNodeID()));\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            node.getNodeID());\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerResource(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,143 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerResource(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n-    case KILL_PREEMPTED_CONTAINER:\n+    case MARK_CONTAINER_FOR_KILLABLE:\n     {\n-      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n-      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n-      killPreemptedContainer(containerToBeKilled);\n+      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n+      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n+      markContainerForKillable(killableContainer);\n+    }\n+    break;\n+    case MARK_CONTAINER_FOR_NONKILLABLE:\n+    {\n+      if (isLazyPreemptionEnabled) {\n+        ContainerPreemptEvent cancelKillContainerEvent \u003d\n+            (ContainerPreemptEvent) event;\n+        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n+      }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerResource(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,134 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerResource(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n-    case MARK_CONTAINER_FOR_KILLABLE:\n+    case KILL_PREEMPTED_CONTAINER:\n     {\n-      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n-      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n-      markContainerForKillable(killableContainer);\n-    }\n-    break;\n-    case MARK_CONTAINER_FOR_NONKILLABLE:\n-    {\n-      if (isLazyPreemptionEnabled) {\n-        ContainerPreemptEvent cancelKillContainerEvent \u003d\n-            (ContainerPreemptEvent) event;\n-        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n-      }\n+      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n+      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n+      killPreemptedContainer(containerToBeKilled);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerResource(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_PREEMPTED_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killPreemptedContainer(containerToBeKilled);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/03/16 2:19 PM",
      "commitNameOld": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,143 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       if (containerExpiredEvent.isIncrease()) {\n         rollbackContainerResource(containerId);\n       } else {\n         completedContainer(getRMContainer(containerId),\n             SchedulerUtils.createAbnormalContainerStatus(\n                 containerId,\n                 SchedulerUtils.EXPIRED_CONTAINER),\n             RMContainerEventType.EXPIRE);\n       }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n-    case KILL_PREEMPTED_CONTAINER:\n+    case MARK_CONTAINER_FOR_KILLABLE:\n     {\n-      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n-      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n-      killPreemptedContainer(containerToBeKilled);\n+      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n+      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n+      markContainerForKillable(killableContainer);\n+    }\n+    break;\n+    case MARK_CONTAINER_FOR_NONKILLABLE:\n+    {\n+      if (isLazyPreemptionEnabled) {\n+        ContainerPreemptEvent cancelKillContainerEvent \u003d\n+            (ContainerPreemptEvent) event;\n+        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n+      }\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerResource(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case MARK_CONTAINER_FOR_KILLABLE:\n    {\n      ContainerPreemptEvent containerKillableEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer killableContainer \u003d containerKillableEvent.getContainer();\n      markContainerForKillable(killableContainer);\n    }\n    break;\n    case MARK_CONTAINER_FOR_NONKILLABLE:\n    {\n      if (isLazyPreemptionEnabled) {\n        ContainerPreemptEvent cancelKillContainerEvent \u003d\n            (ContainerPreemptEvent) event;\n        markContainerForNonKillable(cancelKillContainerEvent.getContainer());\n      }\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "d16b17b4d299b4d58f879a2a15708bacd0938685": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4138. Roll back container resource allocation after resource increase token expires. Contributed by Meng Ding\n",
      "commitDate": "10/02/16 6:06 PM",
      "commitName": "d16b17b4d299b4d58f879a2a15708bacd0938685",
      "commitAuthor": "Jian He",
      "commitDateOld": "28/01/16 2:51 PM",
      "commitNameOld": "7f46636495e23693d588b0915f464fa7afd9102e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 13.14,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,134 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n-      super.completedContainer(getRMContainer(containerId),\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              containerId, \n-              SchedulerUtils.EXPIRED_CONTAINER), \n-          RMContainerEventType.EXPIRE);\n+      if (containerExpiredEvent.isIncrease()) {\n+        rollbackContainerResource(containerId);\n+      } else {\n+        completedContainer(getRMContainer(containerId),\n+            SchedulerUtils.createAbnormalContainerStatus(\n+                containerId,\n+                SchedulerUtils.EXPIRED_CONTAINER),\n+            RMContainerEventType.EXPIRE);\n+      }\n     }\n     break;\n     case KILL_RESERVED_CONTAINER:\n     {\n       ContainerPreemptEvent killReservedContainerEvent \u003d\n           (ContainerPreemptEvent) event;\n       RMContainer container \u003d killReservedContainerEvent.getContainer();\n       killReservedContainer(container);\n     }\n     break;\n     case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n     case KILL_PREEMPTED_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n       killPreemptedContainer(containerToBeKilled);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      if (containerExpiredEvent.isIncrease()) {\n        rollbackContainerResource(containerId);\n      } else {\n        completedContainer(getRMContainer(containerId),\n            SchedulerUtils.createAbnormalContainerStatus(\n                containerId,\n                SchedulerUtils.EXPIRED_CONTAINER),\n            RMContainerEventType.EXPIRE);\n      }\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_PREEMPTED_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killPreemptedContainer(containerToBeKilled);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "18/01/16 5:30 PM",
      "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:27 PM",
      "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,130 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n-      completedContainer(getRMContainer(containerId), \n+      super.completedContainer(getRMContainer(containerId),\n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n-    case DROP_RESERVATION:\n+    case KILL_RESERVED_CONTAINER:\n     {\n-      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n-      RMContainer container \u003d dropReservationEvent.getContainer();\n-      dropContainerReservation(container);\n+      ContainerPreemptEvent killReservedContainerEvent \u003d\n+          (ContainerPreemptEvent) event;\n+      RMContainer container \u003d killReservedContainerEvent.getContainer();\n+      killReservedContainer(container);\n     }\n     break;\n-    case PREEMPT_CONTAINER:\n+    case MARK_CONTAINER_FOR_PREEMPTION:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n-      preemptContainer(aid, containerToBePreempted);\n+      markContainerForPreemption(aid, containerToBePreempted);\n     }\n     break;\n-    case KILL_CONTAINER:\n+    case KILL_PREEMPTED_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n-      killContainer(containerToBeKilled);\n-    }\n-    break;\n-    case CONTAINER_RESCHEDULED:\n-    {\n-      ContainerRescheduledEvent containerRescheduledEvent \u003d\n-          (ContainerRescheduledEvent) event;\n-      RMContainer container \u003d containerRescheduledEvent.getContainer();\n-      recoverResourceRequestForContainer(container);\n+      killPreemptedContainer(containerToBeKilled);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      super.completedContainer(getRMContainer(containerId),\n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case MARK_CONTAINER_FOR_PREEMPTION:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      markContainerForPreemption(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_PREEMPTED_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killPreemptedContainer(containerToBeKilled);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
      "commitDate": "18/01/16 5:27 PM",
      "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 1:06 AM",
      "commitNameOld": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.68,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,137 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n-      super.completedContainer(getRMContainer(containerId), \n+      completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n-    case KILL_RESERVED_CONTAINER:\n+    case DROP_RESERVATION:\n     {\n-      ContainerPreemptEvent killReservedContainerEvent \u003d\n-          (ContainerPreemptEvent) event;\n-      RMContainer container \u003d killReservedContainerEvent.getContainer();\n-      killReservedContainer(container);\n+      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n+      RMContainer container \u003d dropReservationEvent.getContainer();\n+      dropContainerReservation(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n-    case KILL_PREEMPTED_CONTAINER:\n+    case KILL_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n-      killPreemptedContainer(containerToBeKilled);\n+      killContainer(containerToBeKilled);\n+    }\n+    break;\n+    case CONTAINER_RESCHEDULED:\n+    {\n+      ContainerRescheduledEvent containerRescheduledEvent \u003d\n+          (ContainerRescheduledEvent) event;\n+      RMContainer container \u003d containerRescheduledEvent.getContainer();\n+      recoverResourceRequestForContainer(container);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case DROP_RESERVATION:\n    {\n      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer container \u003d dropReservationEvent.getContainer();\n      dropContainerReservation(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killContainer(containerToBeKilled);\n    }\n    break;\n    case CONTAINER_RESCHEDULED:\n    {\n      ContainerRescheduledEvent containerRescheduledEvent \u003d\n          (ContainerRescheduledEvent) event;\n      RMContainer container \u003d containerRescheduledEvent.getContainer();\n      recoverResourceRequestForContainer(container);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
      "commitDate": "18/01/16 1:06 AM",
      "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 12:50 AM",
      "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,130 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n-      completedContainer(getRMContainer(containerId), \n+      super.completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n-    case DROP_RESERVATION:\n+    case KILL_RESERVED_CONTAINER:\n     {\n-      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n-      RMContainer container \u003d dropReservationEvent.getContainer();\n-      dropContainerReservation(container);\n+      ContainerPreemptEvent killReservedContainerEvent \u003d\n+          (ContainerPreemptEvent) event;\n+      RMContainer container \u003d killReservedContainerEvent.getContainer();\n+      killReservedContainer(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n-    case KILL_CONTAINER:\n+    case KILL_PREEMPTED_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n-      killContainer(containerToBeKilled);\n-    }\n-    break;\n-    case CONTAINER_RESCHEDULED:\n-    {\n-      ContainerRescheduledEvent containerRescheduledEvent \u003d\n-          (ContainerRescheduledEvent) event;\n-      RMContainer container \u003d containerRescheduledEvent.getContainer();\n-      recoverResourceRequestForContainer(container);\n+      killPreemptedContainer(containerToBeKilled);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      super.completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_PREEMPTED_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killPreemptedContainer(containerToBeKilled);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "adf260a728df427eb729abe8fb9ad7248991ea54": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
      "commitDate": "18/01/16 12:50 AM",
      "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/01/16 7:04 PM",
      "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,137 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n-      super.completedContainer(getRMContainer(containerId), \n+      completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n-    case KILL_RESERVED_CONTAINER:\n+    case DROP_RESERVATION:\n     {\n-      ContainerPreemptEvent killReservedContainerEvent \u003d\n-          (ContainerPreemptEvent) event;\n-      RMContainer container \u003d killReservedContainerEvent.getContainer();\n-      killReservedContainer(container);\n+      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n+      RMContainer container \u003d dropReservationEvent.getContainer();\n+      dropContainerReservation(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n-    case KILL_PREEMPTED_CONTAINER:\n+    case KILL_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n-      killPreemptedContainer(containerToBeKilled);\n+      killContainer(containerToBeKilled);\n+    }\n+    break;\n+    case CONTAINER_RESCHEDULED:\n+    {\n+      ContainerRescheduledEvent containerRescheduledEvent \u003d\n+          (ContainerRescheduledEvent) event;\n+      RMContainer container \u003d containerRescheduledEvent.getContainer();\n+      recoverResourceRequestForContainer(container);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case DROP_RESERVATION:\n    {\n      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer container \u003d dropReservationEvent.getContainer();\n      dropContainerReservation(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killContainer(containerToBeKilled);\n    }\n    break;\n    case CONTAINER_RESCHEDULED:\n    {\n      ContainerRescheduledEvent containerRescheduledEvent \u003d\n          (ContainerRescheduledEvent) event;\n      RMContainer container \u003d containerRescheduledEvent.getContainer();\n      recoverResourceRequestForContainer(container);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "17/01/16 7:04 PM",
      "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/01/16 9:18 PM",
      "commitNameOld": "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 4.91,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,130 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n           appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n           appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n-      completedContainer(getRMContainer(containerId), \n+      super.completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n-    case DROP_RESERVATION:\n+    case KILL_RESERVED_CONTAINER:\n     {\n-      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n-      RMContainer container \u003d dropReservationEvent.getContainer();\n-      dropContainerReservation(container);\n+      ContainerPreemptEvent killReservedContainerEvent \u003d\n+          (ContainerPreemptEvent) event;\n+      RMContainer container \u003d killReservedContainerEvent.getContainer();\n+      killReservedContainer(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n-    case KILL_CONTAINER:\n+    case KILL_PREEMPTED_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n-      killContainer(containerToBeKilled);\n-    }\n-    break;\n-    case CONTAINER_RESCHEDULED:\n-    {\n-      ContainerRescheduledEvent containerRescheduledEvent \u003d\n-          (ContainerRescheduledEvent) event;\n-      RMContainer container \u003d containerRescheduledEvent.getContainer();\n-      recoverResourceRequestForContainer(container);\n+      killPreemptedContainer(containerToBeKilled);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      super.completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case KILL_RESERVED_CONTAINER:\n    {\n      ContainerPreemptEvent killReservedContainerEvent \u003d\n          (ContainerPreemptEvent) event;\n      RMContainer container \u003d killReservedContainerEvent.getContainer();\n      killReservedContainer(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_PREEMPTED_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killPreemptedContainer(containerToBeKilled);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "ab8eb8770c8b8bff41dacb1a399d75906abb1ac4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3738. Add support for recovery of reserved apps running under dynamic queues (subru via asuresh)\n",
      "commitDate": "24/10/15 10:53 PM",
      "commitName": "ab8eb8770c8b8bff41dacb1a399d75906abb1ac4",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "15/10/15 5:12 PM",
      "commitNameOld": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 9.24,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,137 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n-      String queueName \u003d\n-          resolveReservationQueueName(appAddedEvent.getQueue(),\n-              appAddedEvent.getApplicationId(),\n-              appAddedEvent.getReservationID());\n+      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n+          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n+          appAddedEvent.getIsAppRecovering());\n       if (queueName !\u003d null) {\n         if (!appAddedEvent.getIsAppRecovering()) {\n           addApplication(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         } else {\n           addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n               appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n         }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     case DROP_RESERVATION:\n     {\n       ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer container \u003d dropReservationEvent.getContainer();\n       dropContainerReservation(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n     case KILL_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n       killContainer(containerToBeKilled);\n     }\n     break;\n     case CONTAINER_RESCHEDULED:\n     {\n       ContainerRescheduledEvent containerRescheduledEvent \u003d\n           (ContainerRescheduledEvent) event;\n       RMContainer container \u003d containerRescheduledEvent.getContainer();\n       recoverResourceRequestForContainer(container);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d resolveReservationQueueName(appAddedEvent.getQueue(),\n          appAddedEvent.getApplicationId(), appAddedEvent.getReservationID(),\n          appAddedEvent.getIsAppRecovering());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case DROP_RESERVATION:\n    {\n      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer container \u003d dropReservationEvent.getContainer();\n      dropContainerReservation(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killContainer(containerToBeKilled);\n    }\n    break;\n    case CONTAINER_RESCHEDULED:\n    {\n      ContainerRescheduledEvent containerRescheduledEvent \u003d\n          (ContainerRescheduledEvent) event;\n      RMContainer container \u003d containerRescheduledEvent.getContainer();\n      recoverResourceRequestForContainer(container);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4000. RM crashes with NPE if leaf queue becomes parent queue during restart. Contributed by Varun Saxena\n",
      "commitDate": "15/10/15 5:12 PM",
      "commitName": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/10/15 11:56 AM",
      "commitNameOld": "29a582ada0fe195989eca25e5a995895e178f4ea",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.22,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,138 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d\n           resolveReservationQueueName(appAddedEvent.getQueue(),\n               appAddedEvent.getApplicationId(),\n               appAddedEvent.getReservationID());\n       if (queueName !\u003d null) {\n-        addApplication(appAddedEvent.getApplicationId(),\n-            queueName,\n-            appAddedEvent.getUser(),\n-            appAddedEvent.getIsAppRecovering(),\n-            appAddedEvent.getApplicatonPriority());\n+        if (!appAddedEvent.getIsAppRecovering()) {\n+          addApplication(appAddedEvent.getApplicationId(), queueName,\n+              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n+        } else {\n+          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n+              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n+        }\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     case DROP_RESERVATION:\n     {\n       ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer container \u003d dropReservationEvent.getContainer();\n       dropContainerReservation(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n     case KILL_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n       killContainer(containerToBeKilled);\n     }\n     break;\n     case CONTAINER_RESCHEDULED:\n     {\n       ContainerRescheduledEvent containerRescheduledEvent \u003d\n           (ContainerRescheduledEvent) event;\n       RMContainer container \u003d containerRescheduledEvent.getContainer();\n       recoverResourceRequestForContainer(container);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d\n          resolveReservationQueueName(appAddedEvent.getQueue(),\n              appAddedEvent.getApplicationId(),\n              appAddedEvent.getReservationID());\n      if (queueName !\u003d null) {\n        if (!appAddedEvent.getIsAppRecovering()) {\n          addApplication(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        } else {\n          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,\n              appAddedEvent.getUser(), appAddedEvent.getApplicatonPriority());\n        }\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case DROP_RESERVATION:\n    {\n      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer container \u003d dropReservationEvent.getContainer();\n      dropContainerReservation(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killContainer(containerToBeKilled);\n    }\n    break;\n    case CONTAINER_RESCHEDULED:\n    {\n      ContainerRescheduledEvent containerRescheduledEvent \u003d\n          (ContainerRescheduledEvent) event;\n      RMContainer container \u003d containerRescheduledEvent.getContainer();\n      recoverResourceRequestForContainer(container);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "c39ca541f498712133890961598bbff50d89d68b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2003. Support for Application priority : Changes in RM and Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "21/07/15 9:57 AM",
      "commitName": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/07/15 4:31 AM",
      "commitNameOld": "9b272ccae78918e7d756d84920a9322187d61eed",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 4.23,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,136 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d\n           resolveReservationQueueName(appAddedEvent.getQueue(),\n               appAddedEvent.getApplicationId(),\n               appAddedEvent.getReservationID());\n       if (queueName !\u003d null) {\n         addApplication(appAddedEvent.getApplicationId(),\n             queueName,\n             appAddedEvent.getUser(),\n-            appAddedEvent.getIsAppRecovering());\n+            appAddedEvent.getIsAppRecovering(),\n+            appAddedEvent.getApplicatonPriority());\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     case DROP_RESERVATION:\n     {\n       ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer container \u003d dropReservationEvent.getContainer();\n       dropContainerReservation(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n     case KILL_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n       killContainer(containerToBeKilled);\n     }\n     break;\n     case CONTAINER_RESCHEDULED:\n     {\n       ContainerRescheduledEvent containerRescheduledEvent \u003d\n           (ContainerRescheduledEvent) event;\n       RMContainer container \u003d containerRescheduledEvent.getContainer();\n       recoverResourceRequestForContainer(container);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d\n          resolveReservationQueueName(appAddedEvent.getQueue(),\n              appAddedEvent.getApplicationId(),\n              appAddedEvent.getReservationID());\n      if (queueName !\u003d null) {\n        addApplication(appAddedEvent.getApplicationId(),\n            queueName,\n            appAddedEvent.getUser(),\n            appAddedEvent.getIsAppRecovering(),\n            appAddedEvent.getApplicatonPriority());\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case DROP_RESERVATION:\n    {\n      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer container \u003d dropReservationEvent.getContainer();\n      dropContainerReservation(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killContainer(containerToBeKilled);\n    }\n    break;\n    case CONTAINER_RESCHEDULED:\n    {\n      ContainerRescheduledEvent containerRescheduledEvent \u003d\n          (ContainerRescheduledEvent) event;\n      RMContainer container \u003d containerRescheduledEvent.getContainer();\n      recoverResourceRequestForContainer(container);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "9b272ccae78918e7d756d84920a9322187d61eed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3535. Scheduler must re-request container resources when RMContainer transitions from ALLOCATED to KILLED (rohithsharma and peng.zhang via asuresh)\n",
      "commitDate": "17/07/15 4:31 AM",
      "commitName": "9b272ccae78918e7d756d84920a9322187d61eed",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "01/07/15 5:32 PM",
      "commitNameOld": "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 15.46,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,135 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d\n           resolveReservationQueueName(appAddedEvent.getQueue(),\n               appAddedEvent.getApplicationId(),\n               appAddedEvent.getReservationID());\n       if (queueName !\u003d null) {\n         addApplication(appAddedEvent.getApplicationId(),\n             queueName,\n             appAddedEvent.getUser(),\n             appAddedEvent.getIsAppRecovering());\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     case DROP_RESERVATION:\n     {\n       ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer container \u003d dropReservationEvent.getContainer();\n       dropContainerReservation(container);\n     }\n     break;\n     case PREEMPT_CONTAINER:\n     {\n       ContainerPreemptEvent preemptContainerEvent \u003d\n           (ContainerPreemptEvent)event;\n       ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n       RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n       preemptContainer(aid, containerToBePreempted);\n     }\n     break;\n     case KILL_CONTAINER:\n     {\n       ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n       RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n       killContainer(containerToBeKilled);\n     }\n     break;\n+    case CONTAINER_RESCHEDULED:\n+    {\n+      ContainerRescheduledEvent containerRescheduledEvent \u003d\n+          (ContainerRescheduledEvent) event;\n+      RMContainer container \u003d containerRescheduledEvent.getContainer();\n+      recoverResourceRequestForContainer(container);\n+    }\n+    break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d\n          resolveReservationQueueName(appAddedEvent.getQueue(),\n              appAddedEvent.getApplicationId(),\n              appAddedEvent.getReservationID());\n      if (queueName !\u003d null) {\n        addApplication(appAddedEvent.getApplicationId(),\n            queueName,\n            appAddedEvent.getUser(),\n            appAddedEvent.getIsAppRecovering());\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case DROP_RESERVATION:\n    {\n      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer container \u003d dropReservationEvent.getContainer();\n      dropContainerReservation(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killContainer(containerToBeKilled);\n    }\n    break;\n    case CONTAINER_RESCHEDULED:\n    {\n      ContainerRescheduledEvent containerRescheduledEvent \u003d\n          (ContainerRescheduledEvent) event;\n      RMContainer container \u003d containerRescheduledEvent.getContainer();\n      recoverResourceRequestForContainer(container);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3508. Prevent processing preemption events on the main RM dispatcher. (Varun Saxena via wangda)\n",
      "commitDate": "01/07/15 5:32 PM",
      "commitName": "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "04/06/15 10:52 AM",
      "commitNameOld": "6ad4e59cfc111a92747fdb1fb99cc6378044832a",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 27.28,
      "commitsBetweenForRepo": 191,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,127 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d\n           resolveReservationQueueName(appAddedEvent.getQueue(),\n               appAddedEvent.getApplicationId(),\n               appAddedEvent.getReservationID());\n       if (queueName !\u003d null) {\n         addApplication(appAddedEvent.getApplicationId(),\n             queueName,\n             appAddedEvent.getUser(),\n             appAddedEvent.getIsAppRecovering());\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n+    case DROP_RESERVATION:\n+    {\n+      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n+      RMContainer container \u003d dropReservationEvent.getContainer();\n+      dropContainerReservation(container);\n+    }\n+    break;\n+    case PREEMPT_CONTAINER:\n+    {\n+      ContainerPreemptEvent preemptContainerEvent \u003d\n+          (ContainerPreemptEvent)event;\n+      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n+      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n+      preemptContainer(aid, containerToBePreempted);\n+    }\n+    break;\n+    case KILL_CONTAINER:\n+    {\n+      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n+      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n+      killContainer(containerToBeKilled);\n+    }\n+    break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d\n          resolveReservationQueueName(appAddedEvent.getQueue(),\n              appAddedEvent.getApplicationId(),\n              appAddedEvent.getReservationID());\n      if (queueName !\u003d null) {\n        addApplication(appAddedEvent.getApplicationId(),\n            queueName,\n            appAddedEvent.getUser(),\n            appAddedEvent.getIsAppRecovering());\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    case DROP_RESERVATION:\n    {\n      ContainerPreemptEvent dropReservationEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer container \u003d dropReservationEvent.getContainer();\n      dropContainerReservation(container);\n    }\n    break;\n    case PREEMPT_CONTAINER:\n    {\n      ContainerPreemptEvent preemptContainerEvent \u003d\n          (ContainerPreemptEvent)event;\n      ApplicationAttemptId aid \u003d preemptContainerEvent.getAppId();\n      RMContainer containerToBePreempted \u003d preemptContainerEvent.getContainer();\n      preemptContainer(aid, containerToBePreempted);\n    }\n    break;\n    case KILL_CONTAINER:\n    {\n      ContainerPreemptEvent killContainerEvent \u003d (ContainerPreemptEvent)event;\n      RMContainer containerToBeKilled \u003d killContainerEvent.getContainer();\n      killContainer(containerToBeKilled);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3293. Track and display capacity scheduler health metrics in web\nUI. Contributed by Varun Vasudev\n",
      "commitDate": "09/04/15 11:38 PM",
      "commitName": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
      "commitAuthor": "Xuan",
      "commitDateOld": "17/03/15 10:24 AM",
      "commitNameOld": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 23.55,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,104 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_LABELS_UPDATE:\n     {\n       NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n           (NodeLabelsUpdateSchedulerEvent) event;\n       \n       for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n           .getUpdatedNodeToLabels().entrySet()) {\n         NodeId id \u003d entry.getKey();\n         Set\u003cString\u003e labels \u003d entry.getValue();\n         updateLabelsOnNode(id, labels);\n       }\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n+      setLastNodeUpdateTime(Time.now());\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d\n           resolveReservationQueueName(appAddedEvent.getQueue(),\n               appAddedEvent.getApplicationId(),\n               appAddedEvent.getReservationID());\n       if (queueName !\u003d null) {\n         addApplication(appAddedEvent.getApplicationId(),\n             queueName,\n             appAddedEvent.getUser(),\n             appAddedEvent.getIsAppRecovering());\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      setLastNodeUpdateTime(Time.now());\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d\n          resolveReservationQueueName(appAddedEvent.getQueue(),\n              appAddedEvent.getApplicationId(),\n              appAddedEvent.getReservationID());\n      if (queueName !\u003d null) {\n        addApplication(appAddedEvent.getApplicationId(),\n            queueName,\n            appAddedEvent.getUser(),\n            appAddedEvent.getIsAppRecovering());\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2920. Changed CapacityScheduler to kill containers on nodes where node labels are changed. Contributed by  Wangda Tan\n",
      "commitDate": "22/12/14 4:51 PM",
      "commitName": "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
      "commitAuthor": "Jian He",
      "commitDateOld": "21/11/14 10:32 AM",
      "commitNameOld": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 31.26,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,103 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n+    case NODE_LABELS_UPDATE:\n+    {\n+      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n+          (NodeLabelsUpdateSchedulerEvent) event;\n+      \n+      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n+          .getUpdatedNodeToLabels().entrySet()) {\n+        NodeId id \u003d entry.getKey();\n+        Set\u003cString\u003e labels \u003d entry.getValue();\n+        updateLabelsOnNode(id, labels);\n+      }\n+    }\n+    break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       String queueName \u003d\n           resolveReservationQueueName(appAddedEvent.getQueue(),\n               appAddedEvent.getApplicationId(),\n               appAddedEvent.getReservationID());\n       if (queueName !\u003d null) {\n         addApplication(appAddedEvent.getApplicationId(),\n             queueName,\n             appAddedEvent.getUser(),\n             appAddedEvent.getIsAppRecovering());\n       }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_LABELS_UPDATE:\n    {\n      NodeLabelsUpdateSchedulerEvent labelUpdateEvent \u003d\n          (NodeLabelsUpdateSchedulerEvent) event;\n      \n      for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : labelUpdateEvent\n          .getUpdatedNodeToLabels().entrySet()) {\n        NodeId id \u003d entry.getKey();\n        Set\u003cString\u003e labels \u003d entry.getValue();\n        updateLabelsOnNode(id, labels);\n      }\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d\n          resolveReservationQueueName(appAddedEvent.getQueue(),\n              appAddedEvent.getApplicationId(),\n              appAddedEvent.getReservationID());\n      if (queueName !\u003d null) {\n        addApplication(appAddedEvent.getApplicationId(),\n            queueName,\n            appAddedEvent.getUser(),\n            appAddedEvent.getIsAppRecovering());\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "eb3e40b833b9d82c1556843f960194dc42e482f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1707. Introduce APIs to add/remove/resize queues in the CapacityScheduler. Contributed by Carlo Curino and Subru Krishnan\n(cherry picked from commit aac47fda7fecda9fc18ade34d633eca895865a70)\n\nConflicts:\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthor": "carlo curino",
      "commitDateOld": "02/10/14 3:13 PM",
      "commitNameOld": "054f28552687e9b9859c0126e16a2066e20ead3f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,90 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_RESOURCE_UPDATE:\n     {\n       NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n           (NodeResourceUpdateSchedulerEvent)event;\n       updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n         nodeResourceUpdatedEvent.getResourceOption());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n-      addApplication(appAddedEvent.getApplicationId(),\n-        appAddedEvent.getQueue(),\n-        appAddedEvent.getUser(), appAddedEvent.getIsAppRecovering());\n+      String queueName \u003d\n+          resolveReservationQueueName(appAddedEvent.getQueue(),\n+              appAddedEvent.getApplicationId(),\n+              appAddedEvent.getReservationID());\n+      if (queueName !\u003d null) {\n+        addApplication(appAddedEvent.getApplicationId(),\n+            queueName,\n+            appAddedEvent.getUser(),\n+            appAddedEvent.getIsAppRecovering());\n+      }\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      String queueName \u003d\n          resolveReservationQueueName(appAddedEvent.getQueue(),\n              appAddedEvent.getApplicationId(),\n              appAddedEvent.getReservationID());\n      if (queueName !\u003d null) {\n        addApplication(appAddedEvent.getApplicationId(),\n            queueName,\n            appAddedEvent.getUser(),\n            appAddedEvent.getIsAppRecovering());\n      }\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "5c14bc426b4be381383018ebc2236be83eef15cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1506. Changed RMNode/SchedulerNode to update resource with event notification. Contributed by Junping Du\n",
      "commitDate": "29/08/14 11:05 PM",
      "commitName": "5c14bc426b4be381383018ebc2236be83eef15cd",
      "commitAuthor": "Jian He",
      "commitDateOld": "19/08/14 1:33 PM",
      "commitNameOld": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 10.4,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,83 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n+    case NODE_RESOURCE_UPDATE:\n+    {\n+      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n+          (NodeResourceUpdateSchedulerEvent)event;\n+      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n+        nodeResourceUpdatedEvent.getResourceOption());\n+    }\n+    break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       addApplication(appAddedEvent.getApplicationId(),\n         appAddedEvent.getQueue(),\n         appAddedEvent.getUser(), appAddedEvent.getIsAppRecovering());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n         appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_RESOURCE_UPDATE:\n    {\n      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent \u003d \n          (NodeResourceUpdateSchedulerEvent)event;\n      updateNodeAndQueueResource(nodeResourceUpdatedEvent.getRMNode(),\n        nodeResourceUpdatedEvent.getResourceOption());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      addApplication(appAddedEvent.getApplicationId(),\n        appAddedEvent.getQueue(),\n        appAddedEvent.getUser(), appAddedEvent.getIsAppRecovering());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "bda23181bf1931c37d2590e03da9acdc6688ad34": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2219. Changed ResourceManager to avoid AMs and NMs getting exceptions after RM recovery but before scheduler learns about apps and app-attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611222 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/14 5:14 PM",
      "commitName": "bda23181bf1931c37d2590e03da9acdc6688ad34",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "15/07/14 2:48 PM",
      "commitNameOld": "43589a8df70d4dbaf86609961e27cc4e23dda993",
      "commitAuthorOld": "Mayank Bansal",
      "daysBetweenCommits": 1.1,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,75 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       addApplication(appAddedEvent.getApplicationId(),\n-        appAddedEvent.getQueue(), appAddedEvent.getUser());\n+        appAddedEvent.getQueue(), appAddedEvent.getUser(),\n+        appAddedEvent.getIsAppRecovering());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n-        appAttemptAddedEvent.getShouldNotifyAttemptAdded());\n+        appAttemptAddedEvent.getIsAttemptRecovering());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      addApplication(appAddedEvent.getApplicationId(),\n        appAddedEvent.getQueue(), appAddedEvent.getUser(),\n        appAddedEvent.getIsAppRecovering());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getIsAttemptRecovering());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1365. Changed ApplicationMasterService to allow an app to re-register after RM restart. Contributed by Anubhav Dhoot\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605263 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 9:42 PM",
      "commitName": "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/06/14 8:15 AM",
      "commitNameOld": "d16470025aa0c51a04c530863a96108895d72ddf",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n       recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n         nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       addApplication(appAddedEvent.getApplicationId(),\n         appAddedEvent.getQueue(), appAddedEvent.getUser());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n-        appAttemptAddedEvent.getTransferStateFromPreviousAttempt());\n+        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n+        appAttemptAddedEvent.getShouldNotifyAttemptAdded());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      addApplication(appAddedEvent.getApplicationId(),\n        appAddedEvent.getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),\n        appAttemptAddedEvent.getShouldNotifyAttemptAdded());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "424fd9494f144c035fdef8c533be51e2027ad8d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1368. Added core functionality of recovering container state into schedulers after ResourceManager Restart so as to preserve running work in the cluster. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601303 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/06/14 8:09 PM",
      "commitName": "424fd9494f144c035fdef8c533be51e2027ad8d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/05/14 12:33 PM",
      "commitNameOld": "a4ba451802c6c61a0c804809740d46dd76059f25",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 8.32,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,73 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n+      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n+        nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       RMNode node \u003d nodeUpdatedEvent.getRMNode();\n       nodeUpdate(node);\n       if (!scheduleAsynchronously) {\n         allocateContainersToNode(getNode(node.getNodeID()));\n       }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       addApplication(appAddedEvent.getApplicationId(),\n         appAddedEvent.getQueue(), appAddedEvent.getUser());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),\n        nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      addApplication(appAddedEvent.getApplicationId(),\n        appAddedEvent.getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "57cdf8626a32b8595a645b7551f46ab950db4789": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1512. Enhanced CapacityScheduler to be able to decouple scheduling from node-heartbeats. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1578722 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/03/14 7:53 PM",
      "commitName": "57cdf8626a32b8595a645b7551f46ab950db4789",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/03/14 3:22 PM",
      "commitNameOld": "92317e3459b502f33a3575c247f05d64e5d39a00",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,71 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n-      nodeUpdate(nodeUpdatedEvent.getRMNode());\n+      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n+      nodeUpdate(node);\n+      if (!scheduleAsynchronously) {\n+        allocateContainersToNode(getNode(node.getNodeID()));\n+      }\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       addApplication(appAddedEvent.getApplicationId(),\n         appAddedEvent.getQueue(), appAddedEvent.getUser());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n       addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n         appAttemptAddedEvent.getTransferStateFromPreviousAttempt());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState(),\n         appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      RMNode node \u003d nodeUpdatedEvent.getRMNode();\n      nodeUpdate(node);\n      if (!scheduleAsynchronously) {\n        allocateContainersToNode(getNode(node.getNodeID()));\n      }\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      addApplication(appAddedEvent.getApplicationId(),\n        appAddedEvent.getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/01/14 12:19 PM",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n       addApplication(appAddedEvent.getApplicationId(),\n         appAddedEvent.getQueue(), appAddedEvent.getUser());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationID(),\n         appRemovedEvent.getFinalState());\n     }\n     break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n-      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId());\n+      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n+        appAttemptAddedEvent.getTransferStateFromPreviousAttempt());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n-        appAttemptRemovedEvent.getFinalAttemptState());\n+        appAttemptRemovedEvent.getFinalAttemptState(),\n+        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      addApplication(appAddedEvent.getApplicationId(),\n        appAddedEvent.getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getTransferStateFromPreviousAttempt());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState(),\n        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 12:19 PM",
      "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/12/13 5:44 PM",
      "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 20.77,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,65 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n+    case APP_ADDED:\n+    {\n+      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n+      addApplication(appAddedEvent.getApplicationId(),\n+        appAddedEvent.getQueue(), appAddedEvent.getUser());\n+    }\n+    break;\n+    case APP_REMOVED:\n+    {\n+      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n+      doneApplication(appRemovedEvent.getApplicationID(),\n+        appRemovedEvent.getFinalState());\n+    }\n+    break;\n     case APP_ATTEMPT_ADDED:\n     {\n       AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n           (AppAttemptAddedSchedulerEvent) event;\n-      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n-        appAttemptAddedEvent.getQueue(), appAttemptAddedEvent.getUser());\n+      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId());\n     }\n     break;\n     case APP_ATTEMPT_REMOVED:\n     {\n       AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n           (AppAttemptRemovedSchedulerEvent) event;\n       doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n         appAttemptRemovedEvent.getFinalAttemptState());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent) event;\n      addApplication(appAddedEvent.getApplicationId(),\n        appAddedEvent.getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationID(),\n        appRemovedEvent.getFinalState());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550613 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 5:44 PM",
      "commitName": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:45 PM",
      "commitNameOld": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,52 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n-    case APP_ADDED:\n+    case APP_ATTEMPT_ADDED:\n     {\n-      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n-      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n-          .getQueue(), appAddedEvent.getUser());\n+      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n+          (AppAttemptAddedSchedulerEvent) event;\n+      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n+        appAttemptAddedEvent.getQueue(), appAttemptAddedEvent.getUser());\n     }\n     break;\n-    case APP_REMOVED:\n+    case APP_ATTEMPT_REMOVED:\n     {\n-      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n-      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n-          appRemovedEvent.getFinalAttemptState());\n+      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n+          (AppAttemptRemovedSchedulerEvent) event;\n+      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n+        appAttemptRemovedEvent.getFinalAttemptState());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getQueue(), appAttemptAddedEvent.getUser());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": {
      "type": "Ybodychange",
      "commitMessage": "Reverting YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550594 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:45 PM",
      "commitName": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:07 PM",
      "commitNameOld": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,50 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n-    case APP_ATTEMPT_ADDED:\n+    case APP_ADDED:\n     {\n-      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n-          (AppAttemptAddedSchedulerEvent) event;\n-      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n-        appAttemptAddedEvent.getQueue(), appAttemptAddedEvent.getUser());\n+      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n+      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n+          .getQueue(), appAddedEvent.getUser());\n     }\n     break;\n-    case APP_ATTEMPT_REMOVED:\n+    case APP_REMOVED:\n     {\n-      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n-          (AppAttemptRemovedSchedulerEvent) event;\n-      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n-        appAttemptRemovedEvent.getFinalAttemptState());\n+      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n+      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n+          appRemovedEvent.getFinalAttemptState());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n          .getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n          appRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550579 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:07 PM",
      "commitName": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthor": "Jian He",
      "commitDateOld": "07/12/13 7:09 PM",
      "commitNameOld": "e1d3670f4c233696dc673c37b578ce46b44a6876",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,52 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n-    case APP_ADDED:\n+    case APP_ATTEMPT_ADDED:\n     {\n-      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n-      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n-          .getQueue(), appAddedEvent.getUser());\n+      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n+          (AppAttemptAddedSchedulerEvent) event;\n+      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n+        appAttemptAddedEvent.getQueue(), appAttemptAddedEvent.getUser());\n     }\n     break;\n-    case APP_REMOVED:\n+    case APP_ATTEMPT_REMOVED:\n     {\n-      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n-      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n-          appRemovedEvent.getFinalAttemptState());\n+      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n+          (AppAttemptRemovedSchedulerEvent) event;\n+      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n+        appAttemptRemovedEvent.getFinalAttemptState());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ATTEMPT_ADDED:\n    {\n      AppAttemptAddedSchedulerEvent appAttemptAddedEvent \u003d\n          (AppAttemptAddedSchedulerEvent) event;\n      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),\n        appAttemptAddedEvent.getQueue(), appAttemptAddedEvent.getUser());\n    }\n    break;\n    case APP_ATTEMPT_REMOVED:\n    {\n      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent \u003d\n          (AppAttemptRemovedSchedulerEvent) event;\n      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),\n        appAttemptRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69": {
      "type": "Ybodychange",
      "commitMessage": "YARN-365. Change NM heartbeat handling to not generate a scheduler event on each heartbeat. (Contributed by Xuan Gong)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1450007 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/13 7:32 PM",
      "commitName": "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "09/01/13 1:00 PM",
      "commitNameOld": "106e2e27ffb81f816ae627fa1712f5db5fb36002",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 47.27,
      "commitsBetweenForRepo": 202,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,50 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n-      nodeUpdate(nodeUpdatedEvent.getRMNode(), \n-          nodeUpdatedEvent.getNewlyLaunchedContainers(),\n-          nodeUpdatedEvent.getCompletedContainers());\n+      nodeUpdate(nodeUpdatedEvent.getRMNode());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n       addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n           .getQueue(), appAddedEvent.getUser());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationAttemptID(),\n           appRemovedEvent.getFinalAttemptState());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n       ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n       completedContainer(getRMContainer(containerId), \n           SchedulerUtils.createAbnormalContainerStatus(\n               containerId, \n               SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n          .getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n          appRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode(), \n          nodeUpdatedEvent.getNewlyLaunchedContainers(),\n          nodeUpdatedEvent.getCompletedContainers());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n          .getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n          appRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/11 10:26 AM",
      "commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 11:26 AM",
      "commitNameOld": "1f46b991da9b91585608a0babd3eda39485dce09",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,52 @@\n   public void handle(SchedulerEvent event) {\n     switch(event.getType()) {\n     case NODE_ADDED:\n     {\n       NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n       addNode(nodeAddedEvent.getAddedRMNode());\n     }\n     break;\n     case NODE_REMOVED:\n     {\n       NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n       removeNode(nodeRemovedEvent.getRemovedRMNode());\n     }\n     break;\n     case NODE_UPDATE:\n     {\n       NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n       nodeUpdate(nodeUpdatedEvent.getRMNode(), \n-          nodeUpdatedEvent.getContainers());\n+          nodeUpdatedEvent.getNewlyLaunchedContainers(),\n+          nodeUpdatedEvent.getCompletedContainers());\n     }\n     break;\n     case APP_ADDED:\n     {\n       AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n       addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n           .getQueue(), appAddedEvent.getUser());\n     }\n     break;\n     case APP_REMOVED:\n     {\n       AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n       doneApplication(appRemovedEvent.getApplicationAttemptID(),\n           appRemovedEvent.getFinalAttemptState());\n     }\n     break;\n     case CONTAINER_EXPIRED:\n     {\n       ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n           (ContainerExpiredSchedulerEvent) event;\n-      completedContainer(getRMContainer(containerExpiredEvent.getContainerId()), \n+      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n+      completedContainer(getRMContainer(containerId), \n+          SchedulerUtils.createAbnormalContainerStatus(\n+              containerId, \n+              SchedulerUtils.EXPIRED_CONTAINER), \n           RMContainerEventType.EXPIRE);\n     }\n     break;\n     default:\n       LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode(), \n          nodeUpdatedEvent.getNewlyLaunchedContainers(),\n          nodeUpdatedEvent.getCompletedContainers());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n          .getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n          appRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      ContainerId containerId \u003d containerExpiredEvent.getContainerId();\n      completedContainer(getRMContainer(containerId), \n          SchedulerUtils.createAbnormalContainerStatus(\n              containerId, \n              SchedulerUtils.EXPIRED_CONTAINER), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode(), \n          nodeUpdatedEvent.getContainers());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n          .getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n          appRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      completedContainer(getRMContainer(containerExpiredEvent.getContainerId()), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,47 @@\n+  public void handle(SchedulerEvent event) {\n+    switch(event.getType()) {\n+    case NODE_ADDED:\n+    {\n+      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n+      addNode(nodeAddedEvent.getAddedRMNode());\n+    }\n+    break;\n+    case NODE_REMOVED:\n+    {\n+      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n+      removeNode(nodeRemovedEvent.getRemovedRMNode());\n+    }\n+    break;\n+    case NODE_UPDATE:\n+    {\n+      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n+      nodeUpdate(nodeUpdatedEvent.getRMNode(), \n+          nodeUpdatedEvent.getContainers());\n+    }\n+    break;\n+    case APP_ADDED:\n+    {\n+      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n+      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n+          .getQueue(), appAddedEvent.getUser());\n+    }\n+    break;\n+    case APP_REMOVED:\n+    {\n+      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n+      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n+          appRemovedEvent.getFinalAttemptState());\n+    }\n+    break;\n+    case CONTAINER_EXPIRED:\n+    {\n+      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n+          (ContainerExpiredSchedulerEvent) event;\n+      completedContainer(getRMContainer(containerExpiredEvent.getContainerId()), \n+          RMContainerEventType.EXPIRE);\n+    }\n+    break;\n+    default:\n+      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent event) {\n    switch(event.getType()) {\n    case NODE_ADDED:\n    {\n      NodeAddedSchedulerEvent nodeAddedEvent \u003d (NodeAddedSchedulerEvent)event;\n      addNode(nodeAddedEvent.getAddedRMNode());\n    }\n    break;\n    case NODE_REMOVED:\n    {\n      NodeRemovedSchedulerEvent nodeRemovedEvent \u003d (NodeRemovedSchedulerEvent)event;\n      removeNode(nodeRemovedEvent.getRemovedRMNode());\n    }\n    break;\n    case NODE_UPDATE:\n    {\n      NodeUpdateSchedulerEvent nodeUpdatedEvent \u003d (NodeUpdateSchedulerEvent)event;\n      nodeUpdate(nodeUpdatedEvent.getRMNode(), \n          nodeUpdatedEvent.getContainers());\n    }\n    break;\n    case APP_ADDED:\n    {\n      AppAddedSchedulerEvent appAddedEvent \u003d (AppAddedSchedulerEvent)event;\n      addApplication(appAddedEvent.getApplicationAttemptId(), appAddedEvent\n          .getQueue(), appAddedEvent.getUser());\n    }\n    break;\n    case APP_REMOVED:\n    {\n      AppRemovedSchedulerEvent appRemovedEvent \u003d (AppRemovedSchedulerEvent)event;\n      doneApplication(appRemovedEvent.getApplicationAttemptID(),\n          appRemovedEvent.getFinalAttemptState());\n    }\n    break;\n    case CONTAINER_EXPIRED:\n    {\n      ContainerExpiredSchedulerEvent containerExpiredEvent \u003d \n          (ContainerExpiredSchedulerEvent) event;\n      completedContainer(getRMContainer(containerExpiredEvent.getContainerId()), \n          RMContainerEventType.EXPIRE);\n    }\n    break;\n    default:\n      LOG.error(\"Invalid eventtype \" + event.getType() + \". Ignoring!\");\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}