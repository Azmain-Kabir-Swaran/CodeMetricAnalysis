{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultContainerExecutor.java",
  "functionName": "launchContainer",
  "functionId": "launchContainer___ctx-ContainerStartContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
  "functionStartLine": 216,
  "functionEndLine": 358,
  "numCommitsSeen": 110,
  "timeTaken": 13728,
  "changeHistory": [
    "f7df55f4a89ed2d75d874b32209647ef4f448875",
    "95372657fc25c02399b01793833021ccf88dada2",
    "c2288ac45b748b4119442c46147ccc324926c340",
    "c071aad5da6f6601978e73d38ce5813958848bc4",
    "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4",
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
    "f5d92359145dfb820a9521e00e2d44c4ee96e67e",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "53fafcf061616516c24e2e2007a66a93d23d3e25",
    "21101c01f242439ec8ec40fb3a9ab1991ae0adc7",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769",
    "537c361f5bc888dd74fbe59afe18d08d0746894f",
    "ef1f556cef43cb1ca59ea42506d2389d02514a3e",
    "7a29bccd7aaf2eb33adac937379ba6be43a1031d",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "5f2c518c95b2186b784877a5f41c7b71f8abc2f6",
    "638801cce16fc1dc3259c541dc30a599faaddda1",
    "9385dd50c7f21dae40f0c341e2ca89246604e41a",
    "bfe3816c66de2684ab92dd7be43385fa57d27892",
    "9ef3b2eb60b2c773d35896225d051b523e406ae2",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "76b653a36738a4f420f14c53c7a0a4006dbf066e",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "fafe8cd28e726566509c679e19d7da622f29f90d",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "f7df55f4a89ed2d75d874b32209647ef4f448875": "Ybodychange",
    "95372657fc25c02399b01793833021ccf88dada2": "Ybodychange",
    "c2288ac45b748b4119442c46147ccc324926c340": "Ybodychange",
    "c071aad5da6f6601978e73d38ce5813958848bc4": "Ybodychange",
    "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4": "Ybodychange",
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592": "Yexceptionschange",
    "f5d92359145dfb820a9521e00e2d44c4ee96e67e": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "53fafcf061616516c24e2e2007a66a93d23d3e25": "Ymultichange(Yparameterchange,Ybodychange)",
    "21101c01f242439ec8ec40fb3a9ab1991ae0adc7": "Ybodychange",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": "Ymultichange(Yparameterchange,Ybodychange)",
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769": "Ybodychange",
    "537c361f5bc888dd74fbe59afe18d08d0746894f": "Ybodychange",
    "ef1f556cef43cb1ca59ea42506d2389d02514a3e": "Ybodychange",
    "7a29bccd7aaf2eb33adac937379ba6be43a1031d": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "5f2c518c95b2186b784877a5f41c7b71f8abc2f6": "Ybodychange",
    "638801cce16fc1dc3259c541dc30a599faaddda1": "Ybodychange",
    "9385dd50c7f21dae40f0c341e2ca89246604e41a": "Ybodychange",
    "bfe3816c66de2684ab92dd7be43385fa57d27892": "Ybodychange",
    "9ef3b2eb60b2c773d35896225d051b523e406ae2": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "76b653a36738a4f420f14c53c7a0a4006dbf066e": "Ybodychange",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": "Ybodychange",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": "Ybodychange",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "fafe8cd28e726566509c679e19d7da622f29f90d": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f7df55f4a89ed2d75d874b32209647ef4f448875": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9602. Use logger format in Container Executor. Contributed by Abhishek Modi.\n",
      "commitDate": "11/06/19 9:59 AM",
      "commitName": "f7df55f4a89ed2d75d874b32209647ef4f448875",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 87.73,
      "commitsBetweenForRepo": 542,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,143 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     Path nmPrivateKeystorePath \u003d ctx.getNmPrivateKeystorePath();\n     Path nmPrivateTruststorePath \u003d ctx.getNmPrivateTruststorePath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n             containerId.getApplicationAttemptId().\n                 getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     if (nmPrivateKeystorePath !\u003d null) {\n       Path keystoreDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.KEYSTORE_FILE);\n       copyFile(nmPrivateKeystorePath, keystoreDst, user);\n     }\n \n     if (nmPrivateTruststorePath !\u003d null) {\n       Path truststoreDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.TRUSTSTORE_FILE);\n       copyFile(nmPrivateTruststorePath, truststoreDst, user);\n     }\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n-      LOG.info(\"Container \" + containerIdStr\n-          + \" pid file not set. Returning terminated error\");\n+      LOG.info(\"Container {} pid file not set. Returning terminated error\",\n+          containerIdStr);\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       } else {\n-        LOG.info(\"Container \" + containerIdStr +\n-            \" was marked as inactive. Returning terminated error\");\n+        LOG.info(\"Container {} was marked as inactive. \"\n+            + \"Returning terminated error\", containerIdStr);\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n-      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n+      LOG.warn(\"Exit code from container {} is : {}\", containerId, exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n-        LOG.warn(\"Exception from container-launch with container ID: \"\n-            + containerId + \" and exit code: \" + exitCode , e);\n+        LOG.warn(\"Exception from container-launch with container ID: {}\"\n+            + \" and exit code: {}\", containerId, exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\")\n             .append(\"Container id: \").append(containerId).append(\"\\n\")\n             .append(\"Exit code: \").append(exitCode).append(\"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \")\n               .append(e.getMessage()).append(\"\\n\");\n         }\n \n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \")\n               .append(shExec.getOutput()).append(\"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    Path nmPrivateKeystorePath \u003d ctx.getNmPrivateKeystorePath();\n    Path nmPrivateTruststorePath \u003d ctx.getNmPrivateTruststorePath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    if (nmPrivateKeystorePath !\u003d null) {\n      Path keystoreDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.KEYSTORE_FILE);\n      copyFile(nmPrivateKeystorePath, keystoreDst, user);\n    }\n\n    if (nmPrivateTruststorePath !\u003d null) {\n      Path truststoreDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.TRUSTSTORE_FILE);\n      copyFile(nmPrivateTruststorePath, truststoreDst, user);\n    }\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container {} pid file not set. Returning terminated error\",\n          containerIdStr);\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      } else {\n        LOG.info(\"Container {} was marked as inactive. \"\n            + \"Returning terminated error\", containerIdStr);\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container {} is : {}\", containerId, exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: {}\"\n            + \" and exit code: {}\", containerId, exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\")\n            .append(\"Container id: \").append(containerId).append(\"\\n\")\n            .append(\"Exit code: \").append(exitCode).append(\"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \")\n              .append(e.getMessage()).append(\"\\n\");\n        }\n\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \")\n              .append(shExec.getOutput()).append(\"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "95372657fc25c02399b01793833021ccf88dada2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9287. Consecutive StringBuilder append should be reuse. Contributed by Ayush Saxena.\n",
      "commitDate": "25/02/19 11:45 AM",
      "commitName": "95372657fc25c02399b01793833021ccf88dada2",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "14/11/18 12:22 PM",
      "commitNameOld": "21ec4bdaef4b68adbbf4f33a6f74494c074f803c",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 102.97,
      "commitsBetweenForRepo": 715,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,143 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     Path nmPrivateKeystorePath \u003d ctx.getNmPrivateKeystorePath();\n     Path nmPrivateTruststorePath \u003d ctx.getNmPrivateTruststorePath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n             containerId.getApplicationAttemptId().\n                 getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     if (nmPrivateKeystorePath !\u003d null) {\n       Path keystoreDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.KEYSTORE_FILE);\n       copyFile(nmPrivateKeystorePath, keystoreDst, user);\n     }\n \n     if (nmPrivateTruststorePath !\u003d null) {\n       Path truststoreDst \u003d\n           new Path(containerWorkDir, ContainerLaunch.TRUSTSTORE_FILE);\n       copyFile(nmPrivateTruststorePath, truststoreDst, user);\n     }\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" pid file not set. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       } else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n-        builder.append(\"Exception from container-launch.\\n\");\n-        builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n-        builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n+        builder.append(\"Exception from container-launch.\\n\")\n+            .append(\"Container id: \").append(containerId).append(\"\\n\")\n+            .append(\"Exit code: \").append(exitCode).append(\"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n-          builder.append(\"Exception message: \");\n-          builder.append(e.getMessage()).append(\"\\n\");\n+          builder.append(\"Exception message: \")\n+              .append(e.getMessage()).append(\"\\n\");\n         }\n \n         if (!shExec.getOutput().isEmpty()) {\n-          builder.append(\"Shell output: \");\n-          builder.append(shExec.getOutput()).append(\"\\n\");\n+          builder.append(\"Shell output: \")\n+              .append(shExec.getOutput()).append(\"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    Path nmPrivateKeystorePath \u003d ctx.getNmPrivateKeystorePath();\n    Path nmPrivateTruststorePath \u003d ctx.getNmPrivateTruststorePath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    if (nmPrivateKeystorePath !\u003d null) {\n      Path keystoreDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.KEYSTORE_FILE);\n      copyFile(nmPrivateKeystorePath, keystoreDst, user);\n    }\n\n    if (nmPrivateTruststorePath !\u003d null) {\n      Path truststoreDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.TRUSTSTORE_FILE);\n      copyFile(nmPrivateTruststorePath, truststoreDst, user);\n    }\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" pid file not set. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      } else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\")\n            .append(\"Container id: \").append(containerId).append(\"\\n\")\n            .append(\"Exit code: \").append(exitCode).append(\"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \")\n              .append(e.getMessage()).append(\"\\n\");\n        }\n\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \")\n              .append(shExec.getOutput()).append(\"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "c2288ac45b748b4119442c46147ccc324926c340": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8448. AM HTTPS Support for AM communication with RMWeb proxy. (Contributed by Robert Kanter)\n",
      "commitDate": "16/10/18 1:36 PM",
      "commitName": "c2288ac45b748b4119442c46147ccc324926c340",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "08/10/18 10:56 AM",
      "commitNameOld": "347ea385817766a5c418017009728cd8b9959776",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.11,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,143 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n+    Path nmPrivateKeystorePath \u003d ctx.getNmPrivateKeystorePath();\n+    Path nmPrivateTruststorePath \u003d ctx.getNmPrivateTruststorePath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n             containerId.getApplicationAttemptId().\n                 getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n+    if (nmPrivateKeystorePath !\u003d null) {\n+      Path keystoreDst \u003d\n+          new Path(containerWorkDir, ContainerLaunch.KEYSTORE_FILE);\n+      copyFile(nmPrivateKeystorePath, keystoreDst, user);\n+    }\n+\n+    if (nmPrivateTruststorePath !\u003d null) {\n+      Path truststoreDst \u003d\n+          new Path(containerWorkDir, ContainerLaunch.TRUSTSTORE_FILE);\n+      copyFile(nmPrivateTruststorePath, truststoreDst, user);\n+    }\n+\n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" pid file not set. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       } else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n         builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \");\n           builder.append(e.getMessage()).append(\"\\n\");\n         }\n \n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \");\n           builder.append(shExec.getOutput()).append(\"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    Path nmPrivateKeystorePath \u003d ctx.getNmPrivateKeystorePath();\n    Path nmPrivateTruststorePath \u003d ctx.getNmPrivateTruststorePath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    if (nmPrivateKeystorePath !\u003d null) {\n      Path keystoreDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.KEYSTORE_FILE);\n      copyFile(nmPrivateKeystorePath, keystoreDst, user);\n    }\n\n    if (nmPrivateTruststorePath !\u003d null) {\n      Path truststoreDst \u003d\n          new Path(containerWorkDir, ContainerLaunch.TRUSTSTORE_FILE);\n      copyFile(nmPrivateTruststorePath, truststoreDst, user);\n    }\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" pid file not set. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      } else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n        builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \");\n          builder.append(e.getMessage()).append(\"\\n\");\n        }\n\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \");\n          builder.append(shExec.getOutput()).append(\"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "c071aad5da6f6601978e73d38ce5813958848bc4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7009. TestNMClient.testNMClientNoCleanupOnStop is flaky by design.  (Miklos Szegedi via Haibo Chen)\n",
      "commitDate": "05/10/17 3:50 PM",
      "commitName": "c071aad5da6f6601978e73d38ce5813958848bc4",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "29/09/17 4:39 PM",
      "commitNameOld": "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 5.97,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,129 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n             containerId.getApplicationAttemptId().\n                 getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n-          + \" was marked as inactive. Returning terminated error\");\n+          + \" pid file not set. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       } else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n         builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \");\n           builder.append(e.getMessage()).append(\"\\n\");\n         }\n \n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \");\n           builder.append(shExec.getOutput()).append(\"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" pid file not set. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      } else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n        builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \");\n          builder.append(e.getMessage()).append(\"\\n\");\n        }\n\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \");\n          builder.append(shExec.getOutput()).append(\"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6550. Capture launch_container.sh logs to a separate log file. (Suma Shivaprasad via wangda)\n\nChange-Id: I0ee0b1bb459437432a22cf68861a6354f0decabb\n",
      "commitDate": "29/09/17 4:39 PM",
      "commitName": "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 38.64,
      "commitsBetweenForRepo": 388,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,129 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n             containerId.getApplicationAttemptId().\n                 getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       } else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n         builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \");\n           builder.append(e.getMessage()).append(\"\\n\");\n         }\n-        builder.append(\"Stack trace: \");\n-        builder.append(StringUtils.stringifyException(e)).append(\"\\n\");\n+\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \");\n           builder.append(shExec.getOutput()).append(\"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      } else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n        builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \");\n          builder.append(e.getMessage()).append(\"\\n\");\n        }\n\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \");\n          builder.append(shExec.getOutput()).append(\"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-6302. Fail the node if Linux Container Executor is not configured properly\n(Contributed by Miklos Szegedi via Daniel Templeton)\n",
      "commitDate": "19/04/17 12:23 PM",
      "commitName": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "01/11/16 2:21 AM",
      "commitNameOld": "310aa4686eb697f0700a71d33106514c404dab1b",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 169.42,
      "commitsBetweenForRepo": 977,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,130 @@\n-  public int launchContainer(ContainerStartContext ctx) throws IOException {\n+  public int launchContainer(ContainerStartContext ctx)\n+      throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n             containerId.getApplicationAttemptId().\n                 getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n-      }\n-      else {\n+      } else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n         builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \");\n           builder.append(e.getMessage()).append(\"\\n\");\n         }\n         builder.append(\"Stack trace: \");\n         builder.append(StringUtils.stringifyException(e)).append(\"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \");\n           builder.append(shExec.getOutput()).append(\"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      } else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n        builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \");\n          builder.append(e.getMessage()).append(\"\\n\");\n        }\n        builder.append(\"Stack trace: \");\n        builder.append(StringUtils.stringifyException(e)).append(\"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \");\n          builder.append(shExec.getOutput()).append(\"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {
        "oldValue": "[IOException]",
        "newValue": "[IOException, ConfigurationException]"
      }
    },
    "f5d92359145dfb820a9521e00e2d44c4ee96e67e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5466. DefaultContainerExecutor needs JavaDocs (templedf via rkanter)\n",
      "commitDate": "17/10/16 2:29 PM",
      "commitName": "f5d92359145dfb820a9521e00e2d44c4ee96e67e",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "15/09/16 7:15 AM",
      "commitNameOld": "40b5a59b726733df456330a26f03d5174cc0bc1c",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 32.3,
      "commitsBetweenForRepo": 223,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,130 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n             containerId.getApplicationAttemptId().\n                 getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n-        builder.append(\"Container id: \" + containerId + \"\\n\");\n-        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n+        builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n+        builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n-          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n+          builder.append(\"Exception message: \");\n+          builder.append(e.getMessage()).append(\"\\n\");\n         }\n-        builder.append(\"Stack trace: \"\n-            + StringUtils.stringifyException(e) + \"\\n\");\n+        builder.append(\"Stack trace: \");\n+        builder.append(StringUtils.stringifyException(e)).append(\"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n-          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n+          builder.append(\"Shell output: \");\n+          builder.append(shExec.getOutput()).append(\"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \").append(containerId).append(\"\\n\");\n        builder.append(\"Exit code: \").append(exitCode).append(\"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \");\n          builder.append(e.getMessage()).append(\"\\n\");\n        }\n        builder.append(\"Stack trace: \");\n        builder.append(StringUtils.stringifyException(e)).append(\"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \");\n          builder.append(shExec.getOutput()).append(\"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "25/05/16 6:31 AM",
      "commitNameOld": "c380a22031a62e2d2fe533079e3780f06b069943",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 20.36,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,128 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n-    String containerIdStr \u003d ConverterUtils.toString(containerId);\n+    String containerIdStr \u003d containerId.toString();\n     String appIdStr \u003d\n-        ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n-                getApplicationId());\n+                getApplicationId().toString();\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d containerId.toString();\n    String appIdStr \u003d\n            containerId.getApplicationAttemptId().\n                getApplicationId().toString();\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "53fafcf061616516c24e2e2007a66a93d23d3e25": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
      "commitDate": "21/05/15 3:50 PM",
      "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
          "commitDate": "21/05/15 3:50 PM",
          "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "06/03/15 2:18 PM",
          "commitNameOld": "21101c01f242439ec8ec40fb3a9ab1991ae0adc7",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 76.02,
          "commitsBetweenForRepo": 745,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,125 +1,129 @@\n-  public int launchContainer(Container container,\n-      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n-      String user, String appId, Path containerWorkDir,\n-      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n-    \n+  public int launchContainer(ContainerStartContext ctx) throws IOException {\n+    Container container \u003d ctx.getContainer();\n+    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n+    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n+    String user \u003d ctx.getUser();\n+    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n+    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n+    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n+\n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[container-Container, nmPrivateContainerScriptPath-Path, nmPrivateTokensPath-Path, user-String, appId-String, containerWorkDir-Path, localDirs-List\u003cString\u003e, logDirs-List\u003cString\u003e]",
            "newValue": "[ctx-ContainerStartContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
          "commitDate": "21/05/15 3:50 PM",
          "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "06/03/15 2:18 PM",
          "commitNameOld": "21101c01f242439ec8ec40fb3a9ab1991ae0adc7",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 76.02,
          "commitsBetweenForRepo": 745,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,125 +1,129 @@\n-  public int launchContainer(Container container,\n-      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n-      String user, String appId, Path containerWorkDir,\n-      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n-    \n+  public int launchContainer(ContainerStartContext ctx) throws IOException {\n+    Container container \u003d ctx.getContainer();\n+    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n+    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n+    String user \u003d ctx.getUser();\n+    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n+    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n+    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n+\n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n           containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "21101c01f242439ec8ec40fb3a9ab1991ae0adc7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2190. Added CPU and memory limit options to the default container executor for Windows containers. Contributed by Chuan Liu\n",
      "commitDate": "06/03/15 2:18 PM",
      "commitName": "21101c01f242439ec8ec40fb3a9ab1991ae0adc7",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/12/14 8:32 PM",
      "commitNameOld": "41a548a916d4248164cb9495320f123ec215d70e",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 72.74,
      "commitsBetweenForRepo": 556,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n     \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false, user);\n \n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     copyFile(nmPrivateTokensPath, tokenDst, user);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n     \n     // create log dir under app\n     // fork script\n     Shell.CommandExecutor shExec \u003d null;\n     try {\n       setScriptExecutable(launchDst, user);\n       setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n       shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n-          containerIdStr, user, pidFile,\n+          containerIdStr, user, pidFile, container.getResource(),\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());\n       \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n    \n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile, container.getResource(),\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
      "commitDate": "22/10/14 3:57 PM",
      "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/10/14 6:14 PM",
          "commitNameOld": "0fd0ebae645e671699f6a6a56a012ebe6dfb5b2a",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 5.91,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,125 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n-      String userName, String appId, Path containerWorkDir,\n+      String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n-\n+    \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n-      Path userdir \u003d new Path(usersdir, userName);\n+      Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n-      createDir(containerDir, dirPerm, true, userName);\n+      createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n-    createContainerLogDirs(appIdStr, containerIdStr, logDirs, userName);\n+    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n-    createDir(tmpDir, dirPerm, false, userName);\n+    createDir(tmpDir, dirPerm, false, user);\n \n-    // copy launch script to work dir\n-    Path launchDst \u003d\n-        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n-    copyFile(nmPrivateContainerScriptPath, launchDst, userName);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n-    copyFile(nmPrivateTokensPath, tokenDst, userName);\n+    copyFile(nmPrivateTokensPath, tokenDst, user);\n+\n+    // copy launch script to work dir\n+    Path launchDst \u003d\n+        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n+    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n-\n+    \n     // create log dir under app\n     // fork script\n-    ShellCommandExecutor shExec \u003d null;\n+    Shell.CommandExecutor shExec \u003d null;\n     try {\n-      setScriptExecutable(launchDst, userName);\n-      setScriptExecutable(sb.getWrapperScriptPath(), userName);\n+      setScriptExecutable(launchDst, user);\n+      setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n-      // Setup command to run\n-      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n-        containerIdStr, userName, pidFile, this.getConf());\n-\n-      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n-      shExec \u003d new ShellCommandExecutor(\n-          command,\n+      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n+          containerIdStr, user, pidFile,\n           new File(containerWorkDir.toUri().getPath()),\n-          container.getLaunchContext().getEnvironment());      // sanitized env\n+          container.getLaunchContext().getEnvironment());\n+      \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n-      ; //\n+      if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n    \n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[container-Container, nmPrivateContainerScriptPath-Path, nmPrivateTokensPath-Path, userName-String, appId-String, containerWorkDir-Path, localDirs-List\u003cString\u003e, logDirs-List\u003cString\u003e]",
            "newValue": "[container-Container, nmPrivateContainerScriptPath-Path, nmPrivateTokensPath-Path, user-String, appId-String, containerWorkDir-Path, localDirs-List\u003cString\u003e, logDirs-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/10/14 6:14 PM",
          "commitNameOld": "0fd0ebae645e671699f6a6a56a012ebe6dfb5b2a",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 5.91,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,125 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n-      String userName, String appId, Path containerWorkDir,\n+      String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n-\n+    \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n-      Path userdir \u003d new Path(usersdir, userName);\n+      Path userdir \u003d new Path(usersdir, user);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n-      createDir(containerDir, dirPerm, true, userName);\n+      createDir(containerDir, dirPerm, true, user);\n     }\n \n     // Create the container log-dirs on all disks\n-    createContainerLogDirs(appIdStr, containerIdStr, logDirs, userName);\n+    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n-    createDir(tmpDir, dirPerm, false, userName);\n+    createDir(tmpDir, dirPerm, false, user);\n \n-    // copy launch script to work dir\n-    Path launchDst \u003d\n-        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n-    copyFile(nmPrivateContainerScriptPath, launchDst, userName);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n-    copyFile(nmPrivateTokensPath, tokenDst, userName);\n+    copyFile(nmPrivateTokensPath, tokenDst, user);\n+\n+    // copy launch script to work dir\n+    Path launchDst \u003d\n+        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n+    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n         containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n-\n+    \n     // create log dir under app\n     // fork script\n-    ShellCommandExecutor shExec \u003d null;\n+    Shell.CommandExecutor shExec \u003d null;\n     try {\n-      setScriptExecutable(launchDst, userName);\n-      setScriptExecutable(sb.getWrapperScriptPath(), userName);\n+      setScriptExecutable(launchDst, user);\n+      setScriptExecutable(sb.getWrapperScriptPath(), user);\n \n-      // Setup command to run\n-      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n-        containerIdStr, userName, pidFile, this.getConf());\n-\n-      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n-      shExec \u003d new ShellCommandExecutor(\n-          command,\n+      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n+          containerIdStr, user, pidFile,\n           new File(containerWorkDir.toUri().getPath()),\n-          container.getLaunchContext().getEnvironment());      // sanitized env\n+          container.getLaunchContext().getEnvironment());\n+      \n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n-      ; //\n+      if (shExec !\u003d null) shExec.close();\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n    \n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, user);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, user);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, user);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, user);\n\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, user);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, user);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    // create log dir under app\n    // fork script\n    Shell.CommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, user);\n      setScriptExecutable(sb.getWrapperScriptPath(), user);\n\n      shExec \u003d buildCommandExecutor(sb.getWrapperScriptPath().toString(),\n          containerIdStr, user, pidFile,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());\n      \n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec !\u003d null) shExec.close();\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1972. Added a secure container-executor for Windows. Contributed by Remus Rusanu.\n",
      "commitDate": "01/10/14 10:14 AM",
      "commitName": "ba7f31c2ee8d23ecb183f88920ef06053c0b9769",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/08/14 3:56 AM",
      "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 50.26,
      "commitsBetweenForRepo": 539,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,128 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n-      createDir(containerDir, dirPerm, true);\n+      createDir(containerDir, dirPerm, true, userName);\n     }\n \n     // Create the container log-dirs on all disks\n-    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n+    createContainerLogDirs(appIdStr, containerIdStr, logDirs, userName);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n-    createDir(tmpDir, dirPerm, false);\n+    createDir(tmpDir, dirPerm, false, userName);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n-    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n+    copyFile(nmPrivateContainerScriptPath, launchDst, userName);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n-    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n+    copyFile(nmPrivateTokensPath, tokenDst, userName);\n \n     // Create new local launch wrapper script\n-    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n-      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n-      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n+    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n+        containerIdStr, containerWorkDir); \n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n-      lfs.setPermission(launchDst,\n-          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n-      lfs.setPermission(sb.getWrapperScriptPath(),\n-          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n+      setScriptExecutable(launchDst, userName);\n+      setScriptExecutable(sb.getWrapperScriptPath(), userName);\n \n       // Setup command to run\n       String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n-        containerIdStr, this.getConf());\n+        containerIdStr, userName, pidFile, this.getConf());\n \n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, userName);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, userName);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, userName);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    copyFile(nmPrivateContainerScriptPath, launchDst, userName);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    copyFile(nmPrivateTokensPath, tokenDst, userName);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d getLocalWrapperScriptBuilder(\n        containerIdStr, containerWorkDir); \n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      setScriptExecutable(launchDst, userName);\n      setScriptExecutable(sb.getWrapperScriptPath(), userName);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, userName, pidFile, this.getConf());\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "537c361f5bc888dd74fbe59afe18d08d0746894f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2013. The diagnostics is always the ExitCodeException stack when the container crashes. (Contributed by Tsuyoshi OZAWA)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612449 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/07/14 8:01 PM",
      "commitName": "537c361f5bc888dd74fbe59afe18d08d0746894f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "05/12/13 4:25 PM",
      "commitNameOld": "ef1f556cef43cb1ca59ea42506d2389d02514a3e",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 228.11,
      "commitsBetweenForRepo": 1528,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,131 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n       new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n       new UnixLocalWrapperScriptBuilder(containerWorkDir);\n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(sb.getWrapperScriptPath(),\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n         containerIdStr, this.getConf());\n \n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n-        logOutput(shExec.getOutput());\n-        String diagnostics \u003d \"Exception from container-launch: \"\n-            + e + \"\\n\"\n-            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n+\n+        StringBuilder builder \u003d new StringBuilder();\n+        builder.append(\"Exception from container-launch.\\n\");\n+        builder.append(\"Container id: \" + containerId + \"\\n\");\n+        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n+        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n+          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n+        }\n+        builder.append(\"Stack trace: \"\n+            + StringUtils.stringifyException(e) + \"\\n\");\n+        if (!shExec.getOutput().isEmpty()) {\n+          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n+        }\n+        String diagnostics \u003d builder.toString();\n+        logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, this.getConf());\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "ef1f556cef43cb1ca59ea42506d2389d02514a3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1438. Ensure container diagnostics includes exception from container launch. Contributed by Steve Loughran.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548336 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/12/13 4:25 PM",
      "commitName": "ef1f556cef43cb1ca59ea42506d2389d02514a3e",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "15/10/13 2:14 PM",
      "commitNameOld": "6a55ed333a802e56b710d2aea1c5e25b51cd63fb",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.13,
      "commitsBetweenForRepo": 286,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,120 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n       new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n       new UnixLocalWrapperScriptBuilder(containerWorkDir);\n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(sb.getWrapperScriptPath(),\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n         containerIdStr, this.getConf());\n \n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n         logOutput(shExec.getOutput());\n-        String diagnostics \u003d \"Exception from container-launch: \\n\"\n+        String diagnostics \u003d \"Exception from container-launch: \"\n+            + e + \"\\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, this.getConf());\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \"\n            + e + \"\\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "7a29bccd7aaf2eb33adac937379ba6be43a1031d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-814. Improving diagnostics when containers fail during launch due to various reasons like invalid env etc. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504732 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 5:28 PM",
      "commitName": "7a29bccd7aaf2eb33adac937379ba6be43a1031d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/05/13 9:13 PM",
      "commitNameOld": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 48.84,
      "commitsBetweenForRepo": 322,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,119 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n       new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n       new UnixLocalWrapperScriptBuilder(containerWorkDir);\n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(sb.getWrapperScriptPath(),\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n         containerIdStr, this.getConf());\n \n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n-      LOG.warn(\"Exit code from task is : \" + exitCode);\n-      String message \u003d shExec.getOutput();\n-      logOutput(message);\n-      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n-          message));\n+      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n+      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n+      // terminated/killed forcefully. In all other cases, log the\n+      // container-executor\u0027s output\n+      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n+          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n+        LOG.warn(\"Exception from container-launch with container ID: \"\n+            + containerId + \" and exit code: \" + exitCode , e);\n+        logOutput(shExec.getOutput());\n+        String diagnostics \u003d \"Exception from container-launch: \\n\"\n+            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n+        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n+            diagnostics));\n+      } else {\n+        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n+            \"Container killed on request. Exit code is \" + exitCode));\n+      }\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, this.getConf());\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/04/13 2:39 PM",
      "commitNameOld": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 37.27,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n-    ContainerId containerId \u003d container.getContainer().getId();\n+    ContainerId containerId \u003d container.getContainerId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n       new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n       new UnixLocalWrapperScriptBuilder(containerWorkDir);\n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(sb.getWrapperScriptPath(),\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n         containerIdStr, this.getConf());\n \n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, this.getConf());\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/04/13 7:14 PM",
      "commitNameOld": "44bf8525a591b56b5c09cd4201bd193516ea9530",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.81,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n-    ContainerId containerId \u003d container.getContainerID();\n+    ContainerId containerId \u003d container.getContainer().getId();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n-            container.getContainerID().getApplicationAttemptId().\n+            containerId.getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n       new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n       new UnixLocalWrapperScriptBuilder(containerWorkDir);\n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(sb.getWrapperScriptPath(),\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n         containerIdStr, this.getConf());\n \n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainer().getId();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, this.getConf());\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "5f2c518c95b2186b784877a5f41c7b71f8abc2f6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-443. allow OS scheduling priority of NM to be different than the containers it launches (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1454411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/13 6:46 AM",
      "commitName": "5f2c518c95b2186b784877a5f41c7b71f8abc2f6",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "06/03/13 11:15 AM",
      "commitNameOld": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 1.81,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n       new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n       new UnixLocalWrapperScriptBuilder(containerWorkDir);\n \n     // Fail fast if attempting to launch the wrapper script would fail due to\n     // Windows path length limitation.\n     if (Shell.WINDOWS \u0026\u0026\n         sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n       throw new IOException(String.format(\n         \"Cannot launch container using script at path %s, because it exceeds \" +\n         \"the maximum supported path length of %d characters.  Consider \" +\n         \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n         WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n     }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(sb.getWrapperScriptPath(),\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n-        containerIdStr);\n+        containerIdStr, this.getConf());\n \n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, this.getConf());\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "638801cce16fc1dc3259c541dc30a599faaddda1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/03/13 11:15 AM",
      "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "08/01/13 5:20 AM",
      "commitNameOld": "9385dd50c7f21dae40f0c341e2ca89246604e41a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 57.25,
      "commitsBetweenForRepo": 261,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,107 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n-    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n-    DataOutputStream wrapperScriptOutStream \u003d\n-        lfs.create(wrapperScriptDst,\n-            EnumSet.of(CREATE, OVERWRITE));\n+    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n+      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n+      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n+\n+    // Fail fast if attempting to launch the wrapper script would fail due to\n+    // Windows path length limitation.\n+    if (Shell.WINDOWS \u0026\u0026\n+        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n+      throw new IOException(String.format(\n+        \"Cannot launch container using script at path %s, because it exceeds \" +\n+        \"the maximum supported path length of %d characters.  Consider \" +\n+        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n+        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n+    }\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n-      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n-          .getPath().toString(), pidFile.toString());\n+      sb.writeLocalWrapperScript(launchDst, pidFile);\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n-      lfs.setPermission(wrapperScriptDst,\n+      lfs.setPermission(sb.getWrapperScriptPath(),\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n-      String[] command \u003d {\"bash\",\n-          wrapperScriptDst.toUri().getPath().toString()};\n+      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n+        containerIdStr);\n+\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb \u003d Shell.WINDOWS ?\n      new WindowsLocalWrapperScriptBuilder(containerIdStr, containerWorkDir) :\n      new UnixLocalWrapperScriptBuilder(containerWorkDir);\n\n    // Fail fast if attempting to launch the wrapper script would fail due to\n    // Windows path length limitation.\n    if (Shell.WINDOWS \u0026\u0026\n        sb.getWrapperScriptPath().toString().length() \u003e WIN_MAX_PATH) {\n      throw new IOException(String.format(\n        \"Cannot launch container using script at path %s, because it exceeds \" +\n        \"the maximum supported path length of %d characters.  Consider \" +\n        \"configuring shorter directories in %s.\", sb.getWrapperScriptPath(),\n        WIN_MAX_PATH, YarnConfiguration.NM_LOCAL_DIRS));\n    }\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr);\n\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "9385dd50c7f21dae40f0c341e2ca89246604e41a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-253. Fixed container-launch to not fail when there are no local resources to localize. Contributed by Tom White.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430269 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 5:20 AM",
      "commitName": "9385dd50c7f21dae40f0c341e2ca89246604e41a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/09/12 10:29 AM",
      "commitNameOld": "bfe3816c66de2684ab92dd7be43385fa57d27892",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 108.83,
      "commitsBetweenForRepo": 510,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n-      createDir(containerDir, dirPerm, false);\n+      createDir(containerDir, dirPerm, true);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n     DataOutputStream wrapperScriptOutStream \u003d\n         lfs.create(wrapperScriptDst,\n             EnumSet.of(CREATE, OVERWRITE));\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n           .getPath().toString(), pidFile.toString());\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(wrapperScriptDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d {\"bash\",\n           wrapperScriptDst.toUri().getPath().toString()};\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "bfe3816c66de2684ab92dd7be43385fa57d27892": {
      "type": "Ybodychange",
      "commitMessage": "YARN-88. DefaultContainerExecutor can fail to set proper permissions. (Contributed by Jason Lowe)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1388580 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/09/12 10:29 AM",
      "commitName": "bfe3816c66de2684ab92dd7be43385fa57d27892",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/08/12 11:24 AM",
      "commitNameOld": "9ef3b2eb60b2c773d35896225d051b523e406ae2",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 28.96,
      "commitsBetweenForRepo": 157,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,97 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n+    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n-      lfs.mkdir(containerDir, null, false);\n+      createDir(containerDir, dirPerm, false);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n-    lfs.mkdir(tmpDir, null, false);\n+    createDir(tmpDir, dirPerm, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n     DataOutputStream wrapperScriptOutStream \u003d\n         lfs.create(wrapperScriptDst,\n             EnumSet.of(CREATE, OVERWRITE));\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n           .getPath().toString(), pidFile.toString());\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(wrapperScriptDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d {\"bash\",\n           wrapperScriptDst.toUri().getPath().toString()};\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    FsPermission dirPerm \u003d new FsPermission(APPDIR_PERM);\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "9ef3b2eb60b2c773d35896225d051b523e406ae2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2374. \"Text File Busy\" errors launching MR tasks. Contributed by Andy Isaacson.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1376632 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/08/12 11:24 AM",
      "commitName": "9ef3b2eb60b2c773d35896225d051b523e406ae2",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 15.54,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,96 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     Path tmpDir \u003d new Path(containerWorkDir,\n         YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n     lfs.mkdir(tmpDir, null, false);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n     DataOutputStream wrapperScriptOutStream \u003d\n         lfs.create(wrapperScriptDst,\n             EnumSet.of(CREATE, OVERWRITE));\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n           .getPath().toString(), pidFile.toString());\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(wrapperScriptDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n-      String[] command \u003d {\"bash\", \"-c\",\n+      String[] command \u003d {\"bash\",\n           wrapperScriptDst.toUri().getPath().toString()};\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    lfs.mkdir(tmpDir, null, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    lfs.mkdir(tmpDir, null, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\", \"-c\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java"
      }
    },
    "76b653a36738a4f420f14c53c7a0a4006dbf066e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3716. Fixing YARN+MR to allow MR jobs to be able to use java.io.File.createTempFile to create temporary files as part of their tasks. Contributed by Jonathan Eagles.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1238136 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/12 6:23 PM",
      "commitName": "76b653a36738a4f420f14c53c7a0a4006dbf066e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/12/11 10:33 PM",
      "commitNameOld": "f611e1d1b116613a8fce0abc400e54e155d295e9",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 48.83,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,96 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n     for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n+    Path tmpDir \u003d new Path(containerWorkDir,\n+        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n+    lfs.mkdir(tmpDir, null, false);\n+\n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n     DataOutputStream wrapperScriptOutStream \u003d\n         lfs.create(wrapperScriptDst,\n             EnumSet.of(CREATE, OVERWRITE));\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n           .getPath().toString(), pidFile.toString());\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(wrapperScriptDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d {\"bash\", \"-c\",\n           wrapperScriptDst.toUri().getPath().toString()};\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    Path tmpDir \u003d new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    lfs.mkdir(tmpDir, null, false);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\", \"-c\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/11/11 3:17 PM",
          "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "15/11/11 2:30 AM",
          "commitNameOld": "c56e05196190f172e9c8cdcd9d59d09950f1419b",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.53,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,92 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n-      String userName, String appId, Path containerWorkDir)\n-      throws IOException {\n+      String userName, String appId, Path containerWorkDir,\n+      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n-    String[] sLocalDirs \u003d getConf().getStrings(\n-        YarnConfiguration.NM_LOCAL_DIRS,\n-        YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n-    for (String sLocalDir : sLocalDirs) {\n+    for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n-    createContainerLogDirs(appIdStr, containerIdStr);\n+    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n     DataOutputStream wrapperScriptOutStream \u003d\n         lfs.create(wrapperScriptDst,\n             EnumSet.of(CREATE, OVERWRITE));\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n           .getPath().toString(), pidFile.toString());\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(wrapperScriptDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d {\"bash\", \"-c\",\n           wrapperScriptDst.toUri().getPath().toString()};\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\", \"-c\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[container-Container, nmPrivateContainerScriptPath-Path, nmPrivateTokensPath-Path, userName-String, appId-String, containerWorkDir-Path]",
            "newValue": "[container-Container, nmPrivateContainerScriptPath-Path, nmPrivateTokensPath-Path, userName-String, appId-String, containerWorkDir-Path, localDirs-List\u003cString\u003e, logDirs-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/11/11 3:17 PM",
          "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "15/11/11 2:30 AM",
          "commitNameOld": "c56e05196190f172e9c8cdcd9d59d09950f1419b",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.53,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,92 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n-      String userName, String appId, Path containerWorkDir)\n-      throws IOException {\n+      String userName, String appId, Path containerWorkDir,\n+      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n-    String[] sLocalDirs \u003d getConf().getStrings(\n-        YarnConfiguration.NM_LOCAL_DIRS,\n-        YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n-    for (String sLocalDir : sLocalDirs) {\n+    for (String sLocalDir : localDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n-    createContainerLogDirs(appIdStr, containerIdStr);\n+    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // Create new local launch wrapper script\n     Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n     DataOutputStream wrapperScriptOutStream \u003d\n         lfs.create(wrapperScriptDst,\n             EnumSet.of(CREATE, OVERWRITE));\n \n     Path pidFile \u003d getPidFilePath(containerId);\n     if (pidFile !\u003d null) {\n       writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n           .getPath().toString(), pidFile.toString());\n     } else {\n       LOG.info(\"Container \" + containerIdStr\n           + \" was marked as inactive. Returning terminated error\");\n       return ExitCode.TERMINATED.getExitCode();\n     }\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       lfs.setPermission(wrapperScriptDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n \n       // Setup command to run\n       String[] command \u003d {\"bash\", \"-c\",\n           wrapperScriptDst.toUri().getPath().toString()};\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n           new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n       if (isContainerActive(containerId)) {\n         shExec.execute();\n       }\n       else {\n         LOG.info(\"Container \" + containerIdStr +\n             \" was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\", \"-c\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3240. Fixed NodeManager to be able to forcefully cleanup its containers (process-trees) irrespective of whether the container succeeded, or killed. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189711 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 5:03 AM",
      "commitName": "2fe343f96348e894e6ed16c447c8c77ba1611d11",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/10/11 5:36 PM",
      "commitNameOld": "6217e54718fc0ba8845ef8cc5a558fe67d98c18e",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.48,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,95 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir)\n       throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n-    String[] sLocalDirs \u003d\n-        getConf().getStrings(YarnConfiguration.NM_LOCAL_DIRS, YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n+    String[] sLocalDirs \u003d getConf().getStrings(\n+        YarnConfiguration.NM_LOCAL_DIRS,\n+        YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n     for (String sLocalDir : sLocalDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n+    // Create new local launch wrapper script\n+    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n+    DataOutputStream wrapperScriptOutStream \u003d\n+        lfs.create(wrapperScriptDst,\n+            EnumSet.of(CREATE, OVERWRITE));\n+\n+    Path pidFile \u003d getPidFilePath(containerId);\n+    if (pidFile !\u003d null) {\n+      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n+          .getPath().toString(), pidFile.toString());\n+    } else {\n+      LOG.info(\"Container \" + containerIdStr\n+          + \" was marked as inactive. Returning terminated error\");\n+      return ExitCode.TERMINATED.getExitCode();\n+    }\n+\n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n-      String[] command \u003d \n-          new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n+      lfs.setPermission(wrapperScriptDst,\n+          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n+\n+      // Setup command to run\n+      String[] command \u003d {\"bash\", \"-c\",\n+          wrapperScriptDst.toUri().getPath().toString()};\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(\n           command,\n-          new File(containerWorkDir.toUri().getPath()), \n+          new File(containerWorkDir.toUri().getPath()),\n           container.getLaunchContext().getEnvironment());      // sanitized env\n-      launchCommandObjs.put(containerId, shExec);\n-      shExec.execute();\n+      if (isContainerActive(containerId)) {\n+        shExec.execute();\n+      }\n+      else {\n+        LOG.info(\"Container \" + containerIdStr +\n+            \" was marked as inactive. Returning terminated error\");\n+        return ExitCode.TERMINATED.getExitCode();\n+      }\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n-      launchCommandObjs.remove(containerId);\n+      ; //\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir)\n      throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    String[] sLocalDirs \u003d getConf().getStrings(\n        YarnConfiguration.NM_LOCAL_DIRS,\n        YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n    for (String sLocalDir : sLocalDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // Create new local launch wrapper script\n    Path wrapperScriptDst \u003d new Path(containerWorkDir, WRAPPER_LAUNCH_SCRIPT);\n    DataOutputStream wrapperScriptOutStream \u003d\n        lfs.create(wrapperScriptDst,\n            EnumSet.of(CREATE, OVERWRITE));\n\n    Path pidFile \u003d getPidFilePath(containerId);\n    if (pidFile !\u003d null) {\n      writeLocalWrapperScript(wrapperScriptOutStream, launchDst.toUri()\n          .getPath().toString(), pidFile.toString());\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(wrapperScriptDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command \u003d {\"bash\", \"-c\",\n          wrapperScriptDst.toUri().getPath().toString()};\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      }\n      else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      ; //\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2880. Improved classpath-construction for mapreduce AM and containers. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1173783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/09/11 11:28 AM",
      "commitName": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/09/11 5:05 PM",
      "commitNameOld": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 8.77,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir)\n       throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(\n             container.getContainerID().getApplicationAttemptId().\n                 getApplicationId());\n     String[] sLocalDirs \u003d\n         getConf().getStrings(YarnConfiguration.NM_LOCAL_DIRS, YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n     for (String sLocalDir : sLocalDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       String[] command \u003d \n           new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n-      shExec \u003d new ShellCommandExecutor(command,\n-          new File(containerWorkDir.toUri().getPath()));\n+      shExec \u003d new ShellCommandExecutor(\n+          command,\n+          new File(containerWorkDir.toUri().getPath()), \n+          container.getLaunchContext().getEnvironment());      // sanitized env\n       launchCommandObjs.put(containerId, shExec);\n       shExec.execute();\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       launchCommandObjs.remove(containerId);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir)\n      throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    String[] sLocalDirs \u003d\n        getConf().getStrings(YarnConfiguration.NM_LOCAL_DIRS, YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n    for (String sLocalDir : sLocalDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      String[] command \u003d \n          new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()), \n          container.getLaunchContext().getEnvironment());      // sanitized env\n      launchCommandObjs.put(containerId, shExec);\n      shExec.execute();\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 3.93,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir)\n       throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n-        ConverterUtils.toString(container.getContainerID().getAppId());\n+        ConverterUtils.toString(\n+            container.getContainerID().getApplicationAttemptId().\n+                getApplicationId());\n     String[] sLocalDirs \u003d\n         getConf().getStrings(YarnConfiguration.NM_LOCAL_DIRS, YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n     for (String sLocalDir : sLocalDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       String[] command \u003d \n           new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(command,\n           new File(containerWorkDir.toUri().getPath()));\n       launchCommandObjs.put(containerId, shExec);\n       shExec.execute();\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       launchCommandObjs.remove(containerId);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir)\n      throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(\n            container.getContainerID().getApplicationAttemptId().\n                getApplicationId());\n    String[] sLocalDirs \u003d\n        getConf().getStrings(YarnConfiguration.NM_LOCAL_DIRS, YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n    for (String sLocalDir : sLocalDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      String[] command \u003d \n          new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(command,\n          new File(containerWorkDir.toUri().getPath()));\n      launchCommandObjs.put(containerId, shExec);\n      shExec.execute();\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "fafe8cd28e726566509c679e19d7da622f29f90d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2864. Normalize configuration variable names for YARN. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166955 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 6:44 PM",
      "commitName": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 15.06,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public int launchContainer(Container container,\n       Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n       String userName, String appId, Path containerWorkDir)\n       throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n \n     // create container dirs on all disks\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     String appIdStr \u003d\n         ConverterUtils.toString(container.getContainerID().getAppId());\n     String[] sLocalDirs \u003d\n-        getConf().getStrings(NMConfig.NM_LOCAL_DIR, NMConfig.DEFAULT_NM_LOCAL_DIR);\n+        getConf().getStrings(YarnConfiguration.NM_LOCAL_DIRS, YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n     for (String sLocalDir : sLocalDirs) {\n       Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n       Path userdir \u003d new Path(usersdir, userName);\n       Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n       Path appDir \u003d new Path(appCacheDir, appIdStr);\n       Path containerDir \u003d new Path(appDir, containerIdStr);\n       lfs.mkdir(containerDir, null, false);\n     }\n \n     // Create the container log-dirs on all disks\n     createContainerLogDirs(appIdStr, containerIdStr);\n \n     // copy launch script to work dir\n     Path launchDst \u003d\n         new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n     lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n \n     // copy container tokens to work dir\n     Path tokenDst \u003d\n       new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n     lfs.util().copy(nmPrivateTokensPath, tokenDst);\n \n     // create log dir under app\n     // fork script\n     ShellCommandExecutor shExec \u003d null;\n     try {\n       lfs.setPermission(launchDst,\n           ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n       String[] command \u003d \n           new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n       LOG.info(\"launchContainer: \" + Arrays.toString(command));\n       shExec \u003d new ShellCommandExecutor(command,\n           new File(containerWorkDir.toUri().getPath()));\n       launchCommandObjs.put(containerId, shExec);\n       shExec.execute();\n     } catch (IOException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from task is : \" + exitCode);\n       String message \u003d shExec.getOutput();\n       logOutput(message);\n       container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n           message));\n       return exitCode;\n     } finally {\n       launchCommandObjs.remove(containerId);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir)\n      throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(container.getContainerID().getAppId());\n    String[] sLocalDirs \u003d\n        getConf().getStrings(YarnConfiguration.NM_LOCAL_DIRS, YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n    for (String sLocalDir : sLocalDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      String[] command \u003d \n          new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(command,\n          new File(containerWorkDir.toUri().getPath()));\n      launchCommandObjs.put(containerId, shExec);\n      shExec.execute();\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir)\n      throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(container.getContainerID().getAppId());\n    String[] sLocalDirs \u003d\n        getConf().getStrings(NMConfig.NM_LOCAL_DIR, NMConfig.DEFAULT_NM_LOCAL_DIR);\n    for (String sLocalDir : sLocalDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      String[] command \u003d \n          new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(command,\n          new File(containerWorkDir.toUri().getPath()));\n      launchCommandObjs.put(containerId, shExec);\n      shExec.execute();\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,64 @@\n+  public int launchContainer(Container container,\n+      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n+      String userName, String appId, Path containerWorkDir)\n+      throws IOException {\n+\n+    ContainerId containerId \u003d container.getContainerID();\n+\n+    // create container dirs on all disks\n+    String containerIdStr \u003d ConverterUtils.toString(containerId);\n+    String appIdStr \u003d\n+        ConverterUtils.toString(container.getContainerID().getAppId());\n+    String[] sLocalDirs \u003d\n+        getConf().getStrings(NMConfig.NM_LOCAL_DIR, NMConfig.DEFAULT_NM_LOCAL_DIR);\n+    for (String sLocalDir : sLocalDirs) {\n+      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n+      Path userdir \u003d new Path(usersdir, userName);\n+      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n+      Path appDir \u003d new Path(appCacheDir, appIdStr);\n+      Path containerDir \u003d new Path(appDir, containerIdStr);\n+      lfs.mkdir(containerDir, null, false);\n+    }\n+\n+    // Create the container log-dirs on all disks\n+    createContainerLogDirs(appIdStr, containerIdStr);\n+\n+    // copy launch script to work dir\n+    Path launchDst \u003d\n+        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n+    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n+\n+    // copy container tokens to work dir\n+    Path tokenDst \u003d\n+      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n+    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n+\n+    // create log dir under app\n+    // fork script\n+    ShellCommandExecutor shExec \u003d null;\n+    try {\n+      lfs.setPermission(launchDst,\n+          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n+      String[] command \u003d \n+          new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n+      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n+      shExec \u003d new ShellCommandExecutor(command,\n+          new File(containerWorkDir.toUri().getPath()));\n+      launchCommandObjs.put(containerId, shExec);\n+      shExec.execute();\n+    } catch (IOException e) {\n+      if (null \u003d\u003d shExec) {\n+        return -1;\n+      }\n+      int exitCode \u003d shExec.getExitCode();\n+      LOG.warn(\"Exit code from task is : \" + exitCode);\n+      String message \u003d shExec.getOutput();\n+      logOutput(message);\n+      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n+          message));\n+      return exitCode;\n+    } finally {\n+      launchCommandObjs.remove(containerId);\n+    }\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n      String userName, String appId, Path containerWorkDir)\n      throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n\n    // create container dirs on all disks\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    String appIdStr \u003d\n        ConverterUtils.toString(container.getContainerID().getAppId());\n    String[] sLocalDirs \u003d\n        getConf().getStrings(NMConfig.NM_LOCAL_DIR, NMConfig.DEFAULT_NM_LOCAL_DIR);\n    for (String sLocalDir : sLocalDirs) {\n      Path usersdir \u003d new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir \u003d new Path(usersdir, userName);\n      Path appCacheDir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir \u003d new Path(appCacheDir, appIdStr);\n      Path containerDir \u003d new Path(appDir, containerIdStr);\n      lfs.mkdir(containerDir, null, false);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr);\n\n    // copy launch script to work dir\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst \u003d\n      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n    // create log dir under app\n    // fork script\n    ShellCommandExecutor shExec \u003d null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      String[] command \u003d \n          new String[] { \"bash\", \"-c\", launchDst.toUri().getPath().toString() };\n      LOG.info(\"launchContainer: \" + Arrays.toString(command));\n      shExec \u003d new ShellCommandExecutor(command,\n          new File(containerWorkDir.toUri().getPath()));\n      launchCommandObjs.put(containerId, shExec);\n      shExec.execute();\n    } catch (IOException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from task is : \" + exitCode);\n      String message \u003d shExec.getOutput();\n      logOutput(message);\n      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n          message));\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DefaultContainerExecutor.java"
    }
  }
}