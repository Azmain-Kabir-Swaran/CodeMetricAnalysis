{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeafQueue.java",
  "functionName": "getTotalPendingResourcesConsideringUserLimit",
  "functionId": "getTotalPendingResourcesConsideringUserLimit___clusterResources-Resource__partition-String__deductReservedFromPending-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
  "functionStartLine": 1955,
  "functionEndLine": 1997,
  "numCommitsSeen": 308,
  "timeTaken": 5940,
  "changeHistory": [
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
    "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
    "2346fa3141bf28f25a90b6a426a1d3a3982e464f"
  ],
  "changeHistoryShort": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": "Ybodychange",
    "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2": "Ymultichange(Yparameterchange,Ybodychange)",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ybodychange",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": "Ymultichange(Ymodifierchange,Ybodychange)",
    "2346fa3141bf28f25a90b6a426a1d3a3982e464f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   public Resource getTotalPendingResourcesConsideringUserLimit(\n       Resource clusterResources, String partition,\n       boolean deductReservedFromPending) {\n+    readLock.lock();\n     try {\n-      readLock.lock();\n       Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n           new HashMap\u003c\u003e();\n       Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n       for (FiCaSchedulerApp app : getApplications()) {\n         String userName \u003d app.getUser();\n         if (!userNameToHeadroom.containsKey(userName)) {\n           User user \u003d getUser(userName);\n           Resource headroom \u003d Resources.subtract(\n               getResourceLimitForActiveUsers(app.getUser(), clusterResources,\n                   partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n               user.getUsed(partition));\n           // Make sure headroom is not negative.\n           headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n           userNameToHeadroom.put(userName, headroom);\n         }\n \n         // Check if we need to deduct reserved from pending\n         Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n             partition);\n         if (deductReservedFromPending) {\n           pending \u003d Resources.subtract(pending,\n               app.getAppAttemptResourceUsage().getReserved(partition));\n         }\n         pending \u003d Resources.componentwiseMax(pending, Resources.none());\n \n         Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n             userNameToHeadroom.get(userName), pending);\n         Resources.addTo(totalPendingConsideringUserLimit,\n             minpendingConsideringUserLimit);\n         Resources.subtractFrom(userNameToHeadroom.get(userName),\n             minpendingConsideringUserLimit);\n       }\n       return totalPendingConsideringUserLimit;\n     } finally {\n       readLock.unlock();\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getTotalPendingResourcesConsideringUserLimit(\n      Resource clusterResources, String partition,\n      boolean deductReservedFromPending) {\n    readLock.lock();\n    try {\n      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n          new HashMap\u003c\u003e();\n      Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n      for (FiCaSchedulerApp app : getApplications()) {\n        String userName \u003d app.getUser();\n        if (!userNameToHeadroom.containsKey(userName)) {\n          User user \u003d getUser(userName);\n          Resource headroom \u003d Resources.subtract(\n              getResourceLimitForActiveUsers(app.getUser(), clusterResources,\n                  partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n              user.getUsed(partition));\n          // Make sure headroom is not negative.\n          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n          userNameToHeadroom.put(userName, headroom);\n        }\n\n        // Check if we need to deduct reserved from pending\n        Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n            partition);\n        if (deductReservedFromPending) {\n          pending \u003d Resources.subtract(pending,\n              app.getAppAttemptResourceUsage().getReserved(partition));\n        }\n        pending \u003d Resources.componentwiseMax(pending, Resources.none());\n\n        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n            userNameToHeadroom.get(userName), pending);\n        Resources.addTo(totalPendingConsideringUserLimit,\n            minpendingConsideringUserLimit);\n        Resources.subtractFrom(userNameToHeadroom.get(userName),\n            minpendingConsideringUserLimit);\n      }\n      return totalPendingConsideringUserLimit;\n    } finally {\n      readLock.unlock();\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "09/02/17 10:23 AM",
      "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/01/17 10:52 AM",
      "commitNameOld": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 16.98,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n   public Resource getTotalPendingResourcesConsideringUserLimit(\n-      Resource clusterResources, String partition, boolean deductReservedFromPending) {\n+      Resource clusterResources, String partition,\n+      boolean deductReservedFromPending) {\n     try {\n       readLock.lock();\n       Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n           new HashMap\u003c\u003e();\n       Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n       for (FiCaSchedulerApp app : getApplications()) {\n         String userName \u003d app.getUser();\n         if (!userNameToHeadroom.containsKey(userName)) {\n           User user \u003d getUser(userName);\n           Resource headroom \u003d Resources.subtract(\n-              computeUserLimit(app.getUser(), clusterResources, user, partition,\n-                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n+              getResourceLimitForActiveUsers(app.getUser(), clusterResources,\n+                  partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n               user.getUsed(partition));\n           // Make sure headroom is not negative.\n           headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n           userNameToHeadroom.put(userName, headroom);\n         }\n \n         // Check if we need to deduct reserved from pending\n         Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n             partition);\n         if (deductReservedFromPending) {\n           pending \u003d Resources.subtract(pending,\n               app.getAppAttemptResourceUsage().getReserved(partition));\n         }\n         pending \u003d Resources.componentwiseMax(pending, Resources.none());\n \n         Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n             userNameToHeadroom.get(userName), pending);\n         Resources.addTo(totalPendingConsideringUserLimit,\n             minpendingConsideringUserLimit);\n         Resources.subtractFrom(userNameToHeadroom.get(userName),\n             minpendingConsideringUserLimit);\n       }\n       return totalPendingConsideringUserLimit;\n     } finally {\n       readLock.unlock();\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getTotalPendingResourcesConsideringUserLimit(\n      Resource clusterResources, String partition,\n      boolean deductReservedFromPending) {\n    try {\n      readLock.lock();\n      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n          new HashMap\u003c\u003e();\n      Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n      for (FiCaSchedulerApp app : getApplications()) {\n        String userName \u003d app.getUser();\n        if (!userNameToHeadroom.containsKey(userName)) {\n          User user \u003d getUser(userName);\n          Resource headroom \u003d Resources.subtract(\n              getResourceLimitForActiveUsers(app.getUser(), clusterResources,\n                  partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n              user.getUsed(partition));\n          // Make sure headroom is not negative.\n          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n          userNameToHeadroom.put(userName, headroom);\n        }\n\n        // Check if we need to deduct reserved from pending\n        Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n            partition);\n        if (deductReservedFromPending) {\n          pending \u003d Resources.subtract(pending,\n              app.getAppAttemptResourceUsage().getReserved(partition));\n        }\n        pending \u003d Resources.componentwiseMax(pending, Resources.none());\n\n        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n            userNameToHeadroom.get(userName), pending);\n        Resources.addTo(totalPendingConsideringUserLimit,\n            minpendingConsideringUserLimit);\n        Resources.subtractFrom(userNameToHeadroom.get(userName),\n            minpendingConsideringUserLimit);\n      }\n      return totalPendingConsideringUserLimit;\n    } finally {\n      readLock.unlock();\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6081. LeafQueue#getTotalPendingResourcesConsideringUserLimit should deduct reserved from pending to avoid unnecessary preemption of reserved container. Contributed by Wangda Tan.\n",
      "commitDate": "13/01/17 4:52 AM",
      "commitName": "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6081. LeafQueue#getTotalPendingResourcesConsideringUserLimit should deduct reserved from pending to avoid unnecessary preemption of reserved container. Contributed by Wangda Tan.\n",
          "commitDate": "13/01/17 4:52 AM",
          "commitName": "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
          "commitAuthor": "Sunil G",
          "commitDateOld": "09/01/17 6:14 PM",
          "commitNameOld": "945db55f2e6521d33d4f90bbb09179b0feba5e7a",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 3.44,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,42 @@\n   public Resource getTotalPendingResourcesConsideringUserLimit(\n-          Resource resources, String partition) {\n+      Resource clusterResources, String partition, boolean deductReservedFromPending) {\n     try {\n       readLock.lock();\n       Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n           new HashMap\u003c\u003e();\n-      Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n+      Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n       for (FiCaSchedulerApp app : getApplications()) {\n         String userName \u003d app.getUser();\n         if (!userNameToHeadroom.containsKey(userName)) {\n           User user \u003d getUser(userName);\n           Resource headroom \u003d Resources.subtract(\n-              computeUserLimit(app.getUser(), resources, user, partition,\n+              computeUserLimit(app.getUser(), clusterResources, user, partition,\n                   SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n               user.getUsed(partition));\n           // Make sure headroom is not negative.\n           headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n           userNameToHeadroom.put(userName, headroom);\n         }\n+\n+        // Check if we need to deduct reserved from pending\n+        Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n+            partition);\n+        if (deductReservedFromPending) {\n+          pending \u003d Resources.subtract(pending,\n+              app.getAppAttemptResourceUsage().getReserved(partition));\n+        }\n+        pending \u003d Resources.componentwiseMax(pending, Resources.none());\n+\n         Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n-            userNameToHeadroom.get(userName),\n-            app.getAppAttemptResourceUsage().getPending(partition));\n-        Resources.addTo(pendingConsideringUserLimit,\n+            userNameToHeadroom.get(userName), pending);\n+        Resources.addTo(totalPendingConsideringUserLimit,\n             minpendingConsideringUserLimit);\n         Resources.subtractFrom(userNameToHeadroom.get(userName),\n             minpendingConsideringUserLimit);\n       }\n-      return pendingConsideringUserLimit;\n+      return totalPendingConsideringUserLimit;\n     } finally {\n       readLock.unlock();\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Resource getTotalPendingResourcesConsideringUserLimit(\n      Resource clusterResources, String partition, boolean deductReservedFromPending) {\n    try {\n      readLock.lock();\n      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n          new HashMap\u003c\u003e();\n      Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n      for (FiCaSchedulerApp app : getApplications()) {\n        String userName \u003d app.getUser();\n        if (!userNameToHeadroom.containsKey(userName)) {\n          User user \u003d getUser(userName);\n          Resource headroom \u003d Resources.subtract(\n              computeUserLimit(app.getUser(), clusterResources, user, partition,\n                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n              user.getUsed(partition));\n          // Make sure headroom is not negative.\n          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n          userNameToHeadroom.put(userName, headroom);\n        }\n\n        // Check if we need to deduct reserved from pending\n        Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n            partition);\n        if (deductReservedFromPending) {\n          pending \u003d Resources.subtract(pending,\n              app.getAppAttemptResourceUsage().getReserved(partition));\n        }\n        pending \u003d Resources.componentwiseMax(pending, Resources.none());\n\n        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n            userNameToHeadroom.get(userName), pending);\n        Resources.addTo(totalPendingConsideringUserLimit,\n            minpendingConsideringUserLimit);\n        Resources.subtractFrom(userNameToHeadroom.get(userName),\n            minpendingConsideringUserLimit);\n      }\n      return totalPendingConsideringUserLimit;\n    } finally {\n      readLock.unlock();\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[resources-Resource, partition-String]",
            "newValue": "[clusterResources-Resource, partition-String, deductReservedFromPending-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6081. LeafQueue#getTotalPendingResourcesConsideringUserLimit should deduct reserved from pending to avoid unnecessary preemption of reserved container. Contributed by Wangda Tan.\n",
          "commitDate": "13/01/17 4:52 AM",
          "commitName": "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
          "commitAuthor": "Sunil G",
          "commitDateOld": "09/01/17 6:14 PM",
          "commitNameOld": "945db55f2e6521d33d4f90bbb09179b0feba5e7a",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 3.44,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,42 @@\n   public Resource getTotalPendingResourcesConsideringUserLimit(\n-          Resource resources, String partition) {\n+      Resource clusterResources, String partition, boolean deductReservedFromPending) {\n     try {\n       readLock.lock();\n       Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n           new HashMap\u003c\u003e();\n-      Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n+      Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n       for (FiCaSchedulerApp app : getApplications()) {\n         String userName \u003d app.getUser();\n         if (!userNameToHeadroom.containsKey(userName)) {\n           User user \u003d getUser(userName);\n           Resource headroom \u003d Resources.subtract(\n-              computeUserLimit(app.getUser(), resources, user, partition,\n+              computeUserLimit(app.getUser(), clusterResources, user, partition,\n                   SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n               user.getUsed(partition));\n           // Make sure headroom is not negative.\n           headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n           userNameToHeadroom.put(userName, headroom);\n         }\n+\n+        // Check if we need to deduct reserved from pending\n+        Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n+            partition);\n+        if (deductReservedFromPending) {\n+          pending \u003d Resources.subtract(pending,\n+              app.getAppAttemptResourceUsage().getReserved(partition));\n+        }\n+        pending \u003d Resources.componentwiseMax(pending, Resources.none());\n+\n         Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n-            userNameToHeadroom.get(userName),\n-            app.getAppAttemptResourceUsage().getPending(partition));\n-        Resources.addTo(pendingConsideringUserLimit,\n+            userNameToHeadroom.get(userName), pending);\n+        Resources.addTo(totalPendingConsideringUserLimit,\n             minpendingConsideringUserLimit);\n         Resources.subtractFrom(userNameToHeadroom.get(userName),\n             minpendingConsideringUserLimit);\n       }\n-      return pendingConsideringUserLimit;\n+      return totalPendingConsideringUserLimit;\n     } finally {\n       readLock.unlock();\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Resource getTotalPendingResourcesConsideringUserLimit(\n      Resource clusterResources, String partition, boolean deductReservedFromPending) {\n    try {\n      readLock.lock();\n      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n          new HashMap\u003c\u003e();\n      Resource totalPendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n      for (FiCaSchedulerApp app : getApplications()) {\n        String userName \u003d app.getUser();\n        if (!userNameToHeadroom.containsKey(userName)) {\n          User user \u003d getUser(userName);\n          Resource headroom \u003d Resources.subtract(\n              computeUserLimit(app.getUser(), clusterResources, user, partition,\n                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n              user.getUsed(partition));\n          // Make sure headroom is not negative.\n          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n          userNameToHeadroom.put(userName, headroom);\n        }\n\n        // Check if we need to deduct reserved from pending\n        Resource pending \u003d app.getAppAttemptResourceUsage().getPending(\n            partition);\n        if (deductReservedFromPending) {\n          pending \u003d Resources.subtract(pending,\n              app.getAppAttemptResourceUsage().getReserved(partition));\n        }\n        pending \u003d Resources.componentwiseMax(pending, Resources.none());\n\n        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n            userNameToHeadroom.get(userName), pending);\n        Resources.addTo(totalPendingConsideringUserLimit,\n            minpendingConsideringUserLimit);\n        Resources.subtractFrom(userNameToHeadroom.get(userName),\n            minpendingConsideringUserLimit);\n      }\n      return totalPendingConsideringUserLimit;\n    } finally {\n      readLock.unlock();\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/10/16 1:17 AM",
      "commitNameOld": "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   public Resource getTotalPendingResourcesConsideringUserLimit(\n           Resource resources, String partition) {\n     try {\n       readLock.lock();\n       Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n           new HashMap\u003c\u003e();\n       Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n       for (FiCaSchedulerApp app : getApplications()) {\n         String userName \u003d app.getUser();\n         if (!userNameToHeadroom.containsKey(userName)) {\n           User user \u003d getUser(userName);\n           Resource headroom \u003d Resources.subtract(\n-              computeUserLimit(app, resources, user, partition,\n+              computeUserLimit(app.getUser(), resources, user, partition,\n                   SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n               user.getUsed(partition));\n           // Make sure headroom is not negative.\n           headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n           userNameToHeadroom.put(userName, headroom);\n         }\n         Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n             userNameToHeadroom.get(userName),\n             app.getAppAttemptResourceUsage().getPending(partition));\n         Resources.addTo(pendingConsideringUserLimit,\n             minpendingConsideringUserLimit);\n         Resources.subtractFrom(userNameToHeadroom.get(userName),\n             minpendingConsideringUserLimit);\n       }\n       return pendingConsideringUserLimit;\n     } finally {\n       readLock.unlock();\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getTotalPendingResourcesConsideringUserLimit(\n          Resource resources, String partition) {\n    try {\n      readLock.lock();\n      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n          new HashMap\u003c\u003e();\n      Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n      for (FiCaSchedulerApp app : getApplications()) {\n        String userName \u003d app.getUser();\n        if (!userNameToHeadroom.containsKey(userName)) {\n          User user \u003d getUser(userName);\n          Resource headroom \u003d Resources.subtract(\n              computeUserLimit(app.getUser(), resources, user, partition,\n                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n              user.getUsed(partition));\n          // Make sure headroom is not negative.\n          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n          userNameToHeadroom.put(userName, headroom);\n        }\n        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n            userNameToHeadroom.get(userName),\n            app.getAppAttemptResourceUsage().getPending(partition));\n        Resources.addTo(pendingConsideringUserLimit,\n            minpendingConsideringUserLimit);\n        Resources.subtractFrom(userNameToHeadroom.get(userName),\n            minpendingConsideringUserLimit);\n      }\n      return pendingConsideringUserLimit;\n    } finally {\n      readLock.unlock();\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
      "commitDate": "20/09/16 12:03 AM",
      "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,26 +1,33 @@\n-  public synchronized Resource getTotalPendingResourcesConsideringUserLimit(\n+  public Resource getTotalPendingResourcesConsideringUserLimit(\n           Resource resources, String partition) {\n-    Map\u003cString, Resource\u003e userNameToHeadroom \u003d new HashMap\u003cString, Resource\u003e();\n-    Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n-    for (FiCaSchedulerApp app : getApplications()) {\n-      String userName \u003d app.getUser();\n-      if (!userNameToHeadroom.containsKey(userName)) {\n-        User user \u003d getUser(userName);\n-        Resource headroom \u003d Resources.subtract(\n-            computeUserLimit(app, resources, user, partition,\n-                SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n-                user.getUsed(partition));\n-        // Make sure headroom is not negative.\n-        headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n-        userNameToHeadroom.put(userName, headroom);\n+    try {\n+      readLock.lock();\n+      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n+          new HashMap\u003c\u003e();\n+      Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n+      for (FiCaSchedulerApp app : getApplications()) {\n+        String userName \u003d app.getUser();\n+        if (!userNameToHeadroom.containsKey(userName)) {\n+          User user \u003d getUser(userName);\n+          Resource headroom \u003d Resources.subtract(\n+              computeUserLimit(app, resources, user, partition,\n+                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n+              user.getUsed(partition));\n+          // Make sure headroom is not negative.\n+          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n+          userNameToHeadroom.put(userName, headroom);\n+        }\n+        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n+            userNameToHeadroom.get(userName),\n+            app.getAppAttemptResourceUsage().getPending(partition));\n+        Resources.addTo(pendingConsideringUserLimit,\n+            minpendingConsideringUserLimit);\n+        Resources.subtractFrom(userNameToHeadroom.get(userName),\n+            minpendingConsideringUserLimit);\n       }\n-      Resource minpendingConsideringUserLimit \u003d\n-          Resources.componentwiseMin(userNameToHeadroom.get(userName),\n-                       app.getAppAttemptResourceUsage().getPending(partition));\n-      Resources.addTo(pendingConsideringUserLimit,\n-          minpendingConsideringUserLimit);\n-      Resources.subtractFrom(\n-          userNameToHeadroom.get(userName), minpendingConsideringUserLimit);\n+      return pendingConsideringUserLimit;\n+    } finally {\n+      readLock.unlock();\n     }\n-    return pendingConsideringUserLimit;\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Resource getTotalPendingResourcesConsideringUserLimit(\n          Resource resources, String partition) {\n    try {\n      readLock.lock();\n      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n          new HashMap\u003c\u003e();\n      Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n      for (FiCaSchedulerApp app : getApplications()) {\n        String userName \u003d app.getUser();\n        if (!userNameToHeadroom.containsKey(userName)) {\n          User user \u003d getUser(userName);\n          Resource headroom \u003d Resources.subtract(\n              computeUserLimit(app, resources, user, partition,\n                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n              user.getUsed(partition));\n          // Make sure headroom is not negative.\n          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n          userNameToHeadroom.put(userName, headroom);\n        }\n        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n            userNameToHeadroom.get(userName),\n            app.getAppAttemptResourceUsage().getPending(partition));\n        Resources.addTo(pendingConsideringUserLimit,\n            minpendingConsideringUserLimit);\n        Resources.subtractFrom(userNameToHeadroom.get(userName),\n            minpendingConsideringUserLimit);\n      }\n      return pendingConsideringUserLimit;\n    } finally {\n      readLock.unlock();\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,26 +1,33 @@\n-  public synchronized Resource getTotalPendingResourcesConsideringUserLimit(\n+  public Resource getTotalPendingResourcesConsideringUserLimit(\n           Resource resources, String partition) {\n-    Map\u003cString, Resource\u003e userNameToHeadroom \u003d new HashMap\u003cString, Resource\u003e();\n-    Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n-    for (FiCaSchedulerApp app : getApplications()) {\n-      String userName \u003d app.getUser();\n-      if (!userNameToHeadroom.containsKey(userName)) {\n-        User user \u003d getUser(userName);\n-        Resource headroom \u003d Resources.subtract(\n-            computeUserLimit(app, resources, user, partition,\n-                SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n-                user.getUsed(partition));\n-        // Make sure headroom is not negative.\n-        headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n-        userNameToHeadroom.put(userName, headroom);\n+    try {\n+      readLock.lock();\n+      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n+          new HashMap\u003c\u003e();\n+      Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n+      for (FiCaSchedulerApp app : getApplications()) {\n+        String userName \u003d app.getUser();\n+        if (!userNameToHeadroom.containsKey(userName)) {\n+          User user \u003d getUser(userName);\n+          Resource headroom \u003d Resources.subtract(\n+              computeUserLimit(app, resources, user, partition,\n+                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n+              user.getUsed(partition));\n+          // Make sure headroom is not negative.\n+          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n+          userNameToHeadroom.put(userName, headroom);\n+        }\n+        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n+            userNameToHeadroom.get(userName),\n+            app.getAppAttemptResourceUsage().getPending(partition));\n+        Resources.addTo(pendingConsideringUserLimit,\n+            minpendingConsideringUserLimit);\n+        Resources.subtractFrom(userNameToHeadroom.get(userName),\n+            minpendingConsideringUserLimit);\n       }\n-      Resource minpendingConsideringUserLimit \u003d\n-          Resources.componentwiseMin(userNameToHeadroom.get(userName),\n-                       app.getAppAttemptResourceUsage().getPending(partition));\n-      Resources.addTo(pendingConsideringUserLimit,\n-          minpendingConsideringUserLimit);\n-      Resources.subtractFrom(\n-          userNameToHeadroom.get(userName), minpendingConsideringUserLimit);\n+      return pendingConsideringUserLimit;\n+    } finally {\n+      readLock.unlock();\n     }\n-    return pendingConsideringUserLimit;\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Resource getTotalPendingResourcesConsideringUserLimit(\n          Resource resources, String partition) {\n    try {\n      readLock.lock();\n      Map\u003cString, Resource\u003e userNameToHeadroom \u003d\n          new HashMap\u003c\u003e();\n      Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n      for (FiCaSchedulerApp app : getApplications()) {\n        String userName \u003d app.getUser();\n        if (!userNameToHeadroom.containsKey(userName)) {\n          User user \u003d getUser(userName);\n          Resource headroom \u003d Resources.subtract(\n              computeUserLimit(app, resources, user, partition,\n                  SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n              user.getUsed(partition));\n          // Make sure headroom is not negative.\n          headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n          userNameToHeadroom.put(userName, headroom);\n        }\n        Resource minpendingConsideringUserLimit \u003d Resources.componentwiseMin(\n            userNameToHeadroom.get(userName),\n            app.getAppAttemptResourceUsage().getPending(partition));\n        Resources.addTo(pendingConsideringUserLimit,\n            minpendingConsideringUserLimit);\n        Resources.subtractFrom(userNameToHeadroom.get(userName),\n            minpendingConsideringUserLimit);\n      }\n      return pendingConsideringUserLimit;\n    } finally {\n      readLock.unlock();\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "2346fa3141bf28f25a90b6a426a1d3a3982e464f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3769. Consider user limit when calculating total pending resource for preemption policy in Capacity Scheduler. (Eric Payne via wangda)\n",
      "commitDate": "20/11/15 3:55 PM",
      "commitName": "2346fa3141bf28f25a90b6a426a1d3a3982e464f",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,26 @@\n+  public synchronized Resource getTotalPendingResourcesConsideringUserLimit(\n+          Resource resources, String partition) {\n+    Map\u003cString, Resource\u003e userNameToHeadroom \u003d new HashMap\u003cString, Resource\u003e();\n+    Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n+    for (FiCaSchedulerApp app : getApplications()) {\n+      String userName \u003d app.getUser();\n+      if (!userNameToHeadroom.containsKey(userName)) {\n+        User user \u003d getUser(userName);\n+        Resource headroom \u003d Resources.subtract(\n+            computeUserLimit(app, resources, user, partition,\n+                SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n+                user.getUsed(partition));\n+        // Make sure headroom is not negative.\n+        headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n+        userNameToHeadroom.put(userName, headroom);\n+      }\n+      Resource minpendingConsideringUserLimit \u003d\n+          Resources.componentwiseMin(userNameToHeadroom.get(userName),\n+                       app.getAppAttemptResourceUsage().getPending(partition));\n+      Resources.addTo(pendingConsideringUserLimit,\n+          minpendingConsideringUserLimit);\n+      Resources.subtractFrom(\n+          userNameToHeadroom.get(userName), minpendingConsideringUserLimit);\n+    }\n+    return pendingConsideringUserLimit;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized Resource getTotalPendingResourcesConsideringUserLimit(\n          Resource resources, String partition) {\n    Map\u003cString, Resource\u003e userNameToHeadroom \u003d new HashMap\u003cString, Resource\u003e();\n    Resource pendingConsideringUserLimit \u003d Resource.newInstance(0, 0);\n    for (FiCaSchedulerApp app : getApplications()) {\n      String userName \u003d app.getUser();\n      if (!userNameToHeadroom.containsKey(userName)) {\n        User user \u003d getUser(userName);\n        Resource headroom \u003d Resources.subtract(\n            computeUserLimit(app, resources, user, partition,\n                SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY),\n                user.getUsed(partition));\n        // Make sure headroom is not negative.\n        headroom \u003d Resources.componentwiseMax(headroom, Resources.none());\n        userNameToHeadroom.put(userName, headroom);\n      }\n      Resource minpendingConsideringUserLimit \u003d\n          Resources.componentwiseMin(userNameToHeadroom.get(userName),\n                       app.getAppAttemptResourceUsage().getPending(partition));\n      Resources.addTo(pendingConsideringUserLimit,\n          minpendingConsideringUserLimit);\n      Resources.subtractFrom(\n          userNameToHeadroom.get(userName), minpendingConsideringUserLimit);\n    }\n    return pendingConsideringUserLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
    }
  }
}