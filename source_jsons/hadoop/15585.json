{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FoldedTreeSet.java",
  "functionName": "add",
  "functionId": "add___entry-E__replace-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/util/FoldedTreeSet.java",
  "functionStartLine": 545,
  "functionEndLine": 634,
  "numCommitsSeen": 1,
  "timeTaken": 1294,
  "changeHistory": [
    "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a"
  ],
  "changeHistoryShort": {
    "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9260. Improve the performance and GC friendliness of NameNode startup and full block reports (Staffan Friberg via cmccabe)\n",
      "commitDate": "02/02/16 11:23 AM",
      "commitName": "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,90 @@\n+  private E add(E entry, boolean replace) {\n+    Objects.requireNonNull(entry);\n+\n+    // Empty tree\n+    if (isEmpty()) {\n+      root \u003d cachedOrNewNode(entry);\n+      size \u003d 1;\n+      modCount++;\n+      return null;\n+    }\n+\n+    // Compare right entry first since inserts of comperatively larger entries\n+    // is more likely to be inserted. BlockID is always increasing in HDFS.\n+    Node\u003cE\u003e node \u003d root;\n+    Node\u003cE\u003e prevNode \u003d null;\n+    int result \u003d 0;\n+    while (node !\u003d null) {\n+      prevNode \u003d node;\n+      E[] entries \u003d node.entries;\n+      int rightIndex \u003d node.rightIndex;\n+      result \u003d compare(entry, entries[rightIndex], comparator);\n+      if (result \u003e 0) {\n+        node \u003d node.right;\n+      } else if (result \u003d\u003d 0) {\n+        E prevEntry \u003d entries[rightIndex];\n+        if (replace) {\n+          entries[rightIndex] \u003d entry;\n+        }\n+        return prevEntry;\n+      } else {\n+        int leftIndex \u003d node.leftIndex;\n+        if (leftIndex !\u003d rightIndex) {\n+          result \u003d compare(entry, entries[leftIndex], comparator);\n+        }\n+        if (result \u003c 0) {\n+          node \u003d node.left;\n+        } else if (result \u003d\u003d 0) {\n+          E prevEntry \u003d entries[leftIndex];\n+          if (replace) {\n+            entries[leftIndex] \u003d entry;\n+          }\n+          return prevEntry;\n+        } else {\n+          // Insert in this node\n+          int low \u003d leftIndex + 1, high \u003d rightIndex - 1;\n+          while (low \u003c\u003d high) {\n+            int mid \u003d (low + high) \u003e\u003e\u003e 1;\n+            result \u003d compare(entry, entries[mid], comparator);\n+            if (result \u003e 0) {\n+              low \u003d mid + 1;\n+            } else if (result \u003d\u003d 0) {\n+              E prevEntry \u003d entries[mid];\n+              if (replace) {\n+                entries[mid] \u003d entry;\n+              }\n+              return prevEntry;\n+            } else {\n+              high \u003d mid - 1;\n+            }\n+          }\n+          addElementInNode(node, entry, low);\n+          return null;\n+        }\n+      }\n+    }\n+\n+    assert prevNode !\u003d null;\n+    size++;\n+    modCount++;\n+    if (!prevNode.isFull()) {\n+      // The previous node still has space\n+      if (result \u003c 0) {\n+        prevNode.addEntryLeft(entry);\n+      } else {\n+        prevNode.addEntryRight(entry);\n+      }\n+    } else if (result \u003c 0) {\n+      // The previous node is full, add to adjencent node or a new node\n+      if (prevNode.prev !\u003d null \u0026\u0026 !prevNode.prev.isFull()) {\n+        prevNode.prev.addEntryRight(entry);\n+      } else {\n+        attachNodeLeft(prevNode, cachedOrNewNode(entry));\n+      }\n+    } else if (prevNode.next !\u003d null \u0026\u0026 !prevNode.next.isFull()) {\n+      prevNode.next.addEntryLeft(entry);\n+    } else {\n+      attachNodeRight(prevNode, cachedOrNewNode(entry));\n+    }\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private E add(E entry, boolean replace) {\n    Objects.requireNonNull(entry);\n\n    // Empty tree\n    if (isEmpty()) {\n      root \u003d cachedOrNewNode(entry);\n      size \u003d 1;\n      modCount++;\n      return null;\n    }\n\n    // Compare right entry first since inserts of comperatively larger entries\n    // is more likely to be inserted. BlockID is always increasing in HDFS.\n    Node\u003cE\u003e node \u003d root;\n    Node\u003cE\u003e prevNode \u003d null;\n    int result \u003d 0;\n    while (node !\u003d null) {\n      prevNode \u003d node;\n      E[] entries \u003d node.entries;\n      int rightIndex \u003d node.rightIndex;\n      result \u003d compare(entry, entries[rightIndex], comparator);\n      if (result \u003e 0) {\n        node \u003d node.right;\n      } else if (result \u003d\u003d 0) {\n        E prevEntry \u003d entries[rightIndex];\n        if (replace) {\n          entries[rightIndex] \u003d entry;\n        }\n        return prevEntry;\n      } else {\n        int leftIndex \u003d node.leftIndex;\n        if (leftIndex !\u003d rightIndex) {\n          result \u003d compare(entry, entries[leftIndex], comparator);\n        }\n        if (result \u003c 0) {\n          node \u003d node.left;\n        } else if (result \u003d\u003d 0) {\n          E prevEntry \u003d entries[leftIndex];\n          if (replace) {\n            entries[leftIndex] \u003d entry;\n          }\n          return prevEntry;\n        } else {\n          // Insert in this node\n          int low \u003d leftIndex + 1, high \u003d rightIndex - 1;\n          while (low \u003c\u003d high) {\n            int mid \u003d (low + high) \u003e\u003e\u003e 1;\n            result \u003d compare(entry, entries[mid], comparator);\n            if (result \u003e 0) {\n              low \u003d mid + 1;\n            } else if (result \u003d\u003d 0) {\n              E prevEntry \u003d entries[mid];\n              if (replace) {\n                entries[mid] \u003d entry;\n              }\n              return prevEntry;\n            } else {\n              high \u003d mid - 1;\n            }\n          }\n          addElementInNode(node, entry, low);\n          return null;\n        }\n      }\n    }\n\n    assert prevNode !\u003d null;\n    size++;\n    modCount++;\n    if (!prevNode.isFull()) {\n      // The previous node still has space\n      if (result \u003c 0) {\n        prevNode.addEntryLeft(entry);\n      } else {\n        prevNode.addEntryRight(entry);\n      }\n    } else if (result \u003c 0) {\n      // The previous node is full, add to adjencent node or a new node\n      if (prevNode.prev !\u003d null \u0026\u0026 !prevNode.prev.isFull()) {\n        prevNode.prev.addEntryRight(entry);\n      } else {\n        attachNodeLeft(prevNode, cachedOrNewNode(entry));\n      }\n    } else if (prevNode.next !\u003d null \u0026\u0026 !prevNode.next.isFull()) {\n      prevNode.next.addEntryLeft(entry);\n    } else {\n      attachNodeRight(prevNode, cachedOrNewNode(entry));\n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/util/FoldedTreeSet.java"
    }
  }
}