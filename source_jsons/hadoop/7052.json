{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSPermissionChecker.java",
  "functionName": "hasPermission",
  "functionId": "hasPermission___inode-INodeAttributes__access-FsAction",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
  "functionStartLine": 503,
  "functionEndLine": 525,
  "numCommitsSeen": 117,
  "timeTaken": 7394,
  "changeHistory": [
    "475bff6e8ea23dc0e12ea317531613f8aa74c872",
    "2550371f66c49fe0e40aadaa68744311270084ce",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
    "5ea6fd85c7aff6df28b87789f607bb57ee920639",
    "2ff6faf954eb0f1ab2b339d589edb30040087669",
    "970daaa5e44d3c09afd46d1c8e923a5096708c44",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
    "6a52febfbd97f3b54318e07d4918cea2a9292f53"
  ],
  "changeHistoryShort": {
    "475bff6e8ea23dc0e12ea317531613f8aa74c872": "Ybodychange",
    "2550371f66c49fe0e40aadaa68744311270084ce": "Ybodychange",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange)",
    "5ea6fd85c7aff6df28b87789f607bb57ee920639": "Ybodychange",
    "2ff6faf954eb0f1ab2b339d589edb30040087669": "Ybodychange",
    "970daaa5e44d3c09afd46d1c8e923a5096708c44": "Ybodychange",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "6a52febfbd97f3b54318e07d4918cea2a9292f53": "Yintroduced"
  },
  "changeHistoryDetails": {
    "475bff6e8ea23dc0e12ea317531613f8aa74c872": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13668. FSPermissionChecker may throws AIOOE when check inode permission. Contributed by He Xiaoqiao.\n",
      "commitDate": "13/08/18 2:32 AM",
      "commitName": "475bff6e8ea23dc0e12ea317531613f8aa74c872",
      "commitAuthor": "drankye",
      "commitDateOld": "05/06/18 1:53 AM",
      "commitNameOld": "0e3c31579d1c733decfb9b00721bdc7b86be60f2",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 69.03,
      "commitsBetweenForRepo": 493,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   private boolean hasPermission(INodeAttributes inode, FsAction access) {\n     if (inode \u003d\u003d null) {\n       return true;\n     }\n     final FsPermission mode \u003d inode.getFsPermission();\n     final AclFeature aclFeature \u003d inode.getAclFeature();\n-    if (aclFeature !\u003d null) {\n+    if (aclFeature !\u003d null \u0026\u0026 aclFeature.getEntriesSize() \u003e 0) {\n       // It\u0027s possible that the inode has a default ACL but no access ACL.\n       int firstEntry \u003d aclFeature.getEntryAt(0);\n       if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n         return hasAclPermission(inode, access, mode, aclFeature);\n       }\n     }\n     final FsAction checkAction;\n     if (getUser().equals(inode.getUserName())) { //user class\n       checkAction \u003d mode.getUserAction();\n     } else if (isMemberOfGroup(inode.getGroupName())) { //group class\n       checkAction \u003d mode.getGroupAction();\n     } else { //other class\n       checkAction \u003d mode.getOtherAction();\n     }\n     return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null \u0026\u0026 aclFeature.getEntriesSize() \u003e 0) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (isMemberOfGroup(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "2550371f66c49fe0e40aadaa68744311270084ce": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10711. Optimize FSPermissionChecker group membership check. Contributed by Daryn Sharp.\n",
      "commitDate": "19/08/16 7:12 AM",
      "commitName": "2550371f66c49fe0e40aadaa68744311270084ce",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/08/16 2:14 PM",
      "commitNameOld": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 14.71,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   private boolean hasPermission(INodeAttributes inode, FsAction access) {\n     if (inode \u003d\u003d null) {\n       return true;\n     }\n     final FsPermission mode \u003d inode.getFsPermission();\n     final AclFeature aclFeature \u003d inode.getAclFeature();\n     if (aclFeature !\u003d null) {\n       // It\u0027s possible that the inode has a default ACL but no access ACL.\n       int firstEntry \u003d aclFeature.getEntryAt(0);\n       if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n         return hasAclPermission(inode, access, mode, aclFeature);\n       }\n     }\n     final FsAction checkAction;\n     if (getUser().equals(inode.getUserName())) { //user class\n       checkAction \u003d mode.getUserAction();\n-    } else if (getGroups().contains(inode.getGroupName())) { //group class\n+    } else if (isMemberOfGroup(inode.getGroupName())) { //group class\n       checkAction \u003d mode.getGroupAction();\n     } else { //other class\n       checkAction \u003d mode.getOtherAction();\n     }\n     return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (isMemberOfGroup(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
      "commitDate": "04/08/16 2:14 PM",
      "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,23 @@\n-  public void checkPermission(String fsOwner, String supergroup,\n-      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n-      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n-      FsAction parentAccess, FsAction access, FsAction subAccess,\n-      boolean ignoreEmptyDir)\n-      throws AccessControlException {\n-    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-        ancestorIndex--);\n-\n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n-\n-    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n-    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n+    if (inode \u003d\u003d null) {\n+      return true;\n     }\n-    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+    final FsPermission mode \u003d inode.getFsPermission();\n+    final AclFeature aclFeature \u003d inode.getAclFeature();\n+    if (aclFeature !\u003d null) {\n+      // It\u0027s possible that the inode has a default ACL but no access ACL.\n+      int firstEntry \u003d aclFeature.getEntryAt(0);\n+      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n+        return hasAclPermission(inode, access, mode, aclFeature);\n+      }\n     }\n-    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+    final FsAction checkAction;\n+    if (getUser().equals(inode.getUserName())) { //user class\n+      checkAction \u003d mode.getUserAction();\n+    } else if (getGroups().contains(inode.getGroupName())) { //group class\n+      checkAction \u003d mode.getGroupAction();\n+    } else { //other class\n+      checkAction \u003d mode.getOtherAction();\n     }\n-    if (access !\u003d null) {\n-      check(last, path, access);\n-    }\n-    if (subAccess !\u003d null) {\n-      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n-          snapshotId, subAccess, ignoreEmptyDir);\n-    }\n-    if (doCheckOwner) {\n-      checkOwner(last);\n-    }\n+    return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (getGroups().contains(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "checkPermission",
            "newValue": "hasPermission"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,23 @@\n-  public void checkPermission(String fsOwner, String supergroup,\n-      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n-      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n-      FsAction parentAccess, FsAction access, FsAction subAccess,\n-      boolean ignoreEmptyDir)\n-      throws AccessControlException {\n-    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-        ancestorIndex--);\n-\n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n-\n-    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n-    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n+    if (inode \u003d\u003d null) {\n+      return true;\n     }\n-    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+    final FsPermission mode \u003d inode.getFsPermission();\n+    final AclFeature aclFeature \u003d inode.getAclFeature();\n+    if (aclFeature !\u003d null) {\n+      // It\u0027s possible that the inode has a default ACL but no access ACL.\n+      int firstEntry \u003d aclFeature.getEntryAt(0);\n+      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n+        return hasAclPermission(inode, access, mode, aclFeature);\n+      }\n     }\n-    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+    final FsAction checkAction;\n+    if (getUser().equals(inode.getUserName())) { //user class\n+      checkAction \u003d mode.getUserAction();\n+    } else if (getGroups().contains(inode.getGroupName())) { //group class\n+      checkAction \u003d mode.getGroupAction();\n+    } else { //other class\n+      checkAction \u003d mode.getOtherAction();\n     }\n-    if (access !\u003d null) {\n-      check(last, path, access);\n-    }\n-    if (subAccess !\u003d null) {\n-      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n-          snapshotId, subAccess, ignoreEmptyDir);\n-    }\n-    if (doCheckOwner) {\n-      checkOwner(last);\n-    }\n+    return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (getGroups().contains(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[fsOwner-String, supergroup-String, callerUgi-UserGroupInformation, inodeAttrs-INodeAttributes[], inodes-INode[], pathByNameArr-byte[][], snapshotId-int, path-String, ancestorIndex-int, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean]",
            "newValue": "[inode-INodeAttributes, access-FsAction]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,23 @@\n-  public void checkPermission(String fsOwner, String supergroup,\n-      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n-      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n-      FsAction parentAccess, FsAction access, FsAction subAccess,\n-      boolean ignoreEmptyDir)\n-      throws AccessControlException {\n-    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-        ancestorIndex--);\n-\n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n-\n-    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n-    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n+    if (inode \u003d\u003d null) {\n+      return true;\n     }\n-    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+    final FsPermission mode \u003d inode.getFsPermission();\n+    final AclFeature aclFeature \u003d inode.getAclFeature();\n+    if (aclFeature !\u003d null) {\n+      // It\u0027s possible that the inode has a default ACL but no access ACL.\n+      int firstEntry \u003d aclFeature.getEntryAt(0);\n+      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n+        return hasAclPermission(inode, access, mode, aclFeature);\n+      }\n     }\n-    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+    final FsAction checkAction;\n+    if (getUser().equals(inode.getUserName())) { //user class\n+      checkAction \u003d mode.getUserAction();\n+    } else if (getGroups().contains(inode.getGroupName())) { //group class\n+      checkAction \u003d mode.getGroupAction();\n+    } else { //other class\n+      checkAction \u003d mode.getOtherAction();\n     }\n-    if (access !\u003d null) {\n-      check(last, path, access);\n-    }\n-    if (subAccess !\u003d null) {\n-      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n-          snapshotId, subAccess, ignoreEmptyDir);\n-    }\n-    if (doCheckOwner) {\n-      checkOwner(last);\n-    }\n+    return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (getGroups().contains(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,23 @@\n-  public void checkPermission(String fsOwner, String supergroup,\n-      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n-      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n-      FsAction parentAccess, FsAction access, FsAction subAccess,\n-      boolean ignoreEmptyDir)\n-      throws AccessControlException {\n-    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-        ancestorIndex--);\n-\n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n-\n-    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n-    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n+    if (inode \u003d\u003d null) {\n+      return true;\n     }\n-    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+    final FsPermission mode \u003d inode.getFsPermission();\n+    final AclFeature aclFeature \u003d inode.getAclFeature();\n+    if (aclFeature !\u003d null) {\n+      // It\u0027s possible that the inode has a default ACL but no access ACL.\n+      int firstEntry \u003d aclFeature.getEntryAt(0);\n+      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n+        return hasAclPermission(inode, access, mode, aclFeature);\n+      }\n     }\n-    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+    final FsAction checkAction;\n+    if (getUser().equals(inode.getUserName())) { //user class\n+      checkAction \u003d mode.getUserAction();\n+    } else if (getGroups().contains(inode.getGroupName())) { //group class\n+      checkAction \u003d mode.getGroupAction();\n+    } else { //other class\n+      checkAction \u003d mode.getOtherAction();\n     }\n-    if (access !\u003d null) {\n-      check(last, path, access);\n-    }\n-    if (subAccess !\u003d null) {\n-      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n-          snapshotId, subAccess, ignoreEmptyDir);\n-    }\n-    if (doCheckOwner) {\n-      checkOwner(last);\n-    }\n+    return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (getGroups().contains(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,23 @@\n-  public void checkPermission(String fsOwner, String supergroup,\n-      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n-      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n-      FsAction parentAccess, FsAction access, FsAction subAccess,\n-      boolean ignoreEmptyDir)\n-      throws AccessControlException {\n-    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-        ancestorIndex--);\n-\n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n-\n-    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n-    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n+    if (inode \u003d\u003d null) {\n+      return true;\n     }\n-    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+    final FsPermission mode \u003d inode.getFsPermission();\n+    final AclFeature aclFeature \u003d inode.getAclFeature();\n+    if (aclFeature !\u003d null) {\n+      // It\u0027s possible that the inode has a default ACL but no access ACL.\n+      int firstEntry \u003d aclFeature.getEntryAt(0);\n+      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n+        return hasAclPermission(inode, access, mode, aclFeature);\n+      }\n     }\n-    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+    final FsAction checkAction;\n+    if (getUser().equals(inode.getUserName())) { //user class\n+      checkAction \u003d mode.getUserAction();\n+    } else if (getGroups().contains(inode.getGroupName())) { //group class\n+      checkAction \u003d mode.getGroupAction();\n+    } else { //other class\n+      checkAction \u003d mode.getOtherAction();\n     }\n-    if (access !\u003d null) {\n-      check(last, path, access);\n-    }\n-    if (subAccess !\u003d null) {\n-      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n-          snapshotId, subAccess, ignoreEmptyDir);\n-    }\n-    if (doCheckOwner) {\n-      checkOwner(last);\n-    }\n+    return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (getGroups().contains(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[AccessControlException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,23 @@\n-  public void checkPermission(String fsOwner, String supergroup,\n-      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n-      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n-      FsAction parentAccess, FsAction access, FsAction subAccess,\n-      boolean ignoreEmptyDir)\n-      throws AccessControlException {\n-    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-        ancestorIndex--);\n-\n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n-\n-    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n-    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n+    if (inode \u003d\u003d null) {\n+      return true;\n     }\n-    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+    final FsPermission mode \u003d inode.getFsPermission();\n+    final AclFeature aclFeature \u003d inode.getAclFeature();\n+    if (aclFeature !\u003d null) {\n+      // It\u0027s possible that the inode has a default ACL but no access ACL.\n+      int firstEntry \u003d aclFeature.getEntryAt(0);\n+      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n+        return hasAclPermission(inode, access, mode, aclFeature);\n+      }\n     }\n-    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+    final FsAction checkAction;\n+    if (getUser().equals(inode.getUserName())) { //user class\n+      checkAction \u003d mode.getUserAction();\n+    } else if (getGroups().contains(inode.getGroupName())) { //group class\n+      checkAction \u003d mode.getGroupAction();\n+    } else { //other class\n+      checkAction \u003d mode.getOtherAction();\n     }\n-    if (access !\u003d null) {\n-      check(last, path, access);\n-    }\n-    if (subAccess !\u003d null) {\n-      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n-          snapshotId, subAccess, ignoreEmptyDir);\n-    }\n-    if (doCheckOwner) {\n-      checkOwner(last);\n-    }\n+    return checkAction.implies(access);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean hasPermission(INodeAttributes inode, FsAction access) {\n    if (inode \u003d\u003d null) {\n      return true;\n    }\n    final FsPermission mode \u003d inode.getFsPermission();\n    final AclFeature aclFeature \u003d inode.getAclFeature();\n    if (aclFeature !\u003d null) {\n      // It\u0027s possible that the inode has a default ACL but no access ACL.\n      int firstEntry \u003d aclFeature.getEntryAt(0);\n      if (AclEntryStatusFormat.getScope(firstEntry) \u003d\u003d AclEntryScope.ACCESS) {\n        return hasAclPermission(inode, access, mode, aclFeature);\n      }\n    }\n    final FsAction checkAction;\n    if (getUser().equals(inode.getUserName())) { //user class\n      checkAction \u003d mode.getUserAction();\n    } else if (getGroups().contains(inode.getGroupName())) { //group class\n      checkAction \u003d mode.getGroupAction();\n    } else { //other class\n      checkAction \u003d mode.getOtherAction();\n    }\n    return checkAction.implies(access);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "5ea6fd85c7aff6df28b87789f607bb57ee920639": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10276. HDFS should not expose path info that user has no permission to see. (Yuanbo Liu via Yongjun Zhang)\n",
      "commitDate": "27/05/16 10:02 AM",
      "commitName": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "18/09/15 7:17 AM",
      "commitNameOld": "2ff6faf954eb0f1ab2b339d589edb30040087669",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 252.11,
      "commitsBetweenForRepo": 1699,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,35 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n       INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n-    try {\n-      checkTraverse(inodeAttrs, path, ancestorIndex);\n-    } catch (AccessControlException e) {\n-      checkAncestorType(inodes, ancestorIndex, e);\n-    }\n+\n+    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, path, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n       checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n\n    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "2ff6faf954eb0f1ab2b339d589edb30040087669": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5802. NameNode does not check for inode type before traversing down a path. (Xiao Chen via Yongjun Zhang)\n",
      "commitDate": "18/09/15 7:17 AM",
      "commitName": "2ff6faf954eb0f1ab2b339d589edb30040087669",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "08/09/15 9:57 AM",
      "commitNameOld": "970daaa5e44d3c09afd46d1c8e923a5096708c44",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 9.89,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,38 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n       INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n-    checkTraverse(inodeAttrs, path, ancestorIndex);\n+    try {\n+      checkTraverse(inodeAttrs, path, ancestorIndex);\n+    } catch (AccessControlException e) {\n+      checkAncestorType(inodes, ancestorIndex, e);\n+    }\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, path, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n       checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    try {\n      checkTraverse(inodeAttrs, path, ancestorIndex);\n    } catch (AccessControlException e) {\n      checkAncestorType(inodes, ancestorIndex, e);\n    }\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "970daaa5e44d3c09afd46d1c8e923a5096708c44": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9019. Adding informative message to sticky bit permission denied exception. Contributed by Xiaoyu Yao.\n",
      "commitDate": "08/09/15 9:57 AM",
      "commitName": "970daaa5e44d3c09afd46d1c8e923a5096708c44",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "24/03/15 4:02 PM",
      "commitNameOld": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 167.75,
      "commitsBetweenForRepo": 1241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n       INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodeAttrs, path, ancestorIndex);\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, path, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n       checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
      "commitDate": "24/03/15 4:02 PM",
      "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
      "commitAuthor": "Jitendra Pandey",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "checkFsPermission",
            "newValue": "checkPermission"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[inode-INode, snapshotId-int, access-FsAction, mode-FsPermission]",
            "newValue": "[fsOwner-String, supergroup-String, callerUgi-UserGroupInformation, inodeAttrs-INodeAttributes[], inodes-INode[], pathByNameArr-byte[][], snapshotId-int, path-String, ancestorIndex-int, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "6a52febfbd97f3b54318e07d4918cea2a9292f53": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5612. NameNode: change all permission checks to enforce ACLs in addition to permissions. Contributued by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1559281 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/01/14 3:28 PM",
      "commitName": "6a52febfbd97f3b54318e07d4918cea2a9292f53",
      "commitAuthor": "Haohui Mai",
      "diff": "@@ -0,0 +1,14 @@\n+  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n+      FsPermission mode) throws AccessControlException {\n+    if (user.equals(inode.getUserName(snapshotId))) { //user class\n+      if (mode.getUserAction().implies(access)) { return; }\n+    }\n+    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n+      if (mode.getGroupAction().implies(access)) { return; }\n+    }\n+    else { //other class\n+      if (mode.getOtherAction().implies(access)) { return; }\n+    }\n+    throw new AccessControlException(\n+      toAccessControlString(inode, snapshotId, access, mode));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n      FsPermission mode) throws AccessControlException {\n    if (user.equals(inode.getUserName(snapshotId))) { //user class\n      if (mode.getUserAction().implies(access)) { return; }\n    }\n    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n      if (mode.getGroupAction().implies(access)) { return; }\n    }\n    else { //other class\n      if (mode.getOtherAction().implies(access)) { return; }\n    }\n    throw new AccessControlException(\n      toAccessControlString(inode, snapshotId, access, mode));\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java"
    }
  }
}