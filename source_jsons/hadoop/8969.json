{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystem.java",
  "functionName": "loadFSImage",
  "functionId": "loadFSImage___startOpt-StartupOption",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
  "functionStartLine": 1182,
  "functionEndLine": 1228,
  "numCommitsSeen": 873,
  "timeTaken": 35914,
  "changeHistory": [
    "96c4575d7373079becfa3e3db29ba98e6fb86388",
    "d0b2c5850b523a3888b2fadcfcdf6edbed33f221",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
    "431e7d84c7b68b34ff18de19afe8e46637047fa6",
    "18620649f96d9e378fb7ea40de216284a9d525c7",
    "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8",
    "88209ce181b5ecc55c0ae2bceff4893ab4817e88",
    "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed",
    "a4e0ff5e052abad498595ee198b49c5310c9ec0d",
    "98983b2788508936ad489e61ff61cacfe73ab1b9",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b"
  ],
  "changeHistoryShort": {
    "96c4575d7373079becfa3e3db29ba98e6fb86388": "Ybodychange",
    "d0b2c5850b523a3888b2fadcfcdf6edbed33f221": "Ybodychange",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": "Ybodychange",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": "Ybodychange",
    "431e7d84c7b68b34ff18de19afe8e46637047fa6": "Ybodychange",
    "18620649f96d9e378fb7ea40de216284a9d525c7": "Ybodychange",
    "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8": "Ymodifierchange",
    "88209ce181b5ecc55c0ae2bceff4893ab4817e88": "Ymodifierchange",
    "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed": "Ybodychange",
    "a4e0ff5e052abad498595ee198b49c5310c9ec0d": "Ybodychange",
    "98983b2788508936ad489e61ff61cacfe73ab1b9": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange"
  },
  "changeHistoryDetails": {
    "96c4575d7373079becfa3e3db29ba98e6fb86388": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13805. Journal Nodes should allow to format non-empty directories with -force option. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "23/08/18 7:44 PM",
      "commitName": "96c4575d7373079becfa3e3db29ba98e6fb86388",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "20/08/18 9:03 PM",
      "commitNameOld": "770d9d9bb686bacef601ec8c4f884dc5afa9d4e2",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n-      \n-      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n+      // reuse current id\n+      fsImage.format(this, fsImage.getStorage().determineClusterId(), false);\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock(\"loadFSImage\", true);\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      // reuse current id\n      fsImage.format(this, fsImage.getStorage().determineClusterId(), false);\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock(\"loadFSImage\", true);\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "d0b2c5850b523a3888b2fadcfcdf6edbed33f221": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12516. Suppress the fsnamesystem lock warning on nn startup. Contributed by Ajay Kumar.\n",
      "commitDate": "24/09/17 9:03 PM",
      "commitName": "d0b2c5850b523a3888b2fadcfcdf6edbed33f221",
      "commitAuthor": "Anu Engineer",
      "commitDateOld": "20/09/17 11:51 AM",
      "commitNameOld": "a12f09ba3c4a3aa4c4558090c5e1b7bcaebe3b94",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n-      writeUnlock(\"loadFSImage\");\n+      writeUnlock(\"loadFSImage\", true);\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock(\"loadFSImage\", true);\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
      "commitDate": "14/11/16 11:05 AM",
      "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "08/11/16 6:17 PM",
      "commitNameOld": "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n-      writeUnlock();\n+      writeUnlock(\"loadFSImage\");\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock(\"loadFSImage\");\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8432. Introduce a minimum compatible layout version to allow downgrade in more rolling upgrade use cases. Contributed by Chris Nauroth.\n",
      "commitDate": "06/06/15 9:43 AM",
      "commitName": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "05/06/15 3:09 PM",
      "commitNameOld": "3841d09765bab332c9ae4803c5981799585b1f41",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,47 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n-        updateStorageVersionForRollingUpgrade(fsImage.getLayoutVersion(),\n-            startOpt);\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n-        fsImage.openEditLogForWrite();\n+        fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite(getEffectiveLayoutVersion());\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "431e7d84c7b68b34ff18de19afe8e46637047fa6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7302. Remove \"downgrade\" from \"namenode -rollingUpgrade\" startup option since it may incorrectly finalize an ongoing rolling upgrade.\n    Contributed by Kai Sasaki\n",
      "commitDate": "02/03/15 6:04 PM",
      "commitName": "431e7d84c7b68b34ff18de19afe8e46637047fa6",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "25/02/15 6:14 PM",
      "commitNameOld": "606f5b517ffbeae0140a8c80b4cddc012c7fb3c4",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,49 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n-      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt) ||\n-          RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n+      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         updateStorageVersionForRollingUpgrade(fsImage.getLayoutVersion(),\n             startOpt);\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        updateStorageVersionForRollingUpgrade(fsImage.getLayoutVersion(),\n            startOpt);\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "18620649f96d9e378fb7ea40de216284a9d525c7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7185. The active NameNode will not accept an fsimage sent from the standby during rolling upgrade. Contributed by Jing Zhao.\n",
      "commitDate": "15/10/14 10:27 AM",
      "commitName": "18620649f96d9e378fb7ea40de216284a9d525c7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/10/14 11:42 PM",
      "commitNameOld": "128ace10cdde4e966e30ac429c9a65ab8ace2d6c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,50 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n-      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n+      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt) ||\n+          RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n+        updateStorageVersionForRollingUpgrade(fsImage.getLayoutVersion(),\n+            startOpt);\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt) ||\n          RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        updateStorageVersionForRollingUpgrade(fsImage.getLayoutVersion(),\n            startOpt);\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8": {
      "type": "Ymodifierchange",
      "commitMessage": "Revert HDFS-6940.",
      "commitDate": "09/09/14 5:30 PM",
      "commitName": "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "06/09/14 12:07 PM",
      "commitNameOld": "88209ce181b5ecc55c0ae2bceff4893ab4817e88",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 3.22,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n-  protected void loadFSImage(StartupOption startOpt) throws IOException {\n+  private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[private]"
      }
    },
    "88209ce181b5ecc55c0ae2bceff4893ab4817e88": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-6940. Refactoring to allow ConsensusNode implementation.\nContributed by Konstantin Shvachko.",
      "commitDate": "06/09/14 12:07 PM",
      "commitName": "88209ce181b5ecc55c0ae2bceff4893ab4817e88",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "04/09/14 6:54 PM",
      "commitNameOld": "6104520369045dfaa4b543cbad21236ed322249b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n-  private void loadFSImage(StartupOption startOpt) throws IOException {\n+  protected void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n           || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[protected]"
      }
    },
    "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6597. Add a new option to NN upgrade to terminate the process after upgrade on NN is completed. Contributed by Danilo Vunjak.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611723 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 10:14 AM",
      "commitName": "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "10/07/14 11:18 AM",
      "commitNameOld": "8f520386fb952b70a4e7a9c460a2ecd9b9b855b4",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.96,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,47 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n-      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)) {\n+      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n+          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)\n          || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADEONLY)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "a4e0ff5e052abad498595ee198b49c5310c9ec0d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6480. Move waitForReady() from FSDirectory to FSNamesystem. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603705 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/14 9:13 PM",
      "commitName": "a4e0ff5e052abad498595ee198b49c5310c9ec0d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "17/06/14 6:00 PM",
      "commitNameOld": "8e8a769e7f5ce806ffdf584f017512ab58cd84e8",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n       if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n-    dir.imageLoadComplete();\n+    imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "98983b2788508936ad489e61ff61cacfe73ab1b9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6042. Fix rolling upgrade documentation and error messages. (Contributed by szetszwo)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1573785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/14 2:31 PM",
      "commitName": "98983b2788508936ad489e61ff61cacfe73ab1b9",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "03/03/14 11:51 AM",
      "commitNameOld": "aa8a6e498a66b992047aea710fb3c3f9472969f4",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n-      if (StartupOption.isRollingUpgradeRollback(startOpt)) {\n+      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n         rollingUpgradeInfo \u003d null;\n       }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     dir.imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (RollingUpgradeStartupOption.ROLLBACK.matches(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    dir.imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "25/02/14 12:24 PM",
      "commitNameOld": "abc9a6dad5ebcad07dd899a6e5f6ca26da28622b",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n   private void loadFSImage(StartupOption startOpt) throws IOException {\n     final FSImage fsImage \u003d getFSImage();\n \n     // format before starting up if requested\n     if (startOpt \u003d\u003d StartupOption.FORMAT) {\n       \n       fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n \n       startOpt \u003d StartupOption.REGULAR;\n     }\n     boolean success \u003d false;\n     writeLock();\n     try {\n       // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n       MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n       final boolean staleImage\n           \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n+      if (StartupOption.isRollingUpgradeRollback(startOpt)) {\n+        rollingUpgradeInfo \u003d null;\n+      }\n       final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n       LOG.info(\"Need to save fs image? \" + needToSave\n           + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n           + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n       if (needToSave) {\n         fsImage.saveNamespace(this);\n       } else {\n         // No need to save, so mark the phase done.\n         StartupProgress prog \u003d NameNode.getStartupProgress();\n         prog.beginPhase(Phase.SAVING_CHECKPOINT);\n         prog.endPhase(Phase.SAVING_CHECKPOINT);\n       }\n       // This will start a new log segment and write to the seen_txid file, so\n       // we shouldn\u0027t do it when coming up in standby state\n       if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)) {\n         fsImage.openEditLogForWrite();\n       }\n       success \u003d true;\n     } finally {\n       if (!success) {\n         fsImage.close();\n       }\n       writeUnlock();\n     }\n     dir.imageLoadComplete();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadFSImage(StartupOption startOpt) throws IOException {\n    final FSImage fsImage \u003d getFSImage();\n\n    // format before starting up if requested\n    if (startOpt \u003d\u003d StartupOption.FORMAT) {\n      \n      fsImage.format(this, fsImage.getStorage().determineClusterId());// reuse current id\n\n      startOpt \u003d StartupOption.REGULAR;\n    }\n    boolean success \u003d false;\n    writeLock();\n    try {\n      // We shouldn\u0027t be calling saveNamespace if we\u0027ve come up in standby state.\n      MetaRecoveryContext recovery \u003d startOpt.createRecoveryContext();\n      final boolean staleImage\n          \u003d fsImage.recoverTransitionRead(startOpt, this, recovery);\n      if (StartupOption.isRollingUpgradeRollback(startOpt)) {\n        rollingUpgradeInfo \u003d null;\n      }\n      final boolean needToSave \u003d staleImage \u0026\u0026 !haEnabled \u0026\u0026 !isRollingUpgrade(); \n      LOG.info(\"Need to save fs image? \" + needToSave\n          + \" (staleImage\u003d\" + staleImage + \", haEnabled\u003d\" + haEnabled\n          + \", isRollingUpgrade\u003d\" + isRollingUpgrade() + \")\");\n      if (needToSave) {\n        fsImage.saveNamespace(this);\n      } else {\n        // No need to save, so mark the phase done.\n        StartupProgress prog \u003d NameNode.getStartupProgress();\n        prog.beginPhase(Phase.SAVING_CHECKPOINT);\n        prog.endPhase(Phase.SAVING_CHECKPOINT);\n      }\n      // This will start a new log segment and write to the seen_txid file, so\n      // we shouldn\u0027t do it when coming up in standby state\n      if (!haEnabled || (haEnabled \u0026\u0026 startOpt \u003d\u003d StartupOption.UPGRADE)) {\n        fsImage.openEditLogForWrite();\n      }\n      success \u003d true;\n    } finally {\n      if (!success) {\n        fsImage.close();\n      }\n      writeUnlock();\n    }\n    dir.imageLoadComplete();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    }
  }
}