{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StripedBlockUtil.java",
  "functionName": "calcualteChunkPositionsInBuf",
  "functionId": "calcualteChunkPositionsInBuf___cellSize-int__stripes-AlignedStripe[]__cells-StripingCell[]__buf-ByteBuffer",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/StripedBlockUtil.java",
  "functionStartLine": 556,
  "functionEndLine": 596,
  "numCommitsSeen": 26,
  "timeTaken": 1600,
  "changeHistory": [
    "f6c5ef9903dba5eb268997110ef169125327c2c8",
    "401db4fc65140979fe7665983e36905e886df971"
  ],
  "changeHistoryShort": {
    "f6c5ef9903dba5eb268997110ef169125327c2c8": "Ybodychange",
    "401db4fc65140979fe7665983e36905e886df971": "Ymultichange(Yparameterchange,Ybodychange)"
  },
  "changeHistoryDetails": {
    "f6c5ef9903dba5eb268997110ef169125327c2c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13943. [JDK10] Fix javadoc errors in hadoop-hdfs-client module. Contributed by Akira Ajisaka.\n",
      "commitDate": "01/10/18 5:49 PM",
      "commitName": "f6c5ef9903dba5eb268997110ef169125327c2c8",
      "commitAuthor": "Takanobu Asanuma",
      "commitDateOld": "04/01/18 10:54 AM",
      "commitNameOld": "dc735b286bb656903df49aee776d22ee0c61f860",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 270.25,
      "commitsBetweenForRepo": 2587,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,41 @@\n   private static void calcualteChunkPositionsInBuf(int cellSize,\n       AlignedStripe[] stripes, StripingCell[] cells, ByteBuffer buf) {\n-    /**\n+    /*\n      *     | \u003c--------------- AlignedStripe ---------------\u003e|\n      *\n      *     |\u003c- length_0 -\u003e|\u003c--  length_1  --\u003e|\u003c- length_2 -\u003e|\n      * +------------------+------------------+----------------+\n      * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |  \u003c- blk_0\n      * +------------------+------------------+----------------+\n      *   _/                \\_______________________\n      *  |                                          |\n      *  v offset_0                                 v offset_1\n      * +----------------------------------------------------------+\n      * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|   \u003c- buf\n      * |  (partial)  |    (from blk_1 and blk_2)   |              |\n      * +----------------------------------------------------------+\n-     *\n-     * Cell indexing convention defined in {@link StripingCell}\n      */\n     int done \u003d 0;\n     for (StripingCell cell : cells) {\n       long cellStart \u003d cell.idxInInternalBlk * cellSize + cell.offset;\n       long cellEnd \u003d cellStart + cell.size - 1;\n       StripingChunk chunk;\n       for (AlignedStripe s : stripes) {\n         long stripeEnd \u003d s.getOffsetInBlock() + s.getSpanInBlock() - 1;\n         long overlapStart \u003d Math.max(cellStart, s.getOffsetInBlock());\n         long overlapEnd \u003d Math.min(cellEnd, stripeEnd);\n         int overLapLen \u003d (int) (overlapEnd - overlapStart + 1);\n         if (overLapLen \u003c\u003d 0) {\n           continue;\n         }\n         chunk \u003d s.chunks[cell.idxInStripe];\n         if (chunk \u003d\u003d null) {\n           chunk \u003d new StripingChunk();\n           s.chunks[cell.idxInStripe] \u003d chunk;\n         }\n         chunk.getChunkBuffer().addSlice(buf,\n             (int) (done + overlapStart - cellStart), overLapLen);\n       }\n       done +\u003d cell.size;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void calcualteChunkPositionsInBuf(int cellSize,\n      AlignedStripe[] stripes, StripingCell[] cells, ByteBuffer buf) {\n    /*\n     *     | \u003c--------------- AlignedStripe ---------------\u003e|\n     *\n     *     |\u003c- length_0 -\u003e|\u003c--  length_1  --\u003e|\u003c- length_2 -\u003e|\n     * +------------------+------------------+----------------+\n     * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |  \u003c- blk_0\n     * +------------------+------------------+----------------+\n     *   _/                \\_______________________\n     *  |                                          |\n     *  v offset_0                                 v offset_1\n     * +----------------------------------------------------------+\n     * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|   \u003c- buf\n     * |  (partial)  |    (from blk_1 and blk_2)   |              |\n     * +----------------------------------------------------------+\n     */\n    int done \u003d 0;\n    for (StripingCell cell : cells) {\n      long cellStart \u003d cell.idxInInternalBlk * cellSize + cell.offset;\n      long cellEnd \u003d cellStart + cell.size - 1;\n      StripingChunk chunk;\n      for (AlignedStripe s : stripes) {\n        long stripeEnd \u003d s.getOffsetInBlock() + s.getSpanInBlock() - 1;\n        long overlapStart \u003d Math.max(cellStart, s.getOffsetInBlock());\n        long overlapEnd \u003d Math.min(cellEnd, stripeEnd);\n        int overLapLen \u003d (int) (overlapEnd - overlapStart + 1);\n        if (overLapLen \u003c\u003d 0) {\n          continue;\n        }\n        chunk \u003d s.chunks[cell.idxInStripe];\n        if (chunk \u003d\u003d null) {\n          chunk \u003d new StripingChunk();\n          s.chunks[cell.idxInStripe] \u003d chunk;\n        }\n        chunk.getChunkBuffer().addSlice(buf,\n            (int) (done + overlapStart - cellStart), overLapLen);\n      }\n      done +\u003d cell.size;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/StripedBlockUtil.java",
      "extendedDetails": {}
    },
    "401db4fc65140979fe7665983e36905e886df971": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8901. Use ByteBuffer in striping positional read. Contributed by Sammi Chen and Kai Zheng.\n",
      "commitDate": "08/09/16 11:54 AM",
      "commitName": "401db4fc65140979fe7665983e36905e886df971",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8901. Use ByteBuffer in striping positional read. Contributed by Sammi Chen and Kai Zheng.\n",
          "commitDate": "08/09/16 11:54 AM",
          "commitName": "401db4fc65140979fe7665983e36905e886df971",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "06/04/16 10:50 PM",
          "commitNameOld": "3c18a53cbd2efabb2ad108d63a0b0b558424115f",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 154.54,
          "commitsBetweenForRepo": 1132,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,43 @@\n   private static void calcualteChunkPositionsInBuf(int cellSize,\n-      AlignedStripe[] stripes, StripingCell[] cells, byte[] buf,\n-      int offsetInBuf) {\n+      AlignedStripe[] stripes, StripingCell[] cells, ByteBuffer buf) {\n     /**\n      *     | \u003c--------------- AlignedStripe ---------------\u003e|\n      *\n      *     |\u003c- length_0 -\u003e|\u003c--  length_1  --\u003e|\u003c- length_2 -\u003e|\n      * +------------------+------------------+----------------+\n      * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |  \u003c- blk_0\n      * +------------------+------------------+----------------+\n      *   _/                \\_______________________\n      *  |                                          |\n      *  v offset_0                                 v offset_1\n      * +----------------------------------------------------------+\n      * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|   \u003c- buf\n      * |  (partial)  |    (from blk_1 and blk_2)   |              |\n      * +----------------------------------------------------------+\n      *\n      * Cell indexing convention defined in {@link StripingCell}\n      */\n     int done \u003d 0;\n     for (StripingCell cell : cells) {\n       long cellStart \u003d cell.idxInInternalBlk * cellSize + cell.offset;\n       long cellEnd \u003d cellStart + cell.size - 1;\n+      StripingChunk chunk;\n       for (AlignedStripe s : stripes) {\n         long stripeEnd \u003d s.getOffsetInBlock() + s.getSpanInBlock() - 1;\n         long overlapStart \u003d Math.max(cellStart, s.getOffsetInBlock());\n         long overlapEnd \u003d Math.min(cellEnd, stripeEnd);\n         int overLapLen \u003d (int) (overlapEnd - overlapStart + 1);\n         if (overLapLen \u003c\u003d 0) {\n           continue;\n         }\n-        if (s.chunks[cell.idxInStripe] \u003d\u003d null) {\n-          s.chunks[cell.idxInStripe] \u003d new StripingChunk(buf);\n+        chunk \u003d s.chunks[cell.idxInStripe];\n+        if (chunk \u003d\u003d null) {\n+          chunk \u003d new StripingChunk();\n+          s.chunks[cell.idxInStripe] \u003d chunk;\n         }\n-        s.chunks[cell.idxInStripe].addByteArraySlice(\n-            (int)(offsetInBuf + done + overlapStart - cellStart), overLapLen);\n+        chunk.getChunkBuffer().addSlice(buf,\n+            (int) (done + overlapStart - cellStart), overLapLen);\n       }\n       done +\u003d cell.size;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static void calcualteChunkPositionsInBuf(int cellSize,\n      AlignedStripe[] stripes, StripingCell[] cells, ByteBuffer buf) {\n    /**\n     *     | \u003c--------------- AlignedStripe ---------------\u003e|\n     *\n     *     |\u003c- length_0 -\u003e|\u003c--  length_1  --\u003e|\u003c- length_2 -\u003e|\n     * +------------------+------------------+----------------+\n     * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |  \u003c- blk_0\n     * +------------------+------------------+----------------+\n     *   _/                \\_______________________\n     *  |                                          |\n     *  v offset_0                                 v offset_1\n     * +----------------------------------------------------------+\n     * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|   \u003c- buf\n     * |  (partial)  |    (from blk_1 and blk_2)   |              |\n     * +----------------------------------------------------------+\n     *\n     * Cell indexing convention defined in {@link StripingCell}\n     */\n    int done \u003d 0;\n    for (StripingCell cell : cells) {\n      long cellStart \u003d cell.idxInInternalBlk * cellSize + cell.offset;\n      long cellEnd \u003d cellStart + cell.size - 1;\n      StripingChunk chunk;\n      for (AlignedStripe s : stripes) {\n        long stripeEnd \u003d s.getOffsetInBlock() + s.getSpanInBlock() - 1;\n        long overlapStart \u003d Math.max(cellStart, s.getOffsetInBlock());\n        long overlapEnd \u003d Math.min(cellEnd, stripeEnd);\n        int overLapLen \u003d (int) (overlapEnd - overlapStart + 1);\n        if (overLapLen \u003c\u003d 0) {\n          continue;\n        }\n        chunk \u003d s.chunks[cell.idxInStripe];\n        if (chunk \u003d\u003d null) {\n          chunk \u003d new StripingChunk();\n          s.chunks[cell.idxInStripe] \u003d chunk;\n        }\n        chunk.getChunkBuffer().addSlice(buf,\n            (int) (done + overlapStart - cellStart), overLapLen);\n      }\n      done +\u003d cell.size;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/StripedBlockUtil.java",
          "extendedDetails": {
            "oldValue": "[cellSize-int, stripes-AlignedStripe[], cells-StripingCell[], buf-byte[], offsetInBuf-int]",
            "newValue": "[cellSize-int, stripes-AlignedStripe[], cells-StripingCell[], buf-ByteBuffer]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8901. Use ByteBuffer in striping positional read. Contributed by Sammi Chen and Kai Zheng.\n",
          "commitDate": "08/09/16 11:54 AM",
          "commitName": "401db4fc65140979fe7665983e36905e886df971",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "06/04/16 10:50 PM",
          "commitNameOld": "3c18a53cbd2efabb2ad108d63a0b0b558424115f",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 154.54,
          "commitsBetweenForRepo": 1132,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,43 @@\n   private static void calcualteChunkPositionsInBuf(int cellSize,\n-      AlignedStripe[] stripes, StripingCell[] cells, byte[] buf,\n-      int offsetInBuf) {\n+      AlignedStripe[] stripes, StripingCell[] cells, ByteBuffer buf) {\n     /**\n      *     | \u003c--------------- AlignedStripe ---------------\u003e|\n      *\n      *     |\u003c- length_0 -\u003e|\u003c--  length_1  --\u003e|\u003c- length_2 -\u003e|\n      * +------------------+------------------+----------------+\n      * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |  \u003c- blk_0\n      * +------------------+------------------+----------------+\n      *   _/                \\_______________________\n      *  |                                          |\n      *  v offset_0                                 v offset_1\n      * +----------------------------------------------------------+\n      * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|   \u003c- buf\n      * |  (partial)  |    (from blk_1 and blk_2)   |              |\n      * +----------------------------------------------------------+\n      *\n      * Cell indexing convention defined in {@link StripingCell}\n      */\n     int done \u003d 0;\n     for (StripingCell cell : cells) {\n       long cellStart \u003d cell.idxInInternalBlk * cellSize + cell.offset;\n       long cellEnd \u003d cellStart + cell.size - 1;\n+      StripingChunk chunk;\n       for (AlignedStripe s : stripes) {\n         long stripeEnd \u003d s.getOffsetInBlock() + s.getSpanInBlock() - 1;\n         long overlapStart \u003d Math.max(cellStart, s.getOffsetInBlock());\n         long overlapEnd \u003d Math.min(cellEnd, stripeEnd);\n         int overLapLen \u003d (int) (overlapEnd - overlapStart + 1);\n         if (overLapLen \u003c\u003d 0) {\n           continue;\n         }\n-        if (s.chunks[cell.idxInStripe] \u003d\u003d null) {\n-          s.chunks[cell.idxInStripe] \u003d new StripingChunk(buf);\n+        chunk \u003d s.chunks[cell.idxInStripe];\n+        if (chunk \u003d\u003d null) {\n+          chunk \u003d new StripingChunk();\n+          s.chunks[cell.idxInStripe] \u003d chunk;\n         }\n-        s.chunks[cell.idxInStripe].addByteArraySlice(\n-            (int)(offsetInBuf + done + overlapStart - cellStart), overLapLen);\n+        chunk.getChunkBuffer().addSlice(buf,\n+            (int) (done + overlapStart - cellStart), overLapLen);\n       }\n       done +\u003d cell.size;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static void calcualteChunkPositionsInBuf(int cellSize,\n      AlignedStripe[] stripes, StripingCell[] cells, ByteBuffer buf) {\n    /**\n     *     | \u003c--------------- AlignedStripe ---------------\u003e|\n     *\n     *     |\u003c- length_0 -\u003e|\u003c--  length_1  --\u003e|\u003c- length_2 -\u003e|\n     * +------------------+------------------+----------------+\n     * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |  \u003c- blk_0\n     * +------------------+------------------+----------------+\n     *   _/                \\_______________________\n     *  |                                          |\n     *  v offset_0                                 v offset_1\n     * +----------------------------------------------------------+\n     * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|   \u003c- buf\n     * |  (partial)  |    (from blk_1 and blk_2)   |              |\n     * +----------------------------------------------------------+\n     *\n     * Cell indexing convention defined in {@link StripingCell}\n     */\n    int done \u003d 0;\n    for (StripingCell cell : cells) {\n      long cellStart \u003d cell.idxInInternalBlk * cellSize + cell.offset;\n      long cellEnd \u003d cellStart + cell.size - 1;\n      StripingChunk chunk;\n      for (AlignedStripe s : stripes) {\n        long stripeEnd \u003d s.getOffsetInBlock() + s.getSpanInBlock() - 1;\n        long overlapStart \u003d Math.max(cellStart, s.getOffsetInBlock());\n        long overlapEnd \u003d Math.min(cellEnd, stripeEnd);\n        int overLapLen \u003d (int) (overlapEnd - overlapStart + 1);\n        if (overLapLen \u003c\u003d 0) {\n          continue;\n        }\n        chunk \u003d s.chunks[cell.idxInStripe];\n        if (chunk \u003d\u003d null) {\n          chunk \u003d new StripingChunk();\n          s.chunks[cell.idxInStripe] \u003d chunk;\n        }\n        chunk.getChunkBuffer().addSlice(buf,\n            (int) (done + overlapStart - cellStart), overLapLen);\n      }\n      done +\u003d cell.size;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/StripedBlockUtil.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}