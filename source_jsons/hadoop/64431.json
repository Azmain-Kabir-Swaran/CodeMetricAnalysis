{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AInputStream.java",
  "functionName": "reopen",
  "functionId": "reopen___reason-String__targetPos-long__length-long__forceAbort-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
  "functionStartLine": 180,
  "functionEndLine": 218,
  "numCommitsSeen": 54,
  "timeTaken": 7536,
  "changeHistory": [
    "2382f63fc0bb4108f3f3c542b4be7c04fbedd7c4",
    "6fa229891e06eea62cb9634efde755f40247e816",
    "f365957c6326f88734bc0a5d01cfb7eac713db20",
    "d503f65b6689b19278ec2a0cf9da5a8762539de8",
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35",
    "1ba491ff907fc5d2618add980734a3534e2be098",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "83449abb40633a36b22de538cf82fca240af067e",
    "839b690ed5edc2ac4984640d58c005bb63cd8a07",
    "c6a39232456fa0c98b2b9b6dbeaec762294ca01e",
    "4ee3543625c77c06d566fe81644d21c607d6d74d",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
    "826267f789df657c62f7f5909e5a0b1a7b102c34",
    "6ba52d88ec11444cbac946ffadbc645acd0657de",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "2382f63fc0bb4108f3f3c542b4be7c04fbedd7c4": "Ybodychange",
    "6fa229891e06eea62cb9634efde755f40247e816": "Ybodychange",
    "f365957c6326f88734bc0a5d01cfb7eac713db20": "Ybodychange",
    "d503f65b6689b19278ec2a0cf9da5a8762539de8": "Ymultichange(Yparameterchange,Ybodychange)",
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35": "Ybodychange",
    "1ba491ff907fc5d2618add980734a3534e2be098": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "83449abb40633a36b22de538cf82fca240af067e": "Ybodychange",
    "839b690ed5edc2ac4984640d58c005bb63cd8a07": "Ybodychange",
    "c6a39232456fa0c98b2b9b6dbeaec762294ca01e": "Ybodychange",
    "4ee3543625c77c06d566fe81644d21c607d6d74d": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ybodychange",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ymultichange(Yparameterchange,Ybodychange)",
    "b9e3eff62a7415d8666656a75db69ff3e43f8e7e": "Ymultichange(Yparameterchange,Ybodychange)",
    "826267f789df657c62f7f5909e5a0b1a7b102c34": "Ybodychange",
    "6ba52d88ec11444cbac946ffadbc645acd0657de": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2382f63fc0bb4108f3f3c542b4be7c04fbedd7c4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14747. S3AInputStream to implement CanUnbuffer.\n\nAuthor:    Sahil Takiar \u003cstakiar@cloudera.com\u003e\n",
      "commitDate": "12/04/19 6:12 PM",
      "commitName": "2382f63fc0bb4108f3f3c542b4be7c04fbedd7c4",
      "commitAuthor": "Sahil Takiar",
      "commitDateOld": "13/03/19 1:37 PM",
      "commitNameOld": "6fa229891e06eea62cb9634efde755f40247e816",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 30.19,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   private synchronized void reopen(String reason, long targetPos, long length,\n           boolean forceAbort) throws IOException {\n \n-    if (wrappedStream !\u003d null) {\n+    if (isObjectStreamOpen()) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n         inputPolicy);\n \n     long opencount \u003d streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, contentRangeFinish - 1);\n     if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n         StringUtils.isNotBlank(serverSideEncryptionKey)){\n       request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n     }\n     String operation \u003d opencount \u003d\u003d 0 ? OPERATION_OPEN : OPERATION_REOPEN;\n     String text \u003d String.format(\"%s %s at %d\",\n         operation, uri, targetPos);\n     changeTracker.maybeApplyConstraint(request);\n     S3Object object \u003d Invoker.once(text, uri,\n         () -\u003e client.getObject(request));\n \n     changeTracker.processResponse(object, operation,\n         targetPos);\n     wrappedStream \u003d object.getObjectContent();\n     contentRangeStart \u003d targetPos;\n     if (wrappedStream \u003d\u003d null) {\n       throw new PathIOException(uri,\n           \"Null IO stream from \" + operation + \" of (\" + reason +  \") \");\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length,\n          boolean forceAbort) throws IOException {\n\n    if (isObjectStreamOpen()) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n        inputPolicy);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String operation \u003d opencount \u003d\u003d 0 ? OPERATION_OPEN : OPERATION_REOPEN;\n    String text \u003d String.format(\"%s %s at %d\",\n        operation, uri, targetPos);\n    changeTracker.maybeApplyConstraint(request);\n    S3Object object \u003d Invoker.once(text, uri,\n        () -\u003e client.getObject(request));\n\n    changeTracker.processResponse(object, operation,\n        targetPos);\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new PathIOException(uri,\n          \"Null IO stream from \" + operation + \" of (\" + reason +  \") \");\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "6fa229891e06eea62cb9634efde755f40247e816": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15625. S3A input stream to use etags/version number to detect changed source files.\n\nAuthor: Ben Roling \u003cben.roling@gmail.com\u003e\n\nInitial patch from Brahma Reddy Battula.\n",
      "commitDate": "13/03/19 1:37 PM",
      "commitName": "6fa229891e06eea62cb9634efde755f40247e816",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "09/03/19 8:00 AM",
      "commitNameOld": "0cbe9ad8c23d3fd2ac8ac423b6d2df68de720981",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 4.19,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,39 @@\n   private synchronized void reopen(String reason, long targetPos, long length,\n           boolean forceAbort) throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n         inputPolicy);\n \n     long opencount \u003d streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, contentRangeFinish - 1);\n     if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n         StringUtils.isNotBlank(serverSideEncryptionKey)){\n       request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n     }\n-    String text \u003d String.format(\"Failed to %s %s at %d\",\n-        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n+    String operation \u003d opencount \u003d\u003d 0 ? OPERATION_OPEN : OPERATION_REOPEN;\n+    String text \u003d String.format(\"%s %s at %d\",\n+        operation, uri, targetPos);\n+    changeTracker.maybeApplyConstraint(request);\n     S3Object object \u003d Invoker.once(text, uri,\n         () -\u003e client.getObject(request));\n+\n+    changeTracker.processResponse(object, operation,\n+        targetPos);\n     wrappedStream \u003d object.getObjectContent();\n     contentRangeStart \u003d targetPos;\n     if (wrappedStream \u003d\u003d null) {\n-      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n-          + uri);\n+      throw new PathIOException(uri,\n+          \"Null IO stream from \" + operation + \" of (\" + reason +  \") \");\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length,\n          boolean forceAbort) throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n        inputPolicy);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String operation \u003d opencount \u003d\u003d 0 ? OPERATION_OPEN : OPERATION_REOPEN;\n    String text \u003d String.format(\"%s %s at %d\",\n        operation, uri, targetPos);\n    changeTracker.maybeApplyConstraint(request);\n    S3Object object \u003d Invoker.once(text, uri,\n        () -\u003e client.getObject(request));\n\n    changeTracker.processResponse(object, operation,\n        targetPos);\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new PathIOException(uri,\n          \"Null IO stream from \" + operation + \" of (\" + reason +  \") \");\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "f365957c6326f88734bc0a5d01cfb7eac713db20": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15229. Add FileSystem builder-based openFile() API to match createFile();\nS3A to implement S3 Select through this API.\n\nThe new openFile() API is asynchronous, and implemented across FileSystem and FileContext.\n\nThe MapReduce V2 inputs are moved to this API, and you can actually set must/may\noptions to pass in.\n\nThis is more useful for setting things like s3a seek policy than for S3 select,\nas the existing input format/record readers can\u0027t handle S3 select output where\nthe stream is shorter than the file length, and splitting plain text is suboptimal.\nFuture work is needed there.\n\nIn the meantime, any/all filesystem connectors are now free to add their own filesystem-specific\nconfiguration parameters which can be set in jobs and used to set filesystem input stream\noptions (seek policy, retry, encryption secrets, etc).\n\nContributed by Steve Loughran\n",
      "commitDate": "05/02/19 3:51 AM",
      "commitName": "f365957c6326f88734bc0a5d01cfb7eac713db20",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/07/18 8:52 AM",
      "commitNameOld": "d503f65b6689b19278ec2a0cf9da5a8762539de8",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 209.83,
      "commitsBetweenForRepo": 1641,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   private synchronized void reopen(String reason, long targetPos, long length,\n           boolean forceAbort) throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n         inputPolicy);\n \n     long opencount \u003d streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, contentRangeFinish - 1);\n     if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n         StringUtils.isNotBlank(serverSideEncryptionKey)){\n       request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n     }\n     String text \u003d String.format(\"Failed to %s %s at %d\",\n         (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n-    S3Object object \u003d context.getReadInvoker().once(text, uri,\n+    S3Object object \u003d Invoker.once(text, uri,\n         () -\u003e client.getObject(request));\n     wrappedStream \u003d object.getObjectContent();\n     contentRangeStart \u003d targetPos;\n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n           + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length,\n          boolean forceAbort) throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n        inputPolicy);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String text \u003d String.format(\"Failed to %s %s at %d\",\n        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n    S3Object object \u003d Invoker.once(text, uri,\n        () -\u003e client.getObject(request));\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "d503f65b6689b19278ec2a0cf9da5a8762539de8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-15541. [s3a] Shouldn\u0027t try to drain stream before aborting\nconnection in case of timeout.\n",
      "commitDate": "10/07/18 8:52 AM",
      "commitName": "d503f65b6689b19278ec2a0cf9da5a8762539de8",
      "commitAuthor": "Sean Mackrory",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15541. [s3a] Shouldn\u0027t try to drain stream before aborting\nconnection in case of timeout.\n",
          "commitDate": "10/07/18 8:52 AM",
          "commitName": "d503f65b6689b19278ec2a0cf9da5a8762539de8",
          "commitAuthor": "Sean Mackrory",
          "commitDateOld": "27/06/18 10:37 PM",
          "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 12.43,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,34 @@\n-  private synchronized void reopen(String reason, long targetPos, long length)\n-      throws IOException {\n+  private synchronized void reopen(String reason, long targetPos, long length,\n+          boolean forceAbort) throws IOException {\n \n     if (wrappedStream !\u003d null) {\n-      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n+      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n         inputPolicy);\n \n     long opencount \u003d streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, contentRangeFinish - 1);\n     if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n         StringUtils.isNotBlank(serverSideEncryptionKey)){\n       request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n     }\n     String text \u003d String.format(\"Failed to %s %s at %d\",\n         (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n     S3Object object \u003d context.getReadInvoker().once(text, uri,\n         () -\u003e client.getObject(request));\n     wrappedStream \u003d object.getObjectContent();\n     contentRangeStart \u003d targetPos;\n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n           + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length,\n          boolean forceAbort) throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n        inputPolicy);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String text \u003d String.format(\"Failed to %s %s at %d\",\n        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n    S3Object object \u003d context.getReadInvoker().once(text, uri,\n        () -\u003e client.getObject(request));\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
          "extendedDetails": {
            "oldValue": "[reason-String, targetPos-long, length-long]",
            "newValue": "[reason-String, targetPos-long, length-long, forceAbort-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15541. [s3a] Shouldn\u0027t try to drain stream before aborting\nconnection in case of timeout.\n",
          "commitDate": "10/07/18 8:52 AM",
          "commitName": "d503f65b6689b19278ec2a0cf9da5a8762539de8",
          "commitAuthor": "Sean Mackrory",
          "commitDateOld": "27/06/18 10:37 PM",
          "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 12.43,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,34 @@\n-  private synchronized void reopen(String reason, long targetPos, long length)\n-      throws IOException {\n+  private synchronized void reopen(String reason, long targetPos, long length,\n+          boolean forceAbort) throws IOException {\n \n     if (wrappedStream !\u003d null) {\n-      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n+      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n         inputPolicy);\n \n     long opencount \u003d streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, contentRangeFinish - 1);\n     if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n         StringUtils.isNotBlank(serverSideEncryptionKey)){\n       request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n     }\n     String text \u003d String.format(\"Failed to %s %s at %d\",\n         (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n     S3Object object \u003d context.getReadInvoker().once(text, uri,\n         () -\u003e client.getObject(request));\n     wrappedStream \u003d object.getObjectContent();\n     contentRangeStart \u003d targetPos;\n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n           + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length,\n          boolean forceAbort) throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, forceAbort);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n        inputPolicy);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String text \u003d String.format(\"Failed to %s %s at %d\",\n        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n    S3Object object \u003d context.getReadInvoker().once(text, uri,\n        () -\u003e client.getObject(request));\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13761. S3Guard: implement retries for DDB failures and throttling; translate exceptions.\nContributed by Aaron Fabbri.\n",
      "commitDate": "05/03/18 6:06 AM",
      "commitName": "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/12/17 10:25 AM",
      "commitNameOld": "1ba491ff907fc5d2618add980734a3534e2be098",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 74.82,
      "commitsBetweenForRepo": 402,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n         inputPolicy);\n \n     long opencount \u003d streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, contentRangeFinish - 1);\n     if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n         StringUtils.isNotBlank(serverSideEncryptionKey)){\n       request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n     }\n     String text \u003d String.format(\"Failed to %s %s at %d\",\n         (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n-    S3Object object \u003d invoker.retry(text, uri, true,\n+    S3Object object \u003d context.getReadInvoker().once(text, uri,\n         () -\u003e client.getObject(request));\n     wrappedStream \u003d object.getObjectContent();\n     contentRangeStart \u003d targetPos;\n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n           + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n        inputPolicy);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String text \u003d String.format(\"Failed to %s %s at %d\",\n        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n    S3Object object \u003d context.getReadInvoker().once(text, uri,\n        () -\u003e client.getObject(request));\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "1ba491ff907fc5d2618add980734a3534e2be098": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14965. S3a input stream \"normal\" fadvise mode to be adaptive\n",
      "commitDate": "20/12/17 10:25 AM",
      "commitName": "1ba491ff907fc5d2618add980734a3534e2be098",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "22/11/17 7:28 AM",
      "commitNameOld": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 28.12,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n-        \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n-        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n+        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n+        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n+        inputPolicy);\n \n     long opencount \u003d streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, contentRangeFinish - 1);\n     if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n         StringUtils.isNotBlank(serverSideEncryptionKey)){\n       request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n     }\n     String text \u003d String.format(\"Failed to %s %s at %d\",\n         (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n     S3Object object \u003d invoker.retry(text, uri, true,\n         () -\u003e client.getObject(request));\n     wrappedStream \u003d object.getObjectContent();\n     contentRangeStart \u003d targetPos;\n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n           + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}, policy\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos,\n        inputPolicy);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String text \u003d String.format(\"Failed to %s %s at %d\",\n        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n    S3Object object \u003d invoker.retry(text, uri, true,\n        () -\u003e client.getObject(request));\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "07/09/17 11:55 AM",
      "commitNameOld": "83449abb40633a36b22de538cf82fca240af067e",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 75.86,
      "commitsBetweenForRepo": 676,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n \n-    streamStatistics.streamOpened();\n-    try {\n-      GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n-          .withRange(targetPos, contentRangeFinish - 1);\n-      if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n-          StringUtils.isNotBlank(serverSideEncryptionKey)){\n-        request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n-      }\n-      wrappedStream \u003d client.getObject(request).getObjectContent();\n-      contentRangeStart \u003d targetPos;\n-      if (wrappedStream \u003d\u003d null) {\n-        throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n-            + uri);\n-      }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"Reopen at position \" + targetPos, uri, e);\n+    long opencount \u003d streamStatistics.streamOpened();\n+    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n+        .withRange(targetPos, contentRangeFinish - 1);\n+    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n+        StringUtils.isNotBlank(serverSideEncryptionKey)){\n+      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n+    }\n+    String text \u003d String.format(\"Failed to %s %s at %d\",\n+        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n+    S3Object object \u003d invoker.retry(text, uri, true,\n+        () -\u003e client.getObject(request));\n+    wrappedStream \u003d object.getObjectContent();\n+    contentRangeStart \u003d targetPos;\n+    if (wrappedStream \u003d\u003d null) {\n+      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n+          + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n\n    long opencount \u003d streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, contentRangeFinish - 1);\n    if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n        StringUtils.isNotBlank(serverSideEncryptionKey)){\n      request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n    }\n    String text \u003d String.format(\"Failed to %s %s at %d\",\n        (opencount \u003d\u003d 0 ? \"open\" : \"re-open\"), uri, targetPos);\n    S3Object object \u003d invoker.retry(text, uri, true,\n        () -\u003e client.getObject(request));\n    wrappedStream \u003d object.getObjectContent();\n    contentRangeStart \u003d targetPos;\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "83449abb40633a36b22de538cf82fca240af067e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14774. S3A case \"testRandomReadOverBuffer\" failed due to improper range parameter.\nContributed by Yonger.\n",
      "commitDate": "07/09/17 11:55 AM",
      "commitName": "83449abb40633a36b22de538cf82fca240af067e",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "29/06/17 5:07 PM",
      "commitNameOld": "72993b33b704991f2a0bf743f31b164e58a2dabc",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 69.78,
      "commitsBetweenForRepo": 496,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n \n     streamStatistics.streamOpened();\n     try {\n       GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n-          .withRange(targetPos, contentRangeFinish);\n+          .withRange(targetPos, contentRangeFinish - 1);\n       if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n           StringUtils.isNotBlank(serverSideEncryptionKey)){\n         request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n       }\n       wrappedStream \u003d client.getObject(request).getObjectContent();\n       contentRangeStart \u003d targetPos;\n       if (wrappedStream \u003d\u003d null) {\n         throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n             + uri);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"Reopen at position \" + targetPos, uri, e);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n\n    streamStatistics.streamOpened();\n    try {\n      GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n          .withRange(targetPos, contentRangeFinish - 1);\n      if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n          StringUtils.isNotBlank(serverSideEncryptionKey)){\n        request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n      }\n      wrappedStream \u003d client.getObject(request).getObjectContent();\n      contentRangeStart \u003d targetPos;\n      if (wrappedStream \u003d\u003d null) {\n        throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n            + uri);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"Reopen at position \" + targetPos, uri, e);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "839b690ed5edc2ac4984640d58c005bb63cd8a07": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13075. Add support for SSE-KMS and SSE-C in s3a filesystem. (Steve Moist via lei)\n",
      "commitDate": "11/02/17 1:59 PM",
      "commitName": "839b690ed5edc2ac4984640d58c005bb63cd8a07",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "12/12/16 2:55 PM",
      "commitNameOld": "c6a39232456fa0c98b2b9b6dbeaec762294ca01e",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 60.96,
      "commitsBetweenForRepo": 272,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,33 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n \n     streamStatistics.streamOpened();\n     try {\n       GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n           .withRange(targetPos, contentRangeFinish);\n+      if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n+          StringUtils.isNotBlank(serverSideEncryptionKey)){\n+        request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n+      }\n       wrappedStream \u003d client.getObject(request).getObjectContent();\n       contentRangeStart \u003d targetPos;\n       if (wrappedStream \u003d\u003d null) {\n         throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n             + uri);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"Reopen at position \" + targetPos, uri, e);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n\n    streamStatistics.streamOpened();\n    try {\n      GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n          .withRange(targetPos, contentRangeFinish);\n      if (S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) \u0026\u0026\n          StringUtils.isNotBlank(serverSideEncryptionKey)){\n        request.setSSECustomerKey(new SSECustomerKey(serverSideEncryptionKey));\n      }\n      wrappedStream \u003d client.getObject(request).getObjectContent();\n      contentRangeStart \u003d targetPos;\n      if (wrappedStream \u003d\u003d null) {\n        throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n            + uri);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"Reopen at position \" + targetPos, uri, e);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "c6a39232456fa0c98b2b9b6dbeaec762294ca01e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13871. ITestS3AInputStreamPerformance.testTimeToOpenAndReadWholeFileBlocks performance awful. Contributed by Steve Loughran\n",
      "commitDate": "12/12/16 2:55 PM",
      "commitName": "c6a39232456fa0c98b2b9b6dbeaec762294ca01e",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/09/16 9:36 AM",
      "commitNameOld": "d152557cf7f4d2288524c222fcbaf152bdc038b0",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 97.26,
      "commitsBetweenForRepo": 728,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n \n     if (wrappedStream !\u003d null) {\n-      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish);\n+      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n     }\n \n     contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n         length, contentLength, readahead);\n     LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n         \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n         uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n \n     streamStatistics.streamOpened();\n     try {\n       GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n           .withRange(targetPos, contentRangeFinish);\n       wrappedStream \u003d client.getObject(request).getObjectContent();\n       contentRangeStart \u003d targetPos;\n       if (wrappedStream \u003d\u003d null) {\n         throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n             + uri);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"Reopen at position \" + targetPos, uri, e);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish, false);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n\n    streamStatistics.streamOpened();\n    try {\n      GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n          .withRange(targetPos, contentRangeFinish);\n      wrappedStream \u003d client.getObject(request).getObjectContent();\n      contentRangeStart \u003d targetPos;\n      if (wrappedStream \u003d\u003d null) {\n        throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n            + uri);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"Reopen at position \" + targetPos, uri, e);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "4ee3543625c77c06d566fe81644d21c607d6d74d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13203 S3A: Support fadvise \"random\" mode for high performance readPositioned() reads. Contributed by Rajesh Balamohan and stevel.\n",
      "commitDate": "22/06/16 7:45 AM",
      "commitName": "4ee3543625c77c06d566fe81644d21c607d6d74d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "21/05/16 8:39 AM",
      "commitNameOld": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 31.96,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,29 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n-    requestedStreamLen \u003d this.contentLength;\n \n     if (wrappedStream !\u003d null) {\n-      closeStream(\"reopen(\" + reason + \")\", requestedStreamLen);\n+      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish);\n     }\n-    LOG.debug(\"reopen({}) for {} at targetPos\u003d{}, length\u003d{},\" +\n-        \" requestedStreamLen\u003d{}, streamPosition\u003d{}, nextReadPosition\u003d{}\",\n-        uri, reason, targetPos, length, requestedStreamLen, pos, nextReadPos);\n+\n+    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n+        length, contentLength, readahead);\n+    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n+        \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n+        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n \n     streamStatistics.streamOpened();\n     try {\n       GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n-          .withRange(targetPos, requestedStreamLen);\n+          .withRange(targetPos, contentRangeFinish);\n       wrappedStream \u003d client.getObject(request).getObjectContent();\n-\n+      contentRangeStart \u003d targetPos;\n       if (wrappedStream \u003d\u003d null) {\n         throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n             + uri);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"Reopen at position \" + targetPos, uri, e);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", contentRangeFinish);\n    }\n\n    contentRangeFinish \u003d calculateRequestLimit(inputPolicy, targetPos,\n        length, contentLength, readahead);\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length\u003d{},\" +\n        \" streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, contentRangeFinish, length,  pos, nextReadPos);\n\n    streamStatistics.streamOpened();\n    try {\n      GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n          .withRange(targetPos, contentRangeFinish);\n      wrappedStream \u003d client.getObject(request).getObjectContent();\n      contentRangeStart \u003d targetPos;\n      if (wrappedStream \u003d\u003d null) {\n        throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n            + uri);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"Reopen at position \" + targetPos, uri, e);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 11:24 AM",
      "commitNameOld": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 8.89,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,27 @@\n   private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n     requestedStreamLen \u003d this.contentLength;\n \n     if (wrappedStream !\u003d null) {\n       closeStream(\"reopen(\" + reason + \")\", requestedStreamLen);\n     }\n     LOG.debug(\"reopen({}) for {} at targetPos\u003d{}, length\u003d{},\" +\n         \" requestedStreamLen\u003d{}, streamPosition\u003d{}, nextReadPosition\u003d{}\",\n         uri, reason, targetPos, length, requestedStreamLen, pos, nextReadPos);\n \n     streamStatistics.streamOpened();\n-    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n-        .withRange(targetPos, requestedStreamLen);\n-    wrappedStream \u003d client.getObject(request).getObjectContent();\n+    try {\n+      GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n+          .withRange(targetPos, requestedStreamLen);\n+      wrappedStream \u003d client.getObject(request).getObjectContent();\n \n-    if (wrappedStream \u003d\u003d null) {\n-      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n-          + uri);\n+      if (wrappedStream \u003d\u003d null) {\n+        throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n+            + uri);\n+      }\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"Reopen at position \" + targetPos, uri, e);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n    requestedStreamLen \u003d this.contentLength;\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", requestedStreamLen);\n    }\n    LOG.debug(\"reopen({}) for {} at targetPos\u003d{}, length\u003d{},\" +\n        \" requestedStreamLen\u003d{}, streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, length, requestedStreamLen, pos, nextReadPos);\n\n    streamStatistics.streamOpened();\n    try {\n      GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n          .withRange(targetPos, requestedStreamLen);\n      wrappedStream \u003d client.getObject(request).getObjectContent();\n\n      if (wrappedStream \u003d\u003d null) {\n        throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n            + uri);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"Reopen at position \" + targetPos, uri, e);\n    }\n\n    this.pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
          "commitDate": "12/05/16 11:24 AM",
          "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "09/04/16 3:25 AM",
          "commitNameOld": "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 33.33,
          "commitsBetweenForRepo": 203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,23 @@\n-  private synchronized void reopen(long targetPos, long length)\n+  private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n-    requestedStreamLen \u003d (length \u003c 0) ? this.contentLength :\n-        Math.max(this.contentLength, (CLOSE_THRESHOLD + (targetPos + length)));\n+    requestedStreamLen \u003d this.contentLength;\n \n     if (wrappedStream !\u003d null) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Closing the previous stream\");\n-      }\n-      closeStream(requestedStreamLen);\n+      closeStream(\"reopen(\" + reason + \")\", requestedStreamLen);\n     }\n+    LOG.debug(\"reopen({}) for {} at targetPos\u003d{}, length\u003d{},\" +\n+        \" requestedStreamLen\u003d{}, streamPosition\u003d{}, nextReadPosition\u003d{}\",\n+        uri, reason, targetPos, length, requestedStreamLen, pos, nextReadPos);\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Requesting for \"\n-          + \"targetPos\u003d\" + targetPos\n-          + \", length\u003d\" + length\n-          + \", requestedStreamLen\u003d\" + requestedStreamLen\n-          + \", streamPosition\u003d\" + pos\n-          + \", nextReadPosition\u003d\" + nextReadPos\n-      );\n-    }\n-\n+    streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, requestedStreamLen);\n     wrappedStream \u003d client.getObject(request).getObjectContent();\n \n     if (wrappedStream \u003d\u003d null) {\n-      throw new IOException(\"Null IO stream\");\n+      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n+          + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n    requestedStreamLen \u003d this.contentLength;\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", requestedStreamLen);\n    }\n    LOG.debug(\"reopen({}) for {} at targetPos\u003d{}, length\u003d{},\" +\n        \" requestedStreamLen\u003d{}, streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, length, requestedStreamLen, pos, nextReadPos);\n\n    streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, requestedStreamLen);\n    wrappedStream \u003d client.getObject(request).getObjectContent();\n\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
          "extendedDetails": {
            "oldValue": "[targetPos-long, length-long]",
            "newValue": "[reason-String, targetPos-long, length-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
          "commitDate": "12/05/16 11:24 AM",
          "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "09/04/16 3:25 AM",
          "commitNameOld": "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 33.33,
          "commitsBetweenForRepo": 203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,23 @@\n-  private synchronized void reopen(long targetPos, long length)\n+  private synchronized void reopen(String reason, long targetPos, long length)\n       throws IOException {\n-    requestedStreamLen \u003d (length \u003c 0) ? this.contentLength :\n-        Math.max(this.contentLength, (CLOSE_THRESHOLD + (targetPos + length)));\n+    requestedStreamLen \u003d this.contentLength;\n \n     if (wrappedStream !\u003d null) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Closing the previous stream\");\n-      }\n-      closeStream(requestedStreamLen);\n+      closeStream(\"reopen(\" + reason + \")\", requestedStreamLen);\n     }\n+    LOG.debug(\"reopen({}) for {} at targetPos\u003d{}, length\u003d{},\" +\n+        \" requestedStreamLen\u003d{}, streamPosition\u003d{}, nextReadPosition\u003d{}\",\n+        uri, reason, targetPos, length, requestedStreamLen, pos, nextReadPos);\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Requesting for \"\n-          + \"targetPos\u003d\" + targetPos\n-          + \", length\u003d\" + length\n-          + \", requestedStreamLen\u003d\" + requestedStreamLen\n-          + \", streamPosition\u003d\" + pos\n-          + \", nextReadPosition\u003d\" + nextReadPos\n-      );\n-    }\n-\n+    streamStatistics.streamOpened();\n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n         .withRange(targetPos, requestedStreamLen);\n     wrappedStream \u003d client.getObject(request).getObjectContent();\n \n     if (wrappedStream \u003d\u003d null) {\n-      throw new IOException(\"Null IO stream\");\n+      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n+          + uri);\n     }\n \n     this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void reopen(String reason, long targetPos, long length)\n      throws IOException {\n    requestedStreamLen \u003d this.contentLength;\n\n    if (wrappedStream !\u003d null) {\n      closeStream(\"reopen(\" + reason + \")\", requestedStreamLen);\n    }\n    LOG.debug(\"reopen({}) for {} at targetPos\u003d{}, length\u003d{},\" +\n        \" requestedStreamLen\u003d{}, streamPosition\u003d{}, nextReadPosition\u003d{}\",\n        uri, reason, targetPos, length, requestedStreamLen, pos, nextReadPos);\n\n    streamStatistics.streamOpened();\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, requestedStreamLen);\n    wrappedStream \u003d client.getObject(request).getObjectContent();\n\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream from reopen of (\" + reason +  \") \"\n          + uri);\n    }\n\n    this.pos \u003d targetPos;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "b9e3eff62a7415d8666656a75db69ff3e43f8e7e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-12444 Support lazy seek in S3AInputStream. Rajesh Balamohan via stevel\n",
      "commitDate": "09/04/16 3:25 AM",
      "commitName": "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-12444 Support lazy seek in S3AInputStream. Rajesh Balamohan via stevel\n",
          "commitDate": "09/04/16 3:25 AM",
          "commitName": "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "08/04/16 1:36 PM",
          "commitNameOld": "843ee8d59d8bacbca0d87ccf0790772e39d16138",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,32 @@\n-  private synchronized void reopen(long pos) throws IOException {\n+  private synchronized void reopen(long targetPos, long length)\n+      throws IOException {\n+    requestedStreamLen \u003d (length \u003c 0) ? this.contentLength :\n+        Math.max(this.contentLength, (CLOSE_THRESHOLD + (targetPos + length)));\n \n     if (wrappedStream !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Aborting old stream to open at pos \" + pos);\n+        LOG.debug(\"Closing the previous stream\");\n       }\n-      wrappedStream.abort();\n+      closeStream(requestedStreamLen);\n     }\n \n-    if (pos \u003c 0) {\n-      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK\n-          +\" \" + pos);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Requesting for \"\n+          + \"targetPos\u003d\" + targetPos\n+          + \", length\u003d\" + length\n+          + \", requestedStreamLen\u003d\" + requestedStreamLen\n+          + \", streamPosition\u003d\" + pos\n+          + \", nextReadPosition\u003d\" + nextReadPos\n+      );\n     }\n \n-    if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n-      throw new EOFException(\n-          FSExceptionMessages.CANNOT_SEEK_PAST_EOF\n-          + \" \" + pos);\n-    }\n-\n-    LOG.debug(\"Actually opening file \" + key + \" at pos \" + pos);\n-\n-    GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n-    request.setRange(pos, contentLength-1);\n-\n+    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n+        .withRange(targetPos, requestedStreamLen);\n     wrappedStream \u003d client.getObject(request).getObjectContent();\n \n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream\");\n     }\n \n-    this.pos \u003d pos;\n+    this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void reopen(long targetPos, long length)\n      throws IOException {\n    requestedStreamLen \u003d (length \u003c 0) ? this.contentLength :\n        Math.max(this.contentLength, (CLOSE_THRESHOLD + (targetPos + length)));\n\n    if (wrappedStream !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Closing the previous stream\");\n      }\n      closeStream(requestedStreamLen);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Requesting for \"\n          + \"targetPos\u003d\" + targetPos\n          + \", length\u003d\" + length\n          + \", requestedStreamLen\u003d\" + requestedStreamLen\n          + \", streamPosition\u003d\" + pos\n          + \", nextReadPosition\u003d\" + nextReadPos\n      );\n    }\n\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, requestedStreamLen);\n    wrappedStream \u003d client.getObject(request).getObjectContent();\n\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream\");\n    }\n\n    this.pos \u003d targetPos;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
          "extendedDetails": {
            "oldValue": "[pos-long]",
            "newValue": "[targetPos-long, length-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12444 Support lazy seek in S3AInputStream. Rajesh Balamohan via stevel\n",
          "commitDate": "09/04/16 3:25 AM",
          "commitName": "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "08/04/16 1:36 PM",
          "commitNameOld": "843ee8d59d8bacbca0d87ccf0790772e39d16138",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,32 @@\n-  private synchronized void reopen(long pos) throws IOException {\n+  private synchronized void reopen(long targetPos, long length)\n+      throws IOException {\n+    requestedStreamLen \u003d (length \u003c 0) ? this.contentLength :\n+        Math.max(this.contentLength, (CLOSE_THRESHOLD + (targetPos + length)));\n \n     if (wrappedStream !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Aborting old stream to open at pos \" + pos);\n+        LOG.debug(\"Closing the previous stream\");\n       }\n-      wrappedStream.abort();\n+      closeStream(requestedStreamLen);\n     }\n \n-    if (pos \u003c 0) {\n-      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK\n-          +\" \" + pos);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Requesting for \"\n+          + \"targetPos\u003d\" + targetPos\n+          + \", length\u003d\" + length\n+          + \", requestedStreamLen\u003d\" + requestedStreamLen\n+          + \", streamPosition\u003d\" + pos\n+          + \", nextReadPosition\u003d\" + nextReadPos\n+      );\n     }\n \n-    if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n-      throw new EOFException(\n-          FSExceptionMessages.CANNOT_SEEK_PAST_EOF\n-          + \" \" + pos);\n-    }\n-\n-    LOG.debug(\"Actually opening file \" + key + \" at pos \" + pos);\n-\n-    GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n-    request.setRange(pos, contentLength-1);\n-\n+    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n+        .withRange(targetPos, requestedStreamLen);\n     wrappedStream \u003d client.getObject(request).getObjectContent();\n \n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream\");\n     }\n \n-    this.pos \u003d pos;\n+    this.pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void reopen(long targetPos, long length)\n      throws IOException {\n    requestedStreamLen \u003d (length \u003c 0) ? this.contentLength :\n        Math.max(this.contentLength, (CLOSE_THRESHOLD + (targetPos + length)));\n\n    if (wrappedStream !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Closing the previous stream\");\n      }\n      closeStream(requestedStreamLen);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Requesting for \"\n          + \"targetPos\u003d\" + targetPos\n          + \", length\u003d\" + length\n          + \", requestedStreamLen\u003d\" + requestedStreamLen\n          + \", streamPosition\u003d\" + pos\n          + \", nextReadPosition\u003d\" + nextReadPos\n      );\n    }\n\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key)\n        .withRange(targetPos, requestedStreamLen);\n    wrappedStream \u003d client.getObject(request).getObjectContent();\n\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream\");\n    }\n\n    this.pos \u003d targetPos;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "826267f789df657c62f7f5909e5a0b1a7b102c34": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11570. S3AInputStream.close() downloads the remaining bytes of the object from S3. (Dan Hecht via stevel).\n",
      "commitDate": "17/02/15 8:36 AM",
      "commitName": "826267f789df657c62f7f5909e5a0b1a7b102c34",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/11/14 5:17 PM",
      "commitNameOld": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 103.64,
      "commitsBetweenForRepo": 766,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,33 @@\n   private synchronized void reopen(long pos) throws IOException {\n \n     if (wrappedStream !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Aborting old stream to open at pos \" + pos);\n       }\n       wrappedStream.abort();\n     }\n \n     if (pos \u003c 0) {\n       throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK\n           +\" \" + pos);\n     }\n \n     if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n       throw new EOFException(\n           FSExceptionMessages.CANNOT_SEEK_PAST_EOF\n           + \" \" + pos);\n     }\n \n     LOG.debug(\"Actually opening file \" + key + \" at pos \" + pos);\n \n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n     request.setRange(pos, contentLength-1);\n \n-    wrappedObject \u003d client.getObject(request);\n-    wrappedStream \u003d wrappedObject.getObjectContent();\n+    wrappedStream \u003d client.getObject(request).getObjectContent();\n \n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream\");\n     }\n \n     this.pos \u003d pos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(long pos) throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Aborting old stream to open at pos \" + pos);\n      }\n      wrappedStream.abort();\n    }\n\n    if (pos \u003c 0) {\n      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK\n          +\" \" + pos);\n    }\n\n    if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n      throw new EOFException(\n          FSExceptionMessages.CANNOT_SEEK_PAST_EOF\n          + \" \" + pos);\n    }\n\n    LOG.debug(\"Actually opening file \" + key + \" at pos \" + pos);\n\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n    request.setRange(pos, contentLength-1);\n\n    wrappedStream \u003d client.getObject(request).getObjectContent();\n\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream\");\n    }\n\n    this.pos \u003d pos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "6ba52d88ec11444cbac946ffadbc645acd0657de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10714. AmazonS3Client.deleteObjects() need to be limited to 1000 entries per call. Contributed by Juan Yu.\n",
      "commitDate": "05/11/14 5:17 PM",
      "commitName": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "15/09/14 8:27 AM",
      "commitNameOld": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 51.41,
      "commitsBetweenForRepo": 545,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,34 @@\n   private synchronized void reopen(long pos) throws IOException {\n+\n     if (wrappedStream !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Aborting old stream to open at pos \" + pos);\n       }\n       wrappedStream.abort();\n     }\n \n     if (pos \u003c 0) {\n-      throw new EOFException(\"Trying to seek to a negative offset \" + pos);\n+      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK\n+          +\" \" + pos);\n     }\n \n     if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n-      throw new EOFException(\"Trying to seek to an offset \" + pos + \n-                             \" past the end of the file\");\n+      throw new EOFException(\n+          FSExceptionMessages.CANNOT_SEEK_PAST_EOF\n+          + \" \" + pos);\n     }\n \n-    LOG.info(\"Actually opening file \" + key + \" at pos \" + pos);\n+    LOG.debug(\"Actually opening file \" + key + \" at pos \" + pos);\n \n     GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n     request.setRange(pos, contentLength-1);\n \n     wrappedObject \u003d client.getObject(request);\n     wrappedStream \u003d wrappedObject.getObjectContent();\n \n     if (wrappedStream \u003d\u003d null) {\n       throw new IOException(\"Null IO stream\");\n     }\n \n     this.pos \u003d pos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(long pos) throws IOException {\n\n    if (wrappedStream !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Aborting old stream to open at pos \" + pos);\n      }\n      wrappedStream.abort();\n    }\n\n    if (pos \u003c 0) {\n      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK\n          +\" \" + pos);\n    }\n\n    if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n      throw new EOFException(\n          FSExceptionMessages.CANNOT_SEEK_PAST_EOF\n          + \" \" + pos);\n    }\n\n    LOG.debug(\"Actually opening file \" + key + \" at pos \" + pos);\n\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n    request.setRange(pos, contentLength-1);\n\n    wrappedObject \u003d client.getObject(request);\n    wrappedStream \u003d wrappedObject.getObjectContent();\n\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream\");\n    }\n\n    this.pos \u003d pos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,31 @@\n+  private synchronized void reopen(long pos) throws IOException {\n+    if (wrappedStream !\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Aborting old stream to open at pos \" + pos);\n+      }\n+      wrappedStream.abort();\n+    }\n+\n+    if (pos \u003c 0) {\n+      throw new EOFException(\"Trying to seek to a negative offset \" + pos);\n+    }\n+\n+    if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n+      throw new EOFException(\"Trying to seek to an offset \" + pos + \n+                             \" past the end of the file\");\n+    }\n+\n+    LOG.info(\"Actually opening file \" + key + \" at pos \" + pos);\n+\n+    GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n+    request.setRange(pos, contentLength-1);\n+\n+    wrappedObject \u003d client.getObject(request);\n+    wrappedStream \u003d wrappedObject.getObjectContent();\n+\n+    if (wrappedStream \u003d\u003d null) {\n+      throw new IOException(\"Null IO stream\");\n+    }\n+\n+    this.pos \u003d pos;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(long pos) throws IOException {\n    if (wrappedStream !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Aborting old stream to open at pos \" + pos);\n      }\n      wrappedStream.abort();\n    }\n\n    if (pos \u003c 0) {\n      throw new EOFException(\"Trying to seek to a negative offset \" + pos);\n    }\n\n    if (contentLength \u003e 0 \u0026\u0026 pos \u003e contentLength-1) {\n      throw new EOFException(\"Trying to seek to an offset \" + pos + \n                             \" past the end of the file\");\n    }\n\n    LOG.info(\"Actually opening file \" + key + \" at pos \" + pos);\n\n    GetObjectRequest request \u003d new GetObjectRequest(bucket, key);\n    request.setRange(pos, contentLength-1);\n\n    wrappedObject \u003d client.getObject(request);\n    wrappedStream \u003d wrappedObject.getObjectContent();\n\n    if (wrappedStream \u003d\u003d null) {\n      throw new IOException(\"Null IO stream\");\n    }\n\n    this.pos \u003d pos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java"
    }
  }
}