{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Tasks.java",
  "functionName": "runParallel",
  "functionId": "runParallel___task-Task__I,E__(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/Tasks.java",
  "functionStartLine": 234,
  "functionEndLine": 342,
  "numCommitsSeen": 1,
  "timeTaken": 1257,
  "changeHistory": [
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c"
  ],
  "changeHistoryShort": {
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,109 @@\n+    private \u003cE extends Exception\u003e boolean runParallel(final Task\u003cI, E\u003e task)\n+        throws E {\n+      final Queue\u003cI\u003e succeeded \u003d new ConcurrentLinkedQueue\u003c\u003e();\n+      final Queue\u003cException\u003e exceptions \u003d new ConcurrentLinkedQueue\u003c\u003e();\n+      final AtomicBoolean taskFailed \u003d new AtomicBoolean(false);\n+      final AtomicBoolean abortFailed \u003d new AtomicBoolean(false);\n+      final AtomicBoolean revertFailed \u003d new AtomicBoolean(false);\n+\n+      List\u003cFuture\u003c?\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n+\n+      for (final I item : items) {\n+        // submit a task for each item that will either run or abort the task\n+        futures.add(service.submit(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!(stopOnFailure \u0026\u0026 taskFailed.get())) {\n+              // run the task\n+              boolean threw \u003d true;\n+              try {\n+                LOG.debug(\"Executing task\");\n+                task.run(item);\n+                succeeded.add(item);\n+                LOG.debug(\"Task succeeded\");\n+\n+                threw \u003d false;\n+\n+              } catch (Exception e) {\n+                taskFailed.set(true);\n+                exceptions.add(e);\n+                LOG.info(\"Task failed\", e);\n+\n+                if (onFailure !\u003d null) {\n+                  try {\n+                    onFailure.run(item, e);\n+                  } catch (Exception failException) {\n+                    LOG.error(\"Failed to clean up on failure\", e);\n+                    // swallow the exception\n+                  }\n+                }\n+              } finally {\n+                if (threw) {\n+                  taskFailed.set(true);\n+                }\n+              }\n+\n+            } else if (abortTask !\u003d null) {\n+              // abort the task instead of running it\n+              if (stopAbortsOnFailure \u0026\u0026 abortFailed.get()) {\n+                return;\n+              }\n+\n+              boolean failed \u003d true;\n+              try {\n+                LOG.info(\"Aborting task\");\n+                abortTask.run(item);\n+                failed \u003d false;\n+              } catch (Exception e) {\n+                LOG.error(\"Failed to abort task\", e);\n+                // swallow the exception\n+              } finally {\n+                if (failed) {\n+                  abortFailed.set(true);\n+                }\n+              }\n+            }\n+          }\n+        }));\n+      }\n+\n+      // let the above tasks complete (or abort)\n+      waitFor(futures);\n+      int futureCount \u003d futures.size();\n+      futures.clear();\n+\n+      if (taskFailed.get() \u0026\u0026 revertTask !\u003d null) {\n+        // at least one task failed, revert any that succeeded\n+        LOG.info(\"Reverting all {} succeeded tasks from {} futures\",\n+            succeeded.size(), futureCount);\n+        for (final I item : succeeded) {\n+          futures.add(service.submit(() -\u003e {\n+            if (stopRevertsOnFailure \u0026\u0026 revertFailed.get()) {\n+              return;\n+            }\n+\n+            boolean failed \u003d true;\n+            try {\n+              revertTask.run(item);\n+              failed \u003d false;\n+            } catch (Exception e) {\n+              LOG.error(\"Failed to revert task\", e);\n+              // swallow the exception\n+            } finally {\n+              if (failed) {\n+                revertFailed.set(true);\n+              }\n+            }\n+          }));\n+        }\n+\n+        // let the revert tasks complete\n+        waitFor(futures);\n+      }\n+\n+      if (!suppressExceptions \u0026\u0026 !exceptions.isEmpty()) {\n+        Tasks.\u003cE\u003ethrowOne(exceptions);\n+      }\n+\n+      return !taskFailed.get();\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private \u003cE extends Exception\u003e boolean runParallel(final Task\u003cI, E\u003e task)\n        throws E {\n      final Queue\u003cI\u003e succeeded \u003d new ConcurrentLinkedQueue\u003c\u003e();\n      final Queue\u003cException\u003e exceptions \u003d new ConcurrentLinkedQueue\u003c\u003e();\n      final AtomicBoolean taskFailed \u003d new AtomicBoolean(false);\n      final AtomicBoolean abortFailed \u003d new AtomicBoolean(false);\n      final AtomicBoolean revertFailed \u003d new AtomicBoolean(false);\n\n      List\u003cFuture\u003c?\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n\n      for (final I item : items) {\n        // submit a task for each item that will either run or abort the task\n        futures.add(service.submit(new Runnable() {\n          @Override\n          public void run() {\n            if (!(stopOnFailure \u0026\u0026 taskFailed.get())) {\n              // run the task\n              boolean threw \u003d true;\n              try {\n                LOG.debug(\"Executing task\");\n                task.run(item);\n                succeeded.add(item);\n                LOG.debug(\"Task succeeded\");\n\n                threw \u003d false;\n\n              } catch (Exception e) {\n                taskFailed.set(true);\n                exceptions.add(e);\n                LOG.info(\"Task failed\", e);\n\n                if (onFailure !\u003d null) {\n                  try {\n                    onFailure.run(item, e);\n                  } catch (Exception failException) {\n                    LOG.error(\"Failed to clean up on failure\", e);\n                    // swallow the exception\n                  }\n                }\n              } finally {\n                if (threw) {\n                  taskFailed.set(true);\n                }\n              }\n\n            } else if (abortTask !\u003d null) {\n              // abort the task instead of running it\n              if (stopAbortsOnFailure \u0026\u0026 abortFailed.get()) {\n                return;\n              }\n\n              boolean failed \u003d true;\n              try {\n                LOG.info(\"Aborting task\");\n                abortTask.run(item);\n                failed \u003d false;\n              } catch (Exception e) {\n                LOG.error(\"Failed to abort task\", e);\n                // swallow the exception\n              } finally {\n                if (failed) {\n                  abortFailed.set(true);\n                }\n              }\n            }\n          }\n        }));\n      }\n\n      // let the above tasks complete (or abort)\n      waitFor(futures);\n      int futureCount \u003d futures.size();\n      futures.clear();\n\n      if (taskFailed.get() \u0026\u0026 revertTask !\u003d null) {\n        // at least one task failed, revert any that succeeded\n        LOG.info(\"Reverting all {} succeeded tasks from {} futures\",\n            succeeded.size(), futureCount);\n        for (final I item : succeeded) {\n          futures.add(service.submit(() -\u003e {\n            if (stopRevertsOnFailure \u0026\u0026 revertFailed.get()) {\n              return;\n            }\n\n            boolean failed \u003d true;\n            try {\n              revertTask.run(item);\n              failed \u003d false;\n            } catch (Exception e) {\n              LOG.error(\"Failed to revert task\", e);\n              // swallow the exception\n            } finally {\n              if (failed) {\n                revertFailed.set(true);\n              }\n            }\n          }));\n        }\n\n        // let the revert tasks complete\n        waitFor(futures);\n      }\n\n      if (!suppressExceptions \u0026\u0026 !exceptions.isEmpty()) {\n        Tasks.\u003cE\u003ethrowOne(exceptions);\n      }\n\n      return !taskFailed.get();\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/commit/Tasks.java"
    }
  }
}