{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativePmemMappableBlockLoader.java",
  "functionName": "load",
  "functionId": "load___length-long__blockIn-FileInputStream__metaIn-FileInputStream__blockFileName-String__key-ExtendedBlockId",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/NativePmemMappableBlockLoader.java",
  "functionStartLine": 78,
  "functionEndLine": 119,
  "numCommitsSeen": 3,
  "timeTaken": 1730,
  "changeHistory": [
    "d79cce20abbbf321f6dcce03f4087544124a7cd2",
    "d1aad444907e1fc5314e8e64529e57c51ed7561c"
  ],
  "changeHistoryShort": {
    "d79cce20abbbf321f6dcce03f4087544124a7cd2": "Ybodychange",
    "d1aad444907e1fc5314e8e64529e57c51ed7561c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d79cce20abbbf321f6dcce03f4087544124a7cd2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14740. Recover data blocks from persistent memory read cache during datanode restarts. Contributed by Feilong He.\n",
      "commitDate": "01/01/20 10:14 PM",
      "commitName": "d79cce20abbbf321f6dcce03f4087544124a7cd2",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "15/07/19 12:32 AM",
      "commitNameOld": "e98adb00b7da8fa913b86ecf2049444b1d8617d4",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 170.95,
      "commitsBetweenForRepo": 1070,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public MappableBlock load(long length, FileInputStream blockIn,\n       FileInputStream metaIn, String blockFileName,\n       ExtendedBlockId key)\n       throws IOException {\n     NativePmemMappedBlock mappableBlock \u003d null;\n     POSIX.PmemMappedRegion region \u003d null;\n     String filePath \u003d null;\n \n     FileChannel blockChannel \u003d null;\n     try {\n       blockChannel \u003d blockIn.getChannel();\n       if (blockChannel \u003d\u003d null) {\n         throw new IOException(\"Block InputStream has no FileChannel.\");\n       }\n \n       assert NativeIO.isAvailable();\n       filePath \u003d PmemVolumeManager.getInstance().getCachePath(key);\n-      region \u003d POSIX.Pmem.mapBlock(filePath, length);\n+      region \u003d POSIX.Pmem.mapBlock(filePath, length, false);\n       if (region \u003d\u003d null) {\n         throw new IOException(\"Failed to map the block \" + blockFileName +\n             \" to persistent storage.\");\n       }\n       verifyChecksumAndMapBlock(region, length, metaIn, blockChannel,\n           blockFileName);\n       mappableBlock \u003d new NativePmemMappedBlock(region.getAddress(),\n           region.getLength(), key);\n       LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n           + \", [cached path\u003d{}, address\u003d{}, length\u003d{}]\", key, filePath,\n           region.getAddress(), length);\n     } finally {\n       IOUtils.closeQuietly(blockChannel);\n       if (mappableBlock \u003d\u003d null) {\n         if (region !\u003d null) {\n           // unmap content from persistent memory\n           POSIX.Pmem.unmapBlock(region.getAddress(),\n               region.getLength());\n           FsDatasetUtil.deleteMappedFile(filePath);\n         }\n       }\n     }\n     return mappableBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public MappableBlock load(long length, FileInputStream blockIn,\n      FileInputStream metaIn, String blockFileName,\n      ExtendedBlockId key)\n      throws IOException {\n    NativePmemMappedBlock mappableBlock \u003d null;\n    POSIX.PmemMappedRegion region \u003d null;\n    String filePath \u003d null;\n\n    FileChannel blockChannel \u003d null;\n    try {\n      blockChannel \u003d blockIn.getChannel();\n      if (blockChannel \u003d\u003d null) {\n        throw new IOException(\"Block InputStream has no FileChannel.\");\n      }\n\n      assert NativeIO.isAvailable();\n      filePath \u003d PmemVolumeManager.getInstance().getCachePath(key);\n      region \u003d POSIX.Pmem.mapBlock(filePath, length, false);\n      if (region \u003d\u003d null) {\n        throw new IOException(\"Failed to map the block \" + blockFileName +\n            \" to persistent storage.\");\n      }\n      verifyChecksumAndMapBlock(region, length, metaIn, blockChannel,\n          blockFileName);\n      mappableBlock \u003d new NativePmemMappedBlock(region.getAddress(),\n          region.getLength(), key);\n      LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n          + \", [cached path\u003d{}, address\u003d{}, length\u003d{}]\", key, filePath,\n          region.getAddress(), length);\n    } finally {\n      IOUtils.closeQuietly(blockChannel);\n      if (mappableBlock \u003d\u003d null) {\n        if (region !\u003d null) {\n          // unmap content from persistent memory\n          POSIX.Pmem.unmapBlock(region.getAddress(),\n              region.getLength());\n          FsDatasetUtil.deleteMappedFile(filePath);\n        }\n      }\n    }\n    return mappableBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/NativePmemMappableBlockLoader.java",
      "extendedDetails": {}
    },
    "d1aad444907e1fc5314e8e64529e57c51ed7561c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14356. Implement HDFS cache on SCM with native PMDK libs. Contributed by Feilong He.\n",
      "commitDate": "05/06/19 6:33 AM",
      "commitName": "d1aad444907e1fc5314e8e64529e57c51ed7561c",
      "commitAuthor": "Sammi Chen",
      "diff": "@@ -0,0 +1,42 @@\n+  public MappableBlock load(long length, FileInputStream blockIn,\n+      FileInputStream metaIn, String blockFileName,\n+      ExtendedBlockId key)\n+      throws IOException {\n+    NativePmemMappedBlock mappableBlock \u003d null;\n+    POSIX.PmemMappedRegion region \u003d null;\n+    String filePath \u003d null;\n+\n+    FileChannel blockChannel \u003d null;\n+    try {\n+      blockChannel \u003d blockIn.getChannel();\n+      if (blockChannel \u003d\u003d null) {\n+        throw new IOException(\"Block InputStream has no FileChannel.\");\n+      }\n+\n+      assert NativeIO.isAvailable();\n+      filePath \u003d PmemVolumeManager.getInstance().getCachePath(key);\n+      region \u003d POSIX.Pmem.mapBlock(filePath, length);\n+      if (region \u003d\u003d null) {\n+        throw new IOException(\"Failed to map the block \" + blockFileName +\n+            \" to persistent storage.\");\n+      }\n+      verifyChecksumAndMapBlock(region, length, metaIn, blockChannel,\n+          blockFileName);\n+      mappableBlock \u003d new NativePmemMappedBlock(region.getAddress(),\n+          region.getLength(), key);\n+      LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n+          + \", [cached path\u003d{}, address\u003d{}, length\u003d{}]\", key, filePath,\n+          region.getAddress(), length);\n+    } finally {\n+      IOUtils.closeQuietly(blockChannel);\n+      if (mappableBlock \u003d\u003d null) {\n+        if (region !\u003d null) {\n+          // unmap content from persistent memory\n+          POSIX.Pmem.unmapBlock(region.getAddress(),\n+              region.getLength());\n+          FsDatasetUtil.deleteMappedFile(filePath);\n+        }\n+      }\n+    }\n+    return mappableBlock;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public MappableBlock load(long length, FileInputStream blockIn,\n      FileInputStream metaIn, String blockFileName,\n      ExtendedBlockId key)\n      throws IOException {\n    NativePmemMappedBlock mappableBlock \u003d null;\n    POSIX.PmemMappedRegion region \u003d null;\n    String filePath \u003d null;\n\n    FileChannel blockChannel \u003d null;\n    try {\n      blockChannel \u003d blockIn.getChannel();\n      if (blockChannel \u003d\u003d null) {\n        throw new IOException(\"Block InputStream has no FileChannel.\");\n      }\n\n      assert NativeIO.isAvailable();\n      filePath \u003d PmemVolumeManager.getInstance().getCachePath(key);\n      region \u003d POSIX.Pmem.mapBlock(filePath, length);\n      if (region \u003d\u003d null) {\n        throw new IOException(\"Failed to map the block \" + blockFileName +\n            \" to persistent storage.\");\n      }\n      verifyChecksumAndMapBlock(region, length, metaIn, blockChannel,\n          blockFileName);\n      mappableBlock \u003d new NativePmemMappedBlock(region.getAddress(),\n          region.getLength(), key);\n      LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n          + \", [cached path\u003d{}, address\u003d{}, length\u003d{}]\", key, filePath,\n          region.getAddress(), length);\n    } finally {\n      IOUtils.closeQuietly(blockChannel);\n      if (mappableBlock \u003d\u003d null) {\n        if (region !\u003d null) {\n          // unmap content from persistent memory\n          POSIX.Pmem.unmapBlock(region.getAddress(),\n              region.getLength());\n          FsDatasetUtil.deleteMappedFile(filePath);\n        }\n      }\n    }\n    return mappableBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/NativePmemMappableBlockLoader.java"
    }
  }
}