{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RouterRpcClient.java",
  "functionName": "invokeConcurrent",
  "functionId": "invokeConcurrent___locations-Collection__T__(modifiers-final)__method-RemoteMethod(modifiers-final)__requireResponse-boolean__standby-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
  "functionStartLine": 1097,
  "functionEndLine": 1101,
  "numCommitsSeen": 30,
  "timeTaken": 3778,
  "changeHistory": [
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
    "81601dac8ec7650bec14700b174910390a92fe1f",
    "bc9e588a19c0aaf518de8dab719362be4a8d6a54",
    "ca4f209b49e3aad6a80306f7342c9b6b560a79a7"
  ],
  "changeHistoryShort": {
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Yfilerename",
    "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba": "Ymultichange(Yreturntypechange,Ybodychange)",
    "81601dac8ec7650bec14700b174910390a92fe1f": "Ybodychange",
    "bc9e588a19c0aaf518de8dab719362be4a8d6a54": "Ybodychange",
    "ca4f209b49e3aad6a80306f7342c9b6b560a79a7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "commitDateOld": "19/03/18 5:19 PM",
      "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e void invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby) throws IOException {\n    invokeConcurrent(locations, method, requireResponse, standby, void.class);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java"
      }
    },
    "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.\n",
      "commitDate": "12/01/18 4:25 PM",
      "commitName": "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
      "commitAuthor": "Inigo Goiri",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.\n",
          "commitDate": "12/01/18 4:25 PM",
          "commitName": "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "29/11/17 9:43 AM",
          "commitNameOld": "301641811d93ac22dc6fe1a05f18c1f266cc5e54",
          "commitAuthorOld": "Wei Yan",
          "daysBetweenCommits": 44.28,
          "commitsBetweenForRepo": 258,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,5 @@\n-  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n+  public \u003cT extends RemoteLocationContext, R\u003e void invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby) throws IOException {\n-    return invokeConcurrent(locations, method, requireResponse, standby, -1);\n+    invokeConcurrent(locations, method, requireResponse, standby, void.class);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e void invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby) throws IOException {\n    invokeConcurrent(locations, method, requireResponse, standby, void.class);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
          "extendedDetails": {
            "oldValue": "Map\u003cT,Object\u003e",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.\n",
          "commitDate": "12/01/18 4:25 PM",
          "commitName": "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "29/11/17 9:43 AM",
          "commitNameOld": "301641811d93ac22dc6fe1a05f18c1f266cc5e54",
          "commitAuthorOld": "Wei Yan",
          "daysBetweenCommits": 44.28,
          "commitsBetweenForRepo": 258,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,5 @@\n-  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n+  public \u003cT extends RemoteLocationContext, R\u003e void invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby) throws IOException {\n-    return invokeConcurrent(locations, method, requireResponse, standby, -1);\n+    invokeConcurrent(locations, method, requireResponse, standby, void.class);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e void invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby) throws IOException {\n    invokeConcurrent(locations, method, requireResponse, standby, void.class);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "81601dac8ec7650bec14700b174910390a92fe1f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12273. Federation UI. Contributed by Inigo Goiri.\n\n(cherry picked from commit adbb2e00c7b85524fd43bd68895d49814c16680a)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "81601dac8ec7650bec14700b174910390a92fe1f",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "bc9e588a19c0aaf518de8dab719362be4a8d6a54",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,5 @@\n   public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby) throws IOException {\n-\n-    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n-    final Method m \u003d method.getMethod();\n-\n-    if (locations.size() \u003d\u003d 1) {\n-      // Shortcut, just one call\n-      T location \u003d locations.iterator().next();\n-      String ns \u003d location.getNameserviceId();\n-      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n-          getNamenodesForNameservice(ns);\n-      Object[] paramList \u003d method.getParams(location);\n-      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n-      return Collections.singletonMap(location, result);\n-    }\n-\n-    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n-    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n-    for (final T location : locations) {\n-      String nsId \u003d location.getNameserviceId();\n-      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n-          getNamenodesForNameservice(nsId);\n-      final Object[] paramList \u003d method.getParams(location);\n-      if (standby) {\n-        // Call the objectGetter to all NNs (including standby)\n-        for (final FederationNamenodeContext nn : namenodes) {\n-          String nnId \u003d nn.getNamenodeId();\n-          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n-              Collections.singletonList(nn);\n-          T nnLocation \u003d location;\n-          if (location instanceof RemoteLocation) {\n-            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n-          }\n-          orderedLocations.add(nnLocation);\n-          callables.add(new Callable\u003cObject\u003e() {\n-            public Object call() throws Exception {\n-              return invokeMethod(ugi, nnList, m, paramList);\n-            }\n-          });\n-        }\n-      } else {\n-        // Call the objectGetter in order of nameservices in the NS list\n-        orderedLocations.add(location);\n-        callables.add(new Callable\u003cObject\u003e() {\n-          public Object call() throws Exception {\n-            return invokeMethod(ugi, namenodes, m, paramList);\n-          }\n-        });\n-      }\n-    }\n-\n-    if (rpcMonitor !\u003d null) {\n-      rpcMonitor.proxyOp();\n-    }\n-\n-    try {\n-      List\u003cFuture\u003cObject\u003e\u003e futures \u003d executorService.invokeAll(callables);\n-      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n-      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n-      for (int i\u003d0; i\u003cfutures.size(); i++) {\n-        T location \u003d orderedLocations.get(i);\n-        try {\n-          Future\u003cObject\u003e future \u003d futures.get(i);\n-          Object result \u003d future.get();\n-          results.put(location, result);\n-        } catch (ExecutionException ex) {\n-          Throwable cause \u003d ex.getCause();\n-          LOG.debug(\"Canot execute {} in {}: {}\",\n-              m.getName(), location, cause.getMessage());\n-\n-          // Convert into IOException if needed\n-          IOException ioe \u003d null;\n-          if (cause instanceof IOException) {\n-            ioe \u003d (IOException) cause;\n-          } else {\n-            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n-                m.getName() + \": \" + cause.getMessage(), cause);\n-          }\n-\n-          // Response from all servers required, use this error.\n-          if (requireResponse) {\n-            throw ioe;\n-          }\n-\n-          // Store the exceptions\n-          exceptions.put(location, ioe);\n-        }\n-      }\n-\n-      // Throw the exception for the first location if there are no results\n-      if (results.isEmpty()) {\n-        T location \u003d orderedLocations.get(0);\n-        IOException ioe \u003d exceptions.get(location);\n-        if (ioe !\u003d null) {\n-          throw ioe;\n-        }\n-      }\n-\n-      return results;\n-    } catch (InterruptedException ex) {\n-      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n-      throw new IOException(\n-          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n-    }\n+    return invokeConcurrent(locations, method, requireResponse, standby, -1);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby) throws IOException {\n    return invokeConcurrent(locations, method, requireResponse, standby, -1);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "bc9e588a19c0aaf518de8dab719362be4a8d6a54": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12335. Federation Metrics. Contributed by Inigo Goiri.\n\n(cherry picked from commit 3b19e77752afce87936f5c0d1e6d272fba798d7b)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "bc9e588a19c0aaf518de8dab719362be4a8d6a54",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "ca4f209b49e3aad6a80306f7342c9b6b560a79a7",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,107 @@\n   public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby) throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n       return Collections.singletonMap(location, result);\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, m, paramList);\n           }\n         });\n       }\n     }\n \n+    if (rpcMonitor !\u003d null) {\n+      rpcMonitor.proxyOp();\n+    }\n+\n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d executorService.invokeAll(callables);\n       Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, result);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby) throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n      return Collections.singletonMap(location, result);\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d executorService.invokeAll(callables);\n      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, result);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "ca4f209b49e3aad6a80306f7342c9b6b560a79a7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11546. Federation Router RPC server. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 8a9cdebebf26841a0f1e99fb08135f4597f2eba2)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "ca4f209b49e3aad6a80306f7342c9b6b560a79a7",
      "commitAuthor": "Inigo Goiri",
      "diff": "@@ -0,0 +1,103 @@\n+  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n+      final Collection\u003cT\u003e locations, final RemoteMethod method,\n+      boolean requireResponse, boolean standby) throws IOException {\n+\n+    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n+    final Method m \u003d method.getMethod();\n+\n+    if (locations.size() \u003d\u003d 1) {\n+      // Shortcut, just one call\n+      T location \u003d locations.iterator().next();\n+      String ns \u003d location.getNameserviceId();\n+      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n+          getNamenodesForNameservice(ns);\n+      Object[] paramList \u003d method.getParams(location);\n+      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n+      return Collections.singletonMap(location, result);\n+    }\n+\n+    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n+    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n+    for (final T location : locations) {\n+      String nsId \u003d location.getNameserviceId();\n+      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n+          getNamenodesForNameservice(nsId);\n+      final Object[] paramList \u003d method.getParams(location);\n+      if (standby) {\n+        // Call the objectGetter to all NNs (including standby)\n+        for (final FederationNamenodeContext nn : namenodes) {\n+          String nnId \u003d nn.getNamenodeId();\n+          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n+              Collections.singletonList(nn);\n+          T nnLocation \u003d location;\n+          if (location instanceof RemoteLocation) {\n+            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n+          }\n+          orderedLocations.add(nnLocation);\n+          callables.add(new Callable\u003cObject\u003e() {\n+            public Object call() throws Exception {\n+              return invokeMethod(ugi, nnList, m, paramList);\n+            }\n+          });\n+        }\n+      } else {\n+        // Call the objectGetter in order of nameservices in the NS list\n+        orderedLocations.add(location);\n+        callables.add(new Callable\u003cObject\u003e() {\n+          public Object call() throws Exception {\n+            return invokeMethod(ugi, namenodes, m, paramList);\n+          }\n+        });\n+      }\n+    }\n+\n+    try {\n+      List\u003cFuture\u003cObject\u003e\u003e futures \u003d executorService.invokeAll(callables);\n+      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n+      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n+      for (int i\u003d0; i\u003cfutures.size(); i++) {\n+        T location \u003d orderedLocations.get(i);\n+        try {\n+          Future\u003cObject\u003e future \u003d futures.get(i);\n+          Object result \u003d future.get();\n+          results.put(location, result);\n+        } catch (ExecutionException ex) {\n+          Throwable cause \u003d ex.getCause();\n+          LOG.debug(\"Canot execute {} in {}: {}\",\n+              m.getName(), location, cause.getMessage());\n+\n+          // Convert into IOException if needed\n+          IOException ioe \u003d null;\n+          if (cause instanceof IOException) {\n+            ioe \u003d (IOException) cause;\n+          } else {\n+            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n+                m.getName() + \": \" + cause.getMessage(), cause);\n+          }\n+\n+          // Response from all servers required, use this error.\n+          if (requireResponse) {\n+            throw ioe;\n+          }\n+\n+          // Store the exceptions\n+          exceptions.put(location, ioe);\n+        }\n+      }\n+\n+      // Throw the exception for the first location if there are no results\n+      if (results.isEmpty()) {\n+        T location \u003d orderedLocations.get(0);\n+        IOException ioe \u003d exceptions.get(location);\n+        if (ioe !\u003d null) {\n+          throw ioe;\n+        }\n+      }\n+\n+      return results;\n+    } catch (InterruptedException ex) {\n+      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n+      throw new IOException(\n+          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby) throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n      return Collections.singletonMap(location, result);\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, m, paramList);\n          }\n        });\n      }\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d executorService.invokeAll(callables);\n      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, result);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java"
    }
  }
}