{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FpgaResourceHandlerImpl.java",
  "functionName": "preStart",
  "functionId": "preStart___container-Container",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/fpga/FpgaResourceHandlerImpl.java",
  "functionStartLine": 113,
  "functionEndLine": 229,
  "numCommitsSeen": 9,
  "timeTaken": 2233,
  "changeHistory": [
    "56f1e131ecb9f53dcc2596807f8dec2d2b95bb51",
    "a99eb80659835107f4015c859b3319bf3a70c281",
    "8e1539eca8175f58f836daa5b0ad598c890cbb02",
    "7225ec0ceb49ae8f5588484297a20f07ec047420"
  ],
  "changeHistoryShort": {
    "56f1e131ecb9f53dcc2596807f8dec2d2b95bb51": "Ybodychange",
    "a99eb80659835107f4015c859b3319bf3a70c281": "Ybodychange",
    "8e1539eca8175f58f836daa5b0ad598c890cbb02": "Ybodychange",
    "7225ec0ceb49ae8f5588484297a20f07ec047420": "Yintroduced"
  },
  "changeHistoryDetails": {
    "56f1e131ecb9f53dcc2596807f8dec2d2b95bb51": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9270. Minor cleanup in TestFpgaDiscoverer. Contributed by Peter Bacsko.\n",
      "commitDate": "29/03/19 10:58 AM",
      "commitName": "56f1e131ecb9f53dcc2596807f8dec2d2b95bb51",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "27/03/19 10:08 AM",
      "commitNameOld": "a4cd75e09c934699ec5e2fa969f1c8d0a14c1d49",
      "commitAuthorOld": "Devaraj K",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n   public List\u003cPrivilegedOperation\u003e preStart(Container container)\n       throws ResourceHandlerException {\n     // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n     // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n     // 3. If required, download to ensure IP file exists and configure IP file for all devices\n     List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d container.getContainerId().toString();\n     Resource requestedResource \u003d container.getResource();\n \n     // Create device cgroups for the container\n     cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n       containerIdStr);\n \n     long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n     LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n     String ipFilePath \u003d null;\n     try {\n \n       // allocate even request 0 FPGA because we need to deny all device numbers for this container\n       final String requestedIPID \u003d getRequestedIPID(container);\n       String localizedIPIDHash \u003d null;\n       ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n           requestedIPID, container.getWorkDir(),\n           container.getResourceSet().getLocalizedResources());\n       if (ipFilePath !\u003d null) {\n         try (FileInputStream fis \u003d new FileInputStream(ipFilePath)) {\n           localizedIPIDHash \u003d DigestUtils.sha256Hex(fis);\n         } catch (IOException e) {\n           throw new ResourceHandlerException(\"Could not calculate SHA-256\", e);\n         }\n       }\n \n       FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n           vendorPlugin.getFpgaType(), deviceCount,\n           container, localizedIPIDHash);\n       LOG.info(\"FpgaAllocation:\" + allocation);\n \n       PrivilegedOperation privilegedOperation \u003d\n           new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n           Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n       if (!allocation.getDenied().isEmpty()) {\n         List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n         allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n         privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n             StringUtils.join(\",\", denied)));\n       }\n       privilegedOperationExecutor.executePrivilegedOperation(\n           privilegedOperation, true);\n \n       if (deviceCount \u003e 0) {\n         /**\n          * We only support flashing one IP for all devices now. If user don\u0027t set this\n          * environment variable, we assume that user\u0027s application can find the IP file by\n          * itself.\n          * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n          * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n          * for the containers will achieve the quickest reprogram path\n          *\n          * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n          * programmed with matrix multiplication IP\n          *\n          * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n          * for different devices\n          *\n          * */\n         ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n             getRequestedIPID(container),\n             container.getWorkDir(),\n             container.getResourceSet().getLocalizedResources());\n         if (ipFilePath \u003d\u003d null) {\n           LOG.warn(\"FPGA plugin failed to downloaded IP, please check the\" +\n               \" value of environment viable: \" + REQUEST_FPGA_IP_ID_KEY +\n               \" if you want YARN to program the device\");\n         } else {\n           LOG.info(\"IP file path:\" + ipFilePath);\n-          List\u003cFpgaResourceAllocator.FpgaDevice\u003e allowed \u003d allocation.getAllowed();\n+          List\u003cFpgaDevice\u003e allowed \u003d allocation.getAllowed();\n           String majorMinorNumber;\n           for (int i \u003d 0; i \u003c allowed.size(); i++) {\n             FpgaDevice device \u003d allowed.get(i);\n             majorMinorNumber \u003d device.getMajor() + \":\" + device.getMinor();\n             String currentHash \u003d allowed.get(i).getAocxHash();\n             if (currentHash !\u003d null \u0026\u0026\n                 currentHash.equalsIgnoreCase(localizedIPIDHash)) {\n               LOG.info(\"IP already in device \\\"\"\n                   + allowed.get(i).getAliasDevName() + \",\" +\n                   majorMinorNumber + \"\\\", skip reprogramming\");\n               continue;\n             }\n             if (vendorPlugin.configureIP(ipFilePath, device)) {\n               // update the allocator that we update an IP of a device\n               allocator.updateFpga(containerIdStr, allowed.get(i),\n                   requestedIPID, localizedIPIDHash);\n               //TODO: update the node constraint label\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException re) {\n       allocator.cleanupAssignFpgas(containerIdStr);\n       cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n           containerIdStr);\n       throw re;\n     } catch (PrivilegedOperationException e) {\n       allocator.cleanupAssignFpgas(containerIdStr);\n       cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n           containerIdStr);\n       LOG.warn(\"Could not update cgroup for container\", e);\n       throw new ResourceHandlerException(e);\n     }\n     //isolation operation\n     ret.add(new PrivilegedOperation(\n         PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n         PrivilegedOperation.CGROUP_ARG_PREFIX\n         + cGroupsHandler.getPathForCGroupTasks(\n         CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cPrivilegedOperation\u003e preStart(Container container)\n      throws ResourceHandlerException {\n    // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n    // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n    // 3. If required, download to ensure IP file exists and configure IP file for all devices\n    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d container.getContainerId().toString();\n    Resource requestedResource \u003d container.getResource();\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n      containerIdStr);\n\n    long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n    LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n    String ipFilePath \u003d null;\n    try {\n\n      // allocate even request 0 FPGA because we need to deny all device numbers for this container\n      final String requestedIPID \u003d getRequestedIPID(container);\n      String localizedIPIDHash \u003d null;\n      ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n          requestedIPID, container.getWorkDir(),\n          container.getResourceSet().getLocalizedResources());\n      if (ipFilePath !\u003d null) {\n        try (FileInputStream fis \u003d new FileInputStream(ipFilePath)) {\n          localizedIPIDHash \u003d DigestUtils.sha256Hex(fis);\n        } catch (IOException e) {\n          throw new ResourceHandlerException(\"Could not calculate SHA-256\", e);\n        }\n      }\n\n      FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n          vendorPlugin.getFpgaType(), deviceCount,\n          container, localizedIPIDHash);\n      LOG.info(\"FpgaAllocation:\" + allocation);\n\n      PrivilegedOperation privilegedOperation \u003d\n          new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n          Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n      if (!allocation.getDenied().isEmpty()) {\n        List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n        allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n            StringUtils.join(\",\", denied)));\n      }\n      privilegedOperationExecutor.executePrivilegedOperation(\n          privilegedOperation, true);\n\n      if (deviceCount \u003e 0) {\n        /**\n         * We only support flashing one IP for all devices now. If user don\u0027t set this\n         * environment variable, we assume that user\u0027s application can find the IP file by\n         * itself.\n         * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n         * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n         * for the containers will achieve the quickest reprogram path\n         *\n         * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n         * programmed with matrix multiplication IP\n         *\n         * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n         * for different devices\n         *\n         * */\n        ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n            getRequestedIPID(container),\n            container.getWorkDir(),\n            container.getResourceSet().getLocalizedResources());\n        if (ipFilePath \u003d\u003d null) {\n          LOG.warn(\"FPGA plugin failed to downloaded IP, please check the\" +\n              \" value of environment viable: \" + REQUEST_FPGA_IP_ID_KEY +\n              \" if you want YARN to program the device\");\n        } else {\n          LOG.info(\"IP file path:\" + ipFilePath);\n          List\u003cFpgaDevice\u003e allowed \u003d allocation.getAllowed();\n          String majorMinorNumber;\n          for (int i \u003d 0; i \u003c allowed.size(); i++) {\n            FpgaDevice device \u003d allowed.get(i);\n            majorMinorNumber \u003d device.getMajor() + \":\" + device.getMinor();\n            String currentHash \u003d allowed.get(i).getAocxHash();\n            if (currentHash !\u003d null \u0026\u0026\n                currentHash.equalsIgnoreCase(localizedIPIDHash)) {\n              LOG.info(\"IP already in device \\\"\"\n                  + allowed.get(i).getAliasDevName() + \",\" +\n                  majorMinorNumber + \"\\\", skip reprogramming\");\n              continue;\n            }\n            if (vendorPlugin.configureIP(ipFilePath, device)) {\n              // update the allocator that we update an IP of a device\n              allocator.updateFpga(containerIdStr, allowed.get(i),\n                  requestedIPID, localizedIPIDHash);\n              //TODO: update the node constraint label\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException re) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      throw re;\n    } catch (PrivilegedOperationException e) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      LOG.warn(\"Could not update cgroup for container\", e);\n      throw new ResourceHandlerException(e);\n    }\n    //isolation operation\n    ret.add(new PrivilegedOperation(\n        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n        PrivilegedOperation.CGROUP_ARG_PREFIX\n        + cGroupsHandler.getPathForCGroupTasks(\n        CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/fpga/FpgaResourceHandlerImpl.java",
      "extendedDetails": {}
    },
    "a99eb80659835107f4015c859b3319bf3a70c281": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9267. General improvements in FpgaResourceHandlerImpl. Contributed by Peter Bacsko.\n",
      "commitDate": "21/03/19 11:15 AM",
      "commitName": "a99eb80659835107f4015c859b3319bf3a70c281",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "18/03/19 10:57 AM",
      "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,117 @@\n   public List\u003cPrivilegedOperation\u003e preStart(Container container)\n       throws ResourceHandlerException {\n     // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n     // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n     // 3. If required, download to ensure IP file exists and configure IP file for all devices\n     List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d container.getContainerId().toString();\n     Resource requestedResource \u003d container.getResource();\n \n     // Create device cgroups for the container\n     cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n       containerIdStr);\n \n     long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n     LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n     String ipFilePath \u003d null;\n     try {\n \n       // allocate even request 0 FPGA because we need to deny all device numbers for this container\n+      final String requestedIPID \u003d getRequestedIPID(container);\n+      String localizedIPIDHash \u003d null;\n+      ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n+          requestedIPID, container.getWorkDir(),\n+          container.getResourceSet().getLocalizedResources());\n+      if (ipFilePath !\u003d null) {\n+        try (FileInputStream fis \u003d new FileInputStream(ipFilePath)) {\n+          localizedIPIDHash \u003d DigestUtils.sha256Hex(fis);\n+        } catch (IOException e) {\n+          throw new ResourceHandlerException(\"Could not calculate SHA-256\", e);\n+        }\n+      }\n+\n       FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n           vendorPlugin.getFpgaType(), deviceCount,\n-          container, getRequestedIPID(container));\n+          container, localizedIPIDHash);\n       LOG.info(\"FpgaAllocation:\" + allocation);\n \n       PrivilegedOperation privilegedOperation \u003d\n           new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n           Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n       if (!allocation.getDenied().isEmpty()) {\n         List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n         allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n         privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n             StringUtils.join(\",\", denied)));\n       }\n       privilegedOperationExecutor.executePrivilegedOperation(\n           privilegedOperation, true);\n \n       if (deviceCount \u003e 0) {\n         /**\n          * We only support flashing one IP for all devices now. If user don\u0027t set this\n          * environment variable, we assume that user\u0027s application can find the IP file by\n          * itself.\n          * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n          * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n          * for the containers will achieve the quickest reprogram path\n          *\n          * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n          * programmed with matrix multiplication IP\n          *\n          * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n          * for different devices\n          *\n          * */\n         ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n             getRequestedIPID(container),\n             container.getWorkDir(),\n             container.getResourceSet().getLocalizedResources());\n         if (ipFilePath \u003d\u003d null) {\n           LOG.warn(\"FPGA plugin failed to downloaded IP, please check the\" +\n               \" value of environment viable: \" + REQUEST_FPGA_IP_ID_KEY +\n               \" if you want YARN to program the device\");\n         } else {\n           LOG.info(\"IP file path:\" + ipFilePath);\n           List\u003cFpgaResourceAllocator.FpgaDevice\u003e allowed \u003d allocation.getAllowed();\n           String majorMinorNumber;\n           for (int i \u003d 0; i \u003c allowed.size(); i++) {\n             FpgaDevice device \u003d allowed.get(i);\n             majorMinorNumber \u003d device.getMajor() + \":\" + device.getMinor();\n-            String currentIPID \u003d device.getIPID();\n-            if (null !\u003d currentIPID \u0026\u0026\n-                currentIPID.equalsIgnoreCase(getRequestedIPID(container))) {\n-              LOG.info(\"IP already in device \\\"\" +\n-                  allowed.get(i).getAliasDevName() +\n-                  \",\" + majorMinorNumber + \"\\\", skip reprogramming\");\n+            String currentHash \u003d allowed.get(i).getAocxHash();\n+            if (currentHash !\u003d null \u0026\u0026\n+                currentHash.equalsIgnoreCase(localizedIPIDHash)) {\n+              LOG.info(\"IP already in device \\\"\"\n+                  + allowed.get(i).getAliasDevName() + \",\" +\n+                  majorMinorNumber + \"\\\", skip reprogramming\");\n               continue;\n             }\n             if (vendorPlugin.configureIP(ipFilePath, device)) {\n               // update the allocator that we update an IP of a device\n               allocator.updateFpga(containerIdStr, allowed.get(i),\n-                  getRequestedIPID(container));\n+                  requestedIPID, localizedIPIDHash);\n               //TODO: update the node constraint label\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException re) {\n       allocator.cleanupAssignFpgas(containerIdStr);\n       cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n           containerIdStr);\n       throw re;\n     } catch (PrivilegedOperationException e) {\n       allocator.cleanupAssignFpgas(containerIdStr);\n       cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n           containerIdStr);\n       LOG.warn(\"Could not update cgroup for container\", e);\n       throw new ResourceHandlerException(e);\n     }\n     //isolation operation\n     ret.add(new PrivilegedOperation(\n         PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n         PrivilegedOperation.CGROUP_ARG_PREFIX\n         + cGroupsHandler.getPathForCGroupTasks(\n         CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cPrivilegedOperation\u003e preStart(Container container)\n      throws ResourceHandlerException {\n    // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n    // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n    // 3. If required, download to ensure IP file exists and configure IP file for all devices\n    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d container.getContainerId().toString();\n    Resource requestedResource \u003d container.getResource();\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n      containerIdStr);\n\n    long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n    LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n    String ipFilePath \u003d null;\n    try {\n\n      // allocate even request 0 FPGA because we need to deny all device numbers for this container\n      final String requestedIPID \u003d getRequestedIPID(container);\n      String localizedIPIDHash \u003d null;\n      ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n          requestedIPID, container.getWorkDir(),\n          container.getResourceSet().getLocalizedResources());\n      if (ipFilePath !\u003d null) {\n        try (FileInputStream fis \u003d new FileInputStream(ipFilePath)) {\n          localizedIPIDHash \u003d DigestUtils.sha256Hex(fis);\n        } catch (IOException e) {\n          throw new ResourceHandlerException(\"Could not calculate SHA-256\", e);\n        }\n      }\n\n      FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n          vendorPlugin.getFpgaType(), deviceCount,\n          container, localizedIPIDHash);\n      LOG.info(\"FpgaAllocation:\" + allocation);\n\n      PrivilegedOperation privilegedOperation \u003d\n          new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n          Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n      if (!allocation.getDenied().isEmpty()) {\n        List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n        allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n            StringUtils.join(\",\", denied)));\n      }\n      privilegedOperationExecutor.executePrivilegedOperation(\n          privilegedOperation, true);\n\n      if (deviceCount \u003e 0) {\n        /**\n         * We only support flashing one IP for all devices now. If user don\u0027t set this\n         * environment variable, we assume that user\u0027s application can find the IP file by\n         * itself.\n         * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n         * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n         * for the containers will achieve the quickest reprogram path\n         *\n         * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n         * programmed with matrix multiplication IP\n         *\n         * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n         * for different devices\n         *\n         * */\n        ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n            getRequestedIPID(container),\n            container.getWorkDir(),\n            container.getResourceSet().getLocalizedResources());\n        if (ipFilePath \u003d\u003d null) {\n          LOG.warn(\"FPGA plugin failed to downloaded IP, please check the\" +\n              \" value of environment viable: \" + REQUEST_FPGA_IP_ID_KEY +\n              \" if you want YARN to program the device\");\n        } else {\n          LOG.info(\"IP file path:\" + ipFilePath);\n          List\u003cFpgaResourceAllocator.FpgaDevice\u003e allowed \u003d allocation.getAllowed();\n          String majorMinorNumber;\n          for (int i \u003d 0; i \u003c allowed.size(); i++) {\n            FpgaDevice device \u003d allowed.get(i);\n            majorMinorNumber \u003d device.getMajor() + \":\" + device.getMinor();\n            String currentHash \u003d allowed.get(i).getAocxHash();\n            if (currentHash !\u003d null \u0026\u0026\n                currentHash.equalsIgnoreCase(localizedIPIDHash)) {\n              LOG.info(\"IP already in device \\\"\"\n                  + allowed.get(i).getAliasDevName() + \",\" +\n                  majorMinorNumber + \"\\\", skip reprogramming\");\n              continue;\n            }\n            if (vendorPlugin.configureIP(ipFilePath, device)) {\n              // update the allocator that we update an IP of a device\n              allocator.updateFpga(containerIdStr, allowed.get(i),\n                  requestedIPID, localizedIPIDHash);\n              //TODO: update the node constraint label\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException re) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      throw re;\n    } catch (PrivilegedOperationException e) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      LOG.warn(\"Could not update cgroup for container\", e);\n      throw new ResourceHandlerException(e);\n    }\n    //isolation operation\n    ret.add(new PrivilegedOperation(\n        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n        PrivilegedOperation.CGROUP_ARG_PREFIX\n        + cGroupsHandler.getPathForCGroupTasks(\n        CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/fpga/FpgaResourceHandlerImpl.java",
      "extendedDetails": {}
    },
    "8e1539eca8175f58f836daa5b0ad598c890cbb02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9266. General improvements in IntelFpgaOpenclPlugin. Contributed by Peter Bacsko.\n",
      "commitDate": "12/03/19 2:15 PM",
      "commitName": "8e1539eca8175f58f836daa5b0ad598c890cbb02",
      "commitAuthor": "Sunil G",
      "commitDateOld": "10/12/18 11:12 AM",
      "commitNameOld": "ac578c0e82a5ba24bf59e9e58f91a3eb65c60cfe",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 92.08,
      "commitsBetweenForRepo": 689,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,104 @@\n-  public List\u003cPrivilegedOperation\u003e preStart(Container container) throws ResourceHandlerException {\n+  public List\u003cPrivilegedOperation\u003e preStart(Container container)\n+      throws ResourceHandlerException {\n     // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n     // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n     // 3. If required, download to ensure IP file exists and configure IP file for all devices\n     List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d container.getContainerId().toString();\n     Resource requestedResource \u003d container.getResource();\n \n     // Create device cgroups for the container\n     cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n       containerIdStr);\n \n     long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n     LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n     String ipFilePath \u003d null;\n     try {\n \n       // allocate even request 0 FPGA because we need to deny all device numbers for this container\n       FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n           vendorPlugin.getFpgaType(), deviceCount,\n           container, getRequestedIPID(container));\n       LOG.info(\"FpgaAllocation:\" + allocation);\n \n-      PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n+      PrivilegedOperation privilegedOperation \u003d\n+          new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n           Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n       if (!allocation.getDenied().isEmpty()) {\n         List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n         allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n         privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n             StringUtils.join(\",\", denied)));\n       }\n-      privilegedOperationExecutor.executePrivilegedOperation(privilegedOperation, true);\n+      privilegedOperationExecutor.executePrivilegedOperation(\n+          privilegedOperation, true);\n \n       if (deviceCount \u003e 0) {\n         /**\n          * We only support flashing one IP for all devices now. If user don\u0027t set this\n          * environment variable, we assume that user\u0027s application can find the IP file by\n          * itself.\n          * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n          * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n          * for the containers will achieve the quickest reprogram path\n          *\n          * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n          * programmed with matrix multiplication IP\n          *\n          * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n          * for different devices\n          *\n          * */\n-        ipFilePath \u003d vendorPlugin.downloadIP(getRequestedIPID(container), container.getWorkDir(),\n+        ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n+            getRequestedIPID(container),\n+            container.getWorkDir(),\n             container.getResourceSet().getLocalizedResources());\n-        if (ipFilePath.isEmpty()) {\n-          LOG.warn(\"FPGA plugin failed to download IP but continue, please check the value of environment viable: \" +\n-              REQUEST_FPGA_IP_ID_KEY + \" if you want yarn to help\");\n+        if (ipFilePath \u003d\u003d null) {\n+          LOG.warn(\"FPGA plugin failed to downloaded IP, please check the\" +\n+              \" value of environment viable: \" + REQUEST_FPGA_IP_ID_KEY +\n+              \" if you want YARN to program the device\");\n         } else {\n           LOG.info(\"IP file path:\" + ipFilePath);\n           List\u003cFpgaResourceAllocator.FpgaDevice\u003e allowed \u003d allocation.getAllowed();\n           String majorMinorNumber;\n           for (int i \u003d 0; i \u003c allowed.size(); i++) {\n-            majorMinorNumber \u003d allowed.get(i).getMajor() + \":\" + allowed.get(i).getMinor();\n-            String currentIPID \u003d allowed.get(i).getIPID();\n+            FpgaDevice device \u003d allowed.get(i);\n+            majorMinorNumber \u003d device.getMajor() + \":\" + device.getMinor();\n+            String currentIPID \u003d device.getIPID();\n             if (null !\u003d currentIPID \u0026\u0026\n                 currentIPID.equalsIgnoreCase(getRequestedIPID(container))) {\n-              LOG.info(\"IP already in device \\\"\" + allowed.get(i).getAliasDevName() + \",\" +\n-                  majorMinorNumber + \"\\\", skip reprogramming\");\n+              LOG.info(\"IP already in device \\\"\" +\n+                  allowed.get(i).getAliasDevName() +\n+                  \",\" + majorMinorNumber + \"\\\", skip reprogramming\");\n               continue;\n             }\n-            if (vendorPlugin.configureIP(ipFilePath, majorMinorNumber)) {\n+            if (vendorPlugin.configureIP(ipFilePath, device)) {\n               // update the allocator that we update an IP of a device\n               allocator.updateFpga(containerIdStr, allowed.get(i),\n                   getRequestedIPID(container));\n               //TODO: update the node constraint label\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException re) {\n       allocator.cleanupAssignFpgas(containerIdStr);\n       cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n           containerIdStr);\n       throw re;\n     } catch (PrivilegedOperationException e) {\n       allocator.cleanupAssignFpgas(containerIdStr);\n-      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES, containerIdStr);\n+      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n+          containerIdStr);\n       LOG.warn(\"Could not update cgroup for container\", e);\n       throw new ResourceHandlerException(e);\n     }\n     //isolation operation\n     ret.add(new PrivilegedOperation(\n         PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n         PrivilegedOperation.CGROUP_ARG_PREFIX\n         + cGroupsHandler.getPathForCGroupTasks(\n         CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cPrivilegedOperation\u003e preStart(Container container)\n      throws ResourceHandlerException {\n    // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n    // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n    // 3. If required, download to ensure IP file exists and configure IP file for all devices\n    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d container.getContainerId().toString();\n    Resource requestedResource \u003d container.getResource();\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n      containerIdStr);\n\n    long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n    LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n    String ipFilePath \u003d null;\n    try {\n\n      // allocate even request 0 FPGA because we need to deny all device numbers for this container\n      FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n          vendorPlugin.getFpgaType(), deviceCount,\n          container, getRequestedIPID(container));\n      LOG.info(\"FpgaAllocation:\" + allocation);\n\n      PrivilegedOperation privilegedOperation \u003d\n          new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n          Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n      if (!allocation.getDenied().isEmpty()) {\n        List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n        allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n            StringUtils.join(\",\", denied)));\n      }\n      privilegedOperationExecutor.executePrivilegedOperation(\n          privilegedOperation, true);\n\n      if (deviceCount \u003e 0) {\n        /**\n         * We only support flashing one IP for all devices now. If user don\u0027t set this\n         * environment variable, we assume that user\u0027s application can find the IP file by\n         * itself.\n         * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n         * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n         * for the containers will achieve the quickest reprogram path\n         *\n         * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n         * programmed with matrix multiplication IP\n         *\n         * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n         * for different devices\n         *\n         * */\n        ipFilePath \u003d vendorPlugin.retrieveIPfilePath(\n            getRequestedIPID(container),\n            container.getWorkDir(),\n            container.getResourceSet().getLocalizedResources());\n        if (ipFilePath \u003d\u003d null) {\n          LOG.warn(\"FPGA plugin failed to downloaded IP, please check the\" +\n              \" value of environment viable: \" + REQUEST_FPGA_IP_ID_KEY +\n              \" if you want YARN to program the device\");\n        } else {\n          LOG.info(\"IP file path:\" + ipFilePath);\n          List\u003cFpgaResourceAllocator.FpgaDevice\u003e allowed \u003d allocation.getAllowed();\n          String majorMinorNumber;\n          for (int i \u003d 0; i \u003c allowed.size(); i++) {\n            FpgaDevice device \u003d allowed.get(i);\n            majorMinorNumber \u003d device.getMajor() + \":\" + device.getMinor();\n            String currentIPID \u003d device.getIPID();\n            if (null !\u003d currentIPID \u0026\u0026\n                currentIPID.equalsIgnoreCase(getRequestedIPID(container))) {\n              LOG.info(\"IP already in device \\\"\" +\n                  allowed.get(i).getAliasDevName() +\n                  \",\" + majorMinorNumber + \"\\\", skip reprogramming\");\n              continue;\n            }\n            if (vendorPlugin.configureIP(ipFilePath, device)) {\n              // update the allocator that we update an IP of a device\n              allocator.updateFpga(containerIdStr, allowed.get(i),\n                  getRequestedIPID(container));\n              //TODO: update the node constraint label\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException re) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      throw re;\n    } catch (PrivilegedOperationException e) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      LOG.warn(\"Could not update cgroup for container\", e);\n      throw new ResourceHandlerException(e);\n    }\n    //isolation operation\n    ret.add(new PrivilegedOperation(\n        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n        PrivilegedOperation.CGROUP_ARG_PREFIX\n        + cGroupsHandler.getPathForCGroupTasks(\n        CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/fpga/FpgaResourceHandlerImpl.java",
      "extendedDetails": {}
    },
    "7225ec0ceb49ae8f5588484297a20f07ec047420": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6507. Add support in NodeManager to isolate FPGA devices with CGroups. (Zhankun Tang via wangda)\n\nChange-Id: Ic9afd841805f1035423915a0b0add5f3ba96cf9d\n",
      "commitDate": "01/12/17 10:50 AM",
      "commitName": "7225ec0ceb49ae8f5588484297a20f07ec047420",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,95 @@\n+  public List\u003cPrivilegedOperation\u003e preStart(Container container) throws ResourceHandlerException {\n+    // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n+    // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n+    // 3. If required, download to ensure IP file exists and configure IP file for all devices\n+    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n+    String containerIdStr \u003d container.getContainerId().toString();\n+    Resource requestedResource \u003d container.getResource();\n+\n+    // Create device cgroups for the container\n+    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n+      containerIdStr);\n+\n+    long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n+    LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n+    String ipFilePath \u003d null;\n+    try {\n+\n+      // allocate even request 0 FPGA because we need to deny all device numbers for this container\n+      FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n+          vendorPlugin.getFpgaType(), deviceCount,\n+          container, getRequestedIPID(container));\n+      LOG.info(\"FpgaAllocation:\" + allocation);\n+\n+      PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n+          Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n+      if (!allocation.getDenied().isEmpty()) {\n+        List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n+        allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n+        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n+            StringUtils.join(\",\", denied)));\n+      }\n+      privilegedOperationExecutor.executePrivilegedOperation(privilegedOperation, true);\n+\n+      if (deviceCount \u003e 0) {\n+        /**\n+         * We only support flashing one IP for all devices now. If user don\u0027t set this\n+         * environment variable, we assume that user\u0027s application can find the IP file by\n+         * itself.\n+         * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n+         * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n+         * for the containers will achieve the quickest reprogram path\n+         *\n+         * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n+         * programmed with matrix multiplication IP\n+         *\n+         * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n+         * for different devices\n+         *\n+         * */\n+        ipFilePath \u003d vendorPlugin.downloadIP(getRequestedIPID(container), container.getWorkDir(),\n+            container.getResourceSet().getLocalizedResources());\n+        if (ipFilePath.isEmpty()) {\n+          LOG.warn(\"FPGA plugin failed to download IP but continue, please check the value of environment viable: \" +\n+              REQUEST_FPGA_IP_ID_KEY + \" if you want yarn to help\");\n+        } else {\n+          LOG.info(\"IP file path:\" + ipFilePath);\n+          List\u003cFpgaResourceAllocator.FpgaDevice\u003e allowed \u003d allocation.getAllowed();\n+          String majorMinorNumber;\n+          for (int i \u003d 0; i \u003c allowed.size(); i++) {\n+            majorMinorNumber \u003d allowed.get(i).getMajor() + \":\" + allowed.get(i).getMinor();\n+            String currentIPID \u003d allowed.get(i).getIPID();\n+            if (null !\u003d currentIPID \u0026\u0026\n+                currentIPID.equalsIgnoreCase(getRequestedIPID(container))) {\n+              LOG.info(\"IP already in device \\\"\" + allowed.get(i).getAliasDevName() + \",\" +\n+                  majorMinorNumber + \"\\\", skip reprogramming\");\n+              continue;\n+            }\n+            if (vendorPlugin.configureIP(ipFilePath, majorMinorNumber)) {\n+              // update the allocator that we update an IP of a device\n+              allocator.updateFpga(containerIdStr, allowed.get(i),\n+                  getRequestedIPID(container));\n+              //TODO: update the node constraint label\n+            }\n+          }\n+        }\n+      }\n+    } catch (ResourceHandlerException re) {\n+      allocator.cleanupAssignFpgas(containerIdStr);\n+      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n+          containerIdStr);\n+      throw re;\n+    } catch (PrivilegedOperationException e) {\n+      allocator.cleanupAssignFpgas(containerIdStr);\n+      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES, containerIdStr);\n+      LOG.warn(\"Could not update cgroup for container\", e);\n+      throw new ResourceHandlerException(e);\n+    }\n+    //isolation operation\n+    ret.add(new PrivilegedOperation(\n+        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n+        PrivilegedOperation.CGROUP_ARG_PREFIX\n+        + cGroupsHandler.getPathForCGroupTasks(\n+        CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cPrivilegedOperation\u003e preStart(Container container) throws ResourceHandlerException {\n    // 1. Get requested FPGA type and count, choose corresponding FPGA plugin(s)\n    // 2. Use allocator.assignFpga(type, count) to get FPGAAllocation\n    // 3. If required, download to ensure IP file exists and configure IP file for all devices\n    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d container.getContainerId().toString();\n    Resource requestedResource \u003d container.getResource();\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n      containerIdStr);\n\n    long deviceCount \u003d requestedResource.getResourceValue(FPGA_URI);\n    LOG.info(containerIdStr + \" requested \" + deviceCount + \" Intel FPGA(s)\");\n    String ipFilePath \u003d null;\n    try {\n\n      // allocate even request 0 FPGA because we need to deny all device numbers for this container\n      FpgaResourceAllocator.FpgaAllocation allocation \u003d allocator.assignFpga(\n          vendorPlugin.getFpgaType(), deviceCount,\n          container, getRequestedIPID(container));\n      LOG.info(\"FpgaAllocation:\" + allocation);\n\n      PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(PrivilegedOperation.OperationType.FPGA,\n          Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n      if (!allocation.getDenied().isEmpty()) {\n        List\u003cInteger\u003e denied \u003d new ArrayList\u003c\u003e();\n        allocation.getDenied().forEach(device -\u003e denied.add(device.getMinor()));\n        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_FPGAS_CLI_OPTION,\n            StringUtils.join(\",\", denied)));\n      }\n      privilegedOperationExecutor.executePrivilegedOperation(privilegedOperation, true);\n\n      if (deviceCount \u003e 0) {\n        /**\n         * We only support flashing one IP for all devices now. If user don\u0027t set this\n         * environment variable, we assume that user\u0027s application can find the IP file by\n         * itself.\n         * Note that the IP downloading and reprogramming in advance in YARN is not necessary because\n         * the OpenCL application may find the IP file and reprogram device on the fly. But YARN do this\n         * for the containers will achieve the quickest reprogram path\n         *\n         * For instance, REQUESTED_FPGA_IP_ID \u003d \"matrix_mul\" will make all devices\n         * programmed with matrix multiplication IP\n         *\n         * In the future, we may support \"matrix_mul:1,gzip:2\" format to support different IP\n         * for different devices\n         *\n         * */\n        ipFilePath \u003d vendorPlugin.downloadIP(getRequestedIPID(container), container.getWorkDir(),\n            container.getResourceSet().getLocalizedResources());\n        if (ipFilePath.isEmpty()) {\n          LOG.warn(\"FPGA plugin failed to download IP but continue, please check the value of environment viable: \" +\n              REQUEST_FPGA_IP_ID_KEY + \" if you want yarn to help\");\n        } else {\n          LOG.info(\"IP file path:\" + ipFilePath);\n          List\u003cFpgaResourceAllocator.FpgaDevice\u003e allowed \u003d allocation.getAllowed();\n          String majorMinorNumber;\n          for (int i \u003d 0; i \u003c allowed.size(); i++) {\n            majorMinorNumber \u003d allowed.get(i).getMajor() + \":\" + allowed.get(i).getMinor();\n            String currentIPID \u003d allowed.get(i).getIPID();\n            if (null !\u003d currentIPID \u0026\u0026\n                currentIPID.equalsIgnoreCase(getRequestedIPID(container))) {\n              LOG.info(\"IP already in device \\\"\" + allowed.get(i).getAliasDevName() + \",\" +\n                  majorMinorNumber + \"\\\", skip reprogramming\");\n              continue;\n            }\n            if (vendorPlugin.configureIP(ipFilePath, majorMinorNumber)) {\n              // update the allocator that we update an IP of a device\n              allocator.updateFpga(containerIdStr, allowed.get(i),\n                  getRequestedIPID(container));\n              //TODO: update the node constraint label\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException re) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      throw re;\n    } catch (PrivilegedOperationException e) {\n      allocator.cleanupAssignFpgas(containerIdStr);\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES, containerIdStr);\n      LOG.warn(\"Could not update cgroup for container\", e);\n      throw new ResourceHandlerException(e);\n    }\n    //isolation operation\n    ret.add(new PrivilegedOperation(\n        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n        PrivilegedOperation.CGROUP_ARG_PREFIX\n        + cGroupsHandler.getPathForCGroupTasks(\n        CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/fpga/FpgaResourceHandlerImpl.java"
    }
  }
}