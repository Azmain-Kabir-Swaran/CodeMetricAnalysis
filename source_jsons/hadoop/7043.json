{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSPermissionChecker.java",
  "functionName": "checkPermission",
  "functionId": "checkPermission___inodesInPath-INodesInPath__doCheckOwner-boolean__ancestorAccess-FsAction__parentAccess-FsAction__access-FsAction__subAccess-FsAction__ignoreEmptyDir-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
  "functionStartLine": 190,
  "functionEndLine": 246,
  "numCommitsSeen": 141,
  "timeTaken": 9172,
  "changeHistory": [
    "4b95c242eca540455a4d5d0899aaf73b6064b5ea",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
    "5776a41da08af653206bb94d7c76c9c4dcce059a",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
    "e9c6840b24bab7d6c21243baa9b2353119b0f976",
    "0689363343a281a6f7f6f395227668bddc2663eb",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "6521b5ee423ef489d7b7f85e74dd5f8d91bd06aa",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16",
    "099762a0bc960066f8157fdd1e495b6752a6f802",
    "34413c2000d9262faa37fde88a72939587edc776",
    "7ee5ce3176a74d217551b5981f809a56c719424b",
    "359b4efd193b772d13b2571dedec7e0622309d78",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "4b95c242eca540455a4d5d0899aaf73b6064b5ea": "Ybodychange",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": "Ybodychange",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": "Ybodychange",
    "5776a41da08af653206bb94d7c76c9c4dcce059a": "Ybodychange",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "e9c6840b24bab7d6c21243baa9b2353119b0f976": "Ymultichange(Yparameterchange,Ybodychange)",
    "0689363343a281a6f7f6f395227668bddc2663eb": "Ymultichange(Yparameterchange,Ybodychange)",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "6521b5ee423ef489d7b7f85e74dd5f8d91bd06aa": "Ymultichange(Yparameterchange,Ybodychange)",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": "Ybodychange",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": "Ybodychange",
    "099762a0bc960066f8157fdd1e495b6752a6f802": "Ybodychange",
    "34413c2000d9262faa37fde88a72939587edc776": "Ybodychange",
    "7ee5ce3176a74d217551b5981f809a56c719424b": "Ybodychange",
    "359b4efd193b772d13b2571dedec7e0622309d78": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4b95c242eca540455a4d5d0899aaf73b6064b5ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14743. Enhance INodeAttributeProvider/ AccessControlEnforcer Interface in HDFS to support Authorization of mkdir, rm, rmdir, copy, move etc... (#1829)\n\nReviewed-by: Xiaoyu Yao \u003cxyao@apache.org\u003e",
      "commitDate": "13/03/20 11:29 AM",
      "commitName": "4b95c242eca540455a4d5d0899aaf73b6064b5ea",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "19/02/20 11:33 AM",
      "commitNameOld": "ec7507162c7e23c0cd251e09b6be0030a500f1ca",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 22.96,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,57 @@\n   void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess, boolean ignoreEmptyDir)\n       throws AccessControlException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n           + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodesArray();\n     final INodeAttributes[] inodeAttrs \u003d new INodeAttributes[inodes.length];\n     final byte[][] components \u003d inodesInPath.getPathComponents();\n     for (int i \u003d 0; i \u003c inodes.length \u0026\u0026 inodes[i] !\u003d null; i++) {\n       inodeAttrs[i] \u003d getINodeAttrs(components, i, inodes[i], snapshotId);\n     }\n \n     String path \u003d inodesInPath.getPath();\n     int ancestorIndex \u003d inodes.length - 2;\n \n     AccessControlEnforcer enforcer \u003d getAccessControlEnforcer();\n-    enforcer.checkPermission(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n-        components, snapshotId, path, ancestorIndex, doCheckOwner,\n-        ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n+\n+    String opType \u003d operationType.get();\n+    if (this.authorizeWithContext \u0026\u0026 opType !\u003d null) {\n+      INodeAttributeProvider.AuthorizationContext.Builder builder \u003d\n+          new INodeAttributeProvider.AuthorizationContext.Builder();\n+      builder.fsOwner(fsOwner).\n+          supergroup(supergroup).\n+          callerUgi(callerUgi).\n+          inodeAttrs(inodeAttrs).\n+          inodes(inodes).\n+          pathByNameArr(components).\n+          snapshotId(snapshotId).\n+          path(path).\n+          ancestorIndex(ancestorIndex).\n+          doCheckOwner(doCheckOwner).\n+          ancestorAccess(ancestorAccess).\n+          parentAccess(parentAccess).\n+          access(access).\n+          subAccess(subAccess).\n+          ignoreEmptyDir(ignoreEmptyDir).\n+          operationName(opType).\n+          callerContext(CallerContext.getCurrent());\n+      enforcer.checkPermissionWithContext(builder.build());\n+    } else {\n+      enforcer.checkPermission(fsOwner, supergroup, callerUgi, inodeAttrs,\n+          inodes, components, snapshotId, path, ancestorIndex, doCheckOwner,\n+          ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n+    }\n+\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir)\n      throws AccessControlException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodesArray();\n    final INodeAttributes[] inodeAttrs \u003d new INodeAttributes[inodes.length];\n    final byte[][] components \u003d inodesInPath.getPathComponents();\n    for (int i \u003d 0; i \u003c inodes.length \u0026\u0026 inodes[i] !\u003d null; i++) {\n      inodeAttrs[i] \u003d getINodeAttrs(components, i, inodes[i], snapshotId);\n    }\n\n    String path \u003d inodesInPath.getPath();\n    int ancestorIndex \u003d inodes.length - 2;\n\n    AccessControlEnforcer enforcer \u003d getAccessControlEnforcer();\n\n    String opType \u003d operationType.get();\n    if (this.authorizeWithContext \u0026\u0026 opType !\u003d null) {\n      INodeAttributeProvider.AuthorizationContext.Builder builder \u003d\n          new INodeAttributeProvider.AuthorizationContext.Builder();\n      builder.fsOwner(fsOwner).\n          supergroup(supergroup).\n          callerUgi(callerUgi).\n          inodeAttrs(inodeAttrs).\n          inodes(inodes).\n          pathByNameArr(components).\n          snapshotId(snapshotId).\n          path(path).\n          ancestorIndex(ancestorIndex).\n          doCheckOwner(doCheckOwner).\n          ancestorAccess(ancestorAccess).\n          parentAccess(parentAccess).\n          access(access).\n          subAccess(subAccess).\n          ignoreEmptyDir(ignoreEmptyDir).\n          operationName(opType).\n          callerContext(CallerContext.getCurrent());\n      enforcer.checkPermissionWithContext(builder.build());\n    } else {\n      enforcer.checkPermission(fsOwner, supergroup, callerUgi, inodeAttrs,\n          inodes, components, snapshotId, path, ancestorIndex, doCheckOwner,\n          ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n    }\n\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
      "commitDate": "04/08/16 2:14 PM",
      "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "27/05/16 10:02 AM",
      "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 69.18,
      "commitsBetweenForRepo": 580,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,31 @@\n   void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess, boolean ignoreEmptyDir)\n       throws AccessControlException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n           + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodesArray();\n     final INodeAttributes[] inodeAttrs \u003d new INodeAttributes[inodes.length];\n-    final byte[][] pathByNameArr \u003d new byte[inodes.length][];\n+    final byte[][] components \u003d inodesInPath.getPathComponents();\n     for (int i \u003d 0; i \u003c inodes.length \u0026\u0026 inodes[i] !\u003d null; i++) {\n-      if (inodes[i] !\u003d null) {\n-        pathByNameArr[i] \u003d inodes[i].getLocalNameBytes();\n-        inodeAttrs[i] \u003d getINodeAttrs(pathByNameArr, i, inodes[i], snapshotId);\n-      }\n+      inodeAttrs[i] \u003d getINodeAttrs(components, i, inodes[i], snapshotId);\n     }\n \n     String path \u003d inodesInPath.getPath();\n     int ancestorIndex \u003d inodes.length - 2;\n \n-    AccessControlEnforcer enforcer \u003d\n-        getAttributesProvider().getExternalAccessControlEnforcer(this);\n+    AccessControlEnforcer enforcer \u003d getAccessControlEnforcer();\n     enforcer.checkPermission(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n-        pathByNameArr, snapshotId, path, ancestorIndex, doCheckOwner,\n+        components, snapshotId, path, ancestorIndex, doCheckOwner,\n         ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir)\n      throws AccessControlException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodesArray();\n    final INodeAttributes[] inodeAttrs \u003d new INodeAttributes[inodes.length];\n    final byte[][] components \u003d inodesInPath.getPathComponents();\n    for (int i \u003d 0; i \u003c inodes.length \u0026\u0026 inodes[i] !\u003d null; i++) {\n      inodeAttrs[i] \u003d getINodeAttrs(components, i, inodes[i], snapshotId);\n    }\n\n    String path \u003d inodesInPath.getPath();\n    int ancestorIndex \u003d inodes.length - 2;\n\n    AccessControlEnforcer enforcer \u003d getAccessControlEnforcer();\n    enforcer.checkPermission(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n        components, snapshotId, path, ancestorIndex, doCheckOwner,\n        ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
      "commitDate": "24/03/15 4:02 PM",
      "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "09/12/14 6:57 PM",
      "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 104.84,
      "commitsBetweenForRepo": 828,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,35 @@\n   void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess, boolean ignoreEmptyDir)\n       throws AccessControlException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n           + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n-    final int length \u003d inodesInPath.length();\n-    final INode last \u003d length \u003e 0 ? inodesInPath.getLastINode() : null;\n-    final INode parent \u003d length \u003e 1 ? inodesInPath.getINode(-2) : null;\n+    final INode[] inodes \u003d inodesInPath.getINodesArray();\n+    final INodeAttributes[] inodeAttrs \u003d new INodeAttributes[inodes.length];\n+    final byte[][] pathByNameArr \u003d new byte[inodes.length][];\n+    for (int i \u003d 0; i \u003c inodes.length \u0026\u0026 inodes[i] !\u003d null; i++) {\n+      if (inodes[i] !\u003d null) {\n+        pathByNameArr[i] \u003d inodes[i].getLocalNameBytes();\n+        inodeAttrs[i] \u003d getINodeAttrs(pathByNameArr, i, inodes[i], snapshotId);\n+      }\n+    }\n \n-    checkTraverse(inodesInPath, snapshotId);\n+    String path \u003d inodesInPath.getPath();\n+    int ancestorIndex \u003d inodes.length - 2;\n \n-    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(parent, last, snapshotId);\n-    }\n-    if (ancestorAccess !\u003d null \u0026\u0026 length \u003e 1) {\n-      List\u003cINode\u003e inodes \u003d inodesInPath.getReadOnlyINodes();\n-      INode ancestor \u003d null;\n-      for (int i \u003d inodes.size() - 2; i \u003e\u003d 0 \u0026\u0026 (ancestor \u003d inodes.get(i)) \u003d\u003d\n-          null; i--);\n-      check(ancestor, snapshotId, ancestorAccess);\n-    }\n-    if (parentAccess !\u003d null \u0026\u0026 length \u003e 1 \u0026\u0026 parent !\u003d null) {\n-      check(parent, snapshotId, parentAccess);\n-    }\n-    if (access !\u003d null) {\n-      check(last, snapshotId, access);\n-    }\n-    if (subAccess !\u003d null) {\n-      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n-    }\n-    if (doCheckOwner) {\n-      checkOwner(last, snapshotId);\n-    }\n+    AccessControlEnforcer enforcer \u003d\n+        getAttributesProvider().getExternalAccessControlEnforcer(this);\n+    enforcer.checkPermission(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n+        pathByNameArr, snapshotId, path, ancestorIndex, doCheckOwner,\n+        ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir)\n      throws AccessControlException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodesArray();\n    final INodeAttributes[] inodeAttrs \u003d new INodeAttributes[inodes.length];\n    final byte[][] pathByNameArr \u003d new byte[inodes.length][];\n    for (int i \u003d 0; i \u003c inodes.length \u0026\u0026 inodes[i] !\u003d null; i++) {\n      if (inodes[i] !\u003d null) {\n        pathByNameArr[i] \u003d inodes[i].getLocalNameBytes();\n        inodeAttrs[i] \u003d getINodeAttrs(pathByNameArr, i, inodes[i], snapshotId);\n      }\n    }\n\n    String path \u003d inodesInPath.getPath();\n    int ancestorIndex \u003d inodes.length - 2;\n\n    AccessControlEnforcer enforcer \u003d\n        getAttributesProvider().getExternalAccessControlEnforcer(this);\n    enforcer.checkPermission(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n        pathByNameArr, snapshotId, path, ancestorIndex, doCheckOwner,\n        ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "5776a41da08af653206bb94d7c76c9c4dcce059a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7498. Simplify the logic in INodesInPath. Contributed by Jing Zhao.\n",
      "commitDate": "09/12/14 11:37 AM",
      "commitName": "5776a41da08af653206bb94d7c76c9c4dcce059a",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "05/12/14 2:17 PM",
      "commitNameOld": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n   void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess, boolean ignoreEmptyDir)\n       throws AccessControlException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n           + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n-    final INode[] inodes \u003d inodesInPath.getINodes();\n-    int ancestorIndex \u003d inodes.length - 2;\n-    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-        ancestorIndex--);\n-    checkTraverse(inodes, ancestorIndex, snapshotId);\n+    final int length \u003d inodesInPath.length();\n+    final INode last \u003d length \u003e 0 ? inodesInPath.getLastINode() : null;\n+    final INode parent \u003d length \u003e 1 ? inodesInPath.getINode(-2) : null;\n \n-    final INode last \u003d inodes[inodes.length - 1];\n+    checkTraverse(inodesInPath, snapshotId);\n+\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n+        \u0026\u0026 length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(parent, last, snapshotId);\n     }\n-    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n+    if (ancestorAccess !\u003d null \u0026\u0026 length \u003e 1) {\n+      List\u003cINode\u003e inodes \u003d inodesInPath.getReadOnlyINodes();\n+      INode ancestor \u003d null;\n+      for (int i \u003d inodes.size() - 2; i \u003e\u003d 0 \u0026\u0026 (ancestor \u003d inodes.get(i)) \u003d\u003d\n+          null; i--);\n+      check(ancestor, snapshotId, ancestorAccess);\n     }\n-    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n+    if (parentAccess !\u003d null \u0026\u0026 length \u003e 1 \u0026\u0026 parent !\u003d null) {\n+      check(parent, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n       checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir)\n      throws AccessControlException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final int length \u003d inodesInPath.length();\n    final INode last \u003d length \u003e 0 ? inodesInPath.getLastINode() : null;\n    final INode parent \u003d length \u003e 1 ? inodesInPath.getINode(-2) : null;\n\n    checkTraverse(inodesInPath, snapshotId);\n\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(parent, last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 length \u003e 1) {\n      List\u003cINode\u003e inodes \u003d inodesInPath.getReadOnlyINodes();\n      INode ancestor \u003d null;\n      for (int i \u003d inodes.size() - 2; i \u003e\u003d 0 \u0026\u0026 (ancestor \u003d inodes.get(i)) \u003d\u003d\n          null; i--);\n      check(ancestor, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 length \u003e 1 \u0026\u0026 parent !\u003d null) {\n      check(parent, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
      "commitDate": "05/12/14 2:17 PM",
      "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "04/12/14 8:49 PM",
          "commitNameOld": "0653918dad855b394e8e3b8b3f512f474d872ee9",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.73,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,43 @@\n-  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n+  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n-      FsAction subAccess, boolean ignoreEmptyDir, boolean resolveLink)\n-      throws AccessControlException, UnresolvedLinkException {\n+      FsAction subAccess, boolean ignoreEmptyDir)\n+      throws AccessControlException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n-          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir\n-          + \", resolveLink\u003d\" + resolveLink);\n+          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n-    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n       checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir)\n      throws AccessControlException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[path-String, dir-FSDirectory, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean, resolveLink-boolean]",
            "newValue": "[inodesInPath-INodesInPath, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "04/12/14 8:49 PM",
          "commitNameOld": "0653918dad855b394e8e3b8b3f512f474d872ee9",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.73,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,43 @@\n-  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n+  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n-      FsAction subAccess, boolean ignoreEmptyDir, boolean resolveLink)\n-      throws AccessControlException, UnresolvedLinkException {\n+      FsAction subAccess, boolean ignoreEmptyDir)\n+      throws AccessControlException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n-          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir\n-          + \", resolveLink\u003d\" + resolveLink);\n+          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n-    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n       checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir)\n      throws AccessControlException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[AccessControlException, UnresolvedLinkException]",
            "newValue": "[AccessControlException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "04/12/14 8:49 PM",
          "commitNameOld": "0653918dad855b394e8e3b8b3f512f474d872ee9",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.73,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,43 @@\n-  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n+  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n-      FsAction subAccess, boolean ignoreEmptyDir, boolean resolveLink)\n-      throws AccessControlException, UnresolvedLinkException {\n+      FsAction subAccess, boolean ignoreEmptyDir)\n+      throws AccessControlException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n-          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir\n-          + \", resolveLink\u003d\" + resolveLink);\n+          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n-    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n       checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(INodesInPath inodesInPath, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir)\n      throws AccessControlException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "e9c6840b24bab7d6c21243baa9b2353119b0f976": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Command hdfs dfs -rm -r can\u0027t remove empty directory. Contributed by Yongjun Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594036 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/05/14 10:54 AM",
      "commitName": "e9c6840b24bab7d6c21243baa9b2353119b0f976",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Command hdfs dfs -rm -r can\u0027t remove empty directory. Contributed by Yongjun Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594036 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/05/14 10:54 AM",
          "commitName": "e9c6840b24bab7d6c21243baa9b2353119b0f976",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "30/04/14 10:44 AM",
          "commitNameOld": "0689363343a281a6f7f6f395227668bddc2663eb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 12.01,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,45 @@\n   void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n-      FsAction subAccess, boolean resolveLink)\n+      FsAction subAccess, boolean ignoreEmptyDir, boolean resolveLink)\n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n+          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir\n           + \", resolveLink\u003d\" + resolveLink);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n     final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n-      checkSubAccess(last, snapshotId, subAccess);\n+      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir, boolean resolveLink)\n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir\n          + \", resolveLink\u003d\" + resolveLink);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[path-String, dir-FSDirectory, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, resolveLink-boolean]",
            "newValue": "[path-String, dir-FSDirectory, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean, resolveLink-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Command hdfs dfs -rm -r can\u0027t remove empty directory. Contributed by Yongjun Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594036 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/05/14 10:54 AM",
          "commitName": "e9c6840b24bab7d6c21243baa9b2353119b0f976",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "30/04/14 10:44 AM",
          "commitNameOld": "0689363343a281a6f7f6f395227668bddc2663eb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 12.01,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,45 @@\n   void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n-      FsAction subAccess, boolean resolveLink)\n+      FsAction subAccess, boolean ignoreEmptyDir, boolean resolveLink)\n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n+          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir\n           + \", resolveLink\u003d\" + resolveLink);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n     final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n-      checkSubAccess(last, snapshotId, subAccess);\n+      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean ignoreEmptyDir, boolean resolveLink)\n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", ignoreEmptyDir\u003d\" + ignoreEmptyDir\n          + \", resolveLink\u003d\" + resolveLink);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "0689363343a281a6f7f6f395227668bddc2663eb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6304. Consolidate the logic of path resolution in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1591411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/14 10:44 AM",
      "commitName": "0689363343a281a6f7f6f395227668bddc2663eb",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6304. Consolidate the logic of path resolution in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1591411 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/04/14 10:44 AM",
          "commitName": "0689363343a281a6f7f6f395227668bddc2663eb",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "12/02/14 2:54 PM",
          "commitNameOld": "fc14360b0340a33c0e1eb34967d4dcd772533418",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 76.78,
          "commitsBetweenForRepo": 601,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,44 @@\n-  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n+  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess, boolean resolveLink)\n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n           + \", resolveLink\u003d\" + resolveLink);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n-    final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n+    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n       checkSubAccess(last, snapshotId, subAccess);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean resolveLink)\n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", resolveLink\u003d\" + resolveLink);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[path-String, root-INodeDirectory, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, resolveLink-boolean]",
            "newValue": "[path-String, dir-FSDirectory, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, resolveLink-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6304. Consolidate the logic of path resolution in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1591411 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/04/14 10:44 AM",
          "commitName": "0689363343a281a6f7f6f395227668bddc2663eb",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "12/02/14 2:54 PM",
          "commitNameOld": "fc14360b0340a33c0e1eb34967d4dcd772533418",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 76.78,
          "commitsBetweenForRepo": 601,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,44 @@\n-  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n+  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess, boolean resolveLink)\n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n           + \", resolveLink\u003d\" + resolveLink);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n-    final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n+    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n     final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n       check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n       checkSubAccess(last, snapshotId, subAccess);\n     }\n     if (doCheckOwner) {\n       checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(String path, FSDirectory dir, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean resolveLink)\n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", resolveLink\u003d\" + resolveLink);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final INodesInPath inodesInPath \u003d dir.getINodesInPath(path, resolveLink);\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/11/13 3:52 PM",
      "commitNameOld": "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 55.88,
      "commitsBetweenForRepo": 301,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess, boolean resolveLink)\n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess\n           + \", resolveLink\u003d\" + resolveLink);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n     // If resolveLink, the check is performed on the link target.\n     final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n-    final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n+    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n     final INode[] inodes \u003d inodesInPath.getINodes();\n     int ancestorIndex \u003d inodes.length - 2;\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n-    checkTraverse(inodes, ancestorIndex, snapshot);\n+    checkTraverse(inodes, ancestorIndex, snapshotId);\n \n     final INode last \u003d inodes[inodes.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n+      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-      check(inodes, ancestorIndex, snapshot, ancestorAccess);\n+      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-      check(inodes, inodes.length - 2, snapshot, parentAccess);\n+      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n     }\n     if (access !\u003d null) {\n-      check(last, snapshot, access);\n+      check(last, snapshotId, access);\n     }\n     if (subAccess !\u003d null) {\n-      checkSubAccess(last, snapshot, subAccess);\n+      checkSubAccess(last, snapshotId, subAccess);\n     }\n     if (doCheckOwner) {\n-      checkOwner(last, snapshot);\n+      checkOwner(last, snapshotId);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean resolveLink)\n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", resolveLink\u003d\" + resolveLink);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n    final int snapshotId \u003d inodesInPath.getPathSnapshotId();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshotId);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshotId);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshotId, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshotId, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshotId, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshotId, subAccess);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshotId);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "6521b5ee423ef489d7b7f85e74dd5f8d91bd06aa": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-4765. Permission check of symlink deletion incorrectly throws UnresolvedLinkException. Contributed by Andrew Wang.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/13 10:22 AM",
      "commitName": "6521b5ee423ef489d7b7f85e74dd5f8d91bd06aa",
      "commitAuthor": "Aaron Myers",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-4765. Permission check of symlink deletion incorrectly throws UnresolvedLinkException. Contributed by Andrew Wang.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481976 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/05/13 10:22 AM",
          "commitName": "6521b5ee423ef489d7b7f85e74dd5f8d91bd06aa",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "25/04/13 6:05 PM",
          "commitNameOld": "76b80b48ec3850a2873c2f1e5f319150bf3ccd03",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 17.68,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n-      FsAction subAccess) \n+      FsAction subAccess, boolean resolveLink)\n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n-          + \", subAccess\u003d\" + subAccess);\n+          + \", subAccess\u003d\" + subAccess\n+          + \", resolveLink\u003d\" + resolveLink);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n-      // Resolve symlinks, the check is performed on the link target.\n-      final INodesInPath inodesInPath \u003d root.getINodesInPath(path, true); \n-      final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n-      final INode[] inodes \u003d inodesInPath.getINodes();\n-      int ancestorIndex \u003d inodes.length - 2;\n-      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-          ancestorIndex--);\n-      checkTraverse(inodes, ancestorIndex, snapshot);\n+    // If resolveLink, the check is performed on the link target.\n+    final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n+    final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n+    final INode[] inodes \u003d inodesInPath.getINodes();\n+    int ancestorIndex \u003d inodes.length - 2;\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodes, ancestorIndex, snapshot);\n \n-      final INode last \u003d inodes[inodes.length - 1];\n-      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-        checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n-      }\n-      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-        check(inodes, ancestorIndex, snapshot, ancestorAccess);\n-      }\n-      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-        check(inodes, inodes.length - 2, snapshot, parentAccess);\n-      }\n-      if (access !\u003d null) {\n-        check(last, snapshot, access);\n-      }\n-      if (subAccess !\u003d null) {\n-        checkSubAccess(last, snapshot, subAccess);\n-      }\n-      if (doCheckOwner) {\n-        checkOwner(last, snapshot);\n-      }\n+    final INode last \u003d inodes[inodes.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n+    }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n+      check(inodes, ancestorIndex, snapshot, ancestorAccess);\n+    }\n+    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n+      check(inodes, inodes.length - 2, snapshot, parentAccess);\n+    }\n+    if (access !\u003d null) {\n+      check(last, snapshot, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      checkSubAccess(last, snapshot, subAccess);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last, snapshot);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean resolveLink)\n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", resolveLink\u003d\" + resolveLink);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n    final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshot);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshot, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshot, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshot, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshot, subAccess);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshot);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[path-String, root-INodeDirectory, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction]",
            "newValue": "[path-String, root-INodeDirectory, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, resolveLink-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4765. Permission check of symlink deletion incorrectly throws UnresolvedLinkException. Contributed by Andrew Wang.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481976 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/05/13 10:22 AM",
          "commitName": "6521b5ee423ef489d7b7f85e74dd5f8d91bd06aa",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "25/04/13 6:05 PM",
          "commitNameOld": "76b80b48ec3850a2873c2f1e5f319150bf3ccd03",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 17.68,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n-      FsAction subAccess) \n+      FsAction subAccess, boolean resolveLink)\n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n-          + \", subAccess\u003d\" + subAccess);\n+          + \", subAccess\u003d\" + subAccess\n+          + \", resolveLink\u003d\" + resolveLink);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n-      // Resolve symlinks, the check is performed on the link target.\n-      final INodesInPath inodesInPath \u003d root.getINodesInPath(path, true); \n-      final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n-      final INode[] inodes \u003d inodesInPath.getINodes();\n-      int ancestorIndex \u003d inodes.length - 2;\n-      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n-          ancestorIndex--);\n-      checkTraverse(inodes, ancestorIndex, snapshot);\n+    // If resolveLink, the check is performed on the link target.\n+    final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n+    final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n+    final INode[] inodes \u003d inodesInPath.getINodes();\n+    int ancestorIndex \u003d inodes.length - 2;\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodes, ancestorIndex, snapshot);\n \n-      final INode last \u003d inodes[inodes.length - 1];\n-      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-        checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n-      }\n-      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-        check(inodes, ancestorIndex, snapshot, ancestorAccess);\n-      }\n-      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-        check(inodes, inodes.length - 2, snapshot, parentAccess);\n-      }\n-      if (access !\u003d null) {\n-        check(last, snapshot, access);\n-      }\n-      if (subAccess !\u003d null) {\n-        checkSubAccess(last, snapshot, subAccess);\n-      }\n-      if (doCheckOwner) {\n-        checkOwner(last, snapshot);\n-      }\n+    final INode last \u003d inodes[inodes.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n+    }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n+      check(inodes, ancestorIndex, snapshot, ancestorAccess);\n+    }\n+    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n+      check(inodes, inodes.length - 2, snapshot, parentAccess);\n+    }\n+    if (access !\u003d null) {\n+      check(last, snapshot, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      checkSubAccess(last, snapshot, subAccess);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last, snapshot);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess, boolean resolveLink)\n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess\n          + \", resolveLink\u003d\" + resolveLink);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n    // If resolveLink, the check is performed on the link target.\n    final INodesInPath inodesInPath \u003d root.getINodesInPath(path, resolveLink);\n    final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n    final INode[] inodes \u003d inodesInPath.getINodes();\n    int ancestorIndex \u003d inodes.length - 2;\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodes, ancestorIndex, snapshot);\n\n    final INode last \u003d inodes[inodes.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, ancestorIndex, snapshot, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n      check(inodes, inodes.length - 2, snapshot, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, snapshot, access);\n    }\n    if (subAccess !\u003d null) {\n      checkSubAccess(last, snapshot, subAccess);\n    }\n    if (doCheckOwner) {\n      checkOwner(last, snapshot);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4189. Renames the getMutableXxx methods to getXxx4Write and fix a bug that some getExistingPathINodes calls should be getINodesInPath4Write.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1441193 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/13 1:13 PM",
      "commitName": "2372e394dd99d69d396327d5a5e172953a8b8c6a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "20/12/12 5:30 PM",
      "commitNameOld": "b9f965de120b5278ac84a7e98aecb32aafde4c16",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 41.82,
      "commitsBetweenForRepo": 202,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess) \n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n       // Resolve symlinks, the check is performed on the link target.\n-      final INodesInPath inodesInPath \u003d root.getExistingPathINodes(path, true); \n+      final INodesInPath inodesInPath \u003d root.getINodesInPath(path, true); \n       final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n       final INode[] inodes \u003d inodesInPath.getINodes();\n       int ancestorIndex \u003d inodes.length - 2;\n       for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n           ancestorIndex--);\n       checkTraverse(inodes, ancestorIndex, snapshot);\n \n       final INode last \u003d inodes[inodes.length - 1];\n       if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n           \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n         checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n       }\n       if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, ancestorIndex, snapshot, ancestorAccess);\n       }\n       if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, inodes.length - 2, snapshot, parentAccess);\n       }\n       if (access !\u003d null) {\n         check(last, snapshot, access);\n       }\n       if (subAccess !\u003d null) {\n         checkSubAccess(last, snapshot, subAccess);\n       }\n       if (doCheckOwner) {\n         checkOwner(last, snapshot);\n       }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      final INodesInPath inodesInPath \u003d root.getINodesInPath(path, true); \n      final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n      final INode[] inodes \u003d inodesInPath.getINodes();\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex, snapshot);\n\n      final INode last \u003d inodes[inodes.length - 1];\n      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n        checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n      }\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, snapshot, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, snapshot, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(last, snapshot, access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(last, snapshot, subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(last, snapshot);\n      }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4103. Support O(1) snapshot creation.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/12/12 5:30 PM",
      "commitName": "b9f965de120b5278ac84a7e98aecb32aafde4c16",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "13/11/12 11:59 AM",
      "commitNameOld": "099762a0bc960066f8157fdd1e495b6752a6f802",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 37.23,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess) \n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n       // Resolve symlinks, the check is performed on the link target.\n       final INodesInPath inodesInPath \u003d root.getExistingPathINodes(path, true); \n+      final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n       final INode[] inodes \u003d inodesInPath.getINodes();\n       int ancestorIndex \u003d inodes.length - 2;\n       for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n           ancestorIndex--);\n-      checkTraverse(inodes, ancestorIndex);\n+      checkTraverse(inodes, ancestorIndex, snapshot);\n \n+      final INode last \u003d inodes[inodes.length - 1];\n       if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n-        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n+          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+        checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n       }\n       if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-        check(inodes, ancestorIndex, ancestorAccess);\n+        check(inodes, ancestorIndex, snapshot, ancestorAccess);\n       }\n       if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n-        check(inodes, inodes.length - 2, parentAccess);\n+        check(inodes, inodes.length - 2, snapshot, parentAccess);\n       }\n       if (access !\u003d null) {\n-        check(inodes[inodes.length - 1], access);\n+        check(last, snapshot, access);\n       }\n       if (subAccess !\u003d null) {\n-        final Snapshot s \u003d inodesInPath.getPathSnapshot();\n-        checkSubAccess(inodes[inodes.length - 1], s, subAccess);\n+        checkSubAccess(last, snapshot, subAccess);\n       }\n       if (doCheckOwner) {\n-        checkOwner(inodes[inodes.length - 1]);\n+        checkOwner(last, snapshot);\n       }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      final INodesInPath inodesInPath \u003d root.getExistingPathINodes(path, true); \n      final Snapshot snapshot \u003d inodesInPath.getPathSnapshot();\n      final INode[] inodes \u003d inodesInPath.getINodes();\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex, snapshot);\n\n      final INode last \u003d inodes[inodes.length - 1];\n      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 last !\u003d null) {\n        checkStickyBit(inodes[inodes.length - 2], last, snapshot);\n      }\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, snapshot, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, snapshot, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(last, snapshot, access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(last, snapshot, subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(last, snapshot);\n      }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "099762a0bc960066f8157fdd1e495b6752a6f802": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4177. Add a snapshot parameter to INodeDirectory.getChildrenList() for selecting particular snapshot children list views.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1408923 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/12 11:59 AM",
      "commitName": "099762a0bc960066f8157fdd1e495b6752a6f802",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "05/11/12 3:56 PM",
      "commitNameOld": "34413c2000d9262faa37fde88a72939587edc776",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 7.84,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,42 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess) \n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n       // Resolve symlinks, the check is performed on the link target.\n-      final INode[] inodes \u003d root.getExistingPathINodes(path, true).getINodes();\n+      final INodesInPath inodesInPath \u003d root.getExistingPathINodes(path, true); \n+      final INode[] inodes \u003d inodesInPath.getINodes();\n       int ancestorIndex \u003d inodes.length - 2;\n       for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n           ancestorIndex--);\n       checkTraverse(inodes, ancestorIndex);\n \n       if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n           \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n         checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n       }\n       if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, ancestorIndex, ancestorAccess);\n       }\n       if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, inodes.length - 2, parentAccess);\n       }\n       if (access !\u003d null) {\n         check(inodes[inodes.length - 1], access);\n       }\n       if (subAccess !\u003d null) {\n-        checkSubAccess(inodes[inodes.length - 1], subAccess);\n+        final Snapshot s \u003d inodesInPath.getPathSnapshot();\n+        checkSubAccess(inodes[inodes.length - 1], s, subAccess);\n       }\n       if (doCheckOwner) {\n         checkOwner(inodes[inodes.length - 1]);\n       }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      final INodesInPath inodesInPath \u003d root.getExistingPathINodes(path, true); \n      final INode[] inodes \u003d inodesInPath.getINodes();\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex);\n\n      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n      }\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(inodes[inodes.length - 1], access);\n      }\n      if (subAccess !\u003d null) {\n        final Snapshot s \u003d inodesInPath.getPathSnapshot();\n        checkSubAccess(inodes[inodes.length - 1], s, subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(inodes[inodes.length - 1]);\n      }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "34413c2000d9262faa37fde88a72939587edc776": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c 1406006 from trunk for HDFS-4151. Change the methods in FSDirectory to pass INodesInPath instead of INode[] as a parameter.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1406014 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/12 3:56 PM",
      "commitName": "34413c2000d9262faa37fde88a72939587edc776",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/10/12 11:08 AM",
      "commitNameOld": "0e796b61e829c4bf763caf13b0f53cb1bcefdeee",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 10.24,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess) \n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n       // Resolve symlinks, the check is performed on the link target.\n-      INode[] inodes \u003d root.getExistingPathINodes(path, true);\n+      final INode[] inodes \u003d root.getExistingPathINodes(path, true).getINodes();\n       int ancestorIndex \u003d inodes.length - 2;\n       for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n           ancestorIndex--);\n       checkTraverse(inodes, ancestorIndex);\n \n       if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n           \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n         checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n       }\n       if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, ancestorIndex, ancestorAccess);\n       }\n       if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, inodes.length - 2, parentAccess);\n       }\n       if (access !\u003d null) {\n         check(inodes[inodes.length - 1], access);\n       }\n       if (subAccess !\u003d null) {\n         checkSubAccess(inodes[inodes.length - 1], subAccess);\n       }\n       if (doCheckOwner) {\n         checkOwner(inodes[inodes.length - 1]);\n       }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      final INode[] inodes \u003d root.getExistingPathINodes(path, true).getINodes();\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex);\n\n      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n      }\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(inodes[inodes.length - 1], access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(inodes[inodes.length - 1], subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(inodes[inodes.length - 1]);\n      }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "7ee5ce3176a74d217551b5981f809a56c719424b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4151. Change the methods in FSDirectory to pass INodesInPath instead of INode[] as a parameter.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/12 3:26 PM",
      "commitName": "7ee5ce3176a74d217551b5981f809a56c719424b",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/10/12 11:08 AM",
      "commitNameOld": "0e796b61e829c4bf763caf13b0f53cb1bcefdeee",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 10.22,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess) \n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n       // Resolve symlinks, the check is performed on the link target.\n-      INode[] inodes \u003d root.getExistingPathINodes(path, true);\n+      final INode[] inodes \u003d root.getExistingPathINodes(path, true).getINodes();\n       int ancestorIndex \u003d inodes.length - 2;\n       for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n           ancestorIndex--);\n       checkTraverse(inodes, ancestorIndex);\n \n       if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n           \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n         checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n       }\n       if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, ancestorIndex, ancestorAccess);\n       }\n       if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, inodes.length - 2, parentAccess);\n       }\n       if (access !\u003d null) {\n         check(inodes[inodes.length - 1], access);\n       }\n       if (subAccess !\u003d null) {\n         checkSubAccess(inodes[inodes.length - 1], subAccess);\n       }\n       if (doCheckOwner) {\n         checkOwner(inodes[inodes.length - 1]);\n       }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      final INode[] inodes \u003d root.getExistingPathINodes(path, true).getINodes();\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex);\n\n      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n      }\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(inodes[inodes.length - 1], access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(inodes[inodes.length - 1], subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(inodes[inodes.length - 1]);\n      }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "359b4efd193b772d13b2571dedec7e0622309d78": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3581. FSPermissionChecker#checkPermission sticky bit check missing range check. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1356971 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/07/12 2:43 PM",
      "commitName": "359b4efd193b772d13b2571dedec7e0622309d78",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 313.9,
      "commitsBetweenForRepo": 2132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n       FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n       FsAction subAccess) \n       throws AccessControlException, UnresolvedLinkException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"ACCESS CHECK: \" + this\n           + \", doCheckOwner\u003d\" + doCheckOwner\n           + \", ancestorAccess\u003d\" + ancestorAccess\n           + \", parentAccess\u003d\" + parentAccess\n           + \", access\u003d\" + access\n           + \", subAccess\u003d\" + subAccess);\n     }\n     // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n       // Resolve symlinks, the check is performed on the link target.\n       INode[] inodes \u003d root.getExistingPathINodes(path, true);\n       int ancestorIndex \u003d inodes.length - 2;\n       for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n           ancestorIndex--);\n       checkTraverse(inodes, ancestorIndex);\n \n-      if(parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n-          \u0026\u0026 inodes[inodes.length - 1] !\u003d null)\n+      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n         checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n-\n+      }\n       if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, ancestorIndex, ancestorAccess);\n       }\n       if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n         check(inodes, inodes.length - 2, parentAccess);\n       }\n       if (access !\u003d null) {\n         check(inodes[inodes.length - 1], access);\n       }\n       if (subAccess !\u003d null) {\n         checkSubAccess(inodes[inodes.length - 1], subAccess);\n       }\n       if (doCheckOwner) {\n         checkOwner(inodes[inodes.length - 1]);\n       }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      INode[] inodes \u003d root.getExistingPathINodes(path, true);\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex);\n\n      if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes.length \u003e 1 \u0026\u0026 inodes[inodes.length - 1] !\u003d null) {\n        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n      }\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(inodes[inodes.length - 1], access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(inodes[inodes.length - 1], subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(inodes[inodes.length - 1]);\n      }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      INode[] inodes \u003d root.getExistingPathINodes(path, true);\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex);\n\n      if(parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes[inodes.length - 1] !\u003d null)\n        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(inodes[inodes.length - 1], access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(inodes[inodes.length - 1], subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(inodes[inodes.length - 1]);\n      }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      INode[] inodes \u003d root.getExistingPathINodes(path, true);\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex);\n\n      if(parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes[inodes.length - 1] !\u003d null)\n        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(inodes[inodes.length - 1], access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(inodes[inodes.length - 1], subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(inodes[inodes.length - 1]);\n      }\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,40 @@\n+  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n+      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n+      FsAction subAccess) \n+      throws AccessControlException, UnresolvedLinkException {\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"ACCESS CHECK: \" + this\n+          + \", doCheckOwner\u003d\" + doCheckOwner\n+          + \", ancestorAccess\u003d\" + ancestorAccess\n+          + \", parentAccess\u003d\" + parentAccess\n+          + \", access\u003d\" + access\n+          + \", subAccess\u003d\" + subAccess);\n+    }\n+    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n+      // Resolve symlinks, the check is performed on the link target.\n+      INode[] inodes \u003d root.getExistingPathINodes(path, true);\n+      int ancestorIndex \u003d inodes.length - 2;\n+      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+          ancestorIndex--);\n+      checkTraverse(inodes, ancestorIndex);\n+\n+      if(parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+          \u0026\u0026 inodes[inodes.length - 1] !\u003d null)\n+        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n+\n+      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n+        check(inodes, ancestorIndex, ancestorAccess);\n+      }\n+      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n+        check(inodes, inodes.length - 2, parentAccess);\n+      }\n+      if (access !\u003d null) {\n+        check(inodes[inodes.length - 1], access);\n+      }\n+      if (subAccess !\u003d null) {\n+        checkSubAccess(inodes[inodes.length - 1], subAccess);\n+      }\n+      if (doCheckOwner) {\n+        checkOwner(inodes[inodes.length - 1]);\n+      }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void checkPermission(String path, INodeDirectory root, boolean doCheckOwner,\n      FsAction ancestorAccess, FsAction parentAccess, FsAction access,\n      FsAction subAccess) \n      throws AccessControlException, UnresolvedLinkException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ACCESS CHECK: \" + this\n          + \", doCheckOwner\u003d\" + doCheckOwner\n          + \", ancestorAccess\u003d\" + ancestorAccess\n          + \", parentAccess\u003d\" + parentAccess\n          + \", access\u003d\" + access\n          + \", subAccess\u003d\" + subAccess);\n    }\n    // check if (parentAccess !\u003d null) \u0026\u0026 file exists, then check sb\n      // Resolve symlinks, the check is performed on the link target.\n      INode[] inodes \u003d root.getExistingPathINodes(path, true);\n      int ancestorIndex \u003d inodes.length - 2;\n      for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n          ancestorIndex--);\n      checkTraverse(inodes, ancestorIndex);\n\n      if(parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n          \u0026\u0026 inodes[inodes.length - 1] !\u003d null)\n        checkStickyBit(inodes[inodes.length - 2], inodes[inodes.length - 1]);\n\n      if (ancestorAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, ancestorIndex, ancestorAccess);\n      }\n      if (parentAccess !\u003d null \u0026\u0026 inodes.length \u003e 1) {\n        check(inodes, inodes.length - 2, parentAccess);\n      }\n      if (access !\u003d null) {\n        check(inodes[inodes.length - 1], access);\n      }\n      if (subAccess !\u003d null) {\n        checkSubAccess(inodes[inodes.length - 1], subAccess);\n      }\n      if (doCheckOwner) {\n        checkOwner(inodes[inodes.length - 1]);\n      }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java"
    }
  }
}