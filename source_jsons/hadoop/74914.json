{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractDelegationTokenSecretManager.java",
  "functionName": "addPersistedDelegationToken",
  "functionId": "addPersistedDelegationToken___identifier-TokenIdent__renewDate-long",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java",
  "functionStartLine": 318,
  "functionEndLine": 346,
  "numCommitsSeen": 32,
  "timeTaken": 2305,
  "changeHistory": [
    "ab6aa4c7265db5bcbb446c2f779289023d454b81",
    "fd2f22adec5c2f21f792045dbfde9385c21403ec",
    "db45f047ab6b19d8a3e7752bb2cde10827cd8dad",
    "ef784a2e08c2452026a85ae382a956ff7deecbd0",
    "db890eef3208cc557476fa510f7a253ba22bc68a",
    "e4374d803663c626de610cd5f062f25a6d7d5d4e",
    "fdfedf4c31fa1d8338fc915a631dfc57c1ca38da"
  ],
  "changeHistoryShort": {
    "ab6aa4c7265db5bcbb446c2f779289023d454b81": "Ybodychange",
    "fd2f22adec5c2f21f792045dbfde9385c21403ec": "Ybodychange",
    "db45f047ab6b19d8a3e7752bb2cde10827cd8dad": "Ybodychange",
    "ef784a2e08c2452026a85ae382a956ff7deecbd0": "Ybodychange",
    "db890eef3208cc557476fa510f7a253ba22bc68a": "Ybodychange",
    "e4374d803663c626de610cd5f062f25a6d7d5d4e": "Ybodychange",
    "fdfedf4c31fa1d8338fc915a631dfc57c1ca38da": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ab6aa4c7265db5bcbb446c2f779289023d454b81": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8865. RMStateStore contains large number of expired RMDelegationToken. Contributed by Wilfred Spiegelenburg\n",
      "commitDate": "06/11/18 6:40 AM",
      "commitName": "ab6aa4c7265db5bcbb446c2f779289023d454b81",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "06/02/18 1:33 PM",
      "commitNameOld": "2dd960de983a30bf0d9ee957bdb09f825f9d40a3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 272.71,
      "commitsBetweenForRepo": 2736,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,29 @@\n   public synchronized void addPersistedDelegationToken(\n       TokenIdent identifier, long renewDate) throws IOException {\n     if (running) {\n       // a safety check\n       throw new IOException(\n           \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n     }\n     int keyId \u003d identifier.getMasterKeyId();\n     DelegationKey dKey \u003d allKeys.get(keyId);\n+    byte[] password \u003d null;\n     if (dKey \u003d\u003d null) {\n-      LOG.warn(\"No KEY found for persisted identifier \"\n+      LOG.warn(\"No KEY found for persisted identifier, expiring stored token \"\n           + formatTokenId(identifier));\n-      return;\n+      // make sure the token is expired\n+      renewDate \u003d 0L;\n+    } else {\n+      password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n     }\n-    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n     if (identifier.getSequenceNumber() \u003e getDelegationTokenSeqNum()) {\n       setDelegationTokenSeqNum(identifier.getSequenceNumber());\n     }\n     if (getTokenInfo(identifier) \u003d\u003d null) {\n       currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n           password, getTrackingIdIfEnabled(identifier)));\n     } else {\n       throw new IOException(\"Same delegation token being added twice: \"\n           + formatTokenId(identifier));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPersistedDelegationToken(\n      TokenIdent identifier, long renewDate) throws IOException {\n    if (running) {\n      // a safety check\n      throw new IOException(\n          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n    }\n    int keyId \u003d identifier.getMasterKeyId();\n    DelegationKey dKey \u003d allKeys.get(keyId);\n    byte[] password \u003d null;\n    if (dKey \u003d\u003d null) {\n      LOG.warn(\"No KEY found for persisted identifier, expiring stored token \"\n          + formatTokenId(identifier));\n      // make sure the token is expired\n      renewDate \u003d 0L;\n    } else {\n      password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n    }\n    if (identifier.getSequenceNumber() \u003e getDelegationTokenSeqNum()) {\n      setDelegationTokenSeqNum(identifier.getSequenceNumber());\n    }\n    if (getTokenInfo(identifier) \u003d\u003d null) {\n      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n          password, getTrackingIdIfEnabled(identifier)));\n    } else {\n      throw new IOException(\"Same delegation token being added twice: \"\n          + formatTokenId(identifier));\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "fd2f22adec5c2f21f792045dbfde9385c21403ec": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13720. Add more info to the msgs printed in AbstractDelegationTokenSecretManager. Contributed by Yongjun Zhang.\n",
      "commitDate": "10/11/16 10:42 PM",
      "commitName": "fd2f22adec5c2f21f792045dbfde9385c21403ec",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "20/09/16 1:20 PM",
      "commitNameOld": "e80386d69d5fb6a08aa3366e42d2518747af569f",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 51.43,
      "commitsBetweenForRepo": 451,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,26 @@\n   public synchronized void addPersistedDelegationToken(\n       TokenIdent identifier, long renewDate) throws IOException {\n     if (running) {\n       // a safety check\n       throw new IOException(\n           \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n     }\n     int keyId \u003d identifier.getMasterKeyId();\n     DelegationKey dKey \u003d allKeys.get(keyId);\n     if (dKey \u003d\u003d null) {\n-      LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n+      LOG.warn(\"No KEY found for persisted identifier \"\n+          + formatTokenId(identifier));\n       return;\n     }\n     byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n     if (identifier.getSequenceNumber() \u003e getDelegationTokenSeqNum()) {\n       setDelegationTokenSeqNum(identifier.getSequenceNumber());\n     }\n     if (getTokenInfo(identifier) \u003d\u003d null) {\n       currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n           password, getTrackingIdIfEnabled(identifier)));\n     } else {\n-      throw new IOException(\"Same delegation token being added twice.\");\n+      throw new IOException(\"Same delegation token being added twice: \"\n+          + formatTokenId(identifier));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPersistedDelegationToken(\n      TokenIdent identifier, long renewDate) throws IOException {\n    if (running) {\n      // a safety check\n      throw new IOException(\n          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n    }\n    int keyId \u003d identifier.getMasterKeyId();\n    DelegationKey dKey \u003d allKeys.get(keyId);\n    if (dKey \u003d\u003d null) {\n      LOG.warn(\"No KEY found for persisted identifier \"\n          + formatTokenId(identifier));\n      return;\n    }\n    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n    if (identifier.getSequenceNumber() \u003e getDelegationTokenSeqNum()) {\n      setDelegationTokenSeqNum(identifier.getSequenceNumber());\n    }\n    if (getTokenInfo(identifier) \u003d\u003d null) {\n      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n          password, getTrackingIdIfEnabled(identifier)));\n    } else {\n      throw new IOException(\"Same delegation token being added twice: \"\n          + formatTokenId(identifier));\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "db45f047ab6b19d8a3e7752bb2cde10827cd8dad": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11170. ZKDelegationTokenSecretManager fails to renewToken created by a peer. (Arun Suresh and Gregory Chanan via kasha)\n",
      "commitDate": "23/10/14 5:04 PM",
      "commitName": "db45f047ab6b19d8a3e7752bb2cde10827cd8dad",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "22/10/14 2:26 PM",
      "commitNameOld": "70719e5c62f32836914bea88e1ddd99c0ed009e1",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   public synchronized void addPersistedDelegationToken(\n       TokenIdent identifier, long renewDate) throws IOException {\n     if (running) {\n       // a safety check\n       throw new IOException(\n           \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n     }\n     int keyId \u003d identifier.getMasterKeyId();\n     DelegationKey dKey \u003d allKeys.get(keyId);\n     if (dKey \u003d\u003d null) {\n       LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n       return;\n     }\n     byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n-    if (identifier.getSequenceNumber() \u003e delegationTokenSequenceNumber) {\n-      delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n+    if (identifier.getSequenceNumber() \u003e getDelegationTokenSeqNum()) {\n+      setDelegationTokenSeqNum(identifier.getSequenceNumber());\n     }\n     if (getTokenInfo(identifier) \u003d\u003d null) {\n       currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n           password, getTrackingIdIfEnabled(identifier)));\n     } else {\n       throw new IOException(\"Same delegation token being added twice.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPersistedDelegationToken(\n      TokenIdent identifier, long renewDate) throws IOException {\n    if (running) {\n      // a safety check\n      throw new IOException(\n          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n    }\n    int keyId \u003d identifier.getMasterKeyId();\n    DelegationKey dKey \u003d allKeys.get(keyId);\n    if (dKey \u003d\u003d null) {\n      LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n      return;\n    }\n    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n    if (identifier.getSequenceNumber() \u003e getDelegationTokenSeqNum()) {\n      setDelegationTokenSeqNum(identifier.getSequenceNumber());\n    }\n    if (getTokenInfo(identifier) \u003d\u003d null) {\n      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n          password, getTrackingIdIfEnabled(identifier)));\n    } else {\n      throw new IOException(\"Same delegation token being added twice.\");\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "ef784a2e08c2452026a85ae382a956ff7deecbd0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11017. Addendum to fix RM HA. KMS delegation token secret manager should be able to use zookeeper as store. (Arun Suresh via kasha)\n",
      "commitDate": "23/09/14 5:07 PM",
      "commitName": "ef784a2e08c2452026a85ae382a956ff7deecbd0",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "20/09/14 8:21 AM",
      "commitNameOld": "db890eef3208cc557476fa510f7a253ba22bc68a",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 3.37,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,24 @@\n   public synchronized void addPersistedDelegationToken(\n       TokenIdent identifier, long renewDate) throws IOException {\n     if (running) {\n       // a safety check\n       throw new IOException(\n           \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n     }\n     int keyId \u003d identifier.getMasterKeyId();\n-    DelegationKey dKey \u003d getDelegationKey(keyId);\n+    DelegationKey dKey \u003d allKeys.get(keyId);\n     if (dKey \u003d\u003d null) {\n       LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n       return;\n     }\n     byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n-    int delegationTokenSeqNum \u003d getDelegationTokenSeqNum();\n-    if (identifier.getSequenceNumber() \u003e delegationTokenSeqNum) {\n-      setDelegationTokenSeqNum(identifier.getSequenceNumber());\n+    if (identifier.getSequenceNumber() \u003e delegationTokenSequenceNumber) {\n+      delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n     }\n     if (getTokenInfo(identifier) \u003d\u003d null) {\n-      storeToken(identifier, new DelegationTokenInformation(renewDate,\n+      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n           password, getTrackingIdIfEnabled(identifier)));\n     } else {\n       throw new IOException(\"Same delegation token being added twice.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPersistedDelegationToken(\n      TokenIdent identifier, long renewDate) throws IOException {\n    if (running) {\n      // a safety check\n      throw new IOException(\n          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n    }\n    int keyId \u003d identifier.getMasterKeyId();\n    DelegationKey dKey \u003d allKeys.get(keyId);\n    if (dKey \u003d\u003d null) {\n      LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n      return;\n    }\n    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n    if (identifier.getSequenceNumber() \u003e delegationTokenSequenceNumber) {\n      delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n    }\n    if (getTokenInfo(identifier) \u003d\u003d null) {\n      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n          password, getTrackingIdIfEnabled(identifier)));\n    } else {\n      throw new IOException(\"Same delegation token being added twice.\");\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "db890eef3208cc557476fa510f7a253ba22bc68a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11017. KMS delegation token secret manager should be able to use zookeeper as store. (asuresh via tucu)\n",
      "commitDate": "20/09/14 8:21 AM",
      "commitName": "db890eef3208cc557476fa510f7a253ba22bc68a",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "02/05/14 11:38 AM",
      "commitNameOld": "bee448cacd142a4125e60c840022b65cc5fe9efa",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 140.86,
      "commitsBetweenForRepo": 1122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,25 @@\n   public synchronized void addPersistedDelegationToken(\n       TokenIdent identifier, long renewDate) throws IOException {\n     if (running) {\n       // a safety check\n       throw new IOException(\n           \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n     }\n     int keyId \u003d identifier.getMasterKeyId();\n-    DelegationKey dKey \u003d allKeys.get(keyId);\n+    DelegationKey dKey \u003d getDelegationKey(keyId);\n     if (dKey \u003d\u003d null) {\n       LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n       return;\n     }\n     byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n-    if (identifier.getSequenceNumber() \u003e this.delegationTokenSequenceNumber) {\n-      this.delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n+    int delegationTokenSeqNum \u003d getDelegationTokenSeqNum();\n+    if (identifier.getSequenceNumber() \u003e delegationTokenSeqNum) {\n+      setDelegationTokenSeqNum(identifier.getSequenceNumber());\n     }\n-    if (currentTokens.get(identifier) \u003d\u003d null) {\n-      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n+    if (getTokenInfo(identifier) \u003d\u003d null) {\n+      storeToken(identifier, new DelegationTokenInformation(renewDate,\n           password, getTrackingIdIfEnabled(identifier)));\n     } else {\n       throw new IOException(\"Same delegation token being added twice.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPersistedDelegationToken(\n      TokenIdent identifier, long renewDate) throws IOException {\n    if (running) {\n      // a safety check\n      throw new IOException(\n          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n    }\n    int keyId \u003d identifier.getMasterKeyId();\n    DelegationKey dKey \u003d getDelegationKey(keyId);\n    if (dKey \u003d\u003d null) {\n      LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n      return;\n    }\n    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n    int delegationTokenSeqNum \u003d getDelegationTokenSeqNum();\n    if (identifier.getSequenceNumber() \u003e delegationTokenSeqNum) {\n      setDelegationTokenSeqNum(identifier.getSequenceNumber());\n    }\n    if (getTokenInfo(identifier) \u003d\u003d null) {\n      storeToken(identifier, new DelegationTokenInformation(renewDate,\n          password, getTrackingIdIfEnabled(identifier)));\n    } else {\n      throw new IOException(\"Same delegation token being added twice.\");\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "e4374d803663c626de610cd5f062f25a6d7d5d4e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4680. Audit logging of delegation tokens for MR tracing. (Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1522012 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/13 12:57 PM",
      "commitName": "e4374d803663c626de610cd5f062f25a6d7d5d4e",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "29/05/13 5:52 PM",
      "commitNameOld": "fdfedf4c31fa1d8338fc915a631dfc57c1ca38da",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 104.79,
      "commitsBetweenForRepo": 649,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   public synchronized void addPersistedDelegationToken(\n       TokenIdent identifier, long renewDate) throws IOException {\n     if (running) {\n       // a safety check\n       throw new IOException(\n           \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n     }\n     int keyId \u003d identifier.getMasterKeyId();\n     DelegationKey dKey \u003d allKeys.get(keyId);\n     if (dKey \u003d\u003d null) {\n       LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n       return;\n     }\n     byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n     if (identifier.getSequenceNumber() \u003e this.delegationTokenSequenceNumber) {\n       this.delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n     }\n     if (currentTokens.get(identifier) \u003d\u003d null) {\n       currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n-          password));\n+          password, getTrackingIdIfEnabled(identifier)));\n     } else {\n       throw new IOException(\n           \"Same delegation token being added twice.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPersistedDelegationToken(\n      TokenIdent identifier, long renewDate) throws IOException {\n    if (running) {\n      // a safety check\n      throw new IOException(\n          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n    }\n    int keyId \u003d identifier.getMasterKeyId();\n    DelegationKey dKey \u003d allKeys.get(keyId);\n    if (dKey \u003d\u003d null) {\n      LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n      return;\n    }\n    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n    if (identifier.getSequenceNumber() \u003e this.delegationTokenSequenceNumber) {\n      this.delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n    }\n    if (currentTokens.get(identifier) \u003d\u003d null) {\n      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n          password, getTrackingIdIfEnabled(identifier)));\n    } else {\n      throw new IOException(\n          \"Same delegation token being added twice.\");\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "fdfedf4c31fa1d8338fc915a631dfc57c1ca38da": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9574. Added new methods in AbstractDelegationTokenSecretManager for helping YARN ResourceManager to reuse code for RM restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487692 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/05/13 5:52 PM",
      "commitName": "fdfedf4c31fa1d8338fc915a631dfc57c1ca38da",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,25 @@\n+  public synchronized void addPersistedDelegationToken(\n+      TokenIdent identifier, long renewDate) throws IOException {\n+    if (running) {\n+      // a safety check\n+      throw new IOException(\n+          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n+    }\n+    int keyId \u003d identifier.getMasterKeyId();\n+    DelegationKey dKey \u003d allKeys.get(keyId);\n+    if (dKey \u003d\u003d null) {\n+      LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n+      return;\n+    }\n+    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n+    if (identifier.getSequenceNumber() \u003e this.delegationTokenSequenceNumber) {\n+      this.delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n+    }\n+    if (currentTokens.get(identifier) \u003d\u003d null) {\n+      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n+          password));\n+    } else {\n+      throw new IOException(\n+          \"Same delegation token being added twice.\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPersistedDelegationToken(\n      TokenIdent identifier, long renewDate) throws IOException {\n    if (running) {\n      // a safety check\n      throw new IOException(\n          \"Can\u0027t add persisted delegation token to a running SecretManager.\");\n    }\n    int keyId \u003d identifier.getMasterKeyId();\n    DelegationKey dKey \u003d allKeys.get(keyId);\n    if (dKey \u003d\u003d null) {\n      LOG.warn(\"No KEY found for persisted identifier \" + identifier.toString());\n      return;\n    }\n    byte[] password \u003d createPassword(identifier.getBytes(), dKey.getKey());\n    if (identifier.getSequenceNumber() \u003e this.delegationTokenSequenceNumber) {\n      this.delegationTokenSequenceNumber \u003d identifier.getSequenceNumber();\n    }\n    if (currentTokens.get(identifier) \u003d\u003d null) {\n      currentTokens.put(identifier, new DelegationTokenInformation(renewDate,\n          password));\n    } else {\n      throw new IOException(\n          \"Same delegation token being added twice.\");\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/AbstractDelegationTokenSecretManager.java"
    }
  }
}